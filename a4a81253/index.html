<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.0.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.22.1">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Linux基础 - ZQ的博客</title>

  
    <meta name="description" content="Linux基础Linux简介操作系统是什么，操作系统概述Linux 也是众多操作系统之一，要想知道 Linux 是什么，首先得说一说什么是操作系统。 计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：  硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础">
<meta property="og:url" content="https://blog.forever520.top/a4a81253/index.html">
<meta property="og:site_name" content="ZQ的博客">
<meta property="og:description" content="Linux基础Linux简介操作系统是什么，操作系统概述Linux 也是众多操作系统之一，要想知道 Linux 是什么，首先得说一说什么是操作系统。 计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：  硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446557.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446026.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446458.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446621.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447171.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447606.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447965.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447867.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447438.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447224.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447715.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448545.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448953.gif">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448569.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448488.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448899.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151449460.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151449799.jpg">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151449801.jpg">
<meta property="article:published_time" content="2022-03-15T06:40:08.000Z">
<meta property="article:modified_time" content="2023-11-07T13:41:06.441Z">
<meta property="article:author" content="Gentle Conspiracy">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="CentOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446557.gif">
  
  
  
  <meta name="keywords" content="Linux,CentOS">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
    
      <script type="text/javascript" src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.6.4.min.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/hls.js@latest"></script>
    
      <script type="text/javascript" src="http://cdn.dashjs.org/latest/dash.all.min.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/flv.js@latest"></script>
    
      <link rel="shortcut icon" type="image/x-icon" href="https://pic.forever520.top/i/1/202312/uLuOlGS4OA/202204172211451.jpg" />
    
      <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures/imgs/kancss.css" >
    
      <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Everlasting16108/html/css/my.css" >
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures1/js/ag.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/qiehuan6.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/tiao3.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/myconsole.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/mydebug.js"></script>
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://pic.forever520.top/i/1/202312/uLuOlGS4OA/202204172211451.jpg" onerror="javascript:this.classList.add('error');this.src='https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">ZQ的博客</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/favorites/">收藏</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/about/">关于</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">Linux基础</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%AE%80%E4%BB%8B"><span class="toc-text">Linux简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">操作系统是什么，操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">1) 文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">2) 设备驱动程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-text">3) 用户接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-text">4) 系统服务程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNIX-Linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">UNIX&#x2F;Linux系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E6%A0%B8%E5%B1%82"><span class="toc-text">1) 内核层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Shell%E5%B1%82"><span class="toc-text">2) Shell层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">3) 应用层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">Linux系统的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%A7%E9%87%8F%E7%9A%84%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%85%8D%E8%B4%B9%E8%BD%AF%E4%BB%B6"><span class="toc-text">1) 大量的可用软件及免费软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%89%AF%E5%A5%BD%E7%9A%84%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E5%8F%8A%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-text">2) 良好的可移植性及灵活性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E8%89%AF%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">3) 优良的稳定性和安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%94%AF%E6%8C%81%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80"><span class="toc-text">4) 支持几乎所有的网络协议及开发语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81Linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常见Linux发行版本有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">Linux 发行版本的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%EF%BC%88%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%EF%BC%89%E5%A4%A7%E6%AF%94%E6%8B%BC-%E9%99%84%E5%B8%A6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">Linux桌面环境（桌面系统）大比拼[附带优缺点]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-KDE-%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F"><span class="toc-text">1. KDE 桌面系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-GNOME-%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83"><span class="toc-text">2. GNOME 桌面环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Unity"><span class="toc-text">3. Unity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-MATE"><span class="toc-text">4. MATE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cinnamon"><span class="toc-text">5. Cinnamon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%80%82%E7%94%A8%E4%BA%8E%E8%BE%83%E8%80%81%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E7%9A%84-Linux-%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83"><span class="toc-text">6. 适用于较老硬件设备的 Linux 桌面环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83"><span class="toc-text">查看桌面环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">开源软件是什么？有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">开源协议是什么？有哪些？如何选择？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GNU-GPL%EF%BC%88GNU-General-Public-License%EF%BC%8CGNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%89"><span class="toc-text">1) GNU GPL（GNU General Public License，GNU通用公共许可证）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BSD%EF%BC%88Berkeley-Software-Distribution%EF%BC%8C%E4%BC%AF%E5%85%8B%E5%88%A9%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83%E7%89%88%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="toc-text">2) BSD（Berkeley Software Distribution，伯克利软件发布版）协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Apache-%E8%AE%B8%E5%8F%AF%E8%AF%81%E7%89%88%E6%9C%AC%EF%BC%88Apache-License-Version%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="toc-text">3) Apache 许可证版本（Apache License Version）协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-MIT%EF%BC%88Massachusetts-Institute-of-Technology%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="toc-text">4) MIT（Massachusetts Institute of Technology）协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-GUN-LGPL%EF%BC%88GNU-Lesser-General-Public-License%EF%BC%8CGNU-%E5%AE%BD%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%89"><span class="toc-text">5) GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE"><span class="toc-text">如何选择开源协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B"><span class="toc-text">Linux系统安装教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE%EF%BC%88RFB%E3%80%81RDP%E3%80%81Telnet%E5%92%8CSSH%EF%BC%89"><span class="toc-text">Linux远程管理协议（RFB、RDP、Telnet和SSH）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDP-%E5%AF%B9%E6%AF%94-RFB"><span class="toc-text">RDP 对比 RFB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Telnet-%E5%AF%B9%E6%AF%94-SSH"><span class="toc-text">Telnet 对比 SSH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6"><span class="toc-text">Linux远程管理软件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%80%E8%A7%88%E8%A1%A8"><span class="toc-text">Linux文件目录结构一览表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%88-%EF%BC%89"><span class="toc-text">Linux 根目录（&#x2F;）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-usr%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux &#x2F;usr目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-var-%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux &#x2F;var 目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%82%E8%BD%BD%EF%BC%8CLinux%E6%8C%82%E8%BD%BD%E8%AF%A6%E8%A7%A3"><span class="toc-text">什么是挂载，Linux挂载详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-text">Linux文件和目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">Linux文件系统的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">Linux绝对路径和相对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">Linux文件（目录）命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">Linux命令行下如何识别文件类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-text">Linux命令基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-text">命令提示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-text">命令的基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1) 选项的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2) 参数的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-cd%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux cd命令：切换目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-pwd%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84"><span class="toc-text">Linux pwd命令：显示当前路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-ls%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6"><span class="toc-text">Linux ls命令：查看目录下文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-mkdir%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%89"><span class="toc-text">Linux mkdir命令：创建目录（文件夹）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-rmdir%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%88%A0%E9%99%A4%E7%A9%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux rmdir命令：删除空目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-touch%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%8F%8A%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">Linux touch命令：创建文件及修改文件时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-ln%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%BB%BA%E7%AB%8B%E9%93%BE%E6%8E%A5%EF%BC%88%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%89%E6%96%87%E4%BB%B6"><span class="toc-text">Linux ln命令：建立链接（硬链接和软链接）文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E8%AF%A6%E8%A7%A3"><span class="toc-text">Linux硬链接和软链接详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="toc-text">对硬链接的深度剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="toc-text">对软链接的深度剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-cp%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux cp命令：复制文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-rm%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux rm命令：删除文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-mv%E5%91%BD%E4%BB%A4%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E6%88%96%E6%94%B9%E5%90%8D"><span class="toc-text">Linux mv命令：移动文件或改名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">Linux命令行自动补全功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8CLinux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">什么是环境变量，Linux环境变量及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">Linux PATH环境变量及作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%89%93%E5%8C%85%EF%BC%88%E5%BD%92%E6%A1%A3%EF%BC%89%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="toc-text">Linux打包（归档）和压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%EF%BC%88%E5%BD%92%E6%A1%A3%EF%BC%89%E5%92%8C%E5%8E%8B%E7%BC%A9%EF%BC%88%E5%8C%85%E5%90%AB%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-text">打包（归档）和压缩（包含两者的区别）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-tar%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">Linux tar打包命令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tar%E5%91%BD%E4%BB%A4%E5%81%9A%E6%89%93%E5%8C%85%E6%93%8D%E4%BD%9C"><span class="toc-text">tar命令做打包操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tar%E5%91%BD%E4%BB%A4%E5%81%9A%E8%A7%A3%E6%89%93%E5%8C%85%E6%93%8D%E4%BD%9C"><span class="toc-text">tar命令做解打包操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tar%E5%91%BD%E4%BB%A4%E5%81%9A%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9%EF%BC%88%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%A7%A3%E6%89%93%E5%8C%85%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-text">tar命令做打包压缩（解压缩解打包）操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-zip%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux zip命令：压缩文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-unzip%E5%91%BD%E4%BB%A4%EF%BC%9A%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6"><span class="toc-text">Linux unzip命令：解压zip文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-gzip%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux gzip命令：压缩文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-gunzip%E5%91%BD%E4%BB%A4%EF%BC%9A%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux gunzip命令：解压缩文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-bzip2%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%EF%BC%88-bz2%E6%A0%BC%E5%BC%8F%EF%BC%89"><span class="toc-text">Linux bzip2命令：压缩文件（.bz2格式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-bunzip2%E5%91%BD%E4%BB%A4%EF%BC%9Abz2%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">Linux bunzip2命令：bz2格式的解压缩命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-text">Vim文本编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Vim%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E3%80%81%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-text">Linux Vim三种工作模式（命令模式、输入模式和编辑模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">Vim的命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E7%9A%84%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">Vim的输入模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim-%E7%9A%84%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F"><span class="toc-text">Vim 的编辑模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E7%BC%96%E8%BE%91%EF%BC%89"><span class="toc-text">Linux Vim基本操作（文件的打开和编辑）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-text">Vim 打开文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Vim-%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%BE%91"><span class="toc-text">使用 Vim 进行编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim-%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC"><span class="toc-text">Vim 插入文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim-%E6%9F%A5%E6%89%BE%E6%96%87%E6%9C%AC"><span class="toc-text">Vim 查找文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim-%E6%9B%BF%E6%8D%A2%E6%96%87%E6%9C%AC"><span class="toc-text">Vim 替换文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim%E5%88%A0%E9%99%A4%E6%96%87%E6%9C%AC"><span class="toc-text">Vim删除文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim%E5%A4%8D%E5%88%B6%E5%92%8C%E7%B2%98%E8%B4%B4%E6%96%87%E6%9C%AC"><span class="toc-text">Vim复制和粘贴文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">Vim其他常用快捷键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vim-%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA%E6%96%87%E6%9C%AC"><span class="toc-text">Vim 保存退出文本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vim%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB"><span class="toc-text">Vim移动光标快捷键汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%90%91%E9%94%AE"><span class="toc-text">Vim快捷方向键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E5%85%89%E6%A0%87%E4%BB%A5%E5%8D%95%E8%AF%8D%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%A7%BB%E5%8A%A8"><span class="toc-text">Vim光标以单词为单位移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E8%87%B3%E8%A1%8C%E9%A6%96%E6%88%96%E8%A1%8C%E5%B0%BE"><span class="toc-text">Vim光标移动至行首或行尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E8%87%B3%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6"><span class="toc-text">Vim光标移动至指定字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E8%A1%8C"><span class="toc-text">Vim光标移动到指定行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%A4%84"><span class="toc-text">Vim光标移动到匹配的括号处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Vim%E6%92%A4%E9%94%80%E5%92%8C%E6%81%A2%E5%A4%8D%E6%92%A4%E9%94%80%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">Linux Vim撤销和恢复撤销快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Vim%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95"><span class="toc-text">Linux Vim可视化模式及其用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vim-%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%BC%96%E8%BE%91"><span class="toc-text">Vim 多窗口编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%BC%96%E8%BE%91"><span class="toc-text">启动多窗口编辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vim%E7%9A%84%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%BC%96%E8%BE%91"><span class="toc-text">vim的多窗口编辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AA%97%E5%8F%A3%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-text">分割窗口的选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%AA%97%E5%8F%A3%E9%97%B4%E6%B8%B8%E8%B5%B0"><span class="toc-text">在窗口间游走</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">移动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%AC%E8%BA%AB%EF%BC%88%E8%BD%AE%E6%8D%A2%E6%88%96%E4%BA%A4%E6%8D%A2%EF%BC%89"><span class="toc-text">移动窗口本身（轮换或交换）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B9%B6%E6%94%B9%E5%8F%98%E5%85%B6%E5%B8%83%E5%B1%80"><span class="toc-text">移动窗口并改变其布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%B0%BA%E5%AF%B8"><span class="toc-text">调整窗口尺寸</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%BC%96%E8%BE%91"><span class="toc-text">分页编辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E8%B5%B0%E5%88%86%E9%A1%B5"><span class="toc-text">游走分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E4%B8%8E%E7%A6%BB%E5%BC%80%E7%AA%97%E5%8F%A3"><span class="toc-text">关闭与离开窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Vim%E6%89%B9%E9%87%8F%E6%B3%A8%E9%87%8A%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">Linux Vim批量注释和自定义注释快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88-vimrc%EF%BC%89"><span class="toc-text">Vim配置文件（.vimrc）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vim%E4%B8%AD%E6%89%A7%E8%A1%8CLinux%E5%91%BD%E4%BB%A4%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">Vim中执行Linux命令的几种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%EF%BC%88Linux%E4%B8%89%E5%89%91%E5%AE%A2grep%E3%80%81sed%E5%92%8Cawk%EF%BC%89"><span class="toc-text">Linux文本处理（Linux三剑客grep、sed和awk）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-cat%E5%91%BD%E4%BB%A4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E5%88%B0%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="toc-text">Linux cat命令：连接文件并打印输出到标准输出设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-more%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">Linux more命令：分屏显示文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-head%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">Linux head命令：显示文件开头的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-less%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">Linux less命令：查看文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-tail%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">Linux tail命令：显示文件结尾的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E9%87%8D%E5%AE%9A%E5%90%91%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">Linux重定向用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">Linux 中的数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA"><span class="toc-text">重定向输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5"><span class="toc-text">重定向输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-text">重定向错误信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%95%B0%E6%8D%AE%E8%87%B3-dev-null"><span class="toc-text">重定向数据至 &#x2F;dev&#x2F;null</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-grep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">Linux grep命令详解：查找文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-sed%E5%91%BD%E4%BB%A4%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">Linux sed命令完全攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sed%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-s-%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed s 替换脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-d-%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed d 替换脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-a-%E5%92%8C-i-%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed a 和 i 脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-c-%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed c 替换脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-y-%E8%BD%AC%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed y 转换脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-p-%E6%89%93%E5%8D%B0%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed p 打印脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-w-%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed w 脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-r-%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed r 脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-q-%E9%80%80%E5%87%BA%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed q 退出脚本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">sed 脚本命令的寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E6%95%B0%E5%AD%97%E5%BD%A2%E5%BC%8F%E6%8C%87%E5%AE%9A%E8%A1%8C%E5%8C%BA%E9%97%B4"><span class="toc-text">以数字形式指定行区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E6%8C%87%E5%AE%9A%E8%A1%8C%E5%8C%BA%E9%97%B4"><span class="toc-text">用文本模式指定行区间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-sed%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2"><span class="toc-text">Linux sed命令高级用法精讲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-%E5%A4%9A%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">sed 多行命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N-%E5%A4%9A%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">N 多行操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%A4%9A%E8%A1%8C%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4"><span class="toc-text">D 多行删除命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P-%E5%A4%9A%E8%A1%8C%E6%89%93%E5%8D%B0%E5%91%BD%E4%BB%A4"><span class="toc-text">P 多行打印命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed-%E4%BF%9D%E6%8C%81%E7%A9%BA%E9%97%B4"><span class="toc-text">sed 保持空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed%E6%94%B9%E5%8F%98%E6%8C%87%E5%AE%9A%E6%B5%81%E7%A8%8B"><span class="toc-text">sed改变指定流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%88%86%E6%94%AF%E5%91%BD%E4%BB%A4"><span class="toc-text">b 分支命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#t-%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-text">t 测试命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">Linux awk命令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#awk-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5%E5%8F%98%E9%87%8F"><span class="toc-text">awk 使用数据字段变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk-%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-text">awk 脚本命令使用多个命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E7%A8%8B%E5%BA%8F"><span class="toc-text">awk从文件中读取程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk-BEGIN%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">awk BEGIN关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk-END%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">awk END关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-text">Linux系统软件安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-text">Linux软件包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E6%BA%90%E7%A0%81%E5%8C%85"><span class="toc-text">Linux源码包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85"><span class="toc-text">Linux二进制包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%8C%85-VS-RPM%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85"><span class="toc-text">源码包 VS RPM二进制包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-text">如何选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-RPM%E5%8C%85%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">Linux RPM包统一命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-RPM%E5%8C%85%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD%E5%92%8C%E5%8D%87%E7%BA%A7%EF%BC%88rpm%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="toc-text">Linux RPM包安装、卸载和升级（rpm命令）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM%E5%8C%85%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84"><span class="toc-text">RPM包默认安装路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM-%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">RPM 包的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM%E5%8C%85%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-text">RPM包的升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPM%E5%8C%85%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-text">RPM包的卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-rpm%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%88-q%E3%80%81-qa%E3%80%81-i%E3%80%81-p%E3%80%81-l%E3%80%81-f%E3%80%81-R%EF%BC%89"><span class="toc-text">Linux rpm命令查询软件包（-q、-qa、-i、-p、-l、-f、-R）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rpm-q%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85"><span class="toc-text">rpm -q：查询软件包是否安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpm-qa%EF%BC%9A%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%89%80%E6%9C%89%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-text">rpm -qa：查询系统中所有安装的软件包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpm-qi%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-text">rpm -qi：查询软件包的详细信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpm-ql%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8"><span class="toc-text">rpm -ql：命令查询软件包的文件列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpm-qf%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%AARPM%E5%8C%85"><span class="toc-text">rpm -qf：命令查询系统文件属于哪个RPM包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpm-qR%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-text">rpm -qR：查询软件包的依赖关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-RPM%E5%8C%85%E9%AA%8C%E8%AF%81%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%EF%BC%88%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%89"><span class="toc-text">Linux RPM包验证和数字证书（数字签名）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-RPM-%E5%8C%85%E6%A0%A1%E9%AA%8C"><span class="toc-text">Linux RPM 包校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-RPM%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81"><span class="toc-text">Linux RPM数字证书验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%8F%90%E5%8F%96RPM%E5%8C%85%E6%96%87%E4%BB%B6-cpio%E5%91%BD%E4%BB%A4"><span class="toc-text">Linux提取RPM包文件(cpio命令)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-cpio-%E5%91%BD%E4%BB%A4%E6%8F%90%E5%8F%96-RPM-%E5%8C%85%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6"><span class="toc-text">使用 cpio 命令提取 RPM 包中指定文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-SRPM%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85"><span class="toc-text">Linux SRPM源码包安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rpmbuild-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">rpmbuild 命令的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpmbuild%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85SRPM%E5%8C%85"><span class="toc-text">rpmbuild命令安装SRPM包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-spec-%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-text">利用 *.spec 文件安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-RPM%E5%8C%85%E4%BE%9D%E8%B5%96%E6%80%A7%EF%BC%88%E5%90%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-text">Linux RPM包依赖性（含解决方案）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-yum%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8Cyum%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">Linux yum是什么，yum源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-yum-%E6%BA%90%E6%90%AD%E5%BB%BA"><span class="toc-text">网络 yum 源搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0-yum-%E6%BA%90"><span class="toc-text">本地 yum 源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-yum%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%9F%A5%E8%AF%A2%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%87%E7%BA%A7%E5%92%8C%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%89"><span class="toc-text">Linux yum命令详解（查询、安装、升级和卸载软件包）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yum%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="toc-text">yum查询命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4"><span class="toc-text">yum安装命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum-%E5%8D%87%E7%BA%A7%E5%91%BD%E4%BB%A4"><span class="toc-text">yum 升级命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum-%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4"><span class="toc-text">yum 卸载命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-yum%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">Linux yum管理软件组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yum%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E7%BB%84%E5%8C%85%E5%90%AB%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-text">yum查询软件组包含的软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%BB%84"><span class="toc-text">yum安装软件组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yum%E5%91%BD%E4%BB%A4%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6%E7%BB%84"><span class="toc-text">yum命令卸载软件组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%95%99%E7%A8%8B%EF%BC%88%E4%BB%A5apache%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-text">Linux源码包安装和卸载教程（以apache为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6"><span class="toc-text">Linux源码包安装软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E6%BA%90%E7%A0%81%E5%8C%85%E5%8D%B8%E8%BD%BD"><span class="toc-text">Linux源码包卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%BA%90%E7%A0%81%E5%8C%85%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7%E6%96%B9%E6%B3%95"><span class="toc-text">Linux源码包快速升级方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E8%A1%A5%E4%B8%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">Linux补丁文件的生成和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99apache%E6%89%93%E5%85%A5%E8%A1%A5%E4%B8%81"><span class="toc-text">给apache打入补丁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%8F%8A%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%EF%BC%88%E4%BB%A5webmin%E5%AE%89%E8%A3%85%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-text">Linux脚本程序包及安装方法（以webmin安装为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webmin%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-text">webmin安装步骤</span></a></li></ol></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></div><div id="post-meta">
    <span>发布于&nbsp;<time datetime="2022-03-15T06:40:08.000Z">2022-03-15</time></span>
    
    <span>更新于&nbsp;<time datetime="2023-11-07T13:41:06.441Z">2023-11-07</time></span>
    </div></div></div>

<article class='md-text content post reveal'>
<h1 class="article-title"><span>Linux基础</span></h1>
<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><h3 id="操作系统是什么，操作系统概述"><a href="#操作系统是什么，操作系统概述" class="headerlink" title="操作系统是什么，操作系统概述"></a>操作系统是什么，操作系统概述</h3><p>Linux 也是众多操作系统之一，要想知道 Linux 是什么，首先得说一说什么是操作系统。</p>
<p>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：</p>
<ul>
<li>硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等；</li>
<li>软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。</li>
</ul>
<p><strong>操作系统（Operating System，OS）</strong>是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。</p>
<p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如：</p>
<h4 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1) 文件系统"></a>1) 文件系统</h4><p>提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</p>
<h4 id="2-设备驱动程序"><a href="#2-设备驱动程序" class="headerlink" title="2) 设备驱动程序"></a>2) 设备驱动程序</h4><p>提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。简单来说，就是让你能吃到鸡蛋，但不用养一只鸡。</p>
<h4 id="3-用户接口"><a href="#3-用户接口" class="headerlink" title="3) 用户接口"></a>3) 用户接口</h4><p>操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。</p>
<h4 id="4-系统服务程序"><a href="#4-系统服务程序" class="headerlink" title="4) 系统服务程序"></a>4) 系统服务程序</h4><p>当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</p>
<p>打个比方，操作系统就好像是一个政府，其它软件都会被它管控；操作系统在给其他软件提供各种便利的同时，还会约束其他软件不能为所欲为。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446557.gif" alt="操作系统在计算机架构中的位置"></p>
<p>目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS、Windows Phone（简称 WP），嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等。</p>
<h3 id="UNIX-Linux系统结构"><a href="#UNIX-Linux系统结构" class="headerlink" title="UNIX&#x2F;Linux系统结构"></a>UNIX&#x2F;Linux系统结构</h3><p>UNIX&#x2F;Linux 系统可以粗糙地抽象为 3 个层次（所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解），如图 3 所示。底层是 UNIX&#x2F;Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446026.jpg" alt="img"></p>
<h4 id="1-内核层"><a href="#1-内核层" class="headerlink" title="1) 内核层"></a>1) 内核层</h4><p>内核层是 UNIX&#x2F;Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</p>
<h4 id="2-Shell层"><a href="#2-Shell层" class="headerlink" title="2) Shell层"></a>2) Shell层</h4><p>Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p>
<h4 id="3-应用层"><a href="#3-应用层" class="headerlink" title="3) 应用层"></a>3) 应用层</h4><p>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP&#x2F;IP 是一个协议，定义软件所应具备的功能），可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</p>
<p>现在大多数的 UNIX 系统上（包括 Solaris、HP-UX、AIX 等）都可以运行 CDE （Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境）的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。</p>
<p>X Window 与微软的 Windows 图形环境有很大的区别：</p>
<ul>
<li>UNIX&#x2F;Linux 系统与 X Window 没有必然捆绑的关系，也就是说，UNIX&#x2F;Linux 可以安装 X Window，也可以不安装；而微软的 Windows 图形环境与内核捆绑密切。</li>
<li>UNIX&#x2F;Linux 系统不依赖图形环境，依然可以通过命令行完成 100% 的功能，而且因为不使用图形环境还会节省大量的系统资源。</li>
</ul>
<h3 id="Linux系统的优缺点"><a href="#Linux系统的优缺点" class="headerlink" title="Linux系统的优缺点"></a>Linux系统的优缺点</h3><h4 id="1-大量的可用软件及免费软件"><a href="#1-大量的可用软件及免费软件" class="headerlink" title="1) 大量的可用软件及免费软件"></a>1) 大量的可用软件及免费软件</h4><p>Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。</p>
<p>但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。</p>
<h4 id="2-良好的可移植性及灵活性"><a href="#2-良好的可移植性及灵活性" class="headerlink" title="2) 良好的可移植性及灵活性"></a>2) 良好的可移植性及灵活性</h4><p>Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。</p>
<p>如果读者希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS&#x2F;BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。</p>
<h4 id="3-优良的稳定性和安全性"><a href="#3-优良的稳定性和安全性" class="headerlink" title="3) 优良的稳定性和安全性"></a>3) 优良的稳定性和安全性</h4><p>著名的黑客埃里克•雷蒙德（EricS.Raymond）有一句名言：“足够多的眼睛，就可让所有问题浮现”。举个例子，假如笔者在演讲，台下人山人海，明哥中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算明哥衣领上有一大块油渍也不会被发现。</p>
<p>Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。</p>
<p>提到 Linux 的安全性，我们可以做一个实验：在一台计算机上，在安装了 Windows 系统后不安装杀毒软件联网一个月，看看会有什么情况；同样，在安装了 Linux 系统后不安装杀毒软件联网一个月，我们比较一下，大家就明白了什么是 Linux 的安全性。Windows 系统不安装杀毒软件，相信大家都知道会有什么下场吧……</p>
<h4 id="4-支持几乎所有的网络协议及开发语言"><a href="#4-支持几乎所有的网络协议及开发语言" class="headerlink" title="4) 支持几乎所有的网络协议及开发语言"></a>4) 支持几乎所有的网络协议及开发语言</h4><p>经常有初学的朋友问我，Linux 是不是对 TCP&#x2F;IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP&#x2F;IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP&#x2F;IP 无关呢？所以，Linux 对网络协议和开发语言的支持很好。</p>
<p>Linux 的优点在此不一一列举，只说明这几点供读者参考。诚然，Linux 不可能没有缺点，如桌面应用还有待完善、Linux 的标准统一还需要推广、开源软件的盈利模式与发展还有待考验等，不过，瑕不掩瑜。</p>
<h3 id="常见Linux发行版本有哪些？"><a href="#常见Linux发行版本有哪些？" class="headerlink" title="常见Linux发行版本有哪些？"></a>常见Linux发行版本有哪些？</h3><p>从技术上来说，李纳斯•托瓦兹开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p>
<p>在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以Linux为核心的操作系统软件包”。</p>
<p>Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层（由发行商整合开发的应用）才有所体现。</p>
<p>Linux 的发行版本可以大体分为两类：</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表；</li>
<li>社区组织维护的发行版本，以 Debian 为代表。</li>
</ul>
<table>
<thead>
<tr>
<th>版本名称</th>
<th>网 址</th>
<th>特 点</th>
<th>软件包管理器</th>
</tr>
</thead>
<tbody><tr>
<td>Debian Linux</td>
<td><a target="_blank" rel="noopener" href="http://www.debian.org/">www.debian.org</a></td>
<td>开放的开发模式，且易于进行软件包升级</td>
<td>apt</td>
</tr>
<tr>
<td>Fedora Core</td>
<td><a target="_blank" rel="noopener" href="http://www.redhat.com/">www.redhat.com</a></td>
<td>拥有数量庞人的用户，优秀的社区技术支持. 并且有许多创新</td>
<td>up2date（rpm），yum （rpm）</td>
</tr>
<tr>
<td>CentOS</td>
<td><a target="_blank" rel="noopener" href="http://www.centos.org/">www.centos.org</a></td>
<td>CentOS 是一种对 RHEL（Red Hat Enterprise Linux）源代码再编译的产物，由于 Linux 是开发源代码的操作系统，并不排斥样基于源代码的再分发，CentOS 就是将商业的 Linux 操作系统 RHEL 进行源代码再编译后分发，并在 RHEL 的基础上修正了不少已知的漏洞</td>
<td>rpm</td>
</tr>
<tr>
<td>SUSE Linux</td>
<td><a target="_blank" rel="noopener" href="http://www.suse.com/">www.suse.com</a></td>
<td>专业的操作系统，易用的 YaST 软件包管理系统</td>
<td>YaST（rpm），第三方 apt （rpm）软件库（repository）</td>
</tr>
<tr>
<td>Mandriva</td>
<td><a target="_blank" rel="noopener" href="http://www.mandriva.com/">www.mandriva.com</a></td>
<td>操作界面友好，使用图形配置工具，有庞大的社区进行技术支持，支持 NTFS 分区的大小变更</td>
<td>rpm</td>
</tr>
<tr>
<td>KNOPPIX</td>
<td><a target="_blank" rel="noopener" href="http://www.knoppix.com/">www.knoppix.com</a></td>
<td>可以直接在 CD 上运行，具有优秀的硬件检测和适配能力，可作为系统的急救盘使用</td>
<td>apt</td>
</tr>
<tr>
<td>Gentoo Linux</td>
<td><a target="_blank" rel="noopener" href="http://www.gentoo.org/">www.gentoo.org</a></td>
<td>高度的可定制性，使用手册完整</td>
<td>portage</td>
</tr>
<tr>
<td>Ubuntu</td>
<td><a target="_blank" rel="noopener" href="http://www.ubuntu.com/">www.ubuntu.com</a></td>
<td>优秀已用的桌面环境，基于 Debian 构建</td>
<td>apt</td>
</tr>
</tbody></table>
<h4 id="Linux-发行版本的选择"><a href="#Linux-发行版本的选择" class="headerlink" title="Linux 发行版本的选择"></a>Linux 发行版本的选择</h4><p>Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议：</p>
<ol>
<li>如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。</li>
<li>如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。</li>
<li>如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。</li>
<li>如果你对系统稳定性要求很高，则可以考虑 FreeBSD。</li>
<li>如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。</li>
</ol>
<p>以上纯属个人化建议，非官方指导意见。其实 Linux 的发行版本众多，但是系统的核心——内核却系出同门，所以只要学会使用其中一种，即可触类旁通。</p>
<h3 id="Linux桌面环境（桌面系统）大比拼-附带优缺点"><a href="#Linux桌面环境（桌面系统）大比拼-附带优缺点" class="headerlink" title="Linux桌面环境（桌面系统）大比拼[附带优缺点]"></a>Linux桌面环境（桌面系统）大比拼[附带优缺点]</h3><p>Linux 中的桌面环境也是一个程序，它和内核不是绑定的，两者的开发也不是同步的；给不带界面的 Linux 系统安装上一个桌面环境，你就能看到各种漂亮的窗口，并能用鼠标点击它们了。</p>
<h4 id="1-KDE-桌面系统"><a href="#1-KDE-桌面系统" class="headerlink" title="1. KDE 桌面系统"></a>1. KDE 桌面系统</h4><p>KDE 是 K Desktop Environment 的缩写，中文译为“K桌面环境”。</p>
<p>许多流行的 Linux 发行版都提供了 KDE 桌面环境，比如 Ubuntu、Linux Mint、OpenSUSE、Fedora、Kubuntu、PC Linux OS 等。</p>
<p>KDE 和 Windows 比较类似，各位初学者相信都是 Windows 的用户，所以切换到 KDE 也不会有太大的障碍。</p>
<p>KDE 允许你把应用程序图标和文件图标放置在桌面的特定位置上。单击应用程序图标，Linux 系统就会运行该应用程序。单击文件图标，KDE 桌面就会确定使用哪种应用程序来处理该文件。</p>
<p>KDE 是所有桌面环境中最容易定制的。在其他桌面环境中，你需要几个插件、窗口组件和调整工具才可以定制环境，KDE 将所有工具和窗口组件都塞入到系统设置中。借助先进的设置管理器，可以控制一切，不需要任何第三方工具，就可以根据用户的喜好和要求来美化及调整桌面。</p>
<p>KDE 项目组还还发了大量的可运行在 KDE 环境中的应用程序，包括 Dolphin（文件管理工具）、Konsole（终端）、Kate（文本编辑工具）、Gwenview（图片查看工具）、Okular（文档及PDF查看工具）、Digikam（照片编辑和整理工具）、KMail（电子邮件客户软件）、Quassel（IRC客户软件）、K3b（DVD刻录程序）、Krunner（启动器）等，它们都是默认安装的。</p>
<p>对 KDE 优缺点的总结：</p>
<ul>
<li>优点：KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备</li>
<li>缺点：Kmail 等一些组件的配置对新手来说过于复杂。</li>
</ul>
<h4 id="2-GNOME-桌面环境"><a href="#2-GNOME-桌面环境" class="headerlink" title="2. GNOME 桌面环境"></a>2. GNOME 桌面环境</h4><p>GNOME 是 the GNU Network Object Model Environment 的缩写，中文译为“GNU网络对象模型环境”。</p>
<p>GNOME 的特点是简洁、运行速度快，但是没有太多的定制选项，用户需要安装第三方工具来实现。</p>
<p>GNOME 甚至不包括一些简单的调整选项，比如更改主题、更改字体等，就这两种基本的调整而言，用户都需要安装第三方工具。所以，GONME 适合那些不需要高度定制界面的用户。</p>
<p>GNOME 被用作 Fedora 中的默认桌面环境，提供在几款流行的 Linux 发行版中，比如 Ubuntu、Debian、OpenSUSE 等。</p>
<p>对 GNOME 优缺点的总结：</p>
<ul>
<li>优点：简单易用，可通过插件来扩展功能。</li>
<li>缺点：对插件的管理能力比较差，也缺少其它桌面环境拥有的许多功能。</li>
</ul>
<h4 id="3-Unity"><a href="#3-Unity" class="headerlink" title="3. Unity"></a>3. Unity</h4><p>Unity 是由 Ubuntu 的母公司 Canonical 开发的一款外壳。之所以说它是外壳，是因为 Unity 运行在 GNOME 桌面环境之上，使用了所有 GNOME 的核心应用程序。</p>
<p>Unity 使用了不同的界面风格，如果你用的是 Ubuntu Linux 发行版，你会注意到 Unity 与 KDE 和 GNOME 桌面环境有些不一样。</p>
<p>Unity 在左边有一个启动器，位于启动器顶部的是搜索图标，又叫“Dash”。在 Dash 上搜索文件时，不仅会给出来自硬盘的搜索结果，还会给出来自在线来源的搜索结果，比如 Google Drive、Facebook、Picasa、Flick 及其他。</p>
<p>Unity 还提供了隐藏启动器、触摸侧边栏就显示的选项，用户还可以调高&#x2F;调低显示启动器菜单的灵敏度。</p>
<p>Unity 很简单、运行速度快，但 Unity 在系统设置下却没有定制桌面的太多选项，要想安装主题或者定制另外不同的选项，比如系统菜单是否应该总是可见，或者“从启动器图标一次点击最小化”，用户需要安装第三方工具。</p>
<blockquote>
<p>CCSM 和 Unity Tweak Tool 是面向 Unity 桌面环境的非常流行的定制工具。</p>
</blockquote>
<p>对 Unity 优缺点的总结：</p>
<ul>
<li>优点：界面简洁直观，可以通过第三方工具来深度定制，而且使用了平视显示器（HUD）等新技术。</li>
<li>缺点：默认的定制功能比较差劲，通知机制一般。</li>
</ul>
<h4 id="4-MATE"><a href="#4-MATE" class="headerlink" title="4. MATE"></a>4. MATE</h4><p>上面我们提到，GNOME 3 进行了全新的界面设计，这招致一些用户的不满，他们推出了其它的桌面环境，MATE 就是其中之一。</p>
<p>MATE 是一种从现在无人维护的 GNOME 2 代码库派生出来的桌面环境。</p>
<p>MATE 让人觉得在使用旧的桌面环境，但是结合了历年来界面方面的诸多改进。MATE 还非常适用于低配计算机，所以如果你有一台旧的或速度较慢的计算机，可以使用 MATE。</p>
<p>MATE 还是许多流行的 Linux 发行版随带的，比如 Ubuntu、Linux Mint、Mageia、Debian 及另外更多发行版。Ubuntu MATE 头一回是官方版本。</p>
<p>“欢迎首次发布的 Ubuntu MATE 官方版本。现在，用户将更容易更新软件，因为所有组件现在都在 Ubuntu 软件库中。”</p>
<p>MATE 自带的应用程序包括 Caja（文件管理工具）、Pluma（文本编辑工具）、Atril（文档查看工具）、Eye of MATE（图像查看工具）等，如果用户不需要其他功能完备的桌面环境的所有额外功能，那么 MATE 对他们来说是一款简单的轻量级桌面环境。</p>
<p>对 META 优缺点的总结：</p>
<ul>
<li>优点：轻量级的桌面环境，能够兼容教旧的硬件设备。</li>
<li>缺点：我也不知道有什么明显的缺点，欢迎读者留言告知。</li>
</ul>
<h4 id="5-Cinnamon"><a href="#5-Cinnamon" class="headerlink" title="5. Cinnamon"></a>5. Cinnamon</h4><p>与 MATE 类似，Cinnamon 是由 Linux Mint 团队因为不满 Gnome 3 的改进而开发的另一种桌面环境。但 Cinnamon 与 MATE 不同之处在于，Cinnamon 建立在 Gnome 3 的基础上。Cinnamon 是新的，而且在积极开发之中，但这款出色的桌面环境没有因新颖而在功能方面有所减弱。</p>
<p>Cinnamon 拥有 GNOME 和 Unity 等其它桌面环境所没有的种种功能。Cinnamon 是高度可定制的桌面环境，不需要任何外部插件、窗口组件和调整工具来定制桌面。Cinnamon 甚至可以通过设置管理器本身来下载并安装主题，甚至不需要打开互联网浏览器。</p>
<p>由于种种出色的所需功能，Cinnamon 对任何刚接触 Linux 的新用户来说都非常方便。许多用户放弃使用 Linux，是因为他们并不了解 Linux 的工作方式，但是我强烈建议新手应从 Cinnamon 桌面环境开始入手。</p>
<p>许多流行的 Linux 发行版提供了各自版本的 Cinnamon，比如 Ubuntu、Fedora、OpenSUSE、Gentoo、Arch Linux 等。Cinnamon 还是 Linux Mint 的默认桌面环境。</p>
<p>对 Cinnamon 优缺点的总结：</p>
<ul>
<li>优点：成熟完美，高度可性质，适合 Linux 新手。</li>
<li>缺点：有时候可能会有软件错误。</li>
</ul>
<h4 id="6-适用于较老硬件设备的-Linux-桌面环境"><a href="#6-适用于较老硬件设备的-Linux-桌面环境" class="headerlink" title="6. 适用于较老硬件设备的 Linux 桌面环境"></a>6. 适用于较老硬件设备的 Linux 桌面环境</h4><p>图形化桌面环境的弊端在于它们要占用相当一部分的系统资源来保证正常运行。在 Linux 发展之初，Linux 的标志和卖点之一就是它可以运行在处理能力较弱的老旧 PC 上，这些 PC 无力运行较新的 Windows 桌面。</p>
<p>然而随着 KDE 和 GNOME 桌面环境的普及，情况发生了变化。运行 KDE 或 GNOME 桌面要占用的内存资源和较新的 Windows 桌面环境旗鼓相当。</p>
<p>如果你的 PC 已经有些年代了，也不要泄气。Linux 开发人员已经联手让 Linux 返璞归真。他们开发了一些低内存开销的图形化桌面应用，提供了能够在老旧 PC 上完美运行的基本功能。尽管这些图形化桌面环境并没有大量专为其设计的应用，但它们仍然能运行许多基本的图形化程序，支持如文字处理、电子表格、数据库、绘图以及多媒体等功能。</p>
<p>下表列出了一些可在配置较低的 PC 和笔记本电脑上运行的轻量级 Linux 图形化桌面环境。</p>
<table>
<thead>
<tr>
<th>桌面环境</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Fluxbox</td>
<td>一个没有面板的轻型桌面，仅有一个可用来启动程序的弹出式菜单。</td>
</tr>
<tr>
<td>Xfce</td>
<td>和 KDE 很像的一个桌面，但少了很多图像以适应低内存环境。</td>
</tr>
<tr>
<td>JWM</td>
<td>Joe 的窗口管理器（Joe’s Window Manager），非常适用于低内存低硬盘空间环境的超轻型桌面。</td>
</tr>
<tr>
<td>Fvwm</td>
<td>支持如虚拟桌面和面板等高级桌面功能，但能够在低内存环境中运行。</td>
</tr>
<tr>
<td>fvwm95</td>
<td>从 fvwm 衍生而来，但看起来更像是 Windows 95 桌面。</td>
</tr>
</tbody></table>
<p>以上这些图形化桌面环境并不如 KDE 或 GNOME 桌面一样绚丽，但却提供了恰到好处的基本图形化功能。</p>
<p>如果你用的是老旧 PC，尝试一下基于上述某个桌面环境的 Linux 发行版，看看怎么样，可能会有惊喜哦。</p>
<h4 id="查看桌面环境"><a href="#查看桌面环境" class="headerlink" title="查看桌面环境"></a>查看桌面环境</h4><p>我们可以通过环境变量 DESKTOP_SESSION 来查看当前 Linux 发行版使用了哪种桌面环境，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[]$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$DESKTOP_SESSION</span></span></span><br><span class="line">gnome-classic</span><br></pre></td></tr></table></figure>

<p>这表明我使用的是 GNOME。</p>
<p>另外，你也可以查看<code>/etc</code>下有没有对应的目录，例如 gnome 目录或者 kde 目录，如果有的话，就说明已经安装了。</p>
<h3 id="开源软件是什么？有哪些？"><a href="#开源软件是什么？有哪些？" class="headerlink" title="开源软件是什么？有哪些？"></a>开源软件是什么？有哪些？</h3><p>Linux 是一款开源软件，我们可以随意浏览和修改它的源代码，学习 Linux，不得不谈到开源精神。Linux 本身就是开源精神的受益者，它几乎是全球最大的开源软件。</p>
<p>简单来说，开源软件就是把软件程序与源代码文件一起打包提供给用户，用户既可以不受限制地使用该软件的全部功能，也可以根据自己的需求修改源代码，甚至编制成衍生产品再次发布出去。</p>
<p>用户具有使用自由、修改自由、重新发布自由和创建衍生品自由，这正好符合了黑客和极客对自由的追求，因此开源软件在国内外都有着很高的人气，大家聚集在开源社区，共同推动开源软件的进步。</p>
<p>坦白来讲，每一位投身 Linux 的技术人或者程序员，只要听到开源项目就会由衷地感到自豪，这是一种从骨子里面带有的独特情况。</p>
<p>支持开源软件的企业不单出是为了利益，而是相互扶持，共同努力服务好更多的用户。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>低风险</td>
<td>使用闭源软件无疑是把命运交给他人，一旦封闭的源代码没有人来维护，你将进退维谷；而且相较于商业软件公司，开源社区很少存在倒闭的问题。</td>
</tr>
<tr>
<td>高品质</td>
<td>相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的 bug 还没有等爆发就已经被修补。</td>
</tr>
<tr>
<td>低成本</td>
<td>开源工作者都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。</td>
</tr>
<tr>
<td>更透明</td>
<td>没有哪个笨蛋会把木马、后门等放到开放的源代码中，这样无疑是把自己的罪行暴露在阳光之下。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>软件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>Linux 是一款开源的操作系统，它的内核由多名极客共同维护。Linux 是开源软件的经典之作、代表之作、巅峰之作。</td>
</tr>
<tr>
<td>Apache</td>
<td>世界使用排名第一的 Web 服务器软件。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://c.biancheng.net/mysql/">MySQL</a></td>
<td>世界上最流行的关系型数据库，适合中小型网站。</td>
</tr>
<tr>
<td>Firefox</td>
<td>火狐浏览器。在 Chrome 推出之前，Firefox 几乎是最快速的浏览器，直到现在也是 Web 开发人员的调试利器。</td>
</tr>
<tr>
<td>OpenOffice</td>
<td>套跨平台的办公软件套件，类似 Microsoft Office。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://c.biancheng.net/gcc/">GCC</a></td>
<td>C语言&#x2F;<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>编译器。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/php/">PHP</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/python/">Python</a></td>
<td>开源的编程语言。</td>
</tr>
</tbody></table>
<p>国内外开源社区推荐：<a target="_blank" rel="noopener" href="https://www.oschina.net/">开源中国</a>、<a target="_blank" rel="noopener" href="http://www.chinaunix.net/">ChinaUnix</a>、<a target="_blank" rel="noopener" href="https://github.com/">GitHub</a>、<a target="_blank" rel="noopener" href="http://www.apache.org/">Apache</a>、<a target="_blank" rel="noopener" href="https://sourceforge.net/">SourceForge</a>、</p>
<p>开源社区以国外为主，国内开源社区由于资金、人才、气氛等问题一直不太稳定，最后附上一张开源社区汇总图。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446458.jpg" alt="开源软件生态体系"></p>
<h3 id="开源协议是什么？有哪些？如何选择？"><a href="#开源协议是什么？有哪些？如何选择？" class="headerlink" title="开源协议是什么？有哪些？如何选择？"></a>开源协议是什么？有哪些？如何选择？</h3><p>开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织（Open Source Initiative）认可的开源许可协议来保证开源工作者的权益。</p>
<p>开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。</p>
<p>开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。</p>
<p>对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。</p>
<h4 id="1-GNU-GPL（GNU-General-Public-License，GNU通用公共许可证）"><a href="#1-GNU-GPL（GNU-General-Public-License，GNU通用公共许可证）" class="headerlink" title="1) GNU GPL（GNU General Public License，GNU通用公共许可证）"></a>1) GNU GPL（GNU General Public License，GNU通用公共许可证）</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151446621.jpg" alt="GUN GPL开源协议图标"></p>
<p>只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件。</p>
<p>遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>复制自由</td>
<td>允许把软件复制到任何人的电脑中，并且不限制复制的数量。</td>
</tr>
<tr>
<td>传播自由</td>
<td>允许软件以各种形式进行传播。</td>
</tr>
<tr>
<td>收费传播</td>
<td>允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。</td>
</tr>
<tr>
<td>修改自由</td>
<td>允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。</td>
</tr>
</tbody></table>
<h4 id="2-BSD（Berkeley-Software-Distribution，伯克利软件发布版）协议"><a href="#2-BSD（Berkeley-Software-Distribution，伯克利软件发布版）协议" class="headerlink" title="2) BSD（Berkeley Software Distribution，伯克利软件发布版）协议"></a>2) BSD（Berkeley Software Distribution，伯克利软件发布版）协议</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447171.jpg" alt="BSD开源协议图标"></p>
<p>BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件：</p>
<ul>
<li>如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。</li>
<li>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。</li>
<li>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</li>
</ul>
<p>BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。</p>
<h4 id="3-Apache-许可证版本（Apache-License-Version）协议"><a href="#3-Apache-许可证版本（Apache-License-Version）协议" class="headerlink" title="3) Apache 许可证版本（Apache License Version）协议"></a>3) Apache 许可证版本（Apache License Version）协议</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447606.jpg" alt="Apache开源协议"></p>
<p>Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。</p>
<p>现在热门的 Hadoop、Apache HTTP Server、<a target="_blank" rel="noopener" href="http://c.biancheng.net/mongodb/">MongoDB</a> 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件：</p>
<ul>
<li>该软件及其衍生品必须继续使用 Apache 许可协议。</li>
<li>如果修改了程序源代码，需要在文档中进行声明。</li>
<li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li>
<li>如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。</li>
</ul>
<h4 id="4-MIT（Massachusetts-Institute-of-Technology）协议"><a href="#4-MIT（Massachusetts-Institute-of-Technology）协议" class="headerlink" title="4) MIT（Massachusetts Institute of Technology）协议"></a>4) MIT（Massachusetts Institute of Technology）协议</h4><p>目前限制最少的开源许可协议之一（比 BSD 和 Apache 的限制都少），只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。</p>
<p>使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。</p>
<h4 id="5-GUN-LGPL（GNU-Lesser-General-Public-License，GNU-宽通用公共许可证）"><a href="#5-GUN-LGPL（GNU-Lesser-General-Public-License，GNU-宽通用公共许可证）" class="headerlink" title="5) GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）"></a>5) GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）</h4><p>LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议。</p>
<p>LGPL 允许商业软件通过类库引用（link）的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<h3 id="如何选择开源协议"><a href="#如何选择开源协议" class="headerlink" title="如何选择开源协议"></a>如何选择开源协议</h3><p>世界上的开源协议有上百种（有兴趣的读者<a target="_blank" rel="noopener" href="http://www.gnu.org/licenses/license-list.html">请猛击这里</a>了解），很少有人能彻底搞清它们之间的区别，即使在最流行的六种开源协议——GPL、BSD、MIT、Mozilla、Apache 和 LGPL——之中做选择，也很复杂。</p>
<p>乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议，大家看了一目了然，真是清爽。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447965.gif" alt="如何选择开源协议"></p>
<h2 id="Linux系统安装教程"><a href="#Linux系统安装教程" class="headerlink" title="Linux系统安装教程"></a>Linux系统安装教程</h2><h3 id="Linux远程管理协议（RFB、RDP、Telnet和SSH）"><a href="#Linux远程管理协议（RFB、RDP、Telnet和SSH）" class="headerlink" title="Linux远程管理协议（RFB、RDP、Telnet和SSH）"></a>Linux远程管理协议（RFB、RDP、Telnet和SSH）</h3><p>提到远程管理，通常指的是远程管理服务器，而非个人计算机。个人计算机可以随时拿来用，服务器通常放置在机房中，用户无法直接接触到服务器硬件，只能采用远程管理的方式。</p>
<p>远程管理，实际上就是计算机（服务器）之间通过网络进行数据传输（信息交换）的过程，与浏览器需要 HTTP 协议（超文本传输协议）浏览网页一样，远程管理同样需要远程管理协议的支持。</p>
<p>目前，常用的远程管理协议有以下 4 种：</p>
<ul>
<li>RDP（remote desktop protocol）协议：远程桌面协议，大部分 Windows 系统都默认支持此协议，Windows 系统中的远程桌面管理就基于该协议。</li>
<li>RFB（Remote FrameBuffer）协议：图形化远程管理协议，VNC 远程管理工具就基于此协议。</li>
<li>Telnet：命令行界面远程管理协议，几乎所有的操作系统都默认支持此协议。此协议的特点是，在进行数据传送时使用明文传输的方式，也就是不对数据进行加密。</li>
<li>SSH（Secure Shell）协议：命令行界面远程管理协议，几乎所有操作系统都默认支持此协议。和 Telnet 不同，该协议在数据传输时会对数据进行加密并压缩，因此使用此协议传输数据既安全速度又快。</li>
</ul>
<h4 id="RDP-对比-RFB"><a href="#RDP-对比-RFB" class="headerlink" title="RDP 对比 RFB"></a>RDP 对比 RFB</h4><p>RDP 协议和 RFB 协议都允许用户通过图形用户界面访问远程系统，但 RFB 协议倾向于传输图像，RDP 协议倾向于传输指令：</p>
<ul>
<li>RFB 协议会在服务器端将窗口在显存中画好，然后将图像传给客户端，客户端只需要将得到的图像解码显示即可；</li>
<li>RDP 会将画图的工作交给客户端，服务器端需要根据客户端的显示能力做适当的调整。</li>
</ul>
<p>因此，完成相同的操作，使用 RFB 协议传输的数据量会比 RDP 大，而 RDP 对客户端的要求比 RFB 更苛刻，RFB 适用于瘦客户端，而 RDP 适用于低速网络。</p>
<p>瘦客户端是相对于胖客户端而言的，比如，人们使用 QQ，需要下载客户端，这属于“胖客户”；反之，通过浏览器就可查阅网络上各种资料，无需再下载其他任何软件，这属于“瘦客户”。简单理解，瘦客户端指的是最大可能减轻客户端的负担，多数工作由服务器端完成；胖客户端则相反。</p>
<h4 id="Telnet-对比-SSH"><a href="#Telnet-对比-SSH" class="headerlink" title="Telnet 对比 SSH"></a>Telnet 对比 SSH</h4><p>Telnet 协议和 SSH 协议都是命令行远程管理协议，有共同的应用领域，常用于远程访问服务器。</p>
<p>相比 Telnet 协议，SSH 协议在发送数据时会对数据进行加密操作，数据传输更安全，因此 SSH 协议几乎在所有应用领域代替了 Telnet 协议。</p>
<p>在一些测试、无需加密的场合（如局域网），Telnet协议仍常被使用。</p>
<h4 id="Linux远程管理软件"><a href="#Linux远程管理软件" class="headerlink" title="Linux远程管理软件"></a>Linux远程管理软件</h4><p>基于以上 4 种远程管理协议，Linux 远程管理服务器的软件可分为以下 3 种：</p>
<ul>
<li>类似于 VNC（基于 RFB 协议）的图形远程管理软件，如 Xmanager、VNC VIEWER 以及 TightVNC 等；</li>
<li>基于 SSH 协议的命令行操作管理；</li>
<li>类似 Webmin 的基于浏览器的远程管理，此种管理方式只提供简单的管理窗口，可用的管理功能有限；</li>
</ul>
<p>介于安全性和稳定性的考虑，大部分的服务器都舍弃图形管理界面而选择命令行界面，因此远程管理 Linux 服务器常使用基于 SSH 协议的命令行管理方式。</p>
<p>目前，基于 SSH 协议常用的远程管理工具有 PuTTY、SecureCRT、WinSCP 等，这些管理工具的具体使用下节给大家详细介绍。</p>
<h3 id="Linux文件目录结构一览表"><a href="#Linux文件目录结构一览表" class="headerlink" title="Linux文件目录结构一览表"></a>Linux文件目录结构一览表</h3><p>学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。</p>
<p>使用 Linux 时，通过命令行输入 <code>ls -l /</code> 可以看到，在 Linux 根目录（&#x2F;）下包含很多的子目录（称为一级目录），例如 bin、boot、dev 等。同时，各一级目录下还含有很多子目录（称为二级目录），比如 &#x2F;bin&#x2F;bash、&#x2F;bin&#x2F;ed 等。Linux 文件系统目录总体呈现树形结构，&#x2F; 根目录就相当于树根。</p>
<p>由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果你进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。</p>
<p>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p>
<blockquote>
<p>FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（&#x2F;usr 和 &#x2F;var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
</blockquote>
<h4 id="Linux-根目录（-）"><a href="#Linux-根目录（-）" class="headerlink" title="Linux 根目录（&#x2F;）"></a>Linux 根目录（&#x2F;）</h4><p>FHS 认为，Linux 系统的根目录（&#x2F;）最为重要（没有之一），其原因有以下 2 点：</p>
<ol>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ol>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bin&#x2F;</td>
<td>存放系统命令，普通用户和 root 都可以执行。放在 &#x2F;bin 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>&#x2F;boot&#x2F;</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>&#x2F;home&#x2F;</td>
<td>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 &#x2F;home&#x2F; 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 &#x2F;home&#x2F;liming</td>
</tr>
<tr>
<td>&#x2F;lib&#x2F;</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;media&#x2F;</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td>&#x2F;mnt&#x2F;</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>&#x2F;misc&#x2F;</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 &#x2F;media&#x2F;、&#x2F;mnt&#x2F;、&#x2F;misc&#x2F;，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 &#x2F;mnt&#x2F;，所以养成了在 &#x2F;mnt&#x2F; 下建立不同目录挂载不同设备的习惯，如 &#x2F;mnt&#x2F;cdrom&#x2F; 挂载光盘、&#x2F;mnt&#x2F;usb&#x2F; 挂载 U 盘，都是可以的</td>
</tr>
<tr>
<td>&#x2F;opt&#x2F;</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 &#x2F;usr&#x2F;local&#x2F; 目录中，也就是说，&#x2F;usr&#x2F;local&#x2F; 目录也可以用来安装软件</td>
</tr>
<tr>
<td>&#x2F;root&#x2F;</td>
<td>root 的主目录。普通用户主目录在 &#x2F;home&#x2F; 下，root 主目录直接在“&#x2F;”下</td>
</tr>
<tr>
<td>&#x2F;sbin&#x2F;</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>&#x2F;srv&#x2F;</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>&#x2F;tmp&#x2F;</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
</tbody></table>
<p>FHS 针对根目录中包含的子目录仅限于表 1，但除此之外，Linux 系统根目录下通常还包含表 2 中的几个一级目录。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;lost+found&#x2F;</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，&#x2F;lost+found 就是根分区的备份恢复目录，&#x2F;boot&#x2F;lost+found 就是 &#x2F;boot 分区的备份恢复目录</td>
</tr>
<tr>
<td>&#x2F;proc&#x2F;</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 &#x2F;proc&#x2F;cpuinfo 是保存 CPU 信息的，&#x2F;proc&#x2F;devices 是保存设备驱动的列表的，&#x2F;proc&#x2F;filesystems 是保存文件系统列表的，&#x2F;proc&#x2F;net 是保存网络协议信息的……</td>
</tr>
<tr>
<td>&#x2F;sys&#x2F;</td>
<td>虚拟文件系统。和 &#x2F;proc&#x2F; 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
</tbody></table>
<h4 id="Linux-usr目录"><a href="#Linux-usr目录" class="headerlink" title="Linux &#x2F;usr目录"></a>Linux &#x2F;usr目录</h4><p>usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 &#x2F;usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。</p>
<p>Linux 系统中，所有系统默认的软件都存储在 &#x2F;usr 目录下，&#x2F;usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体。</p>
<p>FHS 建议，&#x2F;usr 目录应具备表 3 所示的子目录。</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;sbin&#x2F;</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib&#x2F;</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;XllR6&#x2F;</td>
<td>图形界面系统保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local&#x2F;</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;src&#x2F;</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 &#x2F;usr&#x2F;local&#x2F;src&#x2F; 目录中，把内核源码保存到 &#x2F;usr&#x2F;src&#x2F;linux&#x2F; 目录中</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;include</td>
<td>C&#x2F;C++ 等编程语言头文件的放置目录</td>
</tr>
</tbody></table>
<h4 id="Linux-var-目录"><a href="#Linux-var-目录" class="headerlink" title="Linux &#x2F;var 目录"></a>Linux &#x2F;var 目录</h4><p>&#x2F;var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如表 4 所示的这些子目录。</p>
<table>
<thead>
<tr>
<th>&#x2F;var子目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;lib&#x2F;</td>
<td>程序运行中需要调用或改变的数据保存位置。如 MySQL</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 &#x2F;var&#x2F;log&#x2F;messages, &#x2F;var&#x2F;log&#x2F;wtmp 等。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run&#x2F;</td>
<td>一些服务和程序运行后，它们的 PID（进程 ID）保存位置</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;spool&#x2F;</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 &#x2F;var&#x2F;spool&#x2F;mail&#x2F; 存放新收到的邮件，&#x2F;var&#x2F;spool&#x2F;cron&#x2F; 存放系统定时任务。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;www&#x2F;</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;nis和&#x2F;var&#x2F;yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody></table>
<p>根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？</p>
<p>答案是用户的主目录或 &#x2F;tmp&#x2F; 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 &#x2F;proc&#x2F;fn&#x2F;sys&#x2F; 目录，因为它们是保存在内存中的，如果在这里写入数据，那么你的内存会越来越小，直至死机；&#x2F;boot&#x2F; 目录也不能保存额外数据，因为 &#x2F;boot&#x2F; 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。</p>
<p>总之，Linux 要在合理的目录下进行操作和修改。</p>
<h3 id="什么是挂载，Linux挂载详解"><a href="#什么是挂载，Linux挂载详解" class="headerlink" title="什么是挂载，Linux挂载详解"></a>什么是挂载，Linux挂载详解</h3><p>Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p>
<p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p>
<blockquote>
<p>如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p>
</blockquote>
<p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p>
<p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p>
<p>举个例子，我们想通过命令行访问某个 U 盘中的数据，图 1 所示为 U 盘文件目录结构和 Linux 系统中的文件目录结构。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447867.gif" alt="U 盘和 Linux 系统文件目录结构"></p>
<p>目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。</p>
<p>接下来，我们在根目录下新建一个目录 &#x2F;sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，挂载效果如图 2 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447438.gif" alt="文件系统挂载"></p>
<p>可以看到，U 盘文件系统已经成为 Linux 文件系统目录的一部分，此时访问 &#x2F;sdb-u&#x2F; 就等同于访问 U 盘。</p>
<p>前面讲过，根目录下的 &#x2F;dev&#x2F; 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件（比如 sdb1），就位于 &#x2F;dev&#x2F; 目录下（&#x2F;dev&#x2F;sdb1），但无法通过 &#x2F;dev&#x2F;sdb1&#x2F; 直接访问 U 盘数据，访问此目录只会提供给你此设备的一些基本信息（比如容量）。</p>
<p>总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。</p>
<h2 id="Linux文件和目录管理"><a href="#Linux文件和目录管理" class="headerlink" title="Linux文件和目录管理"></a>Linux文件和目录管理</h2><h3 id="Linux文件系统的层次结构"><a href="#Linux文件系统的层次结构" class="headerlink" title="Linux文件系统的层次结构"></a>Linux文件系统的层次结构</h3><p>在 Linux 操作系统中，所有的文件和目录都被组织成以一个根节点“&#x2F;”开始的倒置的树状结构，如图 1 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447224.gif" alt="Linux系统文件和目录组织示意图"></p>
<p>其中，目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“&#x2F;”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。</p>
<blockquote>
<p>其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p>
</blockquote>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“&#x2F;”来分隔。如 cat 的完整路径是 &#x2F;home&#x2F;cat。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“..”表示。</p>
<blockquote>
<p>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找时，不显示该目录或文件。</p>
</blockquote>
<p>为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件（或子目录），比如说，在 &#x2F;bin 和 &#x2F;sbin 目录中存放的应该是可执行文件，有关各个目录存放文件的类型</p>
<h3 id="Linux绝对路径和相对路径"><a href="#Linux绝对路径和相对路径" class="headerlink" title="Linux绝对路径和相对路径"></a>Linux绝对路径和相对路径</h3><p>指明一个文件存放的位置，有 2 种方法，分别是使用绝对路径和相对路径。</p>
<p>我们知道，Linux 系统中所有的文件（目录）都被组织成以根目录“&#x2F;”开始的倒置的树状结构，如图 1 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151447715.gif" alt="img"></p>
<p>绝对路径一定是由根目录 &#x2F; 开始写起。例如，使用绝对路径的表示方式指明 bin 文件所在的位置，该路径应写为 &#x2F;usr&#x2F;bin，测试代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bin</span><br><span class="line">bash： bin： command not found   &lt;-- 没有找到</span><br><span class="line">[root@localhost ~]# /usr/bin</span><br><span class="line">bash: /usr/bin: is a directory   &lt;-- 是一个文件</span><br></pre></td></tr></table></figure>

<p>可以看到，如果仅传递给 Linux 系统一个文件名，它无法找到指定文件；而当将 bin 文件的绝对路径传递 Linux 系统时，它就可以成功找到。</p>
<p>和绝对路径不同，相对路径不是从根目录 &#x2F; 开始写起，而是从当前所在的工作目录开始写起。使用相对路径表明某文件的存储位置时，经常会用到前面讲到的 2 个特殊目录，即当前目录（用 . 表示）和父目录（用 .. 表示）。</p>
<p>举个例子，当我们使用 root 身份登录 Linux 系统时，当前工作目录默认为 &#x2F;root，如果此时需要将当前工作目录调整到 root 的子目录 Desktop 中，当然可以使用绝对路径，示例代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pwd     &lt;-- 显示当前所在的工作路径</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd /root/Desktop</span><br><span class="line">[root@localhost Desktop]# pwd</span><br><span class="line">/root/Desktop</span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用绝对路径，我们成功地改变了当前工作路径。但除此之外，使用相对路径的方式会更简单。因为目前处于 &#x2F;root 的位置，而 Desktop 就位于当前目录下，所以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pwd    &lt;-- 显示当前所在的工作路径</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd ./Desktop</span><br><span class="line">[root@localhost Desktop]# pwd</span><br><span class="line">/root/Desktop</span><br></pre></td></tr></table></figure>

<p>此代码中，.&#x2F;Desktop 表示的就是 Destop 文件相对于 &#x2F;root 所在的路径。</p>
<p>再举一个例子，如果以 root 身份登录 Linux 系统，并实现将当前工作目录由 &#x2F;root 转换为 &#x2F;usr 目录，有以下 2 种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用绝对路径</span></span><br><span class="line">[root@localhost ~]# pwd &lt;-- 显示当前所在的工作路径</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd /usr</span><br><span class="line">[root@localhost ~]# pwd</span><br><span class="line">/usr</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用相对路径</span></span><br><span class="line">[root@localhost ~]# pwd &lt;-- 显示当前所在的工作路径</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd ../usr &lt;-- 相对 root，usr 位于其父目录 /，因此这里要用到 ..</span><br><span class="line">[root@localhost ~]# pwd</span><br><span class="line">/usr</span><br></pre></td></tr></table></figure>

<p>总之，绝对路径是相对于根路径 &#x2F; 的，只要文件不移动位置，那么它的绝对路径是恒定不变的；而相对路径是相对于当前所在目录而言的，随着程序的执行，当前所在目录可能会改变，因此文件的相对路径不是固定不变的。</p>
<h3 id="Linux文件（目录）命名规则"><a href="#Linux文件（目录）命名规则" class="headerlink" title="Linux文件（目录）命名规则"></a>Linux文件（目录）命名规则</h3><p>我们知道，在 Linux 系统中，一切都是文件，既然是文件，就必须要有文件名。同其他系统相比，Linux 操作系统对文件或目录命名的要求相对比较宽松。</p>
<p>Linux 系统中，文件和目录的命名规则如下：</p>
<ol>
<li>除了字符“&#x2F;”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 &lt;、&gt;、？、* 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。</li>
<li>与 Windows 操作系统不同，文件的扩展名对 Linux 操作系统没有特殊的含义，换句话说，Linux 系统并不以文件的扩展名开分区文件类型。例如，dog.exe 只是一个文件，其扩展名 .exe 并不代表此文件就一定是可执行文件。</li>
</ol>
<p>需要注意的是，在 Linux 系统中，硬件设备也是文件，也有各自的文件名称。Linux 系统内核中的 udev 设备管理器会自动对硬件设备的名称进行规范，目的是让用户通过设备文件的名称，就可以大致猜测处设备的属性以及相关信息。</p>
<p>udev 设备管理器会一直以进程的形式运行，并侦听系统内核发出的信号来管理位于 &#x2F;dev 目录下的设备文件。</p>
<p>表 1 罗列出了Linux 系统中常见硬件设备的文件名。</p>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody><tr>
<td>IDE设备</td>
<td>&#x2F;dev&#x2F;hd[a-d]，现在的 IDE设备已经很少见了，因此一般的硬盘设备会以 &#x2F;dev&#x2F;sd 开头。</td>
</tr>
<tr>
<td>SCSI&#x2F;SATA&#x2F;U盘</td>
<td>&#x2F;dev&#x2F;sd[a-p]，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td>&#x2F;dev&#x2F;fd[0-1]</td>
</tr>
<tr>
<td>打印机</td>
<td>&#x2F;dev&#x2F;lp[0-15]</td>
</tr>
<tr>
<td>光驱</td>
<td>&#x2F;dev&#x2F;cdrom</td>
</tr>
<tr>
<td>鼠标</td>
<td>&#x2F;dev&#x2F;mouse</td>
</tr>
<tr>
<td>磁带机</td>
<td>&#x2F;dev&#x2F;st0 或 &#x2F;dev&#x2F;ht0</td>
</tr>
</tbody></table>
<h3 id="Linux命令行下如何识别文件类型？"><a href="#Linux命令行下如何识别文件类型？" class="headerlink" title="Linux命令行下如何识别文件类型？"></a>Linux命令行下如何识别文件类型？</h3><p>对于第一次使用 Linux 命令行的用户，可能真的搞不清楚哪个是文件，哪个是目录，究其原因是很难直接通过名字看出来目录和文件的区别。</p>
<p>虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。例如：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448545.gif" alt="/root 目录下的文件和目录"><br>图 1 &#x2F;root 目录下的文件和目录</p>
<blockquote>
<p>注意，本节多处会使用 pwd（显示当前工作所在的目录）和 ls（列出当前目录中包含的所有文件和子目录）命令，读者只需了解它们的功能即可，本章后续会对它们做详细介绍。</p>
</blockquote>
<p>和 Linux 不同，Windows 下带有 <DIR> 标记的行或使用中括号“[]”括起来的名称就是目录，其他的则是文件（如图 2 所示）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448953.gif" alt="Windows命令行区分文件和目录（文件夹）"><br>图 2 Windows命令行区分文件和目录（文件夹)</p>
<p>不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。</p>
<p>但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 &#x2F;etc&#x2F;DIR_COLORS 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 man 命令，例如：</p>
<p>[root@localhost ~]# man dir_colors</p>
<p>注意，有些 Linux 发行版单独使用 ls 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 ls –color&#x3D;auto 命令，明确令其使用颜色来区分文件类型。</p>
<p>在此基础上，如果不想每次使用 ls 命令时，都显式附带 –color&#x3D;auto，可以执行如下命令：</p>
<p>[root@localhost ~]# alias ls &#x3D; ‘ls –color&#x3D;auto’</p>
<p>通过给 ls –color&#x3D;&#x3D;auto 这个整体设置一个别名 ls，这样当后续使用 ls 命令时，就等同于执行 ls –color&#x3D;auto 命令。</p>
<p>同时，如果想使这个设置永远生效，还需要将其添加到 &#x2F;etc&#x2F;bashrc 或 &#x2F;home&#x2F;<user>&#x2F;.bashrc 文件中，前者对所有用户有效，而后者仅对用户<user>有效。</p>
<blockquote>
<p>其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。</p>
</blockquote>
<p>当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。</p>
<p>通过 ls -l 命令，我们就可以查看当前目录下所有文件和目录各自的属性，如图 3 所示。</p>
<blockquote>
<p> 查看属性](<a target="_blank" rel="noopener" href="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448472.gif">https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448472.gif</a>)<br>图 3 查看属性</p>
</blockquote>
<p>图 3 显示的执行结构中，每行代表一个文件或目录，其中第一个字符表示的就是文件的类型，其可能的取值以及表示的文件类型，如表 4 所示。</p>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody></table>
<blockquote>
<p>除以上 2 种方法外，Linux 还提供了 file 命令，可以查询文件的类型</p>
</blockquote>
<h3 id="Linux命令基本格式"><a href="#Linux命令基本格式" class="headerlink" title="Linux命令基本格式"></a>Linux命令基本格式</h3><p>我们不会再见到图形界面了，因为对服务器来讲，图形界面会占用更多的系统资源，而且会安装更多的服务、开放更多的端口，这对服务器的稳定性和安全性都有负面影响。其实，服务器是一个连显示器都没有的家伙，要图形界面干什么？对服务器来讲，稳定性、可靠性、安全性才是最主要的。而简单易用不是服务器需要考虑的事情，所以学习 Linux，这些枯燥的命令是必须学习和记忆的内容。</p>
<h4 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h4><p>登录系统后，第一眼看到的内容是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢？</p>
<ul>
<li>[]：这是提示符的分隔符号，没有特殊含义。</li>
<li>root：显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li>@：分隔符号，没有特殊含义。</li>
<li>localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。</li>
<li>~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li>#：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是 $。</li>
</ul>
<p>家目录（又称主目录）是什么？ Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家：</p>
<ul>
<li>超级用户的家目录：&#x2F;root。</li>
<li>普通用户的家目录：&#x2F;home&#x2F;用户名。</li>
</ul>
<p>用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local</span><br><span class="line">[root@localhost local]#</span><br></pre></td></tr></table></figure>

<p>仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 &#x2F;usr&#x2F; local，只显示最后一个目录 local)。</p>
<h4 id="命令的基本格式"><a href="#命令的基本格式" class="headerlink" title="命令的基本格式"></a>命令的基本格式</h4><p>接下来看看 Linux 命令的基本格式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# 命令[选项][参数]</span><br></pre></td></tr></table></figure>

<p>命令格式中的 [] 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 ls 命令来解释一下命令的格式。如果按照命令的分类，那么 ls 命令应该属于目录操作命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg install.log install.log.syslog</span><br></pre></td></tr></table></figure>

<h5 id="1-选项的作用"><a href="#1-选项的作用" class="headerlink" title="1) 选项的作用"></a>1) 选项的作用</h5><p>ls 命令之后不加选项和参数也能执行，不过只能执行最基本的功能，即显示当前目录下的文件名。那么加入一个选项，会出现什么结果？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">总用量44</span><br><span class="line">-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--.1 root root 24772 1 月 14 18:17 install.log</span><br><span class="line">-rw-r--r--.1 root root 7690 1 月 14 18:17 install.log.syslog</span><br></pre></td></tr></table></figure>

<p>如果加一个”-l”选项，则可以看到显示的内容明显增多了。”-l”是长格式（long list）的意思，也就是显示文件的详细信息。至于 “-l” 选项的具体含义，我们稍后再详细讲解。可以看到选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。</p>
<p>Linux 的选项又分为短格式选项（-l）和长格式选项（–all）。短格式选项是英文的简写，用一个减号调用，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br></pre></td></tr></table></figure>

<p>而长格式选项是英文完整单词，一般用两个减号调用，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls --all</span><br></pre></td></tr></table></figure>

<p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 ls 命令的短格式选项 -l 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。</p>
<h4 id="2-参数的作用"><a href="#2-参数的作用" class="headerlink" title="2) 参数的作用"></a>2) 参数的作用</h4><p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l anaconda-ks.cfg</span><br><span class="line">-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<p>但是为什么一开始 ls 命令可以省略参数？那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg install.log install.log.syslog</span><br></pre></td></tr></table></figure>

<p>这个 ls 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
<p>总结一下：命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</p>
<h3 id="Linux-cd命令：切换目录"><a href="#Linux-cd命令：切换目录" class="headerlink" title="Linux cd命令：切换目录"></a>Linux cd命令：切换目录</h3><p>cd 命令，是 Change Directory 的缩写，用来切换工作目录。</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 cd 命令是一个典型的 Shell 内置命令，所以 cd 命令没有执行文件所在路径。</p>
<p>cd 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd [相对路径或绝对路径]</span><br><span class="line">除此之外，cd 命令后面可以跟一些特殊符号，表达固定的含义，如表 1 所示：</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td>~用户名</td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td>-</td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td>.</td>
<td>代表当前目录</td>
</tr>
<tr>
<td>..</td>
<td>代表上级目录</td>
</tr>
</tbody></table>
<p>它们的用法分别是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vbird]# cd ~</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示回到自己的主目录，对于 root 用户，其主目录为 /root</span></span><br><span class="line">[root@localhost ~]# cd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有加上任何路径，也代表回到当前登录用户的主目录</span></span><br><span class="line">[root@localhost ~]# cd ~vbird</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代表切换到 vbird 这个用户的主目录，亦即 /home/vbird</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd ..</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示切换到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在 Linux 系统中，根目录确实存在 .（当前目录）以及 ..（当前目录的父目录）两个目录，但由于根目录是最顶级目录，因此根目录的 .. 和 . 的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cd -</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示回到刚刚的那个目录</span></span><br></pre></td></tr></table></figure>

<p>如果你仔细观察的话，不难发现，其实在 [root@localhost ~] 中，就已经指明了当前所在的目录，通常刚登陆时会位于自己的主目录中，而 ~ 就表示主目录，因此也就有了通过使用 <code>cd ~</code> 可以回到自己的主目录。</p>
<p>【例 1】学习 cd - 的用法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/src</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入/usr/local/src目录</span></span><br><span class="line">[root@localhost src]# cd -</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]#</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">&quot;cd -&quot;</span>命令回到进入 src 目录之前的主目录</span></span><br><span class="line">[root@localhost ~]# cd -</span><br><span class="line">/usr/local/src</span><br><span class="line">[root@localhost src]#</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再执行一遍<span class="string">&quot;cd -&quot;</span>命令，又回到了 /usr/local/src 目录</span></span><br></pre></td></tr></table></figure>

<p>【例 2】学习 cd . 和 cd .. 的用法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/src</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入测试目录</span></span><br><span class="line">[root@localhost src]# cd ..</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入上级目录</span></span><br><span class="line">[root@localhost local]# pwd</span><br><span class="line">/usr/local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">pwd</span>是査看当前所在目录的命令，可以看到我们进入了上级目录 /usr/local</span></span><br><span class="line">[root@localhost local]# cd .</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入当前目录</span></span><br><span class="line">[root@localhost local]# pwd</span><br><span class="line">/usr/local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个命令不会有目录的改变，只是告诉大家<span class="string">&quot;.&quot;</span>代表当前目录</span></span><br></pre></td></tr></table></figure>

<p>pwd 命令用于显示当前所在的目录</p>
<h3 id="Linux-pwd命令：显示当前路径"><a href="#Linux-pwd命令：显示当前路径" class="headerlink" title="Linux pwd命令：显示当前路径"></a>Linux pwd命令：显示当前路径</h3><p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录（目前的工作目录）搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p>当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢？可以使用 Linux 系统的 pwd 命令来显示当前目录的绝对路径。</p>
<p>pwd 命令，是 Print Working Directory （打印工作目录）的缩写，功能是显示用户当前所处的工作目录。该命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pwd</span><br></pre></td></tr></table></figure>

<p>【例 1】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# whoami</span><br><span class="line">root</span><br><span class="line">[root@localhost ~]# pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>whoami 命令用于确定当前登陆的用户，后续会做详细介绍。可以看到，root 用户当前所在目录是它的主目录 &#x2F;root。</p>
<p>【例 2】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[demo@localhost ~]# whoami</span><br><span class="line">demo</span><br><span class="line">[demo@localhost ~]# pwd</span><br><span class="line">/home/demo</span><br></pre></td></tr></table></figure>

<p>以上代码表明，当前登陆 Linux 系统的是用户 demo，当前所在目录为 demo 的主目录 &#x2F;home&#x2F;demo。</p>
<p>注意，在 <code>[demo@localhost ~]#</code> 这一部分中，虽然也显示出当前所在的目录（例如 ~ 表示主目录），但此位置只会列出整个路径中最后的那一个目录，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /var/mail</span><br><span class="line">[root@localhost mail]# pwd</span><br><span class="line">/var/mail</span><br></pre></td></tr></table></figure>

<p>我们知道，不同的目录中，目录名是可以重复的，因此，仅通过 <code>[root@localhost mail]</code> 中的 mail，根本无法判断其所在的具体位置，而使用 pwd 命令，可以输出当前所在目录的完整路径。</p>
<h3 id="Linux-ls命令：查看目录下文件"><a href="#Linux-ls命令：查看目录下文件" class="headerlink" title="Linux ls命令：查看目录下文件"></a>Linux ls命令：查看目录下文件</h3><p>如何知道某目录中存放了哪些文件或子目录。</p>
<p>ls 命令，list 的缩写，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。此命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls [选项] 目录名称</span><br></pre></td></tr></table></figure>

<p>表 1 列出了 ls 命令常用的选项以及各自的功能。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。</td>
</tr>
<tr>
<td>-A</td>
<td>显示全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录。</td>
</tr>
<tr>
<td>-d</td>
<td>仅列出目录本身，而不是列出目录内的文件数据。</td>
</tr>
<tr>
<td>-f</td>
<td>ls 默认会以文件名排序，使用 -f 选项会直接列出结果，而不进行排序。</td>
</tr>
<tr>
<td>-F</td>
<td>在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，&#x2F; 代表目录，&#x3D; 代表 <a target="_blank" rel="noopener" href="http://c.biancheng.net/socket/">socket</a> 文件，| 代表 FIFO 文件。</td>
</tr>
<tr>
<td>-h</td>
<td>以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。</td>
</tr>
<tr>
<td>-i</td>
<td>显示 inode 节点信息。</td>
</tr>
<tr>
<td>-l</td>
<td>使用长格式列出文件和目录信息。</td>
</tr>
<tr>
<td>-n</td>
<td>以 UID 和 GID 分别代替文件用户名和群组名显示出来。</td>
</tr>
<tr>
<td>-r</td>
<td>将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。</td>
</tr>
<tr>
<td>-R</td>
<td>连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。</td>
</tr>
<tr>
<td>-S</td>
<td>以文件容量大小排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>-t</td>
<td>以时间排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>–color&#x3D;never –color&#x3D;always –color&#x3D;auto</td>
<td>never 表示不依据文件特性给予颜色显示。 always 表示显示颜色，ls 默认采用这种方式。 auto 表示让系统自行依据配置来判断是否给予颜色。</td>
</tr>
<tr>
<td>–full-time</td>
<td>以完整时间模式 （包含年、月、日、时、分）输出</td>
</tr>
<tr>
<td>–time&#x3D;{atime,ctime}</td>
<td>输出 access 时间或改变权限属性时间（ctime），而不是内容变更时间。</td>
</tr>
</tbody></table>
<p>注意，当 ls 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色（蓝色显示目录，白色显示一般文件）。除此之外，如果想使用 ls 命令显示更多内容，就需要使用表 1 相应的选项。</p>
<p>【例 1】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br><span class="line">total 156</span><br><span class="line">drwxr-x---  4 root root  4096 Sep 24 00:07 .</span><br><span class="line">drwxr-xr-x 23 root root  4096 Sep 22 12:09 ..</span><br><span class="line">-rw-------  1 root root  1474 Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------  1 root root   955 Sep 24 00:08 .bash_history</span><br><span class="line">-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout</span><br><span class="line">-rw-r--r--  1 root root   191 Jan  6  2007 .bash_profile</span><br><span class="line">-rw-r--r--  1 root root   176 Jan  6  2007 .bashrc</span><br><span class="line">drwx------  3 root root  4096 Sep  5 10:37 .gconf</span><br><span class="line">-rw-r--r--  1 root root 42304 Sep  4 18:26 install.log</span><br><span class="line">-rw-r--r--  1 root root  5661 Sep  4 18:25 install.log.syslog</span><br></pre></td></tr></table></figure>

<p>通过使用 -a，你会看到以 . 为开头的几个文件，以及目录文件 （.）、（..）、.gconf 等等，这些都是隐藏的目录和文件。其中，目录文件名以蓝色显示，一般文件以白色显示。</p>
<blockquote>
<p>注意，Linux 系统中，隐藏文件不是为了把文件藏起来不让其他用户找到，而是为了告诉用户这些文件都是重要的系统文件，如非必要，不要乱动！所以，不论是 Linux 还是 Windows 都可以非常简单地査看隐藏文件，只是在 Windows 中绝大多数的病毒和木马都会把自己变成隐藏文件，给用户带来了错觉，以为隐藏文件是为了不让用户发现。</p>
</blockquote>
<p>不仅如此，这里的 ls 命令还使用了 -l 选项，因此才显示出了文件的详细信息，此选项显示的这 7 列的含义分别是：</p>
<ol>
<li>第一列：规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。</li>
<li>第二列：引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列：所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列：大小，默认单位是字节。</li>
<li>第六列：文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列：文件名或目录名。</li>
</ol>
<p>【例 2】<br>如果我们想查看某个目录的详细信息，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /root/</span><br><span class="line">总用量44</span><br><span class="line">-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg</span><br><span class="line">-rw-r-r--.1 root root 24772 1 月 14 18:17 install.log</span><br><span class="line">-rw-r-r--.1 root root 7690 1 月 14 18:17 install.log.syslog</span><br></pre></td></tr></table></figure>

<p>这个命令会显示目录下的内容，而不会显示这个目录本身的详细信息。如果想显示目录本身的信息，就必须加入 “-d” 选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -ld /root/</span><br><span class="line">dr-xr-x---.2 root root 4096 1 月 20 12:30 /root/</span><br></pre></td></tr></table></figure>

<p>【例 3】<br>“ls-l” 显示的文件大小是字节，但是我们更加习惯的是千字节用 KB 显示，兆字节用 MB 显示，而 “-h” 选项就是按照人们习惯的单位显示文件大小的，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -lh</span><br><span class="line">总用量44K</span><br><span class="line">-rw-------.1 root root 1.2K 1 月 14 18:18 anaconda-ks.cfg</span><br><span class="line">-rw-r-r--.1 root root 25K 1 月 14 18:17 install.log</span><br><span class="line">-rw-r-r--.1 root root 7.6K 1 月 14 18:17 install.log.syslog</span><br></pre></td></tr></table></figure>

<h3 id="Linux-mkdir命令：创建目录（文件夹）"><a href="#Linux-mkdir命令：创建目录（文件夹）" class="headerlink" title="Linux mkdir命令：创建目录（文件夹）"></a>Linux mkdir命令：创建目录（文件夹）</h3><p>mkdir 命令，是 make directories 的缩写，用于创建新目录，此命令所有用户都可以使用。</p>
<p>mkdir 命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir [-mp] 目录名</span><br></pre></td></tr></table></figure>

<ul>
<li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。</li>
<li>-p 选项递归创建所有目录，以创建 &#x2F;home&#x2F;test&#x2F;demo 为例，在默认情况下，你需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮你创建 &#x2F;home、&#x2F;home&#x2F;test 以及 &#x2F;home&#x2F;test&#x2F;demo。</li>
</ul>
<p>【例 1】建立目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#mkdir cangls</span><br><span class="line">[root@localhost ~]#ls</span><br><span class="line">anaconda-ks.cfg cangls install.log install.log.syslog</span><br></pre></td></tr></table></figure>

<p>我们建立一个名为 cangls 的目录，通过 ls 命令可以查看到这个目录已经建立。注意，我们在建立目录的时候使用的是相对路径，所以这个目录被建立到当前目录下。</p>
<p>【例 2】使用 -p 选项递归建立目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir lm/movie/jp/cangls</span><br><span class="line">mkdir:无法创建目录&quot;lm/movie/jp/cangls&quot;:没有那个文件或目录</span><br><span class="line">[root@localhost ~]# mkdir -p lm/movie/jp/cangls</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg cangls install.log install.log.syslog lm</span><br><span class="line">[root@localhost ~]# ls lm/</span><br><span class="line">movie</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里只查看一级子目录，其实后续的jp目录、cangls目录都已经建立</span></span><br></pre></td></tr></table></figure>

<p>【例 3】使用 -m 选项自定义目录权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir -m 711 test2</span><br><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure>

<p>仔细看上面的权限部分，也就是 ls 命令输出的第一列数据，test 和 test1 目录由于不是使用 -m 选项设定访问权限，因此这两个目录采用的是默认权限（这里的默认权限值是 755，后续章节再详细介绍默认权限）。</p>
<p>而在创建 test2 时，使用了 -m 选项，通过设定 711 权限值来给予新的目录 drwx–x–x 的权限</p>
<h3 id="Linux-rmdir命令：删除空目录"><a href="#Linux-rmdir命令：删除空目录" class="headerlink" title="Linux rmdir命令：删除空目录"></a>Linux rmdir命令：删除空目录</h3><p>和 mkdir 命令（创建空目录）恰好相反，rmdir（remove empty directories 的缩写）命令用于删除空目录，此命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rmdir [-p] 目录名</span><br></pre></td></tr></table></figure>

<p>-p 选项用于递归删除空目录。</p>
<p>【例 1】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#rmdir cangls</span><br></pre></td></tr></table></figure>

<p>就这么简单，命令后面加目录名称即可，但命令执行成功与否，取决于要删除目录是否是空目录，因为 rmdir 命令只能删除空目录。</p>
<p>【例 2】<br>通过学习 mkdir 命令我们知道，使用 mkdir -p 可以实现递归建立目录，同样地，rmdir 命令可以使用 -p 选项递归删除目录。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rmdir -p lm/movie/jp/cangls</span><br></pre></td></tr></table></figure>

<p>注意，此方式先删除最低一层地目录（这里先删除 cangls），然后逐层删除上级目录，删除时也需要保证各级目录是空目录。</p>
<p>【例 3】<br>rmdir 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost # mkdir test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立测试目录</span></span><br><span class="line">[root@localhost ~]# touch test/boduo</span><br><span class="line">[root@localhost ~]# touch test/longze</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在测试目录中建立两个文件</span></span><br><span class="line">[root@localhost ~]# rmdir test</span><br><span class="line">rmdir:删除&quot;test&quot;失败：目录非空</span><br></pre></td></tr></table></figure>

<p>这个命令比较”笨”，所以并不常用。后续我们会学习 rm 命令，使用此命令不但可以删除目录，还可以删除文件。</p>
<h3 id="Linux-touch命令：创建文件及修改文件时间戳"><a href="#Linux-touch命令：创建文件及修改文件时间戳" class="headerlink" title="Linux touch命令：创建文件及修改文件时间戳"></a>Linux touch命令：创建文件及修改文件时间戳</h3><p>既然知道了如何在 Linux 系统中创建目录，接下来你可能会想在这些目录中创建一些文件，可以使用 touch 命令。</p>
<p>需要注意的是，touch 命令不光可以用来创建文件（当指定操作文件不存在时，该命令会在当前位置建立一个空文件），此命令更重要的功能是修改文件的时间参数（但当文件存在时，会修改此文件的时间参数）。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数（通过 stat 命令进行查看），分别是文件的访问时间、数据修改时间以及状态修改时间：</p>
<ul>
<li>访问时间（Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间（Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间（Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
<p>touch 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-a：只修改文件的访问时间；</li>
<li>-c：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。</li>
<li>-d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</li>
<li>-m：只修改文件的数据修改时间。</li>
<li>-t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 <code>YYMMDDhhmm</code>。</li>
</ul>
<p>可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变（更新为操作当前文件的真正时间）。</p>
<p>【例 1】 touch 命令创建文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#touch bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立名为 bols 的空文件</span></span><br></pre></td></tr></table></figure>

<p>【例 2】 在例 1 的基础上修改文件的访问时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#ll --time=atime bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看文件的访问时间</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 25 21:23 bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件上次的访问时间为 9 月 25 号 21：23</span></span><br><span class="line">[root@localhost ~]#touch bols</span><br><span class="line">[root@localhost ~]#ll --time=atime bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 15 16:36 bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">而如果文件已经存在，则也不会报错，只是会修改文件的访问时间。</span></span><br></pre></td></tr></table></figure>

<p>【例 3】 修改 bols 文件的 atime 和 mtime。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch -d &quot;2017-05-04 15:44&quot; bols</span><br><span class="line">[root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 4 2017 bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 4 2017 bols</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 25 21:40 bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ctime不会变为设定时间，但更新为当前服务器的时间</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-ln命令：建立链接（硬链接和软链接）文件"><a href="#Linux-ln命令：建立链接（硬链接和软链接）文件" class="headerlink" title="Linux ln命令：建立链接（硬链接和软链接）文件"></a>Linux ln命令：建立链接（硬链接和软链接）文件</h3><p>如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统（Linux 文件系统）是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。如果用一张示意图来描述 ext4 文件系统，则可以参考图 1。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448569.jpg" alt="ext4文件系统示意图"></p>
<p>ext4 文件系统会把分区主要分为两大部分（暂时不提超级块）：小部分用于保存文件的 inode (i 节点）信息；剩余的大部分用于保存 block 信息。</p>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息：</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ol>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。</p>
<p>ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种：</p>
<ul>
<li>软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接：我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p>ln 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件；</li>
<li>-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<p>【例 1】创建硬链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls</span><br><span class="line">[root@localhost ~]# ln /root/cangls /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立硬链接文件，目标文件没有写文件名，会和原名一致</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也就是/tmp/cangls 是硬链接文件</span></span><br></pre></td></tr></table></figure>

<p>【例 2】创建软链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch bols</span><br><span class="line">[root@localhost ~]# In -s /root/bols /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立软链接文件</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。这是初学者非常容易犯的错误。</p>
<p>硬链接：硬链接是新的目录条目，其引用系统中的现有文件。文件系统中的每一文件默认具有一个硬链接。为节省空间，可以不复制文件，而创建引用同一文件的新硬链接。新硬链接如果在与现有硬链接相同的目录中创建，则需要有不同的文件名，否则需要在不同的目录中。指向同一文件的所有硬链接具有相同的权限、连接数、用户&#x2F;组所有权、时间戳以及文件内容。指向同一文件内容的硬链接需要在相同的文件系统中。<br>简单说，硬链接就是一个 inode 号对应多个文件。就是同一个文件使用了多个别名</p>
<p>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>
<ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
<p>第三条不能交叉文件系统进行硬链接的创建，为什么？<br>inode 是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，即当 inode 存在且链接计数器（link count）不为 0 时。inode 号仅在各文件系统下是唯一的，当 Linux 挂载多个文件系统后将出现 inode 号重复的现象，因此硬链接创建时不可跨文件系统。</p>
<p>第四条中不能对目录创建硬链接，为什么？<br>简单说，如果针对文件做硬连接，等于针对这个文件对应的inode又做一个链接。所以硬链接等于是同一个inode对应多个文件名。对于目录来说，就是保存这些链接的一个inode。如果针对目录做硬链接，一个子目录的硬链接指向父目录的话，这样就循环了。现 Linux 文件系统中的目录均隐藏了两个个特殊的目录：当前目录（.）与父目录（..）。查看这两个特殊目录的inode号可知其实这两目录就是两个硬链接。若系统允许对目录创建硬链接，则会产生目录环。</p>
<p>软链接：（又称符号链接，即 soft link 或 symbolic link） 软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。软连接可以指向目录，而且软连接所指向的目录可以位于不同的文件系统中。</p>
<p>软链接可以指向目录。而后软连接作为目录使用。可以通过cd正常更改到软连接目录。</p>
<p>软链接特性：</p>
<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接或悬挂的软链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>
<p>当然软链接的用户数据也可以是另一个软链接的路径，其解析过程是递归的。但需注意：软链接创建时原文件的路径指向使用绝对路径较好。使用相对路径创建的软链接被移动后该软链接文件将成为一个死链接，因为链接数据块中记录的亦是相对路径指向。</p>
<h3 id="Linux硬链接和软链接详解"><a href="#Linux硬链接和软链接详解" class="headerlink" title="Linux硬链接和软链接详解"></a>Linux硬链接和软链接详解</h3><h4 id="对硬链接的深度剖析"><a href="#对硬链接的深度剖析" class="headerlink" title="对硬链接的深度剖析"></a>对硬链接的深度剖析</h4><p>首先，我们再来建立一个硬链接文件，然后看看这两个文件的特点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立源文件</span></span><br><span class="line">[root@localhost ~]# ln /root/test /tmp/test-hard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给源文件建立硬链接文件 /tmp/test-hard</span></span><br><span class="line">[root@localhost ~]# ll -i /root/test /tmp/test-hard</span><br><span class="line">262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /root/test</span><br><span class="line">hard</span><br><span class="line">262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /tmp/test-hard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，<span class="string">&quot;ll&quot;</span>等同于<span class="string">&quot;ls -l&quot;</span>。</span></span><br></pre></td></tr></table></figure>

<p>这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。</p>
<p>但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢？我们来画一张示意图，如图 2 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448488.jpg" alt="硬链接示意图"><br>图 2 硬链接示意图</p>
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。</p>
<p>当我们查找一个文件，比如 &#x2F;root&#x2F;test 时，要经过以下步骤：</p>
<ol>
<li>首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 &#x2F;root 的文件名及对应的 inode 号。</li>
<li>通过 &#x2F;root&#x2F; 目录的 inode 号，可以查找到 &#x2F;root&#x2F; 目录的 inode 信息，接着判断用户是否有权限访问 &#x2F;root&#x2F; 目录的 block。</li>
<li>如果有权限，则可以从 &#x2F;root&#x2F; 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 &#x2F;root&#x2F;test 文件的读取与访问。</li>
</ol>
<p>按照这个步骤，在给源文件 &#x2F;root&#x2F;test 建立了硬链接文件 &#x2F;tmp&#x2F;test-hard 之后，在 &#x2F;root&#x2F; 目录和 &#x2F;tmp&#x2F; 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。</p>
<p>这就是硬链接的原理。硬链接的特点如下：</p>
<ul>
<li>不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。</li>
<li>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。</li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p>硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。</p>
<p>我们通过实验来测试一下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo 1111 &gt;&gt;/root/test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向源文件中写入数据</span></span><br><span class="line">[root@localhost ~]# cat /root/test</span><br><span class="line">1111</span><br><span class="line">[root@localhost ~]# cat /tmp/test-hard</span><br><span class="line">1111</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">源文件和硬链接文件都会发生改变</span></span><br><span class="line">[root@localhost ~]# echo 2222 &gt;&gt; /tmp/test-hard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向硬链接文件中写入数据</span></span><br><span class="line">[root@localhost ~]# cat /root/test</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">[root@localhost ~】# cat /tmp/test-hard</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">源文件和硬链接文件也都会发生改变</span></span><br><span class="line">[root@localhost ~]# rm -rf/root/test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除源文件</span></span><br><span class="line">[root@localhost ~]# cat /tmp/test-hard</span><br><span class="line">1111 2222</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">硬链接文件依然可常读取</span></span><br></pre></td></tr></table></figure>

<h4 id="对软链接的深度剖析"><a href="#对软链接的深度剖析" class="headerlink" title="对软链接的深度剖析"></a>对软链接的深度剖析</h4><p>软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch check</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立源文件</span></span><br><span class="line">[root@localhost ~]# ln -s /root/check /tmp/check-soft</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立软链接文件</span></span><br><span class="line">[root@localhost ~]# ll -id /root/check /tmp/check-soft</span><br><span class="line">262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check</span><br><span class="line">917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -&gt; /root/check</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">软链接和源文件的 inode 号不一致，软链接通过 -&gt; 明显地标识出源文件的位置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件</span></span><br></pre></td></tr></table></figure>

<p>再强调一下，软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用。</p>
<p>软链接的标志非常明显，首先，权限位中”l”表示这是一个软链接文件；其次，在文件的后面通过 “-&gt;” 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。</p>
<p>软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。</p>
<p>大家在学习软链接的时候会有一些疑问：Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢？</p>
<p>笔者个人觉得，软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 &#x2F;etc&#x2F;rc.local 放置在 &#x2F;etc 目录中，而有些系统却将其放置在 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 中，那么干脆对这两个文件建立软链接，不论你习惯操作哪一个文件，结果都是一样的。</p>
<p>如果你比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图 3 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448899.jpg" alt="软链接示意图"><br>图 3 软链接示意图</p>
<p>软链接和硬链接在原理上最主要的不同在于：硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
<p>我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。</p>
<ol>
<li>首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限访问根目录的 block，就会在 block 中查找到 &#x2F;tmp&#x2F; 目录的 inode 号。</li>
<li>接着访问 &#x2F;tmp&#x2F; 目录的 inode 信息，判断用户是否有权限访问 &#x2F;tmp&#x2F; 目录的 block。</li>
<li>如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。</li>
<li>通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。</li>
<li>接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。</li>
</ol>
<p>通过这个过程，我们就可以总结出软链接的特点（软链接的特点和 Windows 中的快捷方式完全一致）。</p>
<ul>
<li>不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。</li>
<li>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
<p>我们测试一下软链接的特性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo 111&gt;&gt;/root/check</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改源文件</span></span><br><span class="line">[root@localhost ~]# cat /root/check</span><br><span class="line">111</span><br><span class="line">[root@localhost ~]# cat /tmp/check-soft</span><br><span class="line">111</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不论是源文件还是软链接文件，数据都发生改变</span></span><br><span class="line">[root@localhost ~]# echo 2222 &gt;&gt;/tmp/check-soft</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改软链接文件</span></span><br><span class="line">[root@localhost ~]# cat /tmp/check-soft</span><br><span class="line">111</span><br><span class="line">2222</span><br><span class="line">[root@localhost ~]# cat /root/check</span><br><span class="line">111</span><br><span class="line">2222</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不论是源文件还是软链接文件，数据也都会发生改变</span></span><br><span class="line">[root@localhost ~]# rm -rf/root/check</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除源文件</span></span><br><span class="line">[root@localhost ~]# cat /tmp/check-soft</span><br><span class="line">cat: /tmp/check-soft:没有那个文件或目录</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">软链接无法正常使用</span></span><br></pre></td></tr></table></figure>

<p>软链接是可以链接目录的，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立源目录</span></span><br><span class="line">[root@localhost ~]# ln -s /root/test/ /tmp/</span><br><span class="line">[root@localhost ~]# ll -d /tmp/test</span><br><span class="line">lrwxrwxrwx 1 root root 11 6月 19 12:43 /tmp/test-&gt;/root/test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">软链接可以链接目录</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-cp命令：复制文件和目录"><a href="#Linux-cp命令：复制文件和目录" class="headerlink" title="Linux cp命令：复制文件和目录"></a>Linux cp命令：复制文件和目录</h3><p>cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p>
<p>cp 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-a：相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；</li>
<li>-d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；</li>
<li>-i：询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li>-l：把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li>-s：把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li>-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；</li>
<li>-r：递归复制，用于复制目录；</li>
<li>-u：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。</p>
<blockquote>
<p>这里的软链接，类似于 Windows 系统中的快捷方式，而硬链接则是透过文件系统的 inode 号产生一个新的文件名。无论是复制软链接还是硬链接，都不是复制源文件。</p>
</blockquote>
<p>【例 1】cp 命令基本用法<br>cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立源文件</span></span><br><span class="line">[root@localhost ~]# cp cangls /tmp/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把源文件不改名复制到 /tmp/ 目录下</span></span><br></pre></td></tr></table></figure>

<p>如果需要改名复制，则命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp cangls /tmp/bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改名复制</span></span><br></pre></td></tr></table></figure>

<p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是“cp -i”的别名，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp cangls /tmp/</span><br><span class="line">cp:是否覆盖&quot;/tmp/cangls&quot;?y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目标位置有同名文件，所以会提示是否覆盖</span></span><br></pre></td></tr></table></figure>

<p>接下来我们看看如何复制目录，其实复制目录只需使用“-r”选项即可，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir movie</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立测试目录</span></span><br><span class="line">[root@localhost ~]# cp -r /root/movie/ /tmp/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目录原名复制</span></span><br></pre></td></tr></table></figure>

<p>【例 2】复制软链接文件<br>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢？我们试试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln -s /root/cangls /tmp/cangls_slink</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立一个测试软链接文件/tmp/cangls_slink</span></span><br><span class="line">[root@localhost ~]# ll /tmp/cangls_slink</span><br><span class="line">lrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -&gt; /root/cangls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">源文件本身就是一个软链接文件</span></span><br><span class="line">[root@localhost ~]# cp /tmp/cangls_slink /tmp/cangls_t1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制软链接文件，但是不加<span class="string">&quot;-d&quot;</span>选项</span></span><br><span class="line">[root@localhost ~]# cp -d /tmp/cangls_slink /tmp/cangls_t2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制软链接文件，加入<span class="string">&quot;-d&quot;</span>选项</span></span><br><span class="line">[root@localhost ~]# ll /tmp/cangls_t1 /tmp/cangls_t2</span><br><span class="line">-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">会发现不加<span class="string">&quot;-d&quot;</span>选项，实际复制的是软链接的源文件，而不是软链接文件</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-&gt; /root/cangls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">而如果加入了<span class="string">&quot;-d&quot;</span>选项，则会复制软链接文件</span></span><br></pre></td></tr></table></figure>

<p>这个例子说明，如果在复制软链接文件时不使用 “-d” 选项，则 cp 命令复制的是源文件，而不是软链接文件；只有加入了 “-d” 选项，才会复制软链接文件。请大家注意，”-d” 选项对硬链接是无效的。</p>
<p>【例 3】保留源文件属性复制<br>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp /var/lib/mlocate/mlocate.db /tmp/</span><br><span class="line">[root@localhost ~]# ll /var/lib/mlocate/mlocate.db</span><br><span class="line">-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意源文件的时间和所属组</span></span><br><span class="line">[root@localhost ~]#ll /tmp/mlocate.db</span><br><span class="line">-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span></span><br></pre></td></tr></table></figure>

<p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 “-p” 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="string">&quot;-p&quot;</span>选项</span></span><br><span class="line">[root@localhost ~]# ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span><br><span class="line">-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2</span><br><span class="line">-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">源文件和目标文件的所有属性都一致，包括时间</span></span><br></pre></td></tr></table></figure>

<p>我们之前讲过，”-a” 选项相当于 “-d、-p、-r” 选项，这几个选项我们已经分别讲过了。所以，当我们使用 “-a” 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 “-a” 选项来取代 “-d、-p、-r” 选项更加方便。</p>
<p>例 4】 “-l” 和 “-s” 选项<br>我们如果使用 “-l” 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 “-s” 选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和 “-d” 选项是不同的，”d” 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 “-l” 和 “-s” 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立测试文件</span></span><br><span class="line">[root@localhost ~]# ll -i bols</span><br><span class="line">262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">源文件只是一个普通文件，而不是软链接文件</span></span><br><span class="line">[root@localhost ~]# cp -l /root/bols /tmp/bols_h</span><br><span class="line">[root@localhost ~]# cp -s /root/bols /tmp/bols_s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="string">&quot;-l&quot;</span> 和<span class="string">&quot;-s&quot;</span>选项复制</span></span><br><span class="line">[root@localhost ~]# ll -i /tmp/bols_h /tmp/bols_s</span><br><span class="line">262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目标文件 /tmp/bols_h 为源文件的硬链接文件</span></span><br><span class="line">932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -&gt; /root/bols</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目标文件 /tmp/bols_s 为源文件的软链接文件</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-rm命令：删除文件或目录"><a href="#Linux-rm命令：删除文件或目录" class="headerlink" title="Linux rm命令：删除文件或目录"></a>Linux rm命令：删除文件或目录</h3><p>当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件（即垃圾），这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。</p>
<p>rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm[选项] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-f：强制删除（force），和 -i 选项相反，使用 -f，系统将不再询问，而是直接删除目标文件或目录。</li>
<li>-i：和 -f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 -i 可以有效防止不小心删除有用的文件或目录。</li>
<li>-r：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
<p>注意，rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。</p>
<p>【例 1】基本用法。<br>rm 命令如果任何选项都不加，则默认执行的是”rm -i 文件名”，也就是在删除一个文件之前会先询问是否删除。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls</span><br><span class="line">[root@localhost ~]# rm cangls</span><br><span class="line">rm:是否删除普通空文件&quot;cangls&quot;?y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除前会询问是否删除</span></span><br></pre></td></tr></table></figure>

<p>【例 2】 删除目录。<br>如果需要删除目录，则需要使用”-r”选项。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir -p /test/lm/movie/jp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">递归建立测试目录</span></span><br><span class="line">[root@localhost ~]# rm /test</span><br><span class="line">rm:无法删除&quot;/test/&quot;: 是一个目录</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不加<span class="string">&quot;-r&quot;</span>选项，则会报错</span></span><br><span class="line">[root@localhost ~]# rm -r /test</span><br><span class="line">rm:是否进入目录&quot;/test&quot;?y</span><br><span class="line">rm:是否进入目录&quot;/test/lm/movie&quot;?y</span><br><span class="line">rm:是否删除目录&quot;/test/lm/movie/jp&quot;?y</span><br><span class="line">rm:是否删除目录&quot;/test/lm/movie&quot;?y</span><br><span class="line">rm:是否删除目录&quot;/test/lm&quot;?y</span><br><span class="line">rm:是否删除目录&quot;/test&quot;?y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">会分别询问是否进入子目录、是否删除子目录</span></span><br></pre></td></tr></table></figure>

<p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难！</p>
<p>【例 3】强制删除。<br>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir -p /test/lm/movie/jp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新建立测试目录</span></span><br><span class="line">[root@localhost ~]# rm -rf /test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">强制删除，一了百了</span></span><br></pre></td></tr></table></figure>

<p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p>
<p>虽然 “-rf” 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 “-rf” 选项。</p>
<h3 id="Linux-mv命令：移动文件或改名"><a href="#Linux-mv命令：移动文件或改名" class="headerlink" title="Linux mv命令：移动文件或改名"></a>Linux mv命令：移动文件或改名</h3><p>mv 命令（move 的缩写），既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下：</p>
<p>[root@localhost ~]# mv 【选项】 源文件 目标文件</p>
<p>选项：</p>
<ul>
<li>-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li>-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）；</li>
<li>-n：如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li>-v：显示文件或目录的移动过程；</li>
<li>-u：若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
<p>需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p>
<p>【例 1】移动文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv cangls /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移动之后，源文件会被删除，类似剪切</span></span><br><span class="line">[root@localhost ~]# mkdir movie</span><br><span class="line">[root@localhost ~]# mv movie/ /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以移动目录。和 <span class="built_in">rm</span>、<span class="built_in">cp</span> 不同的是，<span class="built_in">mv</span> 移动目录不需要加入 <span class="string">&quot;-r&quot;</span> 选项</span></span><br></pre></td></tr></table></figure>

<p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 “mv -i” 的别名，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新建立文件</span></span><br><span class="line">[root@localhost ~]# mv cangls /tmp</span><br><span class="line">mv:县否覆盖&quot;tmp/cangls&quot;？y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动</span></span><br></pre></td></tr></table></figure>

<p>【例 2】强制移动。<br>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p>
<p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 “-f” 选项进行强制移动，这就不再需要用户手工确认了。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新建立文件</span></span><br><span class="line">[root@localhost ~]# mv -f cangls /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">就算 /tmp/ 目录下已经存在同名的文件，由于<span class="string">&quot;-f&quot;</span>选项的作用，所以会强制覆盖</span></span><br><span class="line">【例 3】不覆盖移动。</span><br><span class="line">既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 &quot;-n&quot; 选项的帮助了。例如：</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls /tmp</span><br><span class="line">/tmp/bols /tmp/cangls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在/tmp/目录下已经存在bols、cangls文件了</span></span><br><span class="line">[root@localhost ~]# mv -vn bols cangls lmls /tmp/、</span><br><span class="line">&quot;lmls&quot;-&gt;&quot;/tmp/lmls&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再向 /tmp/ 目录中移动同名文件，如果使用了 <span class="string">&quot;-n&quot;</span> 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动（<span class="string">&quot;-v&quot;</span> 选项用于显示移动过程）</span></span><br><span class="line">【例 4】改名。</span><br><span class="line">如果源文件和目标文件在同一目录中，那就是改名。例如：</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv bols lmls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把 bols 改名为 lmls</span></span><br></pre></td></tr></table></figure>

<p>目录也可以按照同样的方法改名。</p>
<p>【例 5】显示移动过程。<br>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 “-v” 选项来查看详细的移动信息。例如：</p>
<p>[root@localhost ~]# touch test1.txt test2.txt test3.txt<br>#建立三个测试文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv -v *.txt /tmp</span><br><span class="line">&quot;test1.txt&quot; -&gt; &quot;/tmp/test1.txt&quot;</span><br><span class="line">&quot;test2.txt&quot; -&gt; &quot;/tmp/test2.txt&quot;</span><br><span class="line">&quot;test3.txt&quot; -&gt; &quot;/tmp/test3.txt&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加入<span class="string">&quot;-v&quot;</span>选项，可以看到有哪些文件进行了移动</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux命令行自动补全功能"><a href="#Linux命令行自动补全功能" class="headerlink" title="Linux命令行自动补全功能"></a>Linux命令行自动补全功能</h3><p>文件名（或者目录名）是执行 Linux 命令中最常见的参数，例如前面介绍的 cd、mkdir、cp 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名（目录名）特别长的时候。</p>
<p>考虑到这种情况，Shell（Bash）提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>
<p>举个例子，在 &#x2F;etc 目录下，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /etc</span><br><span class="line">[root@localhost etc]# cd fs &lt;-- 按一次 Tab 键</span><br></pre></td></tr></table></figure>

<p>当按下 Tab 键时，你会发现 Shell 自动将 “fs” 补全成了 “fatab”，这是因为当前 &#x2F;etc 目录中只有 fstab 是以 “fs” 开头，因此 Shell 可以确定这里想要输入的文件名称为 fstab。</p>
<p>那么，如果当前目录中含有多个以指定字符（或字符串）开头的目录或文件，Shell 还可以成功辨认吗？答案是否定的，但它会以列表的形式给出所有以指定字符或字符串开头的文件或目录，供用户选择。</p>
<p>例如，还是在 &#x2F;etc 目录下，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# cd b &lt;-- 连续按两次 Tab 键</span><br><span class="line">bash_completion.d/      blkid/          bonobo-activation/</span><br><span class="line">bashrc                  bluetooth</span><br></pre></td></tr></table></figure>

<p>可以看到，当按一次 Tab 键时，Shell 没有任何反映，原因就是当前目录下以 “b” 为开头的文件或目录有多个（2 个以上），仅凭一个字符 “b” 无法精准判断出具体指的是哪个文件。而当再一次按下 Tab 键时，Shell 会列表的形式显示给用户当前目录下所有以 “b” 开头的文件或目录。</p>
<p>事实上，Shell 提供的命令行补全功能不仅适用于补全文件名，也同样适用于所有 Linux 命令。举个例子，当输入 ca 并连续按下 2 次 Tab 键时，Shell 会罗列出所有以 “ca” 开头的 Linux 命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# ca &lt;--连续按两次 Tab 键</span><br><span class="line">cacertdir_rehash    cache_restore       capsh       catchsegv</span><br><span class="line">cache_check         cal                 captoinfo</span><br><span class="line">cache_dump          caller              case</span><br><span class="line">cache_repair        canberra-gtk-play   cat</span><br></pre></td></tr></table></figure>

<p>另外，Shell 还有一套被称作通配符的转用符号（如表 1 所示），这些通配符可以搜索并匹配文件名的一部分，从而大大简化了文件名的输入。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意数量的字符。</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符。</td>
</tr>
<tr>
<td>[]</td>
<td>匹配括号内的任意一个字符，甚至 [] 中还可以包含用 -（短横线）连接的字符或数字，表示一定范围内的字符或数字。</td>
</tr>
</tbody></table>
<p>为了学习这些通配符的用法，首先需要建立一个空目录（如 test），并在该目录中创建一些文件（供测试用），执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# makdir test</span><br><span class="line">[root@localhost etc]# cd test</span><br><span class="line">[root@localhost test]# touch apple banana grape grapefruit watermelon</span><br><span class="line">[root@localhost test]# ls</span><br><span class="line">apple banana grape grapefruit watermelon</span><br><span class="line">在此基础上，继续执行如下命令：</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls a* &lt;--匹配所有以 a 字符开头的文件名</span><br><span class="line">apple</span><br><span class="line">[root@localhost test]# ls g*t &lt;--匹配所有以 g 字符开头，以 t 字符结尾的文件名</span><br><span class="line">grapefruit</span><br><span class="line">[root@localhost test]# ls *e* &lt;--匹配所有包含 e 字符的文件名</span><br><span class="line">apple grape grapefruit watermelon</span><br><span class="line">[root@localhost test]# ls *n* &lt;--匹配所有包含 n 字符的文件名</span><br><span class="line">banana watermelon</span><br></pre></td></tr></table></figure>

<p>结合以上实例，因为 * 可以匹配任何数量的字符，因此可以一一实现实例中标注的功能。</p>
<p>接下来，列举一下使用 ? 匹配文件名的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls ????e</span><br><span class="line">apple grape</span><br><span class="line">[root@localhost test]# ls g???e*</span><br><span class="line">grape grapefruit</span><br></pre></td></tr></table></figure>

<p>因为 1 个 ? 只能匹配 1 个任意字符，因此该示例中第一个例子表示的是匹配任意包含 5 个字符但以 e 结尾的文件（apple 和 grape），第二例子表示匹配任何以 g 开头且第 5 个字符为 e 的文件（grape 和 grapefruit）。</p>
<p>最后，列举一些使用括号 [] 匹配文件名的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls [abw]*</span><br><span class="line">apple banana watermelon</span><br><span class="line">[root@localhost test]# ls [agw]*[ne]</span><br><span class="line">apple grape watermelon</span><br></pre></td></tr></table></figure>

<p>此示例中，第一个例子表示匹配任何以 a、b 或 w 开头的文件；第二个例子中表示匹配任何以 a、g、w 开头，以 n 或 e 结尾的文件名。</p>
<p>不仅如此，[] 中还可以通过 -（短横线）表示一定范围内的任意字符（或数字），例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls [a-g]*</span><br><span class="line">apple banana grape grapefruit</span><br></pre></td></tr></table></figure>

<p>其中，[a-g]* 表示匹配以字母 a 到 g 之间任何一个字母开头的文件名。</p>
<h3 id="什么是环境变量，Linux环境变量及作用"><a href="#什么是环境变量，Linux环境变量及作用" class="headerlink" title="什么是环境变量，Linux环境变量及作用"></a>什么是环境变量，Linux环境变量及作用</h3><p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。</p>
<blockquote>
<p>值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</p>
</blockquote>
<p>我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# env</span><br><span class="line">ORBIT_SOCKETDIR=/tmp/orbit-root</span><br><span class="line">HOSTNAME=livecd.centos</span><br><span class="line">GIO_LAUNCHED_DESKTOP_FILE_PID=2065</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>Linux 系统能够正常运行并且为用户提供服务，需要数百个环境变量来协同工作，但是，我们没有必要逐一学习每个变量，这里给大家列举了 10 个非常重要的环境变量，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HOME</td>
<td>用户的主目录（也称家目录）</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody></table>
<p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。</p>
<p>例如，使用下述命令来查看 HOME 变量在不同用户身份下都有哪些值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# su - user1 &lt;--切换到 user1 用户身份</span><br><span class="line">[user1@localhost ~]$ echo $HOME</span><br><span class="line">/home/user1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 su 命令可以临时切换用户身份，此命令的具体用法会在后续章节做详细介绍。</p>
</blockquote>
<p>其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 WORKDIR 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /home/work1</span><br><span class="line">[root@localhost ~]# WORKDIR=/home/work1</span><br><span class="line">[root@localhost ~]# cd $WORKDIR</span><br><span class="line">[root@localhost work1]# pwd</span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure>

<p>但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 export 命令将其提升为全局环境变量，这样其他用户就可以使用它了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost work1]# su user1 &lt;-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span><br><span class="line">[user1@localhost ~]$ cd $WORKDIR</span><br><span class="line">[user1@localhost ~]$ echo $WORKDIR</span><br><span class="line"></span><br><span class="line">[user1@localhost ~]$ exit &lt;--退出user1身份</span><br><span class="line">[root@localhost work1]# export WORKDIR</span><br><span class="line">[root@localhost work1]# su user1</span><br><span class="line">[user1@localhost ~]$ cd $WORKDIR</span><br><span class="line">[user1@localhost work1]$ pwd</span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure>

<h3 id="Linux-PATH环境变量及作用"><a href="#Linux-PATH环境变量及作用" class="headerlink" title="Linux PATH环境变量及作用"></a>Linux PATH环境变量及作用</h3><p>在讲解 PATH 环境变量之前，首先介绍一下 which 命令，它用于查找某个命令所在的绝对路径。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# which rm</span><br><span class="line">/bin/rm</span><br><span class="line">[root@localhost ~]# which rmdir</span><br><span class="line">/bin/rmdir</span><br><span class="line">[root@localhost ~]# which ls</span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">        /bin/ls</span><br></pre></td></tr></table></figure>

<p>注意，ls 是一个相对特殊的命令，它使用 alias 命令做了别名，也就是说，我们常用的 ls 实际上执行的是 ls –color&#x3D;auto。</p>
<p>通过使用 which 命令，可以查找各个外部命令（和 Shell 内置命令相对）所在的绝对路径。学到这里，读者是否有这样一个疑问，为什么前面在使用 rm、rmdir、ls 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置（绝对路径）呢？其实，这是 PATH 环境变量在起作用。</p>
<p>首先，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p>这里的 echo 命令用来输出 PATH 环境变量的值（这里的 $ 是 PATH 的前缀符号），PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。</p>
<blockquote>
<p>如果在 PATH 包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。</p>
</blockquote>
<p>从执行结果中可以看到，&#x2F;bin 目录已经包含在 PATH 环境变量中，因此在使用类似 rm、rmdir、ls等命令时，即便直接使用其命令名，Linux 也可以找到该命令。</p>
<p>为了印证以上观点，下面举个反例，如果我们将 ls 命令移动到 &#x2F;root 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 ls 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 No such file or directory，示例命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /bin/ls /root</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">bash: /bin/ls: No such file or directory</span><br></pre></td></tr></table></figure>

<p>此时，如果仍想使用 ls 命令，有 2 种方法，一种是直接将 &#x2F;root 添加到 PATH 环境变量中，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# PATH=$PATH:/root</span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">Desktop    Downloads    Music    post-install     Public    Videos</span><br><span class="line">Documents  ls           Pictures post-install.org Templates</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$PATH 就恢复成了默认值。</p>
</blockquote>
<p>另一种方法是以绝对路径的方式使用此命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /root/ls</span><br><span class="line">Desktop    Downloads    Music    post-install     Public    Videos</span><br><span class="line">Documents  ls           Pictures post-install.org Templates</span><br></pre></td></tr></table></figure>

<p>为了不影响系统的正常使用，强烈建议大家将移动后的 ls 文件还原，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /root/ls /bin</span><br></pre></td></tr></table></figure>

<h2 id="Linux打包（归档）和压缩"><a href="#Linux打包（归档）和压缩" class="headerlink" title="Linux打包（归档）和压缩"></a>Linux打包（归档）和压缩</h2><h3 id="打包（归档）和压缩（包含两者的区别）"><a href="#打包（归档）和压缩（包含两者的区别）" class="headerlink" title="打包（归档）和压缩（包含两者的区别）"></a>打包（归档）和压缩（包含两者的区别）</h3><p>归档，也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。</p>
<p>通常，归档总是会和系统（数据）备份联系在一起，不过，有关数据备份的内容，留到后续章节讲，本章仅学习归档命令的基本使用。</p>
<p>和归档文件类似，压缩文件也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，压缩文件采用了不同的存储方式，使其所占用的磁盘空间比集合中所有文件大小的总和要小。</p>
<p>压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。比如说，在压缩文件中，有不止一处出现了 “网络”，那么，在压缩文件时，这个词就会用一个代码表示并写入词典文件，这样就可以实现缩小文件体积的目的。</p>
<p>由于计算机处理的信息是以二进制的形式表示的，因此，压缩软件就是把二进制信息中相同的字符串以特殊字符标记，只要通过合理的数学计算，文件的体积就能够被大大压缩。把一个或者多个文件用压缩软件进行压缩，形成一个文件压缩包，既可以节省存储空间，有方便在网络上传送。</p>
<p>如果你能够理解文件压缩的基本原理，那么很容易就能想到，对文件进行压缩，很可能损坏文件中的内容，因此，压缩又可以分为有损压缩和无损压缩。无损压缩很好理解，指的是压缩数据必须准确无误；有损压缩指的是即便丢失个别的数据，对文件也不会造成太大的影响。有损压缩广泛应用于动画、声音和图像文件中，典型代表就是影碟文件格式 mpeg、音乐文件格式 mp3 以及图像文件格式 jpg。</p>
<p>采用压缩工具对文件进行压缩，生成的文件称为压缩包，该文件的体积通常只有原文件的一半甚至更小。需要注意的是，压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原，此过程又称解压缩。</p>
<p>Linux 下，常用归档命令有 2 个，分别是 tar 和 dd（相对而言，tar 的使用更为广泛）；常用的压缩命令有很多，比如 gzip、zip、bzip2 等。这些命令的详细用法，后续文件会做一一介绍。</p>
<p>注意，tar 命令也可以作为压缩命令，也很常用。</p>
<h3 id="Linux-tar打包命令详解"><a href="#Linux-tar打包命令详解" class="headerlink" title="Linux tar打包命令详解"></a>Linux tar打包命令详解</h3><p>Linux 系统中，最常用的归档（打包）命令就是 tar，该命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。</p>
<p>使用 tar 命令归档的包通常称为 tar 包（tar 包文件都是以“.tar”结尾的）。</p>
<h4 id="tar命令做打包操作"><a href="#tar命令做打包操作" class="headerlink" title="tar命令做打包操作"></a>tar命令做打包操作</h4><p>当 tar 命令用于打包操作时，该命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 源文件或目录</span><br></pre></td></tr></table></figure>

<p>此命令常用的选项及各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>将多个文件或目录进行打包。</td>
</tr>
<tr>
<td>-A</td>
<td>追加 tar 文件到归档文件。</td>
</tr>
<tr>
<td>-f 包名</td>
<td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td>
</tr>
<tr>
<td>-v</td>
<td>显示打包文件过程；</td>
</tr>
</tbody></table>
<p>需要注意的是，在使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。</p>
<p>下面给大家举几个例子，一起看看如何使用 tar 命令打包文件和目录。</p>
<p>【例 1】打包文件和目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把anacondehks.cfg打包为 anacondehks.cfg.tar文件</span></span><br></pre></td></tr></table></figure>

<p>选项 “-cvf” 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 “.tar” 作为扩展名。打包目录也是如此：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll -d test/</span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">test</span>是我们之前的测试目录</span></span><br><span class="line">[root@localhost ~]# tar -cvf test.tar test/</span><br><span class="line">test/</span><br><span class="line">test/test3</span><br><span class="line">test/test2</span><br><span class="line">test/test1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把目录打包为test.tar文件</span></span><br><span class="line">tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:</span><br><span class="line">[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg /tmp/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包</span></span><br></pre></td></tr></table></figure>

<p>【例 2】打包并压缩目录。<br>首先声明一点，压缩命令不能直接压缩目录，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#ll -d test test.tar</span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test</span><br><span class="line">-rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们之前已经把<span class="built_in">test</span>目录打包成test.tar文件</span></span><br><span class="line">[root@localhost ~]# gzip test.tar</span><br><span class="line">[root@localhost ~]# ll test.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gzip命令会把test.tar压缩成test.tar.gz</span></span><br></pre></td></tr></table></figure>

<h4 id="tar命令做解打包操作"><a href="#tar命令做解打包操作" class="headerlink" title="tar命令做解打包操作"></a>tar命令做解打包操作</h4><p>当 tar 命令用于对 tar 包做解打包操作时，该命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 压缩包</span><br></pre></td></tr></table></figure>

<p>当用于解打包时，常用的选项与含义如表 2 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-x</td>
<td>对 tar 包做解打包操作。</td>
</tr>
<tr>
<td>-f</td>
<td>指定要解压的 tar 包的包名。</td>
</tr>
<tr>
<td>-t</td>
<td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td>
</tr>
<tr>
<td>-C 目录</td>
<td>指定解打包位置。</td>
</tr>
<tr>
<td>-v</td>
<td>显示解打包的具体过程。</td>
</tr>
</tbody></table>
<p>其实解打包和打包相比，只是把打包选项 “-cvf” 更换为 “-xvf”。我们来试试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg. tar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解打包到当前目录下</span></span><br></pre></td></tr></table></figure>

<p>如果使用 “-xvf” 选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 “-C(大写)” 选项。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf test.tar -C /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把文件包test.tar解打包到/tmp/目录下</span></span><br></pre></td></tr></table></figure>

<p>如果只想查看文件包中有哪些文件，则可以把解打包选项 “-x” 更换为测试选项 “-t”。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -tvf test.tar</span><br><span class="line">drwxr-xr-x root/root 0 2016-06-17 21:09 test/</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test3</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test2</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">会用长格式显示test.tar文件包中文件的详细信息</span></span><br></pre></td></tr></table></figure>

<h4 id="tar命令做打包压缩（解压缩解打包）操作"><a href="#tar命令做打包压缩（解压缩解打包）操作" class="headerlink" title="tar命令做打包压缩（解压缩解打包）操作"></a>tar命令做打包压缩（解压缩解打包）操作</h4><p>你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成 “.tar” 格式，再压缩成 “.tar.gz” 或 “.tar.bz2” 格式。其实 tar 命令是可以同时打包压缩的，前面的讲解之所打包和压缩分开，是为了让大家了解在 Linux 中打包和压缩的不同。</p>
<p>当 tar 命令同时做打包压缩的操作时，其基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 压缩包 源文件或目录</span><br></pre></td></tr></table></figure>

<p>此处常用的选项有以下 2 个，分别是：</p>
<ul>
<li>-z：压缩和解压缩 “.tar.gz” 格式；</li>
<li>-j：压缩和解压缩 “.tar.bz2”格式。</li>
</ul>
<p>【例 1】压缩与解压缩 “.tar.gz”格式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把/temp/目录直接打包压缩为<span class="string">&quot;.tar.gz&quot;</span>格式，通过<span class="string">&quot;-z&quot;</span>来识别格式，<span class="string">&quot;-cvf&quot;</span>和打包选项一致</span></span><br><span class="line"></span><br><span class="line">解压缩也只是在解打包选项 &quot;-xvf&quot; 前面加了一个 &quot;-z&quot; 选项。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# tar -zxvf tmp.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压缩与解打包<span class="string">&quot;.tar.gz&quot;</span>格式</span></span><br></pre></td></tr></table></figure>

<p>前面讲的选项 “-C” 用于指定解压位置、”-t” 用于查看压缩包内容，在这里同样适用。</p>
<p>【例 2】压缩与解压缩 “.tar.bz2” 格式。<br>和”.tar.gz”格式唯一的不同就是”-zcvf”选项换成了 “-jcvf”，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打包压缩为<span class="string">&quot;.tar.bz2&quot;</span>格式，注意压缩包文件名</span></span><br><span class="line">[root@localhost ~]# tar -jxvf tmp.tar.bz2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压缩与解打包<span class="string">&quot;.tar.bz2&quot;</span>格式</span></span><br></pre></td></tr></table></figure>

<p>把文件直接压缩成”.tar.gz”和”.tar.bz2”格式，才是 Linux 中最常用的压缩方式，这是大家一定要掌握的压缩和解压缩方法。</p>
<p>tar 命令最初被用来在磁带上创建备份，现在可以在任何设备上创建备份。利用 tar 命令可以把一大堆的文件和目录打包成一个文件，这对于备份文件或是将几个文件组合成为一个文件进行网络传输是非常有用的。</p>
<h3 id="Linux-zip命令：压缩文件或目录"><a href="#Linux-zip命令：压缩文件或目录" class="headerlink" title="Linux zip命令：压缩文件或目录"></a>Linux zip命令：压缩文件或目录</h3><p>我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式，</p>
<p>本节要讲的 zip 命令，类似于 Windows 系统中的 winzip 压缩程序，其基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#zip [选项] 压缩包名 源文件或源目录列表</span><br></pre></td></tr></table></figure>

<p>注意，zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用。</p>
<p>该命令常用的几个选项及各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td>
</tr>
<tr>
<td>-m</td>
<td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的压缩过程信息。</td>
</tr>
<tr>
<td>-q</td>
<td>在压缩的时候不显示命令的执行过程。</td>
</tr>
<tr>
<td>-压缩级别</td>
<td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td>
</tr>
<tr>
<td>-u</td>
<td>更新压缩文件，即往压缩文件中添加新文件。</td>
</tr>
</tbody></table>
<p>下面给大家举几个例子。</p>
<p>【例 1】zip 命令的基本使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip ana.zip anaconda-ks.cfg</span><br><span class="line">adding: anaconda-ks.cfg (deflated 37%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">[root@localhost ~]# ll ana.zip</span><br><span class="line">-rw-r--r-- 1 root root 935 6月 1716:00 ana.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure>

<p>不仅如此，所有的压缩命令都可以同时压缩多个文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip test.zip install.log install.log.syslog</span><br><span class="line">adding: install.log (deflated 72%)</span><br><span class="line">adding: install.log.syslog (deflated 85%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同时压缩多个文件到test.zip压缩包中</span></span><br><span class="line">[root@localhost ~]#ll test.zip</span><br><span class="line">-rw-r--r-- 1 root root 8368 6月 1716:03 test.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure>

<p>【例 2】使用 zip 命令压缩目录，需要使用“-r”选项，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir dir1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立测试目录</span></span><br><span class="line">[root@localhost ~]# zip -r dir1.zip dir1</span><br><span class="line">adding: dir1/(stored 0%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩目录</span></span><br><span class="line">[root@localhost ~]# ls -dl dir1.zip</span><br><span class="line">-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-unzip命令：解压zip文件"><a href="#Linux-unzip命令：解压zip文件" class="headerlink" title="Linux unzip命令：解压zip文件"></a>Linux unzip命令：解压zip文件</h3><p>unzip 命令可以查看和解压缩 zip 文件。该命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip [选项] 压缩包名</span><br></pre></td></tr></table></figure>

<p>此命令常用的选项以及各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d 目录名</td>
<td>将压缩文件解压到指定目录下。</td>
</tr>
<tr>
<td>-n</td>
<td>解压时并不覆盖已经存在的文件。</td>
</tr>
<tr>
<td>-o</td>
<td>解压时覆盖已经存在的文件，并且无需用户确认。</td>
</tr>
<tr>
<td>-v</td>
<td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩文件有无损坏，但并不解压。</td>
</tr>
<tr>
<td>-x 文件列表</td>
<td>解压文件，但不包含文件列表中指定的文件。</td>
</tr>
</tbody></table>
<p>【例 1】不论是文件压缩包，还是目录压缩包，都可以直接解压缩，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip dir1.zip</span><br><span class="line">Archive: dir1.zip</span><br><span class="line">creating: dirl/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压缩</span></span><br></pre></td></tr></table></figure>

<p>【例 2】使用 -d 选项手动指定解压缩位置，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip -d /tmp/ ana.zip</span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把压缩包解压到指定位置</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-gzip命令：压缩文件或目录"><a href="#Linux-gzip命令：压缩文件或目录" class="headerlink" title="Linux gzip命令：压缩文件或目录"></a>Linux gzip命令：压缩文件或目录</h3><p>gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为“.gz”。</p>
<p>再强调一下，gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。</p>
<p>gzip 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip [选项] 源文件</span><br></pre></td></tr></table></figure>

<p>命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件。该命令常用的选项及含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>将压缩数据输出到标准输出中，并保留源文件。</td>
</tr>
<tr>
<td>-d</td>
<td>对压缩文件进行解压缩。</td>
</tr>
<tr>
<td>-r</td>
<td>递归压缩指定目录下以及子目录下的所有文件。</td>
</tr>
<tr>
<td>-v</td>
<td>对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</td>
</tr>
<tr>
<td>-l</td>
<td>对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。</td>
</tr>
<tr>
<td>-数字</td>
<td>用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。</td>
</tr>
</tbody></table>
<p>【例 1】基本压缩。<br>gzip 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可。我们来试试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩instal.log 文件</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg install.log.gz install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成，但是源文件也消失了</span></span><br></pre></td></tr></table></figure>

<p>【例 2】保留源文件压缩。<br>在使用 gzip 命令压缩文件时，源文件会消失，从而生成压缩文件。这时有些人会有强迫症，就逼问笔者：能不能在压缩文件的时候，不让源文件消失？好吧，也是可以的，不过很别扭。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip -c anaconda-ks.cfg &gt;anaconda-ks.cfg.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到压缩文件和源文件都存在</span></span><br></pre></td></tr></table></figure>

<p>【例 3】 压缩目录。<br>我们可能会想当然地认为 gzip 命令可以压缩目录。 我们来试试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir test</span><br><span class="line">[root@localhost ~]# touch test/test1</span><br><span class="line">[root@localhost ~]# touch test/test2</span><br><span class="line">[root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件</span><br><span class="line">[root@localhost ~]# gzip -r test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩目录，并没有报错</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是查看发现<span class="built_in">test</span>目录依然存在，并没有变为压缩文件</span></span><br><span class="line">[root@localhost ~]# ls test/</span><br><span class="line">testl .gz test2.gz test3.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩</span></span><br></pre></td></tr></table></figure>

<p>在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。</p>
<h3 id="Linux-gunzip命令：解压缩文件或目录"><a href="#Linux-gunzip命令：解压缩文件或目录" class="headerlink" title="Linux gunzip命令：解压缩文件或目录"></a>Linux gunzip命令：解压缩文件或目录</h3><p>gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz）。</p>
<p>对于解压被 gzip 压缩过的文件，还可以使用 gzip 自己，即 gzip -d 压缩包。</p>
<p>gunzip 命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip [选项] 文件</span><br></pre></td></tr></table></figure>

<p>该命令常用的选项及含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归处理，解压缩指定目录下以及子目录下的所有文件。</td>
</tr>
<tr>
<td>-c</td>
<td>把解压缩后的文件输出到标准输出设备。</td>
</tr>
<tr>
<td>-f</td>
<td>强制解压缩文件，不理会文件是否已存在等情况。</td>
</tr>
<tr>
<td>-l</td>
<td>列出压缩文件内容。</td>
</tr>
<tr>
<td>-v</td>
<td>显示命令执行过程。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩文件是否正常，但不对其做解压缩操作。</td>
</tr>
</tbody></table>
<p>【例 1】直接解压缩文件。</p>
<p>[root@localhost ~]# gunzip install.log.gz</p>
<p>当然，”gunzip -r”依然只会解压缩目录下的文件，而不会解打包。要想解压缩”.gz”格式，还可以使用 “gzip -d”命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip -d anaconda-ks.cfg.gz</span><br></pre></td></tr></table></figure>

<p>【例 2】要解压缩目录下的内容，则需使用 “-r” 选项，例如：</p>
<p>[root@localhost ~]# gunzip -r test&#x2F;</p>
<p>注意，如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zcat anaconda-ks.cfg.gz</span><br></pre></td></tr></table></figure>

<h3 id="Linux-bzip2命令：压缩文件（-bz2格式）"><a href="#Linux-bzip2命令：压缩文件（-bz2格式）" class="headerlink" title="Linux bzip2命令：压缩文件（.bz2格式）"></a>Linux bzip2命令：压缩文件（.bz2格式）</h3><p>bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件。当执行压缩任务完成后，会生成一个以“.bz2”为后缀的压缩包。</p>
<p>“.bz2”格式是 Linux 的另一种压缩格式，从理论上来讲，”.bz2”格式的算法更先进、压缩比更好；而 “.gz”格式相对来讲的时间更快。</p>
<p>bzip2 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bzip2 [选项] 源文件</span><br></pre></td></tr></table></figure>

<p>源文件指的要压缩或解压缩的文件，该命令常用的选项及各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。</td>
</tr>
<tr>
<td>-k</td>
<td>bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。</td>
</tr>
<tr>
<td>-f</td>
<td>bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩包文件的完整性。</td>
</tr>
<tr>
<td>-v</td>
<td>压缩或解压缩文件时，显示详细信息。</td>
</tr>
<tr>
<td>-数字</td>
<td>这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高</td>
</tr>
</tbody></table>
<p>注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。</p>
<p>【例 1】直接压缩文件。</p>
<p>[root@localhost ~]# bzip2 anaconda-ks.cfg<br>#压缩成”.bz2”格式</p>
<p>此压缩命令会在压缩的同时删除源文件。</p>
<p>【例 2】压缩的同时保留源文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bzip2 -k install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg.bz2 install.loginstalLlogsyslog install.logsyslogbz2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件和源文件都存在</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-bunzip2命令：bz2格式的解压缩命令"><a href="#Linux-bunzip2命令：bz2格式的解压缩命令" class="headerlink" title="Linux bunzip2命令：bz2格式的解压缩命令"></a>Linux bunzip2命令：bz2格式的解压缩命令</h3><p>要解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令。</p>
<p>bunzip2 命令的使用和 gunzip 命令大致相同，bunzip2 命令只能用于解压文件，即便解压目录，也是解压该目录以及所含子目录下的所有文件。</p>
<p>bunzip2 命令的基本格式为：</p>
<p>[root@localhost ~]# bunzip2 [选项] 源文件</p>
<p>此命令常用的选项以及各自的含义，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-k</td>
<td>解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。</td>
</tr>
<tr>
<td>-f</td>
<td>解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。</td>
</tr>
<tr>
<td>-v</td>
<td>显示命令执行过程。</td>
</tr>
<tr>
<td>-L</td>
<td>列出压缩文件内容。</td>
</tr>
</tbody></table>
<p>先试试使用 gunzip2 命令来进行解压缩，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bunzip2 anaconda-ks.cfg.bz2</span><br></pre></td></tr></table></figure>

<p>“.bz2” 格式也可以使用 “bzip2 -d 压缩包” 命令来进行解压缩，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bzip2 -d install.log.syslog.bz2</span><br></pre></td></tr></table></figure>

<p>和 “.gz” 格式一样，”.bz2” 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bzcat install.log.syslog.bz2</span><br></pre></td></tr></table></figure>

<h2 id="Vim文本编辑器"><a href="#Vim文本编辑器" class="headerlink" title="Vim文本编辑器"></a>Vim文本编辑器</h2><p>Vim 是一个基于文本界面的编辑工具，使用简单且功能强大。更重要的是，Vim 是所有 Linux 发行版本默认的文本编辑器。</p>
<p>很多人习惯将 Vim 称为 Vi，其实 Vim 是 Vi 的增强版（在 Vi 的基础上增加了正则表达式的查找、多窗口的编辑等功能），使用 Vim 进行程序开发会更加方便。</p>
<h3 id="Linux-Vim三种工作模式（命令模式、输入模式和编辑模式）"><a href="#Linux-Vim三种工作模式（命令模式、输入模式和编辑模式）" class="headerlink" title="Linux Vim三种工作模式（命令模式、输入模式和编辑模式）"></a>Linux Vim三种工作模式（命令模式、输入模式和编辑模式）</h3><p>使用 Vim 编辑文件时，存在 3 种工作模式，分别是命令模式、输入模式和编辑模式，这 3 种工作模式可随意切换，如图 1 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151449460.jpg" alt="img"></p>
<h4 id="Vim的命令模式"><a href="#Vim的命令模式" class="headerlink" title="Vim的命令模式"></a>Vim的命令模式</h4><p>使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键（上、下、左、右键）或 k、j、h、i 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。</p>
<h4 id="Vim的输入模式"><a href="#Vim的输入模式" class="headerlink" title="Vim的输入模式"></a>Vim的输入模式</h4><p>在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。</p>
<p>使 Vim 进行输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令（各指令的具体功能如表 3 所示），当编辑文件完成后按 Esc 键即可返回命令模式。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令</td>
</tr>
<tr>
<td>o</td>
<td>在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本</td>
</tr>
<tr>
<td>O</td>
<td>在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本</td>
</tr>
<tr>
<td>a</td>
<td>在当前光标所在位置之后插入随后输入的文本</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令</td>
</tr>
</tbody></table>
<h4 id="Vim-的编辑模式"><a href="#Vim-的编辑模式" class="headerlink" title="Vim 的编辑模式"></a>Vim 的编辑模式</h4><p>编辑模式用于对文件中的指定内容执行保存、查找或替换等操作。</p>
<p>使 Vim 切换到编辑模式的方法是在命令模式状态下按“：”键，此时 Vim 窗口的左下方出现一个“：”符号，这是就可以输入相关指令进行操作了。</p>
<p>指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可。</p>
<p>对于新手来说，经常不知道自己处于什么模式。不论是自己忘了，还是不小心切换了模式，都可以按一次 Esc 键返回命令模式。如果你多按几次 Esc 键后听到”嘀————“的声音，则代表你已经处于命令模式了。</p>
<h3 id="Linux-Vim基本操作（文件的打开和编辑）"><a href="#Linux-Vim基本操作（文件的打开和编辑）" class="headerlink" title="Linux Vim基本操作（文件的打开和编辑）"></a>Linux Vim基本操作（文件的打开和编辑）</h3><h4 id="Vim-打开文件"><a href="#Vim-打开文件" class="headerlink" title="Vim 打开文件"></a>Vim 打开文件</h4><p>使用 Vim 打开文件很简单，例如在命令行模式下打开一个自己编写的文件 &#x2F;test&#x2F;vi.test，打开方法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@itxdl ~]# vim /test/vi.test</span><br></pre></td></tr></table></figure>

<p>刚打开文件时 Vim 处于命令模式，此时文件的下方会显示文件的一些信息，包括文件的总行数和字符数，以及当前光标所在的位置等，此时可以使用插入命令进入输入模式对文件进行编辑</p>
<p>除此之外，我们还可以利用下表中打开文件的命令格式，针对特定情形使用适当的打开方式，可以大大提高我们的效率。</p>
<table>
<thead>
<tr>
<th>Vi 使用的选项</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>vim filename</td>
<td>打开或新建一个文件，并将光标置于第一行的首部</td>
</tr>
<tr>
<td>vim -r filename</td>
<td>恢复上次 vim 打开时崩溃的文件</td>
</tr>
<tr>
<td>vim -R filename</td>
<td>把指定的文件以只读方式放入 Vim 编辑器中</td>
</tr>
<tr>
<td>vim + filename</td>
<td>打开文件，并将光标置于最后一行的首部</td>
</tr>
<tr>
<td>vi +n filename</td>
<td>打开文件，并将光标置于第 n 行的首部</td>
</tr>
<tr>
<td>vi +&#x2F;pattern filename</td>
<td>打幵文件，并将光标置于第一个与 pattern 匹配的位置</td>
</tr>
<tr>
<td>vi -c command filename</td>
<td>在对文件进行编辑前，先执行指定的命令</td>
</tr>
</tbody></table>
<h4 id="使用-Vim-进行编辑"><a href="#使用-Vim-进行编辑" class="headerlink" title="使用 Vim 进行编辑"></a>使用 Vim 进行编辑</h4><p>同样，Vim 提供了大量的编辑快捷键，主要可分为以下几类。</p>
<h5 id="Vim-插入文本"><a href="#Vim-插入文本" class="headerlink" title="Vim 插入文本"></a>Vim 插入文本</h5><p>从命令模式进入输入模式进行编辑，可以按下 I、i、O、o、A、a 等键来完成，使用不同的键，光标所处的位置不同，如表 3 所示。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令</td>
</tr>
<tr>
<td>o</td>
<td>在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本</td>
</tr>
<tr>
<td>O（大写）</td>
<td>在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本</td>
</tr>
<tr>
<td>a</td>
<td>在当前光标所在位置之后插入随后输入的文本</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行 a 命令</td>
</tr>
</tbody></table>
<h5 id="Vim-查找文本"><a href="#Vim-查找文本" class="headerlink" title="Vim 查找文本"></a>Vim 查找文本</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;abc</td>
<td>从光标所在位置向前查找字符串 abc</td>
</tr>
<tr>
<td>&#x2F;^abc</td>
<td>查找以 abc 为行首的行</td>
</tr>
<tr>
<td>&#x2F;abc$</td>
<td>查找以 abc 为行尾的行</td>
</tr>
<tr>
<td>?abc</td>
<td>从光标所在为主向后查找字符串 abc</td>
</tr>
<tr>
<td>n</td>
<td>向同一方向重复上次的查找指令</td>
</tr>
<tr>
<td>N</td>
<td>向相反方向重复上次的查找指定</td>
</tr>
</tbody></table>
<p>如果在文件中并没有找到所要查找的字符串，则在文件底部会出现 “Pattern not found” 提示</p>
<p>在查找过程中需要注意的是，要查找的字符串是严格区分大小写的，如查找 “shenchao” 和 “ShenChao” 会得到不同的结果。</p>
<blockquote>
<p>如果想忽略大小写，则输入命令 “:set ic”；调整回来输入”:set noic”。</p>
</blockquote>
<p>如果在字符串中出现特殊符号，则需要加上转义字符 “&quot;。常见的特殊符号有 \、*、?、$ 等。如果出现这些字符，例如，要查找字符串 “10$”，则需要在命令模式中输入 “&#x2F;10$“。</p>
<h5 id="Vim-替换文本"><a href="#Vim-替换文本" class="headerlink" title="Vim 替换文本"></a>Vim 替换文本</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>替换光标所在位置的字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td>
</tr>
<tr>
<td>:s&#x2F;a1&#x2F;a2&#x2F;g</td>
<td>将当前光标所在行中的所有 a1 用 a2 替换</td>
</tr>
<tr>
<td>:n1,n2s&#x2F;a1&#x2F;a2&#x2F;g</td>
<td>将文件中 n1 到 n2 行中所有 a1 都用 a2 替换</td>
</tr>
<tr>
<td>:g&#x2F;a1&#x2F;a2&#x2F;g</td>
<td>将文件中所有的 a1 都用 a2 替换</td>
</tr>
</tbody></table>
<p>例如，要将某文件中所有的 “root” 替换为 “liudehua”，则有两种输入命令，分别为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:1, $s/root/liudehua/g</span><br><span class="line">或</span><br><span class="line">:%s/root/liudehua/g</span><br></pre></td></tr></table></figure>

<p>上述命令是在编辑模式下操作的，表示的是从第一行到最后一行，即全文查找 “root”，然后替换成 “liudehua”。</p>
<p>如果刚才的命令变成 <code>:10,20 s/root/liudehua/g</code>，则只替换从第 10 行到第 20 行的 “root”。</p>
<h5 id="Vim删除文本"><a href="#Vim删除文本" class="headerlink" title="Vim删除文本"></a>Vim删除文本</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除光标所在位置的字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行（包括此行）后 n 行文本</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行一直到文件末尾的所有内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标位置到行尾的内容</td>
</tr>
<tr>
<td>:a1,a2d</td>
<td>函数从 a1 行到 a2 行的文本内容</td>
</tr>
</tbody></table>
<p>注意，被删除的内容并没有真正删除，都放在了剪贴板中。将光标移动到指定位置处，按下 “p” 键，就可以将刚才删除的内容又粘贴到此处。</p>
<h5 id="Vim复制和粘贴文本"><a href="#Vim复制和粘贴文本" class="headerlink" title="Vim复制和粘贴文本"></a>Vim复制和粘贴文本</h5><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>p</td>
<td>将剪贴板中的内容粘贴到光标后</td>
</tr>
<tr>
<td>P（大写）</td>
<td>将剪贴板中的内容粘贴到光标前</td>
</tr>
<tr>
<td>y</td>
<td>复制已选中的文本到剪贴板</td>
</tr>
<tr>
<td>yy</td>
<td>将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行</td>
</tr>
<tr>
<td>yw</td>
<td>将光标位置的单词复制到剪贴板</td>
</tr>
</tbody></table>
<h5 id="Vim其他常用快捷键"><a href="#Vim其他常用快捷键" class="headerlink" title="Vim其他常用快捷键"></a>Vim其他常用快捷键</h5><p>某些情况下，可能需要把两行进行连接。比如说，下面的文件中有两行文本，现在需要将其合并成一行（实际上就是将两行间的换行符去掉）。可以直接在命令模式中按下 “J” 键，按下前后如图 10 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151449799.jpg" alt="img"><br>图 10 按下 “J” 键前后</p>
<p>如果不小心误删除了文件内容，则可以通过 “u” 键来撤销刚才执行的命令。如果要撤销刚才的多次操作，可以多按几次 “u” 键。</p>
<h5 id="Vim-保存退出文本"><a href="#Vim-保存退出文本" class="headerlink" title="Vim 保存退出文本"></a>Vim 保存退出文本</h5><p>Vim 的保存和退出是在编辑模式中进行的，其常用命令如下表所示。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>:wq</td>
<td>保存并退出 Vim 编辑器</td>
</tr>
<tr>
<td>:wq!</td>
<td>保存并强制退出 Vim 编辑器</td>
</tr>
<tr>
<td>:q</td>
<td>不保存就退出 Vim 编辑器</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存，且强制退出 Vim 编辑器</td>
</tr>
<tr>
<td>:w</td>
<td>保存但是不退出 Vim 编辑器</td>
</tr>
<tr>
<td>:w!</td>
<td>强制保存文本</td>
</tr>
<tr>
<td>:w filename</td>
<td>另存到 filename 文件</td>
</tr>
<tr>
<td>x！</td>
<td>保存文本，并退出 Vim 编辑器，更通用的一个 vim 命令</td>
</tr>
<tr>
<td>ZZ</td>
<td>直接退出 Vim 编辑器</td>
</tr>
</tbody></table>
<p>需要注意的是，”w!” 和 “wq!” 等类似的指令，通常用于对文件没有写权限的时候（显示 readonly），但如果你是文件的所有者或者 root 用户，就可以强制执行。</p>
<h3 id="Vim移动光标快捷键汇总"><a href="#Vim移动光标快捷键汇总" class="headerlink" title="Vim移动光标快捷键汇总"></a>Vim移动光标快捷键汇总</h3><p>Vim 文本编辑器中，最简单的移动光标的方式是使用方向键，但这种方式的效率太低，更高效的方式使用快捷键。</p>
<p>Vim 移动光标常用的快捷键及其功能如下面各表所示，需要注意的是，表中所有的快捷键都在命令模式（默认状态）下直接使用。</p>
<h4 id="Vim快捷方向键"><a href="#Vim快捷方向键" class="headerlink" title="Vim快捷方向键"></a>Vim快捷方向键</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>光标向左移动一位</td>
</tr>
<tr>
<td>j</td>
<td>光标向下移动一行（以回车为换行符），也就是光标向下移动</td>
</tr>
<tr>
<td>k</td>
<td>光标向上移动一行（也就是向上移动）</td>
</tr>
<tr>
<td>l</td>
<td>光标向右移动一位</td>
</tr>
</tbody></table>
<p>最初使用，大家可能觉得比较别扭，但熟能生巧，使用此方式移动光标同样能够提高编辑速度。</p>
<h4 id="Vim光标以单词为单位移动"><a href="#Vim光标以单词为单位移动" class="headerlink" title="Vim光标以单词为单位移动"></a>Vim光标以单词为单位移动</h4><p>某些情形下，可能需要光标迅速移动至一行中的某个位置，将光标以单词为单位进行移动就会很方便。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>w 或 W</td>
<td>光标移动至下一个单词的单词首</td>
</tr>
<tr>
<td>b 或 B</td>
<td>光标移动至上一个单词的单词首</td>
</tr>
<tr>
<td>e 或 E</td>
<td>光标移动至下一个单词的单词尾</td>
</tr>
<tr>
<td>nw 或 nW</td>
<td>n 为数字，表示光标向右移动 n 个单词</td>
</tr>
<tr>
<td>nb 或 nB</td>
<td>n 为数字，表示光标向左移动 n 个单词</td>
</tr>
</tbody></table>
<h4 id="Vim光标移动至行首或行尾"><a href="#Vim光标移动至行首或行尾" class="headerlink" title="Vim光标移动至行首或行尾"></a>Vim光标移动至行首或行尾</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>0 或 ^</td>
<td>光标移动至当前行的行首</td>
</tr>
<tr>
<td>$</td>
<td>光标移动至当前行的行尾</td>
</tr>
<tr>
<td>n$</td>
<td>光标移动至当前行只有 n 行的行尾，n为数字</td>
</tr>
</tbody></table>
<h4 id="Vim光标移动至指定字符"><a href="#Vim光标移动至指定字符" class="headerlink" title="Vim光标移动至指定字符"></a>Vim光标移动至指定字符</h4><p>一行中，如果需要将光标移动到当前行的某个特点字符，则可以使用表 4 中的快捷键。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>fx</td>
<td>光标移动至当前行中下一个 x 字符处</td>
</tr>
<tr>
<td>Fx</td>
<td>光标移动至当前行中下一个 x 字符处</td>
</tr>
</tbody></table>
<h4 id="Vim光标移动到指定行"><a href="#Vim光标移动到指定行" class="headerlink" title="Vim光标移动到指定行"></a>Vim光标移动到指定行</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>光标移动到文件开头</td>
</tr>
<tr>
<td>G</td>
<td>光标移动至文件末尾</td>
</tr>
<tr>
<td>nG</td>
<td>光标移动到第 n 行，n 为数字</td>
</tr>
<tr>
<td>:n</td>
<td>编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首</td>
</tr>
</tbody></table>
<h4 id="Vim光标移动到匹配的括号处"><a href="#Vim光标移动到匹配的括号处" class="headerlink" title="Vim光标移动到匹配的括号处"></a>Vim光标移动到匹配的括号处</h4><p>程序员在编辑程序时，经常会为将光标移动到与一个 “(“ 匹配的 “)” （对于 [] 和 {} 也是一样的）处而感到头疼。Vim 里面提供了一个非常方便地査找匹配括号的命令，这就是 “%”。</p>
<p>比如，在 &#x2F;etc&#x2F;init.d&#x2F;sshd 脚本文件中（最好还是复制后练习，小心驶得万年船），想迅速地将光标定位到与第 49 行的 “{“ 相对应的 “}” 处，则可以将光标先定位在 “{“ 处，然后再使用 “％” 命令，使之定位在 “}” 处，如图 6 所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151449801.jpg" alt="使用&quot;％&quot;命令定位括号"><br>图 6 使用”％”命令定位括号</p>
<h3 id="Linux-Vim撤销和恢复撤销快捷键"><a href="#Linux-Vim撤销和恢复撤销快捷键" class="headerlink" title="Linux Vim撤销和恢复撤销快捷键"></a>Linux Vim撤销和恢复撤销快捷键</h3><p>使用 Vim 编辑文件内容时，经常会有如下 2 种需求：</p>
<ul>
<li>对文件内容做了修改之后，却发现整个修改过程是错误或者没有必要的，想将文件恢复到修改之前的样子。</li>
<li>将文件内容恢复之后，经过仔细考虑，又感觉还是刚才修改过的内容更好，想撤销之前做的恢复操作。</li>
</ul>
<p>基于这 2 种需求，Vim 编辑器提供了撤销和恢复撤销的命令，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>u（小写）</td>
<td>undo 的第 1 个字母，功能是撤销最近一次对文本做的修改操作。</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>Redo 的第 1 个字母，功能是恢复最近一次所做的撤销操作。</td>
</tr>
<tr>
<td>U（大写）</td>
<td>第一次会撤销对一行文本（光标所在行）做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，以上这 3 种命令都必须在 Vim 编辑器处于命令模式时才能使用。</p>
</blockquote>
<p>下面通过一个例子来演示以上 3 个命令的具体用法。首先，我们新建一个 demo.txt 文件并打开，键入一行内容，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>然后按“Esc”键，使 Vim 由输入模式转为命令模式，并使用 yy 命令将这一行文本复制到剪贴板中，如此我们就可以在文本任意位置通过键入 p（或大写的 P）命令将复制的内容粘贴到光标所在的位置。</p>
<p>假设我们将光标调整到第一行最后一个字符处，连续按两次 p 命令（粘贴 2 次），则此时文本中的内容变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>在此基础上，通过 u（小写）命令就可以使文本内容恢复到上一次做粘贴操作之前的样子，其中“上一次”的含义是，恢复操作是可以叠加的，即按一次就会在现有基础上做一次恢复操作。</p>
<p>比如，继续操作 demo.txt 文件，按一次 u，会发现其文本内容变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>再按一次 u，文本内容继续恢复为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>同样，恢复撤销的操作和撤销操作是相对应的，通过按 Ctrl+R 组合键，可以撤销之前所做的一次恢复操作。例如，继续操作 demo.txt 文件，按一次 Ctrl+R，会发现其文本内容恢复为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>再按一次 Ctrl+R，文本内容又恢复为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>U（大写）的功能和之前的 2 个命令不同，它的作用是撤销或恢复撤销对光标所在行文本所做的全部操作。比如，我们对 demo.txt 文件内容做如下修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw新增内容</span><br></pre></td></tr></table></figure>

<p>可以看到，这里对第三行文本做了 2 处修改。在此基础上，如果在命令模式下键入 U（大写），可以看到，之前对第 3 行所做的 2 处修改，全部被恢复了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>如果此时再键入 U（大写），则又会恢复之前对第 3 行文本做过的全部操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw</span><br><span class="line">www.forever.cn.mw新增内容</span><br></pre></td></tr></table></figure>

<h3 id="Linux-Vim可视化模式及其用法"><a href="#Linux-Vim可视化模式及其用法" class="headerlink" title="Linux Vim可视化模式及其用法"></a>Linux Vim可视化模式及其用法</h3><p>相信大家都使用过带图形界面的操作系统中的文字编辑器，用户可以使用鼠标来选择要操作的文本，非常方便。在 Vim 编辑器中也有类似的功能，但不是通过鼠标，而是通过键盘来选择要操作的文本。</p>
<p>在 Vim 中，如果想选中目标文本，就需要调整 Vim 进入可视化模式，如表 1 所示，通过在 Vim 命令模式下键入不同的键，可以进入不同的可视化模式。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v（小写）</td>
<td>又称字符可视化模式，此模式下目标文本的选择是以字符为单位的，也就是说，该模式下要一个字符一个字符的选中要操作的文本。</td>
</tr>
<tr>
<td>V（大写）</td>
<td>又称行可视化模式，此模式化目标文本的选择是以行为单位的，也就是说，该模式化可以一行一行的选中要操作的文本。</td>
</tr>
<tr>
<td>Ctrl+v（组合键）</td>
<td>又称块可视化模式，该模式下可以选中文本中的一个矩形区域作为目标文本，以按下 Ctrl+v 位置作为矩形的一角，光标移动的终点位置作为它的对角。</td>
</tr>
</tbody></table>
<p>以字符可视化模式为例，Vim 成功进入该模式的标志是窗口底部出现 –VISUAL– 标志</p>
<p>相应地，进入行可视化模式的标志是标记处显示 –VISUAL LINE–；进入块可视化模式的标志是图 2 标记处显示 –VISUAL BLOCK–。</p>
<p>需要注意的是，当选中文本并做完相应操作（例如选中文件并按 p 键将其复制到剪贴板中）后，Vim 会自动从可视化模式转换为命令模式。当然，也可以再次按 v（或者 V、Ctrl+v）手动退出可视化模式。</p>
<p>另外值得一提的是，之前所学的在 Vim 命令模式下编辑文本的很多命令，在可视化模式下仍然可以使用。表 3 中罗列出了常用的几个可以在可视化模式下使用的命令。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>删除选中的部分文本。</td>
</tr>
<tr>
<td>D</td>
<td>删除选中部分所在的行，和 d 不同之处在于，即使选中文本中有些字符所在的行没有都选中，删除时也会一并删除。</td>
</tr>
<tr>
<td>y</td>
<td>将选中部分复制到剪贴板中。</td>
</tr>
<tr>
<td>p（小写）</td>
<td>将剪贴板中的内容粘贴到光标之后。</td>
</tr>
<tr>
<td>P（大写）</td>
<td>将剪贴板中的内容粘贴到光标之前。</td>
</tr>
<tr>
<td>u（小写）</td>
<td>将选中部分中的大写字符全部改为小写字符。</td>
</tr>
<tr>
<td>U（大写）</td>
<td>将选中部分中的小写字符全部改为大写字符。</td>
</tr>
<tr>
<td>&gt;</td>
<td>将选中部分右移（缩进）一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。</td>
</tr>
<tr>
<td>&lt;</td>
<td>将选中部分左移一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。</td>
</tr>
</tbody></table>
<h3 id="Vim-多窗口编辑"><a href="#Vim-多窗口编辑" class="headerlink" title="Vim 多窗口编辑"></a>Vim 多窗口编辑</h3><p>vim提供多窗口编辑的功能，可以简化复合的编辑任务。vim的多窗口并不是说在终端上启动多个vim实例。</p>
<h4 id="启动多窗口编辑"><a href="#启动多窗口编辑" class="headerlink" title="启动多窗口编辑"></a>启动多窗口编辑</h4><p>viｍ的多窗口是动态的，可以开始编辑时就打开多窗口，也可以工作时随时增加新窗口，或者删除一个窗口。<br>$ vim  -o  file1 file2  打开一个编辑会话，显示为水平分割成两半的窗口，一个文件占用一个窗口。<br>$ vim  -O  file1 file2  和上面相同，不过是垂直分割两半的窗口</p>
<p>如果画面分割后不足以容纳下所有窗口，那么第一个文件会占用大部分窗口，余下的窗口则载入缓冲区，暂时不能看到，但仍可以取用。</p>
<p>-o后面加一个数字n，是预分配窗口的形式打开：</p>
<p>$ vim  -o5 file1  file2  将分配5个相同的窗口，有3个是闲置的</p>
<h4 id="vim的多窗口编辑"><a href="#vim的多窗口编辑" class="headerlink" title="vim的多窗口编辑"></a>vim的多窗口编辑</h4><p>：split    新建一个窗口，将当前窗口分割成两半，他们显示的是相同缓冲区的内容（同一个文件）。这样就可以在两个窗口中浏览相同的文件了。</p>
<p>：vsplit   创建全新的垂直分割的窗口，同样是显示和当前窗口同一个文件内容。效果如下：</p>
<p>当多个窗口编辑同一个文件时，在任意一个窗口进行编辑（例如删除一行），那么所有相同文件的窗口上都会同时反应效果，因为他们共享同一个文件缓冲区。</p>
<p>如果想编辑或浏览另一个文件，而又不想失去在当前文件中的编辑位置，就用新文件的参数传给：split命令<br>：split  otherfile</p>
<h4 id="分割窗口的选项"><a href="#分割窗口的选项" class="headerlink" title="分割窗口的选项"></a>分割窗口的选项</h4><p>：[n] split(vsplit)  [++opt]  [+cmd]  [file]</p>
<p>命令中：<br>n   为vim指定在新窗口中显示的行数，且新窗口的大小刚好容纳该行数，新窗口位于画面顶端<br>opt  传递vim选项信息给新的窗口会话（请注意，它的前面必须加上两个加号）<br>cmd 传入欲在新窗口中执行的命令（请注意，它的前面必须加上一个加号）<br>file  指定在新窗口中编辑的文件</p>
<p>：sview  filename  以只读的方式水平分割打开一个新窗口<br>：sfind  [++opt]  [+cmd]  [file]  和split的运作方式相似，但在path中寻找filename，如果vim未找到文件则不显示</p>
<h4 id="在窗口间游走"><a href="#在窗口间游走" class="headerlink" title="在窗口间游走"></a>在窗口间游走</h4><p>在gvim或vim中，在窗口中移动其实非常简单，因为gvim已默认支持鼠标点击来换编辑窗口，而vim中，则可以打开mouse选项，<br>：set  mouse &#x3D; a   为命令、输入、导航都激活鼠标的使用</p>
<p>我们知道vim的特色就是可以脱离鼠标而工作，所以可以使用vim提供的全套导航命令，在会话中快速而准确的移动编辑窗口。</p>
<p>按住Ctrl + W，然后再加上h, j, k, l，分别表示向左、下、上、右移动窗口<br>Ctrl + w + h：向左移动窗口<br>Ctrl + w + j： 向下移动窗口<br>Ctrl + w + j： 向上移动窗口<br>Ctrl + w + l： 向右移动窗口</p>
<p>Ctrl + w + w：这个命令会在所有窗口中循环移动<br>Ctrl + w + t：移动到最左上角的窗口<br>Ctrl + w + b：移动到最右下角的窗口<br>Ctrl + w + p：移动到前一个访问的窗口</p>
<h4 id="移动窗口"><a href="#移动窗口" class="headerlink" title="移动窗口"></a>移动窗口</h4><p>vim中有两种移动窗口方式，一种只是简单地在屏幕上切换窗口，尺寸维持不变；另一种则是改变窗口的实际布局，还会调整尺寸，以填充它移动的位置。</p>
<ol>
<li><h5 id="移动窗口本身（轮换或交换）"><a href="#移动窗口本身（轮换或交换）" class="headerlink" title="移动窗口本身（轮换或交换）"></a>移动窗口本身（轮换或交换）</h5></li>
</ol>
<p>Ctrl + w + r：向右或向下方交换窗口，而Ctrl + w + R则和它方向相反。</p>
<p>光标会随着窗口而移动</p>
<p>Ctrl + w + x：交换同列或同行的窗口的位置。vim默认交换当前窗口的与它下一个窗口的位置，如果下方没有窗口，则试着与上一个窗口交换位置。亦可在此命令前加上数量，与制定的窗口交换位置。</p>
<ol start="2">
<li><h5 id="移动窗口并改变其布局"><a href="#移动窗口并改变其布局" class="headerlink" title="移动窗口并改变其布局"></a>移动窗口并改变其布局</h5></li>
</ol>
<p>注：下面的第三个字母都是大写，按玩Ctrl + w之后，按shif + 相应的字母。后面用^代替Ctrl<br>Ctrl + w + K ：移动当前窗口至屏幕顶端，并占用全部宽度<br>^WJ： 移动窗口至屏幕底端，并占用全部宽度<br>^WH：移动窗口至屏幕左端，并占用全部高度<br>^WL：移动窗口至屏幕右端，并占用全部高度</p>
<p>^WT ：移动窗口至屏新的现有分页</p>
<ol start="3">
<li><h5 id="调整窗口尺寸"><a href="#调整窗口尺寸" class="headerlink" title="调整窗口尺寸"></a>调整窗口尺寸</h5></li>
</ol>
<p>改变当前窗口的尺寸，同时当然也会影响到其他窗口。<br>在gvim和vim中，可以用鼠标点击窗口的顶部白色条并窗口直接调整尺寸。</p>
<p>也可以直接用命令，调整尺寸命令也是以Ctrl + W开头：<br>Ctrl + W + &#x3D;  ：让所有窗口调整至相同尺寸（平均划分）<br>Ctrl + W + -：将当前窗口的高度减少一行，也可在ex命令中，：resize -4明确指定减少的尺寸<br>Ctrl + W + +：将当前窗口的高度增加一行。同样在ex命令中，：resize +n 明确指定增加尺寸</p>
<p>Ctrl + W + &lt; ：将当前窗口的宽度减少<br>Ctrl + W + &gt; ：将当前窗口的宽度增加</p>
<p>Ctrl + W + |：将当前窗口的宽度调到最大，也可他哦你通过ex命令：vertical resize n明确指定改变宽度</p>
<h4 id="分页编辑"><a href="#分页编辑" class="headerlink" title="分页编辑"></a>分页编辑</h4><p>除了使多窗口编辑外，vim还允许创建多个分页（tab），每个分页各有独自的行为，类似于浏览器firefox或chrome的分页浏览功能。</p>
<p>我们可以在vim或gvim中使用分页，但在gvim会更好用。<br>最终要的命令<br>：tabnew filename  打开新分页并编辑新文件（可选的）。如果未指定文件，则只打开新分页，并附上空的缓冲区。<br>：tabclose  关闭当前分页<br> ：tabonly  关闭其他所有的分页。如果其他分页中有修改过的文件，则不会移除该分页，除非设置了autowrite选项。此时，所有修改过的文件都在分页关闭前写入磁盘。</p>
<h4 id="游走分页"><a href="#游走分页" class="headerlink" title="游走分页"></a>游走分页</h4><p>可以直接点鼠标来移动到另一个分页，也可以用命令</p>
<p>Ctrl + PageDown：移动到下一个分页</p>
<p>Ctrl + PageUp：移动到上一个分页</p>
<h4 id="关闭与离开窗口"><a href="#关闭与离开窗口" class="headerlink" title="关闭与离开窗口"></a>关闭与离开窗口</h4><p>有4种关闭窗口的方式，分别是：离开（quit）、关闭（close）、隐藏（hide）、关闭其他窗口</p>
<p>^代表Ctrl键<br>^Wq，离开当前窗口<br>^Wc，关闭当前的窗口<br>^Wo，关闭当前窗口以外的所有窗口</p>
<h3 id="Linux-Vim批量注释和自定义注释快捷键"><a href="#Linux-Vim批量注释和自定义注释快捷键" class="headerlink" title="Linux Vim批量注释和自定义注释快捷键"></a>Linux Vim批量注释和自定义注释快捷键</h3><p>使用 Vim 编辑 Shell 脚本，在进行调试时，需要进行多行的注释，每次都要先切换到输入模式，在行首输入注释符”#”再退回命令模式，非常麻烦。</p>
<p>连续行的注释其实可以用替换命令来完成。换句话说，在指定范围行加”#”注释，可以使用 “:起始行，终止行 s&#x2F;^&#x2F;#&#x2F;g”，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,10s/^/#/g</span><br></pre></td></tr></table></figure>

<p>表示在第 1~10 行行首加”#”注释。”^”意为行首；”g”表示执行替换时不询问确认。如果希望每行交互询问是否执行，则可将 “g” 改为 “c”。</p>
<p>取消连续行注释，则可以使用 “:起始行，终止行s&#x2F;^#&#x2F;&#x2F;g”，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,10s/^#//g</span><br></pre></td></tr></table></figure>

<p>意为将行首的”#”替换为空，即删除。</p>
<p>当然，使用语言不同，注释符号或想替换的内容不同，都可以采用此方法，灵活运用即可。</p>
<p>添加”&#x2F;&#x2F;“注释要稍微麻烦一些，命令格式为 “:起始行，终止行 s&#x2F;^&#x2F;//&#x2F;g”。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,5s/^/\/\//g</span><br></pre></td></tr></table></figure>

<p>表示在第 1~5 行行首加”&#x2F;&#x2F;“注释，因为 “&#x2F;“ 前面需要加转义字符 “&quot;，所以写出来比较奇特。</p>
<p>以上方法可以解决连续行的注释问题，如果是非连续的多行就不灵了，这时我们可以定义快捷键简化操作。格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:map 快捷键 执行命令</span><br></pre></td></tr></table></figure>

<p>如定义快捷键 “Ctrl+P” 为在行首添加 “#” 注释，可以执行 “:map^P l#&lt;Esc&gt;”。其中 “^P” 为定义快捷键 “Ctrl+P”。注意：必须同时按 “Ctrl+V+P” 快捷键生成 “^P” 方可有效，或先按 “Ctrl+V” 再按 “Ctrl+P” 也可以，直接输入 “^P” 是无效的。</p>
<p>“l#&lt;Esc&gt;” 就是此快捷键要触发的动作，”l” 为在光标所在行行首插入，”#” 为要输入的字符，”&lt;Esc&gt;” 表示退回命令模式。”&lt;Esc&gt;” 要逐个字符输入，不可直接按键盘上的 Esc 键。</p>
<p>设置成功后，直接在任意需要注释的行上按 “Ctrl+P” 快捷键，就会自动在行首加上 “#” 注释。取消此快捷键定义，输入 “:unmap^P” 即可。</p>
<p>我们可以延伸一下，如果想取消文件行首的快捷键，则可以设置 “:map^B 0x”，快捷键为 “Ctrl+B”, “0” 表示跳到行首，”x” 表示删除光标所在处字符。</p>
<p>再如，有时我们写完脚本等文件，需要在末尾注释中加入自己的邮箱，则可以直接定义每次按快捷键 “Ctrl+E” 实现插入邮箱，定义方法为 “:map^E <a href="mailto:&#x61;&#x31;&#x32;&#x33;&#x34;&#53;&#64;&#x71;&#x71;&#46;&#99;&#111;&#x6d;">&#x61;&#x31;&#x32;&#x33;&#x34;&#53;&#64;&#x71;&#x71;&#46;&#99;&#111;&#x6d;</a>&lt;Esc&gt;”。其中 “a” 表示在当前字符后插入，”<a href="mailto:&#x31;&#x32;&#51;&#x34;&#x35;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#x31;&#x32;&#51;&#x34;&#x35;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>“ 为插入的邮箱，”&lt;Esc&gt;” 表示插入后返回命令模式。</p>
<p>所以，通过定义快捷键，我们可以把前面讲到的命令组合起来使用。</p>
<p>将快捷键对应的命令保存在 .vimrc 文件中，即可在每次使用 Vim 时自动调用，非常方便。</p>
<p>要在 Vim 中显示行号，请使用 :set number 命令显示绝对行号，使用 :set relativenumber 显示相对行号。如果同时启用了绝对行号和相对行号，则 Vim 会切换到混合行号模式。</p>
<h3 id="Vim配置文件（-vimrc）"><a href="#Vim配置文件（-vimrc）" class="headerlink" title="Vim配置文件（.vimrc）"></a>Vim配置文件（.vimrc）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">&quot; 使用vim的modeline来设置当前文件的textwidth,</span><br><span class="line">&quot; 避免输入超过78个字符时自动换行</span><br><span class="line">&quot; 使用:verbose set textwidth?命令可以看到vim默认</span><br><span class="line">&quot; 为vim配置脚本设置了textwidth为78,当输入超过78个字符</span><br><span class="line">&quot; 并按下空格键时会自动换行.将textwidth设成0关闭该功能</span><br><span class="line">&quot;&quot; vim: tw=0 :</span><br><span class="line"></span><br><span class="line">&quot; 去掉有关vi一致性模式,避免操作习惯上的局限.</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; 让Backspace键可以往前删除字符.</span><br><span class="line">&quot; Debian系统自带的vim版本会加载一个debian.vim文件,</span><br><span class="line">&quot; 默认已经设置这一项,</span><br><span class="line">&quot; 可以正常使用Backspace键.如果使用自己编译的vim版本,</span><br><span class="line">&quot; 并自行配置.vimrc文件,可能就没有设置这一项,导致</span><br><span class="line">&quot; Backspace键用不了,或者时灵时不灵.所以主动配置.</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line"></span><br><span class="line">&quot; 1=启动显示状态行, 2=总是显示状态行.</span><br><span class="line">&quot; 设置总是显示状态行,方便看到当前文件名.</span><br><span class="line">set laststatus=2</span><br><span class="line"></span><br><span class="line">&quot; 设置ruler会在右下角显示光标所在的行号和列号,</span><br><span class="line">&quot; 不方便查看.改成设置状态栏显示内容</span><br><span class="line">&quot;&quot; set ruler</span><br><span class="line"></span><br><span class="line">&quot; 设置状态行显示的内容. %F: 显示当前文件的完整路径.</span><br><span class="line">&quot; %r: 如果readonly,会显示[RO]</span><br><span class="line">&quot; %B: 显示光标下字符的编码值,十六进制.</span><br><span class="line">&quot; %l:光标所在的行号. %v:光标所在的虚拟列号.</span><br><span class="line">&quot; %P: 显示当前内容在整个文件中的百分比.</span><br><span class="line">&quot; %H和%M是strftime()函数的参数,获取时间.</span><br><span class="line">set statusline=%F%r\ [HEX=%B][%l,%v,%P]\ %&#123;strftime(\&quot;%H:%M\&quot;)&#125;</span><br><span class="line"> </span><br><span class="line">&quot; 显示还没有输入完整的命令.例如yy命令,输入第一个y会在右下角显示y.</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 使用Tab键补全时,在状态栏显示匹配的列表,</span><br><span class="line">&quot; 方便查看都有哪些命令符合补全条件.</span><br><span class="line">set wildmenu</span><br><span class="line"></span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示所有搜索到的内容.后面用map映射</span><br><span class="line">&quot; 快捷键来方便关闭当前搜索的高亮.</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 光标立刻跳转到搜索到内容</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 搜索到最后匹配的位置后,再次搜索不回到第一个匹配处</span><br><span class="line">set nowrapscan</span><br><span class="line"></span><br><span class="line">&quot; 去掉输入错误时的提示声音</span><br><span class="line">set noeb</span><br><span class="line"></span><br><span class="line">&quot; 默认按下Esc后,需要等待1秒才生效,</span><br><span class="line">&quot; 设置Esc超时时间为100ms,尽快生效</span><br><span class="line">set ttimeout</span><br><span class="line">set ttimeoutlen=100</span><br><span class="line"></span><br><span class="line">&quot; 设置文件编码,主要是避免中文乱码.</span><br><span class="line">&quot; 先注释,后续遇到中文乱码再打开</span><br><span class="line">&quot;&quot; set fileencodings=utf-8,cp936,big5,latin1</span><br><span class="line"></span><br><span class="line">&quot; FIXME 在MS-DOS控制台打开vim时,控制台使用鼠标</span><br><span class="line">&quot; 右键来复制粘贴,设置全鼠标模式,鼠标右键被映射为</span><br><span class="line">&quot; visual mode,不能用来复制粘贴,不方便.但是如果不</span><br><span class="line">&quot; 设置鼠标模式,会无法使用鼠标滚轮来滚动界面.经过验证,</span><br><span class="line">&quot; 发现可以设成普通模式mouse=n来使用鼠标滚轮,也能使用</span><br><span class="line">&quot; 鼠标右键复制粘贴. mouse=c/mouse=i模式都不能用鼠标</span><br><span class="line">&quot; 滚轮. Linux下还是要设成 mouse=a</span><br><span class="line">set mouse=n</span><br><span class="line"></span><br><span class="line">&quot; FIXME 在MS-DOS控制台打开vim,光标很小,不方便看到光标</span><br><span class="line">&quot; 在哪里.下面设置cursorline,高亮光标所在的行.</span><br><span class="line">&quot; cursorlineopt=number只高亮行号部分,不影响正文内容</span><br><span class="line">&quot; 的显示. 在其他容易看到光标的终端上可以去掉这两个设置.</span><br><span class="line">set cursorline</span><br><span class="line">set cursorlineopt=number</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax enable</span><br><span class="line"></span><br><span class="line">&quot; 检测文件类型,并载入文件类型插件,</span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">&quot; 设置自动补全的选项. longest表示只自动补全最大匹配的部分,</span><br><span class="line">&quot; 剩余部分通过CTRL-P/CTRL-N来选择匹配项进行补全. menu表示</span><br><span class="line">&quot; 弹出可补全的内容列表.如果有多个匹配,longest选项不会自动选中</span><br><span class="line">&quot; 并完整补全,要多按一次CTRL-P,比较麻烦,不做设置,保持默认设置,</span><br><span class="line">&quot; vim默认没有设置longest.</span><br><span class="line">&quot;&quot; set completeopt=longest,menu</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进.这个导致从外面拷贝多行以空格开头的内容时,</span><br><span class="line">&quot; 会有多的缩进,先不设置.</span><br><span class="line">&quot;&quot; set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 设置C风格的自动缩进.设置filetype indent on后,就会根据文件</span><br><span class="line">&quot; 类型自动缩进.按照vim用户手册&#x27;30.3 Automatic indenting&#x27;的</span><br><span class="line">&quot; 说明,可以不再单独设置cindent.</span><br><span class="line">&quot;&quot; set cindent</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进时,缩进长度为4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot; 输入Tab字符时,自动替换成空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; 设置softtabstop有一个好处是可以用Backspace键来一次</span><br><span class="line">&quot; 删除4个空格. softtabstop的值为负数,会使用shiftwidth</span><br><span class="line">&quot; 的值,两者保持一致,方便统一缩进.</span><br><span class="line">set softtabstop=-1</span><br><span class="line"></span><br><span class="line">&quot; 设置颜色主题,适用于黑色背景.</span><br><span class="line">colorscheme slate</span><br><span class="line"></span><br><span class="line">&quot; 创建一个新的 MyTabSpace 组,并设置它的颜色</span><br><span class="line">highlight MyTabSpace ctermfg=darkgrey</span><br><span class="line"></span><br><span class="line">&quot; 指定tab字符和空格的颜色组为MyTabSpace,不同字符串</span><br><span class="line">&quot; 之间用|隔开,要使用\|转义.</span><br><span class="line">match MyTabSpace /\t\| /</span><br><span class="line"></span><br><span class="line">&quot; 针对特定类型的代码文件,设置显示Tab键和行尾空格以便在</span><br><span class="line">&quot; 查看代码时注意到它们.</span><br><span class="line">&quot; TODO 后续查看代码如果体验不好再改成用map映射快捷键</span><br><span class="line">&quot; 开关list来动态切换显示.</span><br><span class="line">autocmd FileType c,cpp,java,xml setlocal list | set listchars=tab:&gt;~,trail:.</span><br><span class="line"></span><br><span class="line">&quot; 配置 gtags 插件,用于在函数之间跳转,方便查看源代码.</span><br><span class="line">&quot; 参考 gtags-cscopde.vim 的注释,添加下面语句来</span><br><span class="line">&quot; 使用 &#x27;:tag&#x27; 和 &#x27;&lt;C-]&gt;&#x27;</span><br><span class="line">set cscopetag</span><br><span class="line">&quot; 设置 cscopetag 后,由于gtags-cscopde默认没有启动,</span><br><span class="line">&quot; 还需要进行下面的设置.结合这两个设置, gtags 就可以</span><br><span class="line">&quot; 使用Ctrl-]键来跳转到函数定义处.</span><br><span class="line">let GtagsCscope_Auto_Load = 1</span><br><span class="line">&quot; 配置 GtagsCscope_Auto_Load = 1 后,在没有GTAGS文件</span><br><span class="line">&quot; 的目录下使用vim,会提示 Gtags-cscope: GTAGS not found.</span><br><span class="line">&quot; Press ENTER or type command to continue</span><br><span class="line">&quot; 需要按回车才会打开文件.如果要去掉这个报错,需要设置GtagsCscope_Quiet = 1</span><br><span class="line">let g:GtagsCscope_Quiet = 1</span><br><span class="line">&quot; 设置只有一个匹配结果时,不显示quickfix窗口</span><br><span class="line">let g:Gtags_Close_When_Single = 1</span><br><span class="line"></span><br><span class="line">&quot; 配置 quickfix 相关命令的快捷键. 可以用:map命令</span><br><span class="line">&quot; 查看vim已有的快捷键映射.</span><br><span class="line">nnoremap &lt;F2&gt; :cclose&lt;CR&gt;</span><br><span class="line">nnoremap &lt;F3&gt; :cn&lt;CR&gt;</span><br><span class="line">nnoremap &lt;F4&gt; :cp&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; vim 用 map 命令来映射快捷键,它前面可以加一些前缀来对应</span><br><span class="line">&quot; 不同的场景.下面 map 前面的 nore 表示非递归. nore 前面</span><br><span class="line">&quot; 的n表示只在普通模式下生效.即,基于下面的配置,在插入模式下,</span><br><span class="line">&quot; 按F6没有这个映射效果.插入模式对应i. 下面配置cscope查找</span><br><span class="line">&quot; 文件命令的快捷键为F6,由于需要手动输入文件名,不要加&lt;CR&gt;</span><br><span class="line">nnoremap &lt;F6&gt; :cs find f&lt;Space&gt;</span><br><span class="line"></span><br><span class="line">&quot; 如果要去掉高亮显示搜索到的内容,需要再次搜索一些不存在的字符串,</span><br><span class="line">&quot; 比较麻烦.可以在vim的命令行中执行nohlsearch命令去掉当前高亮.</span><br><span class="line">&quot; 下面的 nohlsearch 以 : 开头表示在命令行执行.</span><br><span class="line">nnoremap &lt;F9&gt; :nohlsearch&lt;CR&gt;</span><br><span class="line">&quot; 插入模式下也用F9来去掉搜索高亮.下面的&lt;C-o&gt;表示CTRL-O.</span><br><span class="line">&quot; CTRL-O键可以在插入模式执行一次命令</span><br><span class="line">inoremap &lt;F9&gt; &lt;C-o&gt;:nohlsearch&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Vim中执行Linux命令的几种方式"><a href="#Vim中执行Linux命令的几种方式" class="headerlink" title="Vim中执行Linux命令的几种方式"></a>Vim中执行Linux命令的几种方式</h3><p>Vim 编辑器不仅提供了大量的命令来方便和加快我们的文件编辑工作，在此编辑器中，我们还可以直接使用 Linux 命令来进一步提高文件编辑的效率，这就是 Vim 编辑器的所谓过滤功能。</p>
<p>由于 Vim 编辑器中支持直接执行 Linux 命令，从而可以方便快捷地对文件完成以下操作：</p>
<ol>
<li>将一个命令的输出结果存入正在编辑的文件；</li>
<li>将正在编辑的文件中的一些数据作为某个指定 Linux 命令的输入。</li>
</ol>
<p>下面，通过一个简单的例子，来演示如何在 Vim 编辑器中执行 Linux 命令。</p>
<p>首先，我们新建一个 demo.txt 文件，并手动输入如下内容，并将光标移动至下一行开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br></pre></td></tr></table></figure>

<p>在此基础上，按 Esc 令 Vim 返回到命令模式，再按下<code>!!</code>，这时在窗口的左下角会出现<code>:.!</code>的提示信息，这就表明我们可以输入 Linux 命令了。例如，我们输入 date 命令</p>
<p>注意，窗口左下角的<code>:.!</code>表示操作文本的范围，其中 . 表示从光标所在行开始，! 表示后续会执行 Linux 命令，整体表示命令的执行结果将插入到光标所在行的位置，因此，如果光标所在位置处有数据，就会被命令的执行结果直接覆盖掉。</p>
<p>确认光标位置无误后，按 Enter（回车）键，这时会发现系统当前的日期和时间写到了 demo.txt 文件中第 2 行的位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">Tue Nov 12 07:20:49 PST 2021</span><br></pre></td></tr></table></figure>

<p>在此基础上，再向该文件中手动输入以下数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">Tue Nov 12 07:20:49 PST 2021</span><br><span class="line">1 文本1</span><br><span class="line">3 文本3</span><br><span class="line">2 文本2</span><br></pre></td></tr></table></figure>

<p>输出完成之后，将光标调整至第 3 行第 1 个字符的位置，然后按 Esc 使 Vim 进行命令模式，并按下<code>!&#125;</code>组合键，你会看到窗口的左下角出现<code>:.,$!</code>的提示信息</p>
<blockquote>
<p>其中 . 表示光标所在的当前行，$ 表示文件最后一行，因此和之前不同，这次选取的是文件中第 3 行及之后的所有内容。</p>
</blockquote>
<p>在此基础上，我们使用 sort 命令对选中文本按照第 1 列进行降序排序，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.,$!sort -nr -k1</span><br></pre></td></tr></table></figure>

<p>按 Enter（回车）键，可以看到，demo.txt 文件中的内容变成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.forever.cn.mw</span><br><span class="line">Tue Nov 12 07:20:49 PST 2021</span><br><span class="line">1 文本1</span><br><span class="line">2 文本2</span><br><span class="line">3 文本3</span><br></pre></td></tr></table></figure>

<p>由此，通过将所选文件作为 sort 命令的输入，实现了对该部分文本的降序排序操作。</p>
<p>除此之外，表 3 罗列出了常用的几种 Vim 和 Linux 命令搭配使用的方式</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:!命令</td>
<td>直接运行一个 Linux 命令，运行完毕之后，即可返回到 Vim 中。</td>
</tr>
<tr>
<td>:w!命令</td>
<td>将 Vim 中所有的文本内容作为指定命令的输入。但命令的执行结果不会写入到当前文件中。</td>
</tr>
<tr>
<td>:r!命令</td>
<td>将命令执行的结果写入到当前 Vim 中，例如 :!ls 表示将 ls 的执行结果输入到 Vim 中。</td>
</tr>
<tr>
<td>:nr!命令</td>
<td>其中 n 为数字，表示将命令的执行结果写入到 Vim 第 n 行的位置。例如，:3r!date 表示将 date 命令的执行结果写入到第 3 行文本处。</td>
</tr>
<tr>
<td>:n,m!命令</td>
<td>其中 n 表示起始行号，m为结束行号，功能是将 Vim 中指定的部分文本作为某个命令的输入，同时将命令的输出也插入到当前指定的位置。</td>
</tr>
<tr>
<td>:n,m w!命令</td>
<td>其中 n 表示起始行号，m为结束行号，其功能是 Vim 中指定的部分文本作为某个命令的输入，但命令的执行结果不会写入到文件中。</td>
</tr>
<tr>
<td>!!date</td>
<td>向 Vim 中插入当前时间。</td>
</tr>
</tbody></table>
<h2 id="Linux文本处理（Linux三剑客grep、sed和awk）"><a href="#Linux文本处理（Linux三剑客grep、sed和awk）" class="headerlink" title="Linux文本处理（Linux三剑客grep、sed和awk）"></a>Linux文本处理（Linux三剑客grep、sed和awk）</h2><h3 id="Linux-cat命令：连接文件并打印输出到标准输出设备"><a href="#Linux-cat命令：连接文件并打印输出到标准输出设备" class="headerlink" title="Linux cat命令：连接文件并打印输出到标准输出设备"></a>Linux cat命令：连接文件并打印输出到标准输出设备</h3><p>cat 命令可以用来显示文本文件的内容（类似于 DOS 下的 type 命令），也可以把几个文件内容附加到另一个文件中，即连接合并文件。</p>
<p>关于此命令，有人认为写 cat 命令的人是因为喜欢猫，因此给此命令起名为“cat”，其实不然，cat 是 concatenate（连接、连续）的简写。</p>
<p>cat 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat [选项] 文件名</span><br><span class="line">或者</span><br><span class="line">[root@localhost ~]# cat 文件1 文件2 &gt; 文件3</span><br></pre></td></tr></table></figure>

<p>这两种格式中，前者用于显示文件的内容，常用选项及各自的含义如表 1 所示；而后者用于连接合并文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>相当于 -vET 选项的整合，用于列出所有隐藏符号；</td>
</tr>
<tr>
<td>-E</td>
<td>列出每行结尾的回车符 $；</td>
</tr>
<tr>
<td>-n</td>
<td>对输出的所有行进行编号；</td>
</tr>
<tr>
<td>-b</td>
<td>同 -n 不同，此选项表示只对非空行进行编号。</td>
</tr>
<tr>
<td>-T</td>
<td>把 Tab 键 ^I 显示出来；</td>
</tr>
<tr>
<td>-V</td>
<td>列出特殊字符；</td>
</tr>
<tr>
<td>-s</td>
<td>当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。</td>
</tr>
</tbody></table>
<p>注意，cat 命令用于查看文件内容时，不论文件内容有多少，都会一次性显示。如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用<code>PgUp+上箭头</code>组合键向上翻页，但是这种翻页是有极限的，如果文件足够长，那么还是无法看全文件的内容。</p>
<p>因此，cat 命令适合查看不太大的文件。当然，在 Linux 中是可以使用其他的命令或方法来查看大文件的，我们以后再来学习。</p>
<p>【例 1】cat 命令本身非常简单，我们可以直接查看文件的内容。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Kickstart file automatically generated by anaconda.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version=DEVEL</span></span><br><span class="line">install</span><br><span class="line">cdrom</span><br><span class="line">lang zh一CN.UTF-8</span><br><span class="line">…省略部分内容...</span><br></pre></td></tr></table></figure>

<p>而如果使用 “-n” 选项，则会显示行号。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -n anaconda-ks.cfg</span><br><span class="line">1 # Kickstart file automatically generated by anaconda.</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 #version=DEVEL</span><br><span class="line">5 install</span><br><span class="line">6 cdrom</span><br><span class="line">…省略部分内容...</span><br></pre></td></tr></table></figure>

<p>如果使用 “-A” 选项，则相当于使用了 “-vET” 选项，可以查看文本中的所有隐藏符号，包括回车符（$）、Tab 键（^I）等。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -A anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Kickstart file automatically generated by anaconda.$</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">$</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version=DEVEL$</span></span><br><span class="line"><span class="meta prompt_">install$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">cdrom$</span></span><br><span class="line">…省略部分内容…</span><br></pre></td></tr></table></figure>

<p>【例 2】将文件 file1.txt 和 file2.txt 的内容合并后输出到文件 file3.txt 中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost base]# ls</span><br><span class="line">file1.txt  file2.txt</span><br><span class="line">[root@localhost base]# cat file1.txt</span><br><span class="line">www.forever.cn.mw(file1.txt)</span><br><span class="line">[root@localhost base]# cat file2.txt</span><br><span class="line">is great(file2.txt)</span><br><span class="line">[root@localhost base]# cat file1.txt file2.txt &gt; file3.txt</span><br><span class="line">[root@localhost base]# more file3.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">more 命令可查看文件中的内容</span></span><br><span class="line">www.forever.cn.mw(file1.txt)</span><br><span class="line">is great(file2.txt)</span><br><span class="line">[root@localhost base]# ls</span><br><span class="line">file1.txt  file2.txt  file3.txt</span><br></pre></td></tr></table></figure>

<h3 id="Linux-more命令：分屏显示文件内容"><a href="#Linux-more命令：分屏显示文件内容" class="headerlink" title="Linux more命令：分屏显示文件内容"></a>Linux more命令：分屏显示文件内容</h3><p>在讲解 cat 命令时，我们留下了一个疑问，即当使用 cat 命令查看文件内容时，如果文件过大，以至使用<code>PgUp+上箭头</code>组合键向上翻页也无法看全文件中的内容，该怎么办呢？这就需要使用 more 命令。</p>
<p>more 命令可以分页显示文本文件的内容，使用者可以逐页阅读文件中内容，此命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# more [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>more 命令比较简单，一般不用什么选项，对于表 1 中所列的选项，读者只需看到认识即可。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>计算行数时，以实际的行数，而不是自动换行过后的行数。</td>
</tr>
<tr>
<td>-p</td>
<td>不以卷动的方式显示每一页，而是先清除屏幕后再显示内容。</td>
</tr>
<tr>
<td>-c</td>
<td>跟 -p 选项相似，不同的是先显示内容再清除其他旧资料。</td>
</tr>
<tr>
<td>-s</td>
<td>当遇到有连续两行以上的空白行时，就替换为一行的空白行。</td>
</tr>
<tr>
<td>-u</td>
<td>不显示下引号（根据环境变量 TERM 指定的终端而有所不同）。</td>
</tr>
<tr>
<td>+n</td>
<td>从第 n 行开始显示文件内容，n 代表数字。</td>
</tr>
<tr>
<td>-n</td>
<td>一次显示的行数，n 代表数字。</td>
</tr>
</tbody></table>
<p>more 命令的执行会打开一个交互界面，因此读者有必要了解一些交互命令，常用的交互命令如表 2 所示。</p>
<table>
<thead>
<tr>
<th>交互指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h 或 ？</td>
<td>显示 more 命令交互命令帮助。</td>
</tr>
<tr>
<td>q 或 Q</td>
<td>退出 more。</td>
</tr>
<tr>
<td>v</td>
<td>在当前行启动一个编辑器。</td>
</tr>
<tr>
<td>:f</td>
<td>显示当前文件的文件名和行号。</td>
</tr>
<tr>
<td>!&lt;命令&gt; 或 :!&lt;命令&gt;</td>
<td>在子Shell中执行指定命令。</td>
</tr>
<tr>
<td>回车键</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>空格键</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>刷新屏幕。</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>显示当前行的行号。</td>
</tr>
<tr>
<td>‘</td>
<td>转到上一次搜索开始的地方。</td>
</tr>
<tr>
<td>Ctrf+f</td>
<td>向下滚动一页。</td>
</tr>
<tr>
<td>.</td>
<td>重复上次输入的命令。</td>
</tr>
<tr>
<td>&#x2F; 字符串</td>
<td>搜索指定的字符串。</td>
</tr>
<tr>
<td>d</td>
<td>向下移动半页。</td>
</tr>
<tr>
<td>b</td>
<td>向上移动一页。</td>
</tr>
</tbody></table>
<p>【例 1】用分页的方式显示 anaconda-ks.cfg 文件的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# more anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Kickstart file automatically generated by anaconda.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version=DEVEL</span></span><br><span class="line">install</span><br><span class="line">cdrom</span><br><span class="line">…省略部分内容…</span><br><span class="line"><span class="meta prompt_">--More--(69%</span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在这里执行交互命令即可</span></span><br></pre></td></tr></table></figure>

<p>【例 2】显示文件 anaconda-ks.cfg 的内容，每 10 行显示一屏，同时清楚屏幕，使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# more -c -10 anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">省略输出内容。</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-head命令：显示文件开头的内容"><a href="#Linux-head命令：显示文件开头的内容" class="headerlink" title="Linux head命令：显示文件开头的内容"></a>Linux head命令：显示文件开头的内容</h3><p>head 命令可以显示指定文件前若干行的文件内容，其基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# head [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>该命令常用选项以及各自的含义，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-n K</td>
<td>这里的 K 表示行数，该选项用来显示文件前 K 行的内容；如果使用 “-K” 作为参数，则表示除了文件最后 K 行外，显示剩余的全部内容。</td>
</tr>
<tr>
<td>-c K</td>
<td>这里的 K 表示字节数，该选项用来显示文件前 K 个字节的内容；如果使用 “-K”，则表示除了文件最后 K 字节的内容，显示剩余全部内容。</td>
</tr>
<tr>
<td>-v</td>
<td>显示文件名；</td>
</tr>
</tbody></table>
<p>注意，如不设置显示的具体行数，则默认显示 10 行的文本数据。</p>
<p>【例 1】基本用法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# head anaconda-ks.cfg</span><br><span class="line">head 命令默认显示文件的开头 10 行内容。如果想显示指定的行数，则只需使用 &quot;-n&quot; 选项即可，例如：</span><br><span class="line">[root@localhost ~]# head -n 20 anaconda-ks.cfg</span><br><span class="line">这是显示文件的开头 20 行内容，也可以直接写 &quot;-行数&quot;，例如：</span><br><span class="line">[root@localhost ~]# head -20 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h3 id="Linux-less命令：查看文件内容"><a href="#Linux-less命令：查看文件内容" class="headerlink" title="Linux less命令：查看文件内容"></a>Linux less命令：查看文件内容</h3><p>less 命令的作用和 more 十分类似，都用来浏览文本文件中的内容，不同之处在于，使用 more 命令浏览文件内容时，只能不断向后翻看，而使用 less 命令浏览，既可以向后翻看，也可以向前翻看。</p>
<p>不仅如此，为了方面用户浏览文本内容，less 命令还提供了以下几个功能：</p>
<ul>
<li>使用光标键可以在文本文件中前后（左后）滚屏；</li>
<li>用行号或百分比作为书签浏览文件；</li>
<li>提供更加友好的检索、高亮显示等操作；</li>
<li>兼容常用的字处理程序（如 Vim、Emacs）的键盘操作；</li>
<li>阅读到文件结束时，less 命令不会退出；</li>
<li>屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。</li>
</ul>
<p>less 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# less [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>此命令可用的选项以及各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项含义</th>
</tr>
</thead>
<tbody><tr>
<td>-N</td>
<td>显示每行的行号。</td>
</tr>
<tr>
<td>-S</td>
<td>行过长时将超出部分舍弃。</td>
</tr>
<tr>
<td>-e</td>
<td>当文件显示结束后，自动离开。</td>
</tr>
<tr>
<td>-g</td>
<td>只标志最后搜索到的关键同。</td>
</tr>
<tr>
<td>-Q</td>
<td>不使用警告音。</td>
</tr>
<tr>
<td>-i</td>
<td>忽略搜索时的大小写。</td>
</tr>
<tr>
<td>-m</td>
<td>显示类似 more 命令的百分比。</td>
</tr>
<tr>
<td>-f</td>
<td>强迫打开特殊文件，比如外围设备代号、目录和二进制文件。</td>
</tr>
<tr>
<td>-s</td>
<td>显示连续空行为一行。</td>
</tr>
<tr>
<td>-b &lt;缓冲区大小&gt;</td>
<td>设置缓冲区的大小。</td>
</tr>
<tr>
<td>-o &lt;文件名&gt;</td>
<td>将 less 输出的内容保存到指定文件中。</td>
</tr>
<tr>
<td>-x &lt;数字&gt;</td>
<td>将【Tab】键显示为规定的数字空格。</td>
</tr>
</tbody></table>
<p>在使用 less 命令查看文件内容的过程中，和 more 命令一样，也会进入交互界面，因此需要读者掌握一些常用的交互指令，如表 2 所示。</p>
<table>
<thead>
<tr>
<th>交互指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;字符串</td>
<td>向下搜索“字符串”的功能。</td>
</tr>
<tr>
<td>?字符串</td>
<td>向上搜索“字符串”的功能。</td>
</tr>
<tr>
<td>n</td>
<td>重复*前一个搜索（与 &#x2F; 成 ? 有关）。</td>
</tr>
<tr>
<td>N</td>
<td>反向重复前一个搜索（与 &#x2F; 或 ? 有关）。</td>
</tr>
<tr>
<td>b</td>
<td>向上移动一页。</td>
</tr>
<tr>
<td>d</td>
<td>向下移动半页。</td>
</tr>
<tr>
<td>h 或 H</td>
<td>显示帮助界面。</td>
</tr>
<tr>
<td>q 或 Q</td>
<td>退出 less 命令。</td>
</tr>
<tr>
<td>y</td>
<td>向上移动一行。</td>
</tr>
<tr>
<td>空格键</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>回车键</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>【PgDn】键</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>【PgUp】键</td>
<td>向上移动一页。</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>向上移动一页。</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>向上移动半页。</td>
</tr>
<tr>
<td>j</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>k</td>
<td>向上移动一行。</td>
</tr>
<tr>
<td>G</td>
<td>移动至最后一行。</td>
</tr>
<tr>
<td>g</td>
<td>移动到第一行。</td>
</tr>
<tr>
<td>ZZ</td>
<td>退出 less 命令。</td>
</tr>
<tr>
<td>v</td>
<td>使用配置的编辑器编辑当前文件。</td>
</tr>
<tr>
<td>[</td>
<td>移动到本文档的上一个节点。</td>
</tr>
<tr>
<td>]</td>
<td>移动到本文档的下一个节点。</td>
</tr>
<tr>
<td>p</td>
<td>移动到同级的上一个节点。</td>
</tr>
<tr>
<td>u</td>
<td>向上移动半页。</td>
</tr>
</tbody></table>
<p>【例 1】使用 less 命令查看 &#x2F;boot&#x2F;grub&#x2F;grub.cfg 文件中的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# less /boot/grub/grub.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#DO NOT EDIT THIS FILE</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#It is automatically generated by grub-mkconfig using templates from /etc/grub.d and settings from /etc/default/grub</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## BEGIN /etc/grub.d/00_header ###</span></span></span><br><span class="line">if [ -s $prefix/grubenv ]; then</span><br><span class="line"> set have_grubenv=true</span><br><span class="line"> load_env</span><br><span class="line">fi</span><br><span class="line">set default=&quot;0&quot;</span><br><span class="line">if [ &quot;$ &#123;prev_saved_entry&#125;&quot; ]; then</span><br><span class="line"> set saved_entry=&quot;$&#123;prev_saved_entry&#125;&quot;</span><br><span class="line"> save_env saved_entry</span><br><span class="line"> set prev_saved_entry= save_env prev_saved_entry</span><br><span class="line"> set boot_once=true</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">function savedefault &#123;</span><br><span class="line"> if [ -z &quot;$&#123;boot_once&#125;&quot; ]; then</span><br><span class="line">:</span><br></pre></td></tr></table></figure>

<p>可以看到，less 在屏幕底部显示一个冒号（：），等待用户输入命令，比如说，用户想向下翻一页，可以按空格键；如果想向上翻一页，可以按 b 键。</p>
<h3 id="Linux-tail命令：显示文件结尾的内容"><a href="#Linux-tail命令：显示文件结尾的内容" class="headerlink" title="Linux tail命令：显示文件结尾的内容"></a>Linux tail命令：显示文件结尾的内容</h3><p>tail 命令和 head 命令正好相反，它用来查看文件末尾的数据，其基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>此命令常用的选项及含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-n K</td>
<td>这里的 K 指的是行数，该选项表示输出最后 K 行，在此基础上，如果使用 -n +K，则表示从文件的第 K 行开始输出。</td>
</tr>
<tr>
<td>-c K</td>
<td>这里的 K 指的是字节数，该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 -c +K 则表示从文件第 K 个字节开始输出。</td>
</tr>
<tr>
<td>-f</td>
<td>输出文件变化后新增加的数据。</td>
</tr>
</tbody></table>
<p>【例 1】查看 &#x2F;etc&#x2F;passwd 文件最后 3 行的数据内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail -n 3 /etc/passwd</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">oprofile:x:16:16:Special user account to be used by OProfile:/var/lib/oprofile:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">除此之外，还可以采用如下这种形式：</span><br><span class="line">[root@localhost ~]# tail -3 /etc/passwd</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">oprofile:x:16:16:Special user account to be used by OProfile:/var/lib/oprofile:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>可以看到，使用 <code>tail -n 3 /etc/passwd</code> 命令和 <code>tail -3 /etc/passwd</code> 的效果是一样的。</p>
<p>【例 2】查看 &#x2F;etc&#x2F;passwd 文件末尾 100 个字节的数据内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail -c 100 /etc/passwd</span><br><span class="line">cpdump:x:72:72::/:/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>【例 3】 监听文件的新増内容。tail 命令有一种比较有趣的用法，可以使用 “-f” 选项来监听文件的新増内容，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tail -f anaconda-ks.cfg</span><br><span class="line">@server-platform</span><br><span class="line">@server-policy</span><br><span class="line">pax</span><br><span class="line">oddjob</span><br><span class="line">sgpio</span><br><span class="line">certmonger</span><br><span class="line">pam_krb5</span><br><span class="line">krb5-workstation</span><br><span class="line">perl-DBD-SQLite</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">光标不会退出文件，而会一直监听在文件的结尾处</span></span><br></pre></td></tr></table></figure>

<p>这条命令会显示文件的最后 10 行内容，而且光标不会退出命令，每隔一秒会检查一下文件是否增加新的内容，如果增加就追加到原来的输出结果后面并显示。因此，这时如果向文件中追加一些数据（需要开启一个新终端）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo 2222222222 &gt;&gt; anaconda-ks.cfg</span><br><span class="line">[root@localhost ~]# echo 3333333333 &gt;&gt; anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在新终端中通过<span class="built_in">echo</span>命令向文件中追加数据</span></span><br></pre></td></tr></table></figure>

<p>那么，在原始的正在监听的终端中，会看到如下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail -f anaconda-ks.cfg @server-platforin</span><br><span class="line">@server-policy</span><br><span class="line">pax</span><br><span class="line">oddjob</span><br><span class="line">sgpio</span><br><span class="line">certmonger</span><br><span class="line">pam_krb5</span><br><span class="line">krb5-workstation</span><br><span class="line">perl-DBD-SQLite</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">end2222222222</span></span><br><span class="line">33333333333</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在文件的结尾处监听到了新増数据</span></span><br></pre></td></tr></table></figure>

<p>如果想终止输出，按【Ctrl+c】键中断 tail 命令即可。</p>
<h3 id="Linux重定向用法详解"><a href="#Linux重定向用法详解" class="headerlink" title="Linux重定向用法详解"></a>Linux重定向用法详解</h3><h4 id="Linux-中的数据流"><a href="#Linux-中的数据流" class="headerlink" title="Linux 中的数据流"></a>Linux 中的数据流</h4><p>谈到 Linux 的重定向，就不得不提以下这3种数据流：</p>
<ul>
<li>输入信息会从 <code>stdin</code> 中读取（标准输入，通常是键盘或鼠标）。</li>
<li>输出信息会被输出到 <code>stdout</code> （标准输出，一个文本文件或者数据流）。</li>
<li>错误信息会被输出到 <code>stderr</code>。</li>
</ul>
<p>了解了这些数据流的存在，在你使用 Shell 时，你就可以更好地控制数据的流向了。</p>
<p>在 Linux 系统中，标准输入，标准输出以及标准错误都作为文件存在。你可以在 <code>/dev</code> 目录下看到它们：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /dev/std*</span></span><br><span class="line">/dev/stderr  /dev/stdin  /dev/stdout</span><br></pre></td></tr></table></figure>

<h4 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h4><p>在 Linux 系统中，使用 <code>&gt;</code> 字符表示重定向输出。例如，将 <code>ls</code> 命令的输出重定向到一个文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt; list.txt</span></span><br></pre></td></tr></table></figure>

<p>执行以上命令后，屏幕上并不会显示 <code>ls</code> 命令的输出信息，因为输出信息已经被重定向至 <code>list.txt</code> 文件中了。</p>
<p>除此之外，重定向还有许多用途，它还可以用于复制文件的内容，而且不限于复制文本文件，二进制文件也可以复制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> image.png &gt; picture.png</span></span><br></pre></td></tr></table></figure>

<p>如果你想要将一个文件的内容复制到另一个文件的末尾，你只需将 <code>&gt;</code> 字符换成 <code>&gt;&gt;</code> 字符串即可，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> lxlinux &gt;&gt; alvi</span></span><br></pre></td></tr></table></figure>

<h4 id="重定向输入"><a href="#重定向输入" class="headerlink" title="重定向输入"></a>重定向输入</h4><p>与重定向输出相反，重定向输入使用的是 <code>&lt;</code> 字符。</p>
<p>输入重定向可以将输入信息重定向至命令中作为参数使用。该功能可能比较少用，但是，当命令需要一个参数列表时，而这些参数都存在一个文件中，然后你想快速地将它们从文件中复制粘贴到终端，这时这个功能就能派上用场了。</p>
<p>例如，<code>package.list</code> 里记录了你需要安装的包的列表，而你想要快速地安装所有的包，只需执行以下这一条命令，就能一次性安装 <code>package.list</code> 里的所有包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install $(&lt;package.list)</span><br></pre></td></tr></table></figure>

<p>输入重定向的常见用法是 Here-document (简称 Here-doc) 以及 Here-string 。</p>
<p>Here-doc 将输入的文本块重定向至标准输入流，直至遇到特殊的文件结束标记符为止（文件结束标记符可以是任意的唯一的字符串，但大部分人都默认使用 <code>EOF</code>）。</p>
<p>你可以尝试在终端输入以下命令（直到第二个 <code>EOF</code> 字符串结束）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">alvin</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">lxlinux.net</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">EOF</span></span></span><br></pre></td></tr></table></figure>

<p>预期的输出应该是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alvin</span><br><span class="line">lxlinux.net</span><br></pre></td></tr></table></figure>

<p>Here-doc 是 Bash 脚本编写者们将多行文本转储到文件或屏幕上的常用技巧。</p>
<p>Here-string 与 Here-doc 相似，但是它只有一个字符串，或者几个被引号括起来的字符串：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt;&lt; <span class="string">alvin</span></span></span><br><span class="line">alvin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">cat &lt;&lt;&lt; &quot;alvin</span> lxlinux.net<span class="string">&quot;</span></span></span><br><span class="line">alvin lxlinux.net</span><br></pre></td></tr></table></figure>

<h4 id="重定向错误信息"><a href="#重定向错误信息" class="headerlink" title="重定向错误信息"></a>重定向错误信息</h4><p>错误信息默认会进入叫 <code>stderr</code> 的流，使用 <code>2&gt;</code> 可以对其进行重定向。例如，将错误信息重定向到名为 <code>output.log</code> 的文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /nope 2&gt; output.log</span></span><br></pre></td></tr></table></figure>

<h4 id="重定向数据至-dev-null"><a href="#重定向数据至-dev-null" class="headerlink" title="重定向数据至 &#x2F;dev&#x2F;null"></a>重定向数据至 &#x2F;dev&#x2F;null</h4><p>就像标准输入、标准输出以及标准错误一样，在 Linux 文件系统中，空，也存在一个文件与之对应，它叫做 <code>null</code> ，放在 <code>/dev</code> 目录下。为了方便读，人们经常省略斜杠，直接把他读作 <code>dev null</code> 。</p>
<p><code>/dev/null</code> 并不保存数据，被写入 <code>/dev/null</code> 的数据最终都会丢失，就像被丢进虚空中一样。因此，你可以使用重定向将不需要的数据输送到 <code>/dev/null</code> 。例如，<code>find</code> 命令的输出往往很冗长，而且在搜索文件时还经常会报告权限冲突的错误，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find ~ -<span class="built_in">type</span> f</span></span><br><span class="line">/home/seth/actual.file</span><br><span class="line">find: `/home/seth/foggy&#x27;: Permission denied</span><br><span class="line">find: `/home/seth/groggy&#x27;: Permission denied</span><br><span class="line">find: `/home/seth/soggy&#x27;: Permission denied</span><br><span class="line">/home/seth/zzz.file</span><br></pre></td></tr></table></figure>

<p>这时，你就可以将错误信息重定向到 <code>/dev/null</code> ，以过滤掉不必要的信息，像这样:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find ~ -<span class="built_in">type</span> f 2&gt; /dev/null</span></span><br><span class="line">/home/seth/actual.file</span><br><span class="line">/home/seth/zzz.file</span><br></pre></td></tr></table></figure>

<h3 id="Linux-grep命令详解：查找文件内容"><a href="#Linux-grep命令详解：查找文件内容" class="headerlink" title="Linux grep命令详解：查找文件内容"></a>Linux grep命令详解：查找文件内容</h3><p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用 grep 命令。</p>
<p>grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。</p>
<p>grep命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p>
<p>正则表达式是描述一组字符串的一个模式，正则表达式的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，grep 命令支持如表 1 所示的这几种正则表达式的元字符（也就是通配符）。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>c*</td>
<td>将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。</td>
</tr>
<tr>
<td>.</td>
<td>将匹配任何一个字符，且只能是一个字符。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>匹配方括号中的任意一个字符。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>匹配除方括号中字符外的所有字符。</td>
</tr>
<tr>
<td>^</td>
<td>锁定行的开头。</td>
</tr>
<tr>
<td>$</td>
<td>锁定行的结尾。</td>
</tr>
</tbody></table>
<p>需要注意的是，在基本正则表达式中，如通配符 *、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \，如 *、+、{、|、( 和 )。</p>
<p>grep 命令是用来在每一个文件或中（或特定输出上）搜索特定的模式，当使用 grep 时，包含指定字符模式的每一行内容，都会被打印（显示）到屏幕上，但是使用 grep 命令并不改变文件中的内容。</p>
<p>grep 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep [选项] 模式 文件名</span><br></pre></td></tr></table></figure>

<p>这里的模式，要么是字符（串），要么是正则表达式。而此命令常用的选项以及各自的含义如表 2 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>仅列出文件中包含模式的行数。</td>
</tr>
<tr>
<td>-i</td>
<td>忽略模式中的字母大小写。</td>
</tr>
<tr>
<td>-l</td>
<td>列出带有匹配行的文件名。</td>
</tr>
<tr>
<td>-n</td>
<td>在每一行的最前面列出行号。</td>
</tr>
<tr>
<td>-v</td>
<td>列出没有匹配模式的行。</td>
</tr>
<tr>
<td>-w</td>
<td>把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。</td>
</tr>
</tbody></table>
<p>注意，如果是搜索多个文件，grep 命令的搜索结果只显示文件中发现匹配模式的文件名；而如果搜索单个文件，grep 命令的结果将显示每一个包含匹配模式的行。</p>
<p>【例 1】假设有一份 emp.data 员工清单，现在要搜索此文件，找出职位为 CLERK 的所有员工，则执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep CLERK emp.data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">忽略输出内容</span></span><br></pre></td></tr></table></figure>

<p>而在此基础上，如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep -c CLERK emp.data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">忽略输出内容</span></span><br></pre></td></tr></table></figure>

<p>【例 2】搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep ^78 emp.data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">忽略输出内容</span></span><br></pre></td></tr></table></figure>


<p>grep 命令的功能非常强大，通过利用它的不同选项以及变化万千的正则表达式，可以获取任何我们所需要的信息。</p>
<h3 id="Linux-sed命令完全攻略"><a href="#Linux-sed命令完全攻略" class="headerlink" title="Linux sed命令完全攻略"></a>Linux sed命令完全攻略</h3><p>我们知道，Vim 采用的是交互式文本编辑模式，你可以用键盘命令来交互性地插入、删除或替换数据中的文本。但本节要讲的 sed 命令不同，它采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。</p>
<p>sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p>
<ol>
<li>每次仅读取一行内容；</li>
<li>根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li>
<li>将执行结果输出。</li>
</ol>
<p>当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p>
<p>sed 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed [选项] [脚本命令] 文件名</span><br></pre></td></tr></table></figure>

<p>该命令常用的选项及含义，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-e 脚本命令</td>
<td>该选项会将其后跟的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td>-f 脚本命令文件</td>
<td>该选项会将其后文件中的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td>-n</td>
<td>默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td>
</tr>
<tr>
<td>-i</td>
<td>此选项会直接修改源文件，要慎用。</td>
</tr>
</tbody></table>
<p>成功使用 sed 命令的关键在于掌握各式各样的脚本命令及格式，它能帮你定制编辑文件的规则。</p>
<h4 id="sed脚本命令"><a href="#sed脚本命令" class="headerlink" title="sed脚本命令"></a>sed脚本命令</h4><h4 id="sed-s-替换脚本命令"><a href="#sed-s-替换脚本命令" class="headerlink" title="sed s 替换脚本命令"></a>sed s 替换脚本命令</h4><p>此命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>

<p>其中，address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。</p>
<p>关于指定具体操作行（address）的用法，这里先不做解释，文章后续会对其做详细介绍。</p>
<p>此命令中常用的 flags 标记如表 2 所示。</p>
<table>
<thead>
<tr>
<th>flags 标记</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td>
</tr>
<tr>
<td>g</td>
<td>对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td>
</tr>
<tr>
<td>p</td>
<td>会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td>
</tr>
<tr>
<td>w file</td>
<td>将缓冲区中的内容写到指定的 file 文件中；</td>
</tr>
<tr>
<td>&amp;</td>
<td>用正则表达式匹配的内容进行替换；</td>
</tr>
<tr>
<td>\n</td>
<td>匹配第 n 个子串，该子串之前在 pattern 中用 () 指定。</td>
</tr>
<tr>
<td>\</td>
<td>转义（转义替换部分包含：&amp;、\ 等）。</td>
</tr>
</tbody></table>
<p>比如，可以指定 sed 用新文本替换第几处模式匹配的地方：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/test/trial/2&#x27; data4.txt</span><br><span class="line">This is a test of the trial script.</span><br><span class="line">This is the second test of the trial script.</span><br></pre></td></tr></table></figure>

<p>可以看到，使用数字 2 作为标记的结果就是，sed 编辑器只替换每行中第 2 次出现的匹配模式。</p>
<p>如果要用新文件替换所有匹配的字符串，可以使用 g 标记：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/test/trial/g&#x27; data4.txt</span><br><span class="line">This is a trial of the trial script.</span><br><span class="line">This is the second trial of the trial script.</span><br></pre></td></tr></table></figure>

<p>我们知道，-n 选项会禁止 sed 输出，但 p 标记会输出修改过的行，将二者匹配使用的效果就是只输出被替换命令修改过的行，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data5.txt</span><br><span class="line">This is a test line.</span><br><span class="line">This is a different line.</span><br><span class="line">[root@localhost ~]# sed -n &#x27;s/test/trial/p&#x27; data5.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure>

<p>w 标记会将匹配后的结果保存到指定文件中，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/test/trial/w test.txt&#x27; data5.txt</span><br><span class="line">This is a trial line.</span><br><span class="line">This is a different line.</span><br><span class="line">[root@localhost ~]#cat test.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure>

<p>在使用 s 脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/\/bin\/bash/\/bin\/csh/&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>

<h4 id="sed-d-替换脚本命令"><a href="#sed-d-替换脚本命令" class="headerlink" title="sed d 替换脚本命令"></a>sed d 替换脚本命令</h4><p>此命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]d</span><br></pre></td></tr></table></figure>

<p>如果需要删除文本中的特定行，可以用 d 脚本命令，它会删除指定行中的所有内容。但使用该命令时要特别小心，如果你忘记指定具体行的话，文件中的所有内容都会被删除，举个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">[root@localhost ~]# sed &#x27;d&#x27; data1.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">什么也不输出，证明成了空文件</span></span><br></pre></td></tr></table></figure>

<p>当和指定地址一起使用时，删除命令显然能发挥出大的功用。可以从数据流中删除特定的文本行。</p>
<p>address 的具体写法后续会做详细介绍，这里只给大家举几个简单的例子：</p>
<ul>
<li><p>通过行号指定，比如删除 data6.txt 文件内容中的第 3 行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">[root@localhost ~]# sed &#x27;3d&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者通过特定行区间指定，比如删除 data6.txt 文件内容中的第 2、3行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,3d&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心，你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，sed 会删除两个指定行之间的所有行（包括指定的行），例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#sed &#x27;/1/,/3/d&#x27; data6.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除第 1~3 行的文本数据</span></span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者通过特殊的文件结尾字符，比如删除 data6.txt 文件内容中第 3 行开始的所有的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3,$d&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure>

<p>在此强调，在默认情况下 sed 并不会修改原始文件，这里被删除的行只是从 sed 的输出中消失了，原始文件没做任何改变。</p>
</li>
</ul>
<h4 id="sed-a-和-i-脚本命令"><a href="#sed-a-和-i-脚本命令" class="headerlink" title="sed a 和 i 脚本命令"></a>sed a 和 i 脚本命令</h4><p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行，这里之所以要同时介绍这 2 个脚本命令，因为它们的基本格式完全相同，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]a（或 i）\新文本内容</span><br></pre></td></tr></table></figure>

<p>下面分别就这 2 个命令，给读者举几个例子。比如说，将一个新行插入到数据流第三行前，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3i\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is an inserted line.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is an inserted line.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>

<p>再比如说，将一个新行附加到数据流中第三行后，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3a\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is an appended line.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an appended line.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>

<p>如果你想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;1i\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is one line of new text.\</span></span><br><span class="line"><span class="language-bash">&gt; This is another line of new text.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is one line of new text.</span><br><span class="line">This is another line of new text.</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>

<p>可以看到，指定的两行都会被添加到数据流中。</p>
<h4 id="sed-c-替换脚本命令"><a href="#sed-c-替换脚本命令" class="headerlink" title="sed c 替换脚本命令"></a>sed c 替换脚本命令</h4><p>c 命令表示将指定行中的所有内容，替换成该选项后面的字符串。该命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]c\用于替换的新文本</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3c\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is a changed line of text.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>

<p>在这个例子中，sed 编辑器会修改第三行中的文本，其实，下面的写法也可以实现此目的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;/number 3/c\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is a changed line of text.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>

<h4 id="sed-y-转换脚本命令"><a href="#sed-y-转换脚本命令" class="headerlink" title="sed y 转换脚本命令"></a>sed y 转换脚本命令</h4><p>y 转换命令是唯一可以处理单个字符的 sed 脚本命令，其基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/outchars/</span><br></pre></td></tr></table></figure>

<p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。</p>
<p>举个简单例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;y/123/789/&#x27; data8.txt</span><br><span class="line">This is line number 7.</span><br><span class="line">This is line number 8.</span><br><span class="line">This is line number 9.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 7 again.</span><br><span class="line">This is yet another line.</span><br><span class="line">This is the last line in the file.</span><br></pre></td></tr></table></figure>

<p>可以看到，inchars 模式中指定字符的每个实例都会被替换成 outchars 模式中相同位置的那个字符。</p>
<p>转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置，再打个比方：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;This 1 is a test of 1 try.&quot; | sed &#x27;y/123/456/&#x27;</span><br><span class="line">This 4 is a test of 4 try.</span><br></pre></td></tr></table></figure>

<p>sed 转换了在文本行中匹配到的字符 1 的两个实例，我们无法限定只转换在特定地方出现的字符。</p>
<h4 id="sed-p-打印脚本命令"><a href="#sed-p-打印脚本命令" class="headerlink" title="sed p 打印脚本命令"></a>sed p 打印脚本命令</h4><p>p 命令表示搜索符号条件的行，并输出该行的内容，此命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]p</span><br></pre></td></tr></table></figure>

<p>p 命令常见的用法是打印包含匹配文本模式的行，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">[root@localhost ~]# sed -n &#x27;/number 3/p&#x27; data6.txt</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure>

<p>可以看到，用 -n 选项和 p 命令配合使用，我们可以禁止输出其他行，只打印包含匹配文本模式的行。</p>
<p>如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;/3/&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/line/test/p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 3.</span><br><span class="line">This is test number 3.</span><br></pre></td></tr></table></figure>

<p>sed 命令会查找包含数字 3 的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。</p>
<h4 id="sed-w-脚本命令"><a href="#sed-w-脚本命令" class="headerlink" title="sed w 脚本命令"></a>sed w 脚本命令</h4><p>w 命令用来将文本中指定行的内容写入文件中，此命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]w filename</span><br></pre></td></tr></table></figure>

<p>这里的 filename 表示文件名，可以使用相对路径或绝对路径，但不管是哪种，运行 sed 命令的用户都必须有文件的写权限。</p>
<p>下面的例子是将数据流中的前两行打印到一个文本文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;1,2w test.txt&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure>

<p>当然，如果不想让行直接输出，可以用 -n 选项，再举个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data11.txt</span><br><span class="line">Blum, R    Browncoat</span><br><span class="line">McGuiness, A Alliance</span><br><span class="line">Bresnahan, C Browncoat</span><br><span class="line">Harken, C   Alliance</span><br><span class="line">[root@localhost ~]# sed -n &#x27;/Browncoat/w Browncoats.txt&#x27; data11.txt</span><br><span class="line">cat Browncoats.txt</span><br><span class="line">Blum, R    Browncoat</span><br><span class="line">Bresnahan, C Browncoat</span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用 w 脚本命令，sed 可以实现将包含文本模式的数据行写入目标文件。</p>
<h4 id="sed-r-脚本命令"><a href="#sed-r-脚本命令" class="headerlink" title="sed r 脚本命令"></a>sed r 脚本命令</h4><p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，该命令的基本格式为：</p>
<p>[address]r filename</p>
<p>sed 命令会将 filename 文件中的内容插入到 address 指定行的后面，比如说：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data12.txt</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">[root@localhost ~]# sed &#x27;3r data12.txt&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>

<p>如果你想将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;$r data12.txt&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br></pre></td></tr></table></figure>

<h4 id="sed-q-退出脚本命令"><a href="#sed-q-退出脚本命令" class="headerlink" title="sed q 退出脚本命令"></a>sed q 退出脚本命令</h4><p>q 命令的作用是使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理。</p>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2q&#x27; test.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure>

<p>可以看到，sed 命令在打印输出第 2 行之后，就停止了，是 q 命令造成的，再比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;/number 1/&#123; s/number 1/number 0/;q; &#125;&#x27; test.txt</span><br><span class="line">This is line number 0.</span><br></pre></td></tr></table></figure>

<p>使用 q 命令之后，sed 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出。</p>
<h4 id="sed-脚本命令的寻址方式"><a href="#sed-脚本命令的寻址方式" class="headerlink" title="sed 脚本命令的寻址方式"></a>sed 脚本命令的寻址方式</h4><p>前面在介绍各个脚本命令时，我们一直忽略了对 address 部分的介绍。对各个脚本命令来说，address 用来表明该脚本命令作用到文本中的具体行。</p>
<p>默认情况下，sed 命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须写明 address 部分，表示的方法有以下 2 种：</p>
<ol>
<li>以数字形式指定行区间；</li>
<li>用文本模式指定具体行区间。</li>
</ol>
<p>以上两种形式都可以使用如下这 2 种格式，分别是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[address]脚本命令</span><br><span class="line">或者</span><br><span class="line">address &#123;</span><br><span class="line">  多个脚本命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种形式在前面例子中都有具体实例，因此这里不再做过多赘述。</p>
<h4 id="以数字形式指定行区间"><a href="#以数字形式指定行区间" class="headerlink" title="以数字形式指定行区间"></a>以数字形式指定行区间</h4><p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。sed 会将文本流中的第一行编号为 1，然后继续按顺序为接下来的行分配行号。</p>
<p>在脚本命令中，指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里举一个 sed 命令作用到指定行号的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#sed &#x27;2s/dog/cat/&#x27; data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>

<p>可以看到，sed 只修改地址指定的第二行的文本。下面的例子中使用了行地址区间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,3s/dog/cat/&#x27; data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>

<p>在此基础上，如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——美元符（$）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,$s/dog/cat/&#x27; data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br></pre></td></tr></table></figure>

<h4 id="用文本模式指定行区间"><a href="#用文本模式指定行区间" class="headerlink" title="用文本模式指定行区间"></a>用文本模式指定行区间</h4><p>sed 允许指定文本模式来过滤出命令要作用的行，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/command</span><br></pre></td></tr></table></figure>

<p>注意，必须用正斜线将要指定的 pattern 封起来，sed 会将该命令作用到包含指定文本模式的行上。</p>
<p>举个例子，如果你想只修改用户 demo 的默认 shell，可以使用 sed 命令，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep demo /etc/passwd</span><br><span class="line">demo:x:502:502::/home/Samantha:/bin/bash</span><br><span class="line">[root@localhost ~]# sed &#x27;/demo/s/bash/csh/&#x27; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">demo:x:502:502::/home/demo:/bin/csh</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限，因此，sed 允许在文本模式使用正则表达式指明作用的具体行。正则表达式允许创建高级文本模式匹配表达式来匹配各种数据。这些表达式结合了一系列通配符、特殊字符以及固定文本字符来生成能够匹配几乎任何形式文本的简练模式。</p>
<p>关于正则表达式，本节不做过多介绍，有兴趣的读者可阅读《<a target="_blank" rel="noopener" href="http://deerchao.net/tutorials/regex/regex-1.htm">正则表达式入门教程</a>》一文，这里仅给读者提供一个简单示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;First Wed&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">h1Helloh1</span><br><span class="line">h2Helloh2</span><br><span class="line">h3Helloh3</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用正则表示式给所有第一个的h1、h2、h3添加&lt;&gt;，给第二个h1、h2、h3添加&lt;/&gt;</span></span><br><span class="line">[root@localhost ~]# cat sed.sh</span><br><span class="line">/h[0-9]/&#123;</span><br><span class="line">    s//\&lt;&amp;\&gt;/1</span><br><span class="line">    s//\&lt;\/&amp;\&gt;/2</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# sed -f sed.sh test.txt</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Hello&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;Hello&lt;/h3&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Linux-sed命令高级用法精讲"><a href="#Linux-sed命令高级用法精讲" class="headerlink" title="Linux sed命令高级用法精讲"></a>Linux sed命令高级用法精讲</h3><h4 id="sed-多行命令"><a href="#sed-多行命令" class="headerlink" title="sed 多行命令"></a>sed 多行命令</h4><p>在学习 sed 命令的基础功能时，你可能注意到了一个局限，即所有的 sed 命令都只是针对单行数据执行操作，在 sed 命令读取缓冲区中的文本数据时，它会基于换行符的位置，将数据分成行，sed 会根据定义好的脚本命令一次处理一行数据。</p>
<p>但是，有时我们需要对跨多行的数据执行特定操作。比如说，在文本中查找一串字符串<code>&quot;www.forever.cn.mw&quot;</code>，它很有可能出现在两行中，每行各包含其中一部分。这时，如果用普通的 sed 编辑器命令来处理文本，就不可能发现这种被分开的情况。</p>
<p>幸运的是，sed 命令的设计人员已经考虑到了这种情况，并设计了对应的解决方案。sed 包含了三个可用来处理多行文本的特殊命令，分别是：</p>
<ol>
<li>Next 命令（N）：将数据流中的下一行加进来创建一个多行组来处理。</li>
<li>Delete（D）：删除多行组中的一行。</li>
<li>Print（P）：打印多行组中的一行。</li>
</ol>
<p>注意，以上命令的缩写，都为大写。</p>
<h4 id="N-多行操作命令"><a href="#N-多行操作命令" class="headerlink" title="N 多行操作命令"></a>N 多行操作命令</h4><p>N 命令会将下一行文本内容添加到缓冲区已有数据之后（之间用换行符分隔），从而使前后两个文本行同时位于缓冲区中，sed 命令会将这两行数据当成一行来处理。</p>
<p>下面这个例子演示的 N 命令的功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed &#x27;/first/&#123; N ; s/\n/ / &#125;&#x27; data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line. This is the second data line.</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure>

<p>在这个例子中，sed 命令查找含有单词 first 的那行文本。找到该行后，它会用 N 命令将下一行合并到那行，然后用替换命令 s 将换行符替换成空格。结果是，文本文件中的两行在 sed 的输出中成了一行。</p>
<p>如果要在数据文件中查找一个可能会分散在两行中的文本短语，如何实现呢？这里给大家一个实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data3.txt</span><br><span class="line">On Tuesday, the Linux System</span><br><span class="line">Administrator&#x27;s group meeting will be held.</span><br><span class="line">All System Administrators should attend.</span><br><span class="line">Thank you for your attendance.</span><br><span class="line">[root@localhost ~]# sed &#x27;N ; s/System Administrator/Desktop User/&#x27; data3.txt</span><br><span class="line">On Tuesday, the Linux Desktop User&#x27;s group meeting will be held.</span><br><span class="line">All Desktop Users should attend.</span><br><span class="line">Thank you for your attendance.</span><br></pre></td></tr></table></figure>

<p>用 N 命令将发现第一个单词的那行和下一行合并后，即使短语内出现了换行，你仍然可以找到它，这是因为，替换命令在 System 和 Administrator之间用了通配符（.）来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这可能不是你想要的。</p>
<p>要解决这个问题，可以在 sed 脚本中用两个替换命令，一个用来匹配短语出现在多行中的情况，一个用来匹配短语出现在单行中的情况，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;N</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data3.txt</span></span></span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User&#x27;s group meeting will be held.</span><br><span class="line">All Desktop Users should attend.</span><br><span class="line">Thank you for your attendance.</span><br></pre></td></tr></table></figure>

<p>第一个替换命令专门查找两个单词间的换行符，并将它放在了替换字符串中。这样就能在第一个替换命令专门在两个检索词之间寻找换行符，并将其纳入替换字符串。这样就允许在新文本的同样位置添加换行符了。</p>
<p>但这个脚本中仍有个小问题，即它总是在执行 sed 命令前将下一行文本读入到缓冲区中，当它到了后一行文本时，就没有下一行可读了，此时 N 命令会叫 sed 程序停止，这就导致，如果要匹配的文本正好在最后一行中，sed 命令将不会发现要匹配的数据。</p>
<p>解决这个 bug 的方法是，将单行命令放到 N 命令前面，将多行命令放到 N 命令后面，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">N</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data3.txt</span></span></span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User&#x27;s group meeting will be held.</span><br><span class="line">All Desktop Users should attend.</span><br><span class="line">Thank you for your attendance.</span><br></pre></td></tr></table></figure>

<p>现在，查找单行中短语的替换命令在数据流的后一行也能正常工作，多行替换命令则会负责短语出现在数据流中间的情况。</p>
<h4 id="D-多行删除命令"><a href="#D-多行删除命令" class="headerlink" title="D 多行删除命令"></a>D 多行删除命令</h4><p>sed 不仅提供了单行删除命令（d），也提供了多行删除命令 D，其作用是只删除缓冲区中的第一行，也就是说，D 命令将缓冲区中第一个换行符（包括换行符）之前的内容删除掉。</p>
<p>比如说：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data4.txt</span><br><span class="line">On Tuesday, the Linux System</span><br><span class="line">Administrator&#x27;s group meeting will be held.</span><br><span class="line">All System Administrators should attend.</span><br><span class="line">[root@localhost ~]# sed &#x27;N ; /System\nAdministrator/D&#x27; data4.txt</span><br><span class="line">Administrator&#x27;s group meeting will be held.</span><br><span class="line">All System Administrators should attend.</span><br></pre></td></tr></table></figure>

<p>文本的第二行被 N 命令加到了缓冲区，因此 sed 命令第一次匹配就是成功，而 D 命令会将缓冲区中第一个换行符之前（也就是第一行）的数据删除，所以，得到了如上所示的结果。</p>
<p>下面的例子中，它会删除数据流中出现在第一行前的空白行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data5.txt</span><br><span class="line"></span><br><span class="line">This is the header line.</span><br><span class="line">This is a data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed &#x27;/^$/&#123;N ; /header/D&#125;&#x27; data5.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is a data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure>

<p>sed会查找空白行，然后用 N 命令来将下一文本行添加到缓冲区。此时如果缓冲区的内容中含有单词 header，则 D 命令会删除缓冲区中的第一行。</p>
<h4 id="P-多行打印命令"><a href="#P-多行打印命令" class="headerlink" title="P 多行打印命令"></a>P 多行打印命令</h4><p>同 d 和 D 之间的区别一样，P（大写）命令和单行打印命令 p（小写）不同，对于具有多行数据的缓冲区来说，它只会打印缓冲区中的第一行，也就是首个换行符之前的所有内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如，test.txt 文件中的内容如下：</span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br><span class="line">eee</span><br><span class="line">fff</span><br></pre></td></tr></table></figure>


<p>表 1 中是对 test.txt 文件中的内容分别用 p 命令和 P 命令后，产生的输出信息的对比。</p>
<table>
<thead>
<tr>
<th>P（大写）命令</th>
<th>p（小写）命令</th>
</tr>
</thead>
<tbody><tr>
<td>[root@localhost ~]# sed ‘&#x2F;.*&#x2F;N;P’ aaa aaa bbb ccc ccc ddd eee eee fff</td>
<td>[root@localhost ~]# sed ‘&#x2F;.*&#x2F;N;p’ aaa bbb aaa bbb ccc ddd ccc ddd eee fff eee fff</td>
</tr>
</tbody></table>
<p>第一个 sed 命令，每次都使用 N 将下一行内容追加到缓冲区内容的后面（用换行符间隔），也就是说，第一次时缓冲区中的内容为 aaa\nbbb，但 P（大写） 命令的作用的打印换行符之前的内容，也就是 aaa，之后则是 sed 在自动输出功能输出 aaa 和 bbb（sed 命令会自动将 \n 输出为换行），依次类推，就输出了所看到的结果。</p>
<p>第二个 sed 命令，使用的是 p （小写）单行打印命令，它会将缓冲区中的所有内容全部打印出来（\n 会自动输出为换行），因此，出现了看到的结果。</p>
<h4 id="sed-保持空间"><a href="#sed-保持空间" class="headerlink" title="sed 保持空间"></a>sed 保持空间</h4><p>前面我们一直说，sed 命令处理的是缓冲区中的内容，其实这里的缓冲区，应称为模式空间。值得一提的是，模式空间并不是 sed 命令保存文件的唯一空间。sed 还有另一块称为保持空间的缓冲区域，它可以用来临时存储一些数据。</p>
<p>表 2 列出了 5 条可用来操作保持空间的命令。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>将模式空间中的内容复制到保持空间</td>
</tr>
<tr>
<td>H</td>
<td>将模式空间中的内容附加到保持空间</td>
</tr>
<tr>
<td>g</td>
<td>将保持空间中的内容复制到模式空间</td>
</tr>
<tr>
<td>G</td>
<td>将保持空间中的内容附加到模式空间</td>
</tr>
<tr>
<td>x</td>
<td>交换模式空间和保持空间中的内容</td>
</tr>
</tbody></table>
<p>通常，在使用 h 或 H 命令将字符串移动到保持空间后，最终还要用 g、G 或 x 命令将保存的字符串移回模式空间。保持空间最直接的作用是，一旦我们将模式空间中所有的文件复制到保持空间中，就可以清空模式空间来加载其他要处理的文本内容。</p>
<p>由于有两个缓冲区域，下面的例子中演示了如何用 h 和 g 命令来将数据在 sed 缓冲区之间移动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed -n &#x27;/first/ &#123;h ; p ; n ; p ; g ; p &#125;&#x27; data2.txt</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the first data line.</span><br></pre></td></tr></table></figure>

<p>这个例子的运行过程是这样的：</p>
<ul>
<li>sed脚本命令用正则表达式过滤出含有单词first的行；</li>
<li>当含有单词 first 的行出现时，h 命令将该行放到保持空间；</li>
<li>p 命令打印模式空间也就是第一个数据行的内容；</li>
<li>n 命令提取数据流中的下一行（This is the second data line），并将它放到模式空间；</li>
<li>p 命令打印模式空间的内容，现在是第二个数据行；</li>
<li>g 命令将保持空间的内容（This is the first data line）放回模式空间，替换当前文本；</li>
<li>p 命令打印模式空间的当前内容，现在变回第一个数据行了。</li>
</ul>
<h4 id="sed改变指定流程"><a href="#sed改变指定流程" class="headerlink" title="sed改变指定流程"></a>sed改变指定流程</h4><h4 id="b-分支命令"><a href="#b-分支命令" class="headerlink" title="b 分支命令"></a>b 分支命令</h4><p>通常，sed 程序的执行过程会从第一个脚本命令开始，一直执行到最后一个脚本命令（D 命令是个例外，它会强制 sed 返回到脚本的顶部，而不读取新的行）。sed 提供了 b 分支命令来改变命令脚本的执行流程，其结果与结构化编程类似。</p>
<p>b 分支命令基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]b [label]</span><br></pre></td></tr></table></figure>

<p>其中，address 参数决定了哪些行的数据会触发分支命令，label 参数定义了要跳转到的位置。</p>
<p>需要注意的是，如果没有加 label 参数，跳转命令会跳转到脚本的结尾，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed &#x27;&#123;2,3b ; s/This is/Is this/ ; s/line./test?/&#125;&#x27; data2.txt</span><br><span class="line">Is this the header test?</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">Is this the last test?</span><br></pre></td></tr></table></figure>

<p>可以看到，因为 b 命令未指定 label 参数，因此数据流中的第2行和第3行并没有执行那两个替换命令。</p>
<p>如果我们不想直接跳到脚本的结尾，可以为 b 命令指定一个标签（也就是格式中的 label，最多为 7 个字符长度）。在使用此该标签时，要以冒号开始（比如 :label2），并将其放到要跳过的脚本命令之后。这样，当 sed 命令匹配并处理该行文本时，会跳过标签之前所有的脚本命令，但会执行标签之后的脚本命令。</p>
<p>比如说：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;&#123;/first/b jump1 ; s/This is the/No jump on/</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:jump1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/This is the/Jump here on/&#125;<span class="string">&#x27; data2.txt</span></span></span><br><span class="line">No jump on header line</span><br><span class="line">Jump here on first data line</span><br><span class="line">No jump on second data line</span><br><span class="line">No jump on last line</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果文本行中出现了 first，程序的执行会直接跳到 jump1 标签之后的脚本行。如果分支命令的模式没有匹配，sed 会继续执行所有的脚本命令。</p>
<p>b 分支命令除了可以向后跳转，还可以向前跳转，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/,//1p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">/,/b start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br><span class="line">This is, a, test, to, remove, commas.</span><br><span class="line">This is a, test, to, remove, commas.</span><br><span class="line">This is a test, to, remove, commas.</span><br><span class="line">This is a test to, remove, commas.</span><br><span class="line">This is a test to remove, commas.</span><br><span class="line">This is a test to remove commas.</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当缓冲区中的行内容中有逗号时，脚本命令就会一直循环执行，每次迭代都会删除文本中的第一个逗号，并打印字符串，直至内容中没有逗号。</p>
<h4 id="t-测试命令"><a href="#t-测试命令" class="headerlink" title="t 测试命令"></a>t 测试命令</h4><p>类似于 b 分支命令，t 命令也可以用来改变 sed 脚本的执行流程。t 测试命令会根据 s 替换命令的结果，如果匹配并替换成功，则脚本的执行会跳转到指定的标签；反之，t 命令无效。</p>
<p>测试命令使用与分支命令相同的格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]t [label]</span><br></pre></td></tr></table></figure>

<p>跟分支命令一样，在没有指定标签的情况下，如果 s 命令替换成功，sed 会跳转到脚本的结尾（相当于不执行任何脚本命令）。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/first/matched/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">t</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/This is the/No match on/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27; data2.txt</span></span></span><br><span class="line">No match on header line</span><br><span class="line">This is the matched data line</span><br><span class="line">No match on second data line</span><br><span class="line">No match on last line</span><br></pre></td></tr></table></figure>

<p>此例中，第一个替换命令会查找模式文本 first，如果匹配并替换成功，命令会直接跳过后面的替换命令；反之，如果第一个替换命令未能匹配成功，第二个替换命令就会被执行。</p>
<p>再举个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;This, is, a, test, to, remove, commas. &quot; | sed -n &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/,//1p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">t start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br><span class="line">This is, a, test, to, remove, commas.</span><br><span class="line">This is a, test, to, remove, commas.</span><br><span class="line">This is a test, to, remove, commas.</span><br><span class="line">This is a test to, remove, commas.</span><br><span class="line">This is a test to remove, commas.</span><br><span class="line">This is a test to remove commas.</span><br></pre></td></tr></table></figure>

<h3 id="Linux-awk命令详解"><a href="#Linux-awk命令详解" class="headerlink" title="Linux awk命令详解"></a>Linux awk命令详解</h3><p>除了使用 sed 命令，Linux 系统中还有一个功能更加强大的文本数据处理工具，就是 awk。它诞生于 20 世纪 70 年代末期，这也许是它影响了众多 Linux 用户的原因之一。</p>
<p>曾有人推测 awk 命令的名字来源于 awkward 这个单词。其实不然，此命令的设计者有 3 位，他们的姓分别是 Aho、Weingberger 和 Kernighan，awk 就取自这 3 为大师姓的首字母。</p>
<p>和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p>
<p>awk 命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk [选项] &#x27;脚本命令&#x27; 文件名</span><br></pre></td></tr></table></figure>

<p>此命令常用的选项以及各自的含义，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-F fs</td>
<td>指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符。</td>
</tr>
<tr>
<td>-f file</td>
<td>从脚本文件中读取 awk 脚本指令，以取代直接在命令行中输入指令。</td>
</tr>
<tr>
<td>-v var&#x3D;val</td>
<td>在执行处理过程之前，设置一个变量 var，并给其设备初始值为 val。</td>
</tr>
</tbody></table>
<p>awk 的强大之处在于脚本命令，它由 2 部分组成，分别为匹配规则和执行命令，如下所示：</p>
<p>‘匹配规则{执行命令}’</p>
<p>这里的匹配规则，和 sed 命令中的 address 部分作用相同，用来指定脚本命令可以作用到文本内容中的具体行，可以使用字符串（比如 &#x2F;demo&#x2F;，表示查看含有 demo 字符串的行）或者正则表达式指定。另外需要注意的是，整个脚本命令是用单引号（’’）括起，而其中的执行命令部分需要用大括号（{}）括起来。</p>
<p>在 awk 程序执行时，如果没有指定执行命令，则默认会把匹配的行输出；如果不指定匹配规则，则默认匹配文本中所有的行。</p>
<p>举个简单的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;/^$/ &#123;print &quot;Blank line&quot;&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>

<p>在此命令中，<code>/^$/</code> 是一个正则表达式，功能是匹配文本中的空白行，同时可以看到，执行命令使用的是 print 命令，此命令经常会使用，它的作用很简单，就是将指定的文本进行输出。因此，整个命令的功能是，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank line。</p>
<h4 id="awk-使用数据字段变量"><a href="#awk-使用数据字段变量" class="headerlink" title="awk 使用数据字段变量"></a>awk 使用数据字段变量</h4><p>awk 的主要特性之一是其处理文本文件中数据的能力，它会自动给一行中的每个数据元素分配一个变量。</p>
<p>默认情况下，awk 会将如下变量分配给它在文本行中发现的数据字段：</p>
<ul>
<li>$0 代表整个文本行；</li>
<li>$1 代表文本行中的第 1 个数据字段；</li>
<li>$2 代表文本行中的第 2 个数据字段；</li>
<li>$n 代表文本行中的第 n 个数据字段。</li>
</ul>
<p>前面说过，在 awk 中，默认的字段分隔符是任意的空白字符（例如空格或制表符）。 在文本行中，每个数据字段都是通过字段分隔符划分的。awk 在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。</p>
<p>所以在下面的例子中，awk 程序读取文本文件，只显示第 1 个数据字段的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">One line of test text.</span><br><span class="line">Two lines of test text.</span><br><span class="line">Three lines of test text.</span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;print $1&#125;&#x27; data2.txt</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br></pre></td></tr></table></figure>

<p>该程序用 $1 字段变量来表示“仅显示每行文本的第 1 个数据字段”。当然，如果你要读取采用了其他字段分隔符的文件，可以用 -F 选项手动指定。</p>
<h4 id="awk-脚本命令使用多个命令"><a href="#awk-脚本命令使用多个命令" class="headerlink" title="awk 脚本命令使用多个命令"></a>awk 脚本命令使用多个命令</h4><p>awk 允许将多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;My name is Rich&quot; | awk &#x27;&#123;$4=&quot;Christine&quot;; print $0&#125;&#x27;</span><br><span class="line">My name is Christine</span><br></pre></td></tr></table></figure>

<p>第一条命令会给字段变量 $4 赋值。第二条命令会打印整个数据字段。可以看到，awk 程序在输出中已经将原文本中的第四个数据字段替换成了新值。</p>
<p>除此之外，也可以一次一行地输入程序脚本命令，比如说：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$4</span>=<span class="string">&quot;Christine&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">print</span> <span class="variable">$0</span>&#125;<span class="string">&#x27;</span></span></span><br><span class="line">My name is Rich</span><br><span class="line">My name is Christine</span><br></pre></td></tr></table></figure>

<p>在你用了表示起始的单引号后，bash shell 会使用 &gt; 来提示输入更多数据，我们可以每次在每行加一条命令，直到输入了结尾的单引号。</p>
<p>注意，此例中因为没有在命令行中指定文件名，awk 程序需要用户输入获得数据，因此当运行这个程序的时候，它会一直等着用户输入文本，此时如果要退出程序，只需按下 Ctrl+D 组合键即可。</p>
<h4 id="awk从文件中读取程序"><a href="#awk从文件中读取程序" class="headerlink" title="awk从文件中读取程序"></a>awk从文件中读取程序</h4><p>跟 sed 一样，awk 允许将脚本命令存储到文件中，然后再在命令行中引用，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat awk.sh</span><br><span class="line">&#123;print $1 &quot;&#x27;s home directory is &quot; $6&#125;</span><br><span class="line">[root@localhost ~]# awk -F: -f awk.sh /etc/passwd</span><br><span class="line">root&#x27;s home directory is /root</span><br><span class="line">bin&#x27;s home directory is /bin</span><br><span class="line">daemon&#x27;s home directory is /sbin</span><br><span class="line">adm&#x27;s home directory is /var/adm</span><br><span class="line">lp&#x27;s home directory is /var/spool/lpd</span><br><span class="line">...</span><br><span class="line">Christine&#x27;s home directory is /home/Christine</span><br><span class="line">Samantha&#x27;s home directory is /home/Samantha</span><br><span class="line">Timothy&#x27;s home directory is /home/Timothy</span><br></pre></td></tr></table></figure>

<p>awk.sh 脚本文件会使用 print 命令打印 &#x2F;etc&#x2F;passwd 文件的主目录数据字段（字段变量 $6），以及 userid 数据字段（字段变量 $1）。注意，在程序文件中，也可以指定多条命令，只要一条命令放一行即可，之间不需要用分号。</p>
<h4 id="awk-BEGIN关键字"><a href="#awk-BEGIN关键字" class="headerlink" title="awk BEGIN关键字"></a>awk BEGIN关键字</h4><p>awk 中还可以指定脚本命令的运行时机。默认情况下，awk 会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用 BEGIN 关键字。</p>
<p>BEGIN 会强制 awk 在读取数据前执行该关键字后指定的脚本命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data3.txt</span><br><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125;<span class="string">&#x27; data3.txt</span></span></span><br><span class="line">The data3 File Contents:</span><br><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的脚本命令中分为 2 部分，BEGIN 部分的脚本指令会在 awk 命令处理数据前运行，而真正用来处理数据的是第二段脚本命令。</p>
<h4 id="awk-END关键字"><a href="#awk-END关键字" class="headerlink" title="awk END关键字"></a>awk END关键字</h4><p>和 BEGIN 关键字相对应，END 关键字允许我们指定一些脚本命令，awk 会在读完数据后执行它们，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">END &#123;<span class="built_in">print</span> <span class="string">&quot;End of File&quot;</span>&#125;<span class="string">&#x27; data3.txt</span></span></span><br><span class="line">The data3 File Contents:</span><br><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">End of File</span><br></pre></td></tr></table></figure>

<p>可以看到，当 awk 程序打印完文件内容后，才会执行 END 中的脚本命令。</p>
<h2 id="Linux系统软件安装"><a href="#Linux系统软件安装" class="headerlink" title="Linux系统软件安装"></a>Linux系统软件安装</h2><h3 id="Linux软件包"><a href="#Linux软件包" class="headerlink" title="Linux软件包"></a>Linux软件包</h3><p>Linux下的软件包众多，且几乎都是经 GPL 授权、免费开源（无偿公开源代码）的。这意味着如果你具备修改软件源代码的能力，只要你愿意，可以随意修改。</p>
<blockquote>
<p>GPL，全称 General Public License，中文名称“通用性公开许可证”，简单理解 GPL 就是一个保护软件自由的一个协议，经 GPL 协议授权的软件必须开源</p>
</blockquote>
<p>Linux下的软件包可细分为两种，分别是源码包和二进制包。</p>
<h4 id="Linux源码包"><a href="#Linux源码包" class="headerlink" title="Linux源码包"></a>Linux源码包</h4><p>实际上，源码包就是一大堆源代码程序，是由程序员按照特定的格式和语法编写出来的。</p>
<p>我们都知道，计算机只能识别机器语言，也就是二进制语言，所以源码包的安装需要一名“翻译官”将“abcd”翻译成二进制语言，这名“翻译官”通常被称为编译器。</p>
<blockquote>
<p>“编译”指的是从源代码到直接被计算机（或虚拟机）执行的目标代码的翻译过程，编译器的功能就是把源代码翻译为二进制代码，让计算机识别并运行</p>
</blockquote>
<p>虽然源码包免费开源，但用户不会编程怎么办？一大堆源代码程序不会使用怎么办？源码包容易安装吗？等等这些都是使用源码包安装方式无法解答的问题。</p>
<p>另外，由于源码包的安装需要把源代码编译为二进制代码，因此安装时间较长。比如，大家应该都在 Windows下安装过 QQ，QQ 功能较多，程序相对较大（有 70 MB左右），但由于其并非是以源码包的形式发布，而是编译后才发布的，因此只需几分钟（经过简单的配置）即可安装成功。但如果我们以源码包安装的方式在 Linux 中安装一个 MySQL 数据库，即便此软件的压缩包仅有 23 MB左右，也需要 30 分钟左右的时间（根据硬件配置不同，略有差异）。</p>
<p>通过对比你会发现，源码包的编译是很费时间的，况且绝多大数用户并不熟悉程序语言，在安装过程中我们只能祈祷程序不要报错，否则初学者很难解决。</p>
<p>为了解决使用源码包安装方式的这些问题，Linux 软件包的安装出现了使用二进制包的安装方式。</p>
<h4 id="Linux二进制包"><a href="#Linux二进制包" class="headerlink" title="Linux二进制包"></a>Linux二进制包</h4><p>二进制包，也就是源码包经过成功编译之后产生的包。由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快（同 Windows下安装软件速度相当），且安装过程报错几率大大减小。</p>
<p>二进制包是 Linux 下默认的软件安装包，因此二进制包又被称为默认安装软件包。目前主要有以下 2 大主流的二进制包管理系统：</p>
<ul>
<li>RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等。</li>
<li>DPKG 包管理系统：由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。</li>
</ul>
<p>RPM 包管理系统和 DPKG 管理系统的原理和形式大同小异，可以触类旁通。由于本教程使用的是 CentOS 6.x 版本，因此本节主要讲解 RPM 二进制包。</p>
<h4 id="源码包-VS-RPM二进制包"><a href="#源码包-VS-RPM二进制包" class="headerlink" title="源码包 VS RPM二进制包"></a>源码包 VS RPM二进制包</h4><p>源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理，Linux 中最常用的打包压缩格式为“tar.gz”，因此源码包又被称为 Tarball。</p>
<p>Tarball 是 Linux 系统的一款打包工具，可以对源码包进行打包压缩处理，人们习惯上将最终得到的打包压缩文件称为 Tarball 文件。</p>
<p>源码包需要我们自己去软件官方网站进行下载，包中通常包含以下内容：</p>
<ul>
<li>源代码文件。</li>
<li>配置和检测程序（如 configure 或 config 等）。</li>
<li>软件安装说明和软件说明（如 INSTALL 或 README）。</li>
</ul>
<p>总的来说，使用源码包安装软件具有以下几点好处：</p>
<ul>
<li>开源。如果你有足够的能力，则可以修改源代码。</li>
<li>可以自由选择所需的功能。</li>
<li>因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也更高。</li>
<li>卸载方便。</li>
</ul>
<p>但同时，使用源码包安装软件也有几点不足：</p>
<ul>
<li>安装过程步骤较多，尤其是在安装较大的软件集合时（如 LAMP 环境搭建），容易出现拼写错误。</li>
<li>编译时间较长，所以安装时间比二进制安装要长。</li>
<li>因为软件是编译安装的，所以在安装过程中一旦报错，新手很难解决。</li>
</ul>
<p>相比源码包，二进制包是在软件发布时已经进行过编译的软件包，所以安装速度比源码包快得多（和 Windows 下软件安装速度相当）。也正是因为已经进行通译，大家无法看到软件的源代码。</p>
<p>使用 RMP 包安装软件具有以下 2 点好处：</p>
<ol>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、査询和卸载。</li>
<li>安装速度比源码包安装快得多。</li>
</ol>
<p>与此同时，使用 RMP 包安装软件有如下不足：</p>
<ul>
<li>经过编译，不能在看到源代码。</li>
<li>功能选择不如源码包灵活。</li>
<li>依赖性。有时我们会发现，在安装软件包 a 时需要先安装 b 和 c，而在安装 b 时需要先安装 d 和 e。这就需要先安装 d 和 e，再安装 b 和 c，最后才能安装 a。比如，我买了一个漂亮的灯具，打算安装在客厅里，可是在安装灯具之前，客厅需要有顶棚，并且顶棚需要刷好油漆。安装软件和装修及其类似，需要有一定的顺序，但是有时依赖性会非常强。</li>
</ul>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>通过源码包和 RMP 二进制包的对比，在 Linux 进行软件安装时，我们应该使用哪种软件包呢？</p>
<p>为了更好的区别两种软件包，这里举个例子。假设我们想做一套家具，源码包就像所有的家具完全由自己动手手工打造（手工编译），想要什么样的板材、油漆、颜色和样式都由自己决定（功能自定义，甚至可以修改源代码）。想想就觉得爽，完全不用被黑心的厂商所左右，而且不用担心质量问题（软件更适合自己的系统，效率更高，更加稳定）。但是，所花费的时间大大超过了买一套家具的时间（编译浪费时间），而且自己真的有做木工这个能力吗（需要对源代码非常了解）？就算请别人定制好的家具，再由自己组装，万一哪个部件不匹配（报错很难解决），怎么办？</p>
<p>那么二进制包呢？也是我们需要一套家具，去商场买了一套（安装简单），家具都是现成的，不会有哪个部件不匹配，除非因为自身问题没有量好尺寸而导致放不下（报错很少）。但是我们完全不知道这套家具用的是什么材料、油漆是否合格，而且家具的样式不能随意选择（软件基本不能自定义功能）。</p>
<p>通过以上对源码包和二进制包的讲解，相信大家对两者的区别和特点有了更清楚的认识。</p>
<h3 id="Linux-RPM包统一命名规则"><a href="#Linux-RPM包统一命名规则" class="headerlink" title="Linux RPM包统一命名规则"></a>Linux RPM包统一命名规则</h3><p>RPM 二进制包的命名需遵守统一的命名规则，用户通过名称就可以直接获取这类包的版本、适用平台等信息。</p>
<p>RPM 二进制包命名的一般格式如下：</p>
<blockquote>
<p>包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名</p>
</blockquote>
<p>例如，RPM 包的名称是<code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code>，其中：</p>
<ul>
<li><p>httped：软件包名。这里需要注意，httped 是包名，而 httpd-2.2.15-15.el6.centos.1.i686.rpm 通常称为包全名，包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名，一不小心就会弄错。</p>
</li>
<li><p>2.2.15：包的版本号，版本号的格式通常为<code>主版本号.次版本号.修正号</code>。</p>
</li>
<li><p>15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。</p>
</li>
<li><p>el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。</p>
</li>
<li><p>centos：表示此包适用于 CentOS 系统。</p>
</li>
<li><p>i686：表示此包使用的硬件平台，目前的 RPM 包支持的平台如表 1 所示：</p>
<table>
<thead>
<tr>
<th>平台名称</th>
<th>适用平台信息</th>
</tr>
</thead>
<tbody><tr>
<td>i386</td>
<td>386 以上的计算机都可以安装</td>
</tr>
<tr>
<td>i586</td>
<td>686 以上的计算机都可以安装</td>
</tr>
<tr>
<td>i686</td>
<td>奔腾 II 以上的计算机都可以安装，目前所有的 CPU 是奔腾 II 以上的，所以这个软件版本居多</td>
</tr>
<tr>
<td>x86_64</td>
<td>64 位 CPU 可以安装</td>
</tr>
<tr>
<td>noarch</td>
<td>没有硬件限制</td>
</tr>
</tbody></table>
</li>
<li><p>rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用 rpm 命令直接安装。此外，还有以 src.rpm 作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。</p>
</li>
</ul>
<p>有读者可能会问，Linux 系统不靠扩展名分区文件类型，那为什么包全名中要包含 .rpm 扩展名呢？其实，这里的扩展名是为系统管理员准备的，如果我们不对 RPM 包标注扩展名，管理员很难知道这是一个 RPM 包，当然也就无法正确使用。</p>
<h3 id="Linux-RPM包安装、卸载和升级（rpm命令）"><a href="#Linux-RPM包安装、卸载和升级（rpm命令）" class="headerlink" title="Linux RPM包安装、卸载和升级（rpm命令）"></a>Linux RPM包安装、卸载和升级（rpm命令）</h3><p>本节讲解如何使用 rpm 命令对 RPM 二进制包进行安装、卸载和升级操作。</p>
<p>我们以安装 apache 程序为例。因为后续章节还会介绍使用源码包的方式安装 apache 程序，读者可以直观地感受到源码包和 RPM 包的区别。</p>
<h4 id="RPM包默认安装路径"><a href="#RPM包默认安装路径" class="headerlink" title="RPM包默认安装路径"></a>RPM包默认安装路径</h4><p>通常情况下，RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到表 1 所示的目录中。</p>
<table>
<thead>
<tr>
<th>安装路径</th>
<th>含 义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib&#x2F;</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man&#x2F;</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<p>RPM 包的默认安装路径是可以通过命令查询的。</p>
<p>除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别），得不偿失。</p>
<p>与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 &#x2F;usr&#x2F;local&#x2F; 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。</p>
<p>实际情况中，一台服务器几乎不会同时包含两个 apache 程序，管理员不好管理，还会占用过多的服务器磁盘空间。</p>
<h4 id="RPM-包的安装"><a href="#RPM-包的安装" class="headerlink" title="RPM 包的安装"></a>RPM 包的安装</h4><p>安装 RPM 的命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ivh 包全名</span><br></pre></td></tr></table></figure>

<p>注意一定是包全名。涉及到包全名的命令，一定要注意路径，可能软件包在光盘中，因此需提前做好设备的挂载工作。</p>
<p>此命令中各选项参数的含义为：</p>
<ul>
<li>-i：安装（install）;</li>
<li>-v：显示更详细的信息（verbose）;</li>
<li>-h：打印 #，显示安装进度（hash）;</li>
</ul>
<p>例如，使用此命令安装 apache 软件包，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ivh \</span><br><span class="line">/mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br><span class="line">Preparing...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################</span></span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">]</span></span><br><span class="line">1:httpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################</span></span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">]</span></span><br></pre></td></tr></table></figure>

<p>注意，直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作。</p>
<p>此命令还可以一次性安装多个软件包，仅需将包全名用空格分开即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ivh a.rpm b.rpm c.rpm</span><br></pre></td></tr></table></figure>


<p>如果还有其他安装要求（比如强制安装某软件而不管它是否有依赖性），可以通过以下选项进行调整：</p>
<ul>
<li>-nodeps：不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强制安装，则可以使用这个选项。注意，这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做。</li>
<li>-replacefiles：替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报”某个文件已经存在”的错误，从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。</li>
<li>-replacepkgs：替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。</li>
<li>-force：强制安装。不管是否已经安装，都重新安装。也就是 -replacefiles 和 -replacepkgs 的综合。</li>
<li>-test：测试安装。不会实际安装，只是检测一下依赖性。</li>
<li>-prefix：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。</li>
</ul>
<p>apache 服务安装完成后，可以尝试启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service 服务名 start|stop|restart|status</span><br></pre></td></tr></table></figure>

<p>各参数含义：</p>
<ul>
<li>start：启动服务；</li>
<li>stop：停止服务；</li>
<li>restart：重启服务；</li>
<li>status: 查看服务状态；</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service httpd start #启动apache服务</span><br></pre></td></tr></table></figure>


<p>服务启动后，可以查看端口号 80 是否出现。命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tlun | grep 80</span><br><span class="line">tcp 0 0 :::80:::* LISTEN</span><br></pre></td></tr></table></figure>

<p>也可以在浏览器中输入 Linux 服务器的 IP 地址，访问这个 apache 服务器。目前在 apache 中没有建立任何网页，所以看到的只是测试页</p>
<h4 id="RPM包的升级"><a href="#RPM包的升级" class="headerlink" title="RPM包的升级"></a>RPM包的升级</h4><p>使用如下命令即可实现 RPM 包的升级：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -Uvh 包全名</span><br></pre></td></tr></table></figure>

<p>-U（大写）选项的含义是：如果该软件没安装过则直接安装；若没安装则升级至最新版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -Fvh 包全名</span><br></pre></td></tr></table></figure>

<p>-F（大写）选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。</p>
<h4 id="RPM包的卸载"><a href="#RPM包的卸载" class="headerlink" title="RPM包的卸载"></a>RPM包的卸载</h4><p>RPM 软件包的卸载要考虑包之间的依赖性。例如，我们先安装的 httpd 软件包，后安装 httpd 的功能模块 mod_ssl 包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。</p>
<p>软件包卸载和拆除大楼是一样的，本来先盖的 2 楼，后盖的 3 楼，那么拆楼时一定要先拆除 3 楼。</p>
<p>如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -e httpd</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_wsgi-3.2-1.el6.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) php-5.3.3-3.el6_2.8.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_ssl-1:2.2.15-15.el6.</span><br><span class="line">centos.1.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_perl-2.0.4-10.el6.i686</span><br><span class="line">httpd = 2.2.15-15.el6.centos.1 is needed by (installed) httpd-manual-2.2.</span><br><span class="line">15-15.el6.centos.1 .noarch</span><br><span class="line">httpd is needed by (installed) webalizer-2.21_02-3.3.el6.i686</span><br><span class="line">httpd is needed by (installed) mod_ssl-1:2.2.15-15.el6.centos.1.i686</span><br><span class="line">httpd=0:2.2.15-15.el6.centos.1 is needed by(installed)mod_ssl-1:2.2.15-15.el6.centos.1.i686</span><br></pre></td></tr></table></figure>


<p>RPM 软件包的卸载很简单，使用如下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -e 包名</span><br></pre></td></tr></table></figure>

<p>-e 选项表示卸载，也就是 erase 的首字母。</p>
<p>RPM 软件包的卸载命令支持使用“-nocteps”选项，即可以不检测依赖性直接卸载，但此方式不推荐大家使用，因为此操作很可能导致其他软件也无法征程使用。</p>
<h3 id="Linux-rpm命令查询软件包（-q、-qa、-i、-p、-l、-f、-R）"><a href="#Linux-rpm命令查询软件包（-q、-qa、-i、-p、-l、-f、-R）" class="headerlink" title="Linux rpm命令查询软件包（-q、-qa、-i、-p、-l、-f、-R）"></a>Linux rpm命令查询软件包（-q、-qa、-i、-p、-l、-f、-R）</h3><p>rpm 命令还可用来对 RPM 软件包做查询操作，具体包括：</p>
<ul>
<li>查询软件包是否已安装；</li>
<li>查询系统中所有已安装的软件包；</li>
<li>查看软件包的详细信息；</li>
<li>查询软件包的文件列表；</li>
<li>查询某系统文件具体属于哪个 RPM 包。</li>
</ul>
<p>使用 rpm 做查询命令的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm 选项 查询对象</span><br></pre></td></tr></table></figure>

<p>下面教大家使用 rpm 命令一一实现以上查询操作。</p>
<h4 id="rpm-q：查询软件包是否安装"><a href="#rpm-q：查询软件包是否安装" class="headerlink" title="rpm -q：查询软件包是否安装"></a>rpm -q：查询软件包是否安装</h4><p>用 rpm 查询软件包是否安装的命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -q 包名</span><br></pre></td></tr></table></figure>

<p>-q 表示查询，是 query 的首字母。</p>
<p>例如，查看 Linux 系统中是否安装 apache，rpm 查询命令应写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -q httpd</span><br><span class="line">httpd-2.2.15-15.el6.centos.1.i686</span><br></pre></td></tr></table></figure>

<p>注意这里使用的是包名，而不是包全名。因为已安装的软件包只需给出包名，系统就可以成功识别（使用包全名反而无法识别）。</p>
<h4 id="rpm-qa：查询系统中所有安装的软件包"><a href="#rpm-qa：查询系统中所有安装的软件包" class="headerlink" title="rpm -qa：查询系统中所有安装的软件包"></a>rpm -qa：查询系统中所有安装的软件包</h4><p>使用 rpm 查询 Linux 系统中所有已安装软件包的命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa</span><br><span class="line">libsamplerate-0.1.7-2.1.el6.i686</span><br><span class="line">startup-notification-0.10-2.1.el6.i686</span><br><span class="line">gnome-themes-2.28.1-6.el6.noarch</span><br><span class="line">fontpackages-filesystem-1.41-1.1.el6.noarch</span><br><span class="line">gdm-libs-2.30.4-33.el6_2.i686</span><br><span class="line">gstreamer-0.10.29-1.el6.i686</span><br><span class="line">redhat-lsb-graphics-4.0-3.el6.centos.i686</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<p>此外，这里还可以使用管道符查找出需要的内容，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep httpd</span><br><span class="line">httpd-devel-2.2.15-15.el6.centos.1.i686</span><br><span class="line">httpd-tools-2.2.15-15.el6.centos.1.i686</span><br><span class="line">httpd-manual-2.2.15-15.el6.centos.1.noarch</span><br><span class="line">httpd-2.2.15-15.el6.centos.1.i686</span><br></pre></td></tr></table></figure>

<p>相比<code>rpm -q 包名</code>命令，采用这种方式可以找到含有包名的所有软件包。</p>
<h4 id="rpm-qi：查询软件包的详细信息"><a href="#rpm-qi：查询软件包的详细信息" class="headerlink" title="rpm -qi：查询软件包的详细信息"></a>rpm -qi：查询软件包的详细信息</h4><p>通过 rpm 命令可以查询软件包的详细信息，命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qi 包名</span><br></pre></td></tr></table></figure>

<p>-i 选项表示查询软件信息，是 information 的首字母。</p>
<p>例如，想查看 apache 包的详细信息，可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qi httpd</span><br><span class="line">Name : httpd Relocations:(not relocatable)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包名</span></span><br><span class="line">Version : 2.2.15 Vendor:CentOS</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">版本和厂商</span></span><br><span class="line">Release : 15.el6.centos.1 Build Date: 2012年02月14日星期二 06时27分1秒</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发行版本和建立时间</span></span><br><span class="line">Install Date: 2013年01月07日星期一19时22分43秒</span><br><span class="line">Build Host:</span><br><span class="line">c6b18n2.bsys.dev.centos.org</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装时间</span></span><br><span class="line">Group : System Environment/Daemons Source RPM:</span><br><span class="line">httpd-2.2.15-15.el6.centos.1.src.rpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">组和源RPM包文件名</span></span><br><span class="line">Size : 2896132 License: ASL 2.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">软件包大小和许可协议</span></span><br><span class="line">Signature :RSA/SHA1,2012年02月14日星期二 19时11分00秒，Key ID</span><br><span class="line">0946fca2c105b9de</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数字签名</span></span><br><span class="line">Packager：CentOS BuildSystem &lt;http://bugs.centos.org&gt;</span><br><span class="line">URL : http://httpd.apache.org/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">厂商网址</span></span><br><span class="line">Summary : Apache HTTP Server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">软件包说明</span></span><br><span class="line">Description:</span><br><span class="line">The Apache HTTP Server is a powerful, efficient, and extensible web server.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">描述</span></span><br></pre></td></tr></table></figure>

<p>除此之外，还可以查询未安装软件包的详细信息，命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qip 包全名</span><br></pre></td></tr></table></figure>

<p>-p 选项表示查询未安装的软件包，是 package 的首字母。</p>
<p>注意，这里用的是包全名，且未安装的软件包需使用“绝对路径+包全名”的方式才能确定包。</p>
<h4 id="rpm-ql：命令查询软件包的文件列表"><a href="#rpm-ql：命令查询软件包的文件列表" class="headerlink" title="rpm -ql：命令查询软件包的文件列表"></a>rpm -ql：命令查询软件包的文件列表</h4><p>通过前面的学习我们知道，rpm 软件包通常采用默认路径安装，各安装文件会分门别类安放在适当的目录文件下。使用 rpm 命令可以查询到已安装软件包中包含的所有文件及各自安装路径，命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ql 包名</span><br></pre></td></tr></table></figure>

<p>-l 选项表示列出软件包所有文件的安装目录。</p>
<p>例如，查看 apache 软件包中所有文件以及各自的安装位置，可使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ql httpd</span><br><span class="line">/etc/httpd</span><br><span class="line">/etc/httpd/conf</span><br><span class="line">/etc/httpd/conf.d</span><br><span class="line">/etc/httpd/conf.d/README</span><br><span class="line">/etc/httpd/conf.d/welcome.conf</span><br><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">/etc/httpd/conf/magic</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<p>同时，rpm 命令还可以查询未安装软件包中包含的所有文件以及打算安装的路径，命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qlp 包全名</span><br></pre></td></tr></table></figure>

<p>-p 选项表示查询未安装的软件包信息，是 package 的首字母。</p>
<p>注意，由于软件包还未安装，因此需要使用“绝对路径+包全名”的方式才能确定包。</p>
<p>比如，我们想查看 bing 软件包（未安装，绝对路径为：&#x2F;mnt&#x2F;cdrom&#x2F;Packages&#x2F;bind-9.8.2-0.10.rc1.el6.i686.rpm）中的所有文件及各自打算安装的位置，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qlp /mnt/cdrom/Packages/bind-9.8.2-0.10.rc1.el6.i686.rpm</span><br><span class="line">/etc/NetworkManager/dispatcher.d/13-named</span><br><span class="line">/etc/logrotate.d/named</span><br><span class="line">/etc/named</span><br><span class="line">/etc/named.conf</span><br><span class="line">/etc/named.iscdlv.key</span><br><span class="line">/etc/named.rfc1912.zones</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<h4 id="rpm-qf：命令查询系统文件属于哪个RPM包"><a href="#rpm-qf：命令查询系统文件属于哪个RPM包" class="headerlink" title="rpm -qf：命令查询系统文件属于哪个RPM包"></a>rpm -qf：命令查询系统文件属于哪个RPM包</h4><p>rpm -ql 命令是通过软件包查询所含文件的安装路径，rpm 还支持反向查询，即查询某系统文件所属哪个 RPM 软件包。其命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qf 系统文件名</span><br></pre></td></tr></table></figure>

<p>-f 选项的含义是查询系统文件所属哪个软件包，是 file 的首字母。</p>
<p>注意，只有使用 RPM 包安装的文件才能使用该命令，手动方式建立的文件无法使用此命令。</p>
<p>例如，查询 ls 命令所属的软件包，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qf /bin/ls</span><br><span class="line">coreutils-8.4-19.el6.i686</span><br></pre></td></tr></table></figure>

<h4 id="rpm-qR：查询软件包的依赖关系"><a href="#rpm-qR：查询软件包的依赖关系" class="headerlink" title="rpm -qR：查询软件包的依赖关系"></a>rpm -qR：查询软件包的依赖关系</h4><p>使用 rpm 命令安装 RPM 包，需考虑与其他 RPM 包的依赖关系。rpm -qR 命令就用来查询某已安装软件包依赖的其他包，该命令的格式为：</p>
<p>[root@localhost ~]# rpm -qR 包名</p>
<p>-R（大写）选项的含义是查询软件包的依赖性，是 requires 的首字母。</p>
<p>例如，查询 apache 软件包的依赖性，可执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qR httpd</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/sh</span><br><span class="line">/etc/mime.types</span><br><span class="line">/usr/sbin/useradd</span><br><span class="line">apr-util-ldap</span><br><span class="line">chkconfig</span><br><span class="line">config(httpd) = 2.2.15-15.el6.centos.1</span><br><span class="line">httpd-tods = 2.2.15-15.el6.centos.1</span><br><span class="line">initscripts &gt;= 8.36</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<p>同样，在此命令的基础上增加 -p 选项，即可实现查找未安装软件包的依赖性。</p>
<p>例如，bind 软件包尚未安装（绝对路径为： &#x2F;mnt&#x2F;cdrom&#x2F;Packages&#x2F;bind-9.8.2-0.10.rc1.el6.i686.rpm），查看此软件包的依赖性可执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qRp /mnt/cdrom/Packages/bind-9.8.2-0.10.rc1.el6.i686.rpm</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/sh</span><br><span class="line">bind-libs = 32:9.8.2-0.10.rc1.el6</span><br><span class="line">chkconfig</span><br><span class="line">chkconfig</span><br><span class="line">config(bind) = 32:9.8.2-0.10.rc1.el6</span><br><span class="line">grep</span><br><span class="line">libbind9.so.80</span><br><span class="line">libc.so.6</span><br><span class="line">libc.so.6(GLIBC_2.0)</span><br><span class="line">libc.so.6(GLIBC_2.1)</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<p>注意，这里使用的也是“绝对路径+包全名”的方式。</p>
<h3 id="Linux-RPM包验证和数字证书（数字签名）"><a href="#Linux-RPM包验证和数字证书（数字签名）" class="headerlink" title="Linux RPM包验证和数字证书（数字签名）"></a>Linux RPM包验证和数字证书（数字签名）</h3><p>执行 <code>rpm -qa</code> 命令可以看到，Linux 系统中装有大量的 RPM 包，且每个包都含有大量的安装文件。因此，为了能够及时发现文件误删、误修改文件数据、恶意篡改文件内容等问题，Linux 提供了以下两种监控（检测）方式：</p>
<ul>
<li>RPM 包校验：其实就是将已安装文件和 &#x2F;var&#x2F;lib&#x2F;rpm&#x2F; 目录下的数据库内容进行比较，确定文件内容是否被修改。</li>
<li>RPM 包数字证书校验：用来校验 RPM 包本身是否被修改。</li>
</ul>
<h4 id="Linux-RPM-包校验"><a href="#Linux-RPM-包校验" class="headerlink" title="Linux RPM 包校验"></a>Linux RPM 包校验</h4><p>RPM 包校验可用来判断已安装的软件包（或文件）是否被修改，此方式可使用的命令格式分为以下 3 种。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -Va</span><br></pre></td></tr></table></figure>

<p>-Va 选项表示校验系统中已安装的所有软件包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -V 已安装的包名</span><br></pre></td></tr></table></figure>

<p>-V 选项表示校验指定 RPM 包中的文件，是 verity 的首字母。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -Vf 系统文件名</span><br></pre></td></tr></table></figure>

<p>-Vf 选项表示校验某个系统文件是否被修改。</p>
<p>例如我们校验 apache 软件包中所有的安装文件是否被修改，可执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost -]# rpm -V httpd</span><br></pre></td></tr></table></figure>

<p>可以看到，执行后无任何提示信息，表明所有用 apache 软件包安装的文件均未改动过，还和从原软件包安装的文件一样。</p>
<p>接下来尝试对 apache 的配置文件 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 做适当修改，修改格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vim /etc/httpd/conf/httpd.conf</span></span><br><span class="line">...省略部分内容...</span><br><span class="line">Directorylndex index.html index.html.var index.php</span><br><span class="line"><span class="comment">#这句话是定义apache可以识别的默认网页文件名。在后面加入了index.php</span></span><br><span class="line"><span class="comment">#这句话大概有400行左右</span></span><br><span class="line">…省略部分内容...</span><br></pre></td></tr></table></figure>

<p>由于我们还未学习如何配置 apache，为防止其崩溃，这里仅尝试修改 apache 的默认网页文件。按照以上格式对文件进行修改后保存退出，再次使用 <code>rpm -V</code> 命令对 apache 软件包进行验证：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -V httpd</span></span><br><span class="line">S.5....T. c /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>

<p>可以看到，结果显示了文件被修改的信息。该信息可分为以下 3 部分：</p>
<ol>
<li>最前面的 8 个字符（S.5….T）都属于验证信息，各字符的具体含义如下：<ul>
<li>S：文件大小是否改变。</li>
<li>M：文件的类型或文件的权限（rwx）是否改变。</li>
<li>5：文件MD5校验和是否改变（可以看成文件内容是否改变）。</li>
<li>D：设备的主从代码是否改变。</li>
<li>L：文件路径是否改变。</li>
<li>U：文件的属主（所有者）是否改变。</li>
<li>G：文件的属组是否改变。</li>
<li>T：文件的修改时间是否改变。</li>
<li>.：若相关项没发生改变，用 . 表示。</li>
</ul>
</li>
<li>被修改文件类型，大致可分为以下几类：<ul>
<li>c：配置文件（configuration file）。</li>
<li>d：普通文档（documentation）。</li>
<li>g：”鬼”文件（ghost file），很少见，就是该文件不应该被这个 RPM 包包含。</li>
<li>l：授权文件（license file）。</li>
<li>r：描述文件（read me）。</li>
</ul>
</li>
<li>被修改文件所在绝对路径（包含文件名）。</li>
</ol>
<p>由此，S.5….T. c S.5….T. c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 表达的完整含义是：配置文件 httpd.conf 的大小、内容、修改时间被人为修改过。</p>
<p>注意，并非所有对文件做修改的行为都是恶意的。通常情况下，对配置文件做修改是正常的，比如说配置 apache 就要修改其配置文件，而如果验证信息提示对二进制文件做了修改，这就需要小心，除非是自己故意修改的。</p>
<h4 id="Linux-RPM数字证书验证"><a href="#Linux-RPM数字证书验证" class="headerlink" title="Linux RPM数字证书验证"></a>Linux RPM数字证书验证</h4><p>RPM 包校验方法只能用来校验已安装的 RPM 包及其安装文件，如果 RPM 包本身就被动过手脚，此方法将无法解决问题，需要使用 RPM 数字证书验证方法。</p>
<p>简单的理解，RPM 包校验其实就是将现有安装文件与最初使用 RPM 包安装时的初始文件进行对比，如果有改动则提示给用户，因此这种方式无法验证 RPM 包本身被修改的情况。</p>
<p>数字证书，又称数字签名，由软件开发商直接发布。Linux 系统安装数字证书后，若 RPM 包做了修改，此包携带的数字证书也会改变，将无法与系统成功匹配，软件无法安装。</p>
<p>可以将数字证书想象成自己的签名，是不能被模仿的（厂商的数字证书是唯一的），只有我认可的文件才会签名（只要是厂商发布的软件，都符合数字证书验证）；如果我的文件被人修改了，那么我的签名就会变得不同（如果软件改变，数字证书就会改变，从而通不过验证。当然，现实中人的手工签名不会直接改变，所以数字证书比手工签名还要可靠）。</p>
<p>使用数字证书验证 RPM 包的方法具有如下 2 个特点：</p>
<ol>
<li>必须找到原厂的公钥文件，然后才能进行安装。</li>
<li>安装 RPM 包会提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。</li>
</ol>
<p>数字证书默认会放到系统中<code>/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</code>位置处，通过以下命令也可验证：</p>
<p>#系统中的数字证书位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br><span class="line">-rw-r--r--.1 root root 1706 6 月 26 17:29 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>


<p>安装数字证书的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm --import /efc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br><span class="line">--import表示导入数字证书</span><br></pre></td></tr></table></figure>


<p>数字证书安装完成后，可使用如下命令进行验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa|grep gpg-pubkey</span><br><span class="line">gpg-pubkey-c105b9de-4e0fd3a3</span><br></pre></td></tr></table></figure>

<p>可以看到，数字证书已成功安装。在装有数字证书的系统上安装 RPM 包时，系统会自动验证包的数字证书，验证通过则可以安装，反之将无法安装（系统会报错）。</p>
<p>数字证书本身也是一个 RPM 包，因此可以用 rpm 命令查询数字证书的详细信息，也可以将其卸载。查询数字证书详细信息的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qi gpg-pubkey-c105b9de-4e0fd3a3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询数字证书包的详细信息</span></span><br><span class="line">Name : gpg-pubkey</span><br><span class="line">Relocations: (not relocatable)</span><br><span class="line">Version : c105b9de Vendor: (none)</span><br><span class="line">Release : 4e0fd3a3 Build Date: 2012年11月12日 星期一 23时05分20秒</span><br><span class="line">Install Date: 2012年11月12日星期一23时05分20秒 Build Host: local host</span><br><span class="line">Group : Public Keys</span><br><span class="line">Source RPM: (none)</span><br><span class="line">Size : 0</span><br><span class="line">License: pubkey</span><br><span class="line">…省略部分输出…</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK----</span><br></pre></td></tr></table></figure>

<p>卸载数字证书可以使用 -e 选项，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -e gpg-pubkey-c105b9de-4ead3a3</span><br></pre></td></tr></table></figure>

<p>虽然数字证书可以手动卸载，但不推荐大家将其卸载。</p>
<h3 id="Linux提取RPM包文件-cpio命令"><a href="#Linux提取RPM包文件-cpio命令" class="headerlink" title="Linux提取RPM包文件(cpio命令)"></a>Linux提取RPM包文件(cpio命令)</h3><p>在讲解如何从 RPM 包中提取文件之前，先来系统学习一下 cpio 命令。</p>
<p>cpio 命令用于从归档包中存入和读取文件，换句话说，cpio 命令可以从归档包中提取文件（或目录），也可以将文件（或目录）复制到归档包中。</p>
<p>归档包，也可称为文件库，其实就是 cpio 或 tar 格式的文件，该文件中包含其他文件以及一些相关信息（文件名、访问权限等）。归档包既可以是磁盘中的文件，也可以是磁带或管道。</p>
<p>cpio 命令可以看做是备份或还原命令，因为它可以将数据（文件）备份到 cpio 归档库，也可以利用 cpio 文档库对数据进行恢复。</p>
<p>使用 cpio 命令备份或恢复数据，需注意以下几点：</p>
<ul>
<li>使用 cpio 备份数据时如果使用的是绝对路径，那么还原数据时会自动恢复到绝对路径下；同理，如果备份数据使用的是相对路径，那么数据会还原到相对路径下。</li>
<li>cpio 命令无法自行指定备份（或还原）的文件，需要目标文件（或目录）的完整路径才能成功读取，因此此命令常与 find 命令配合使用。</li>
<li>cpio 命令恢复数据时不会自动覆盖同名文件，也不会创建目录（直接解压到当前文件夹）。</li>
</ul>
<p>cpio 命令主要有以下 3 种基本模式：</p>
<ol>
<li><p>“-o” 模式：指的是 copy-out 模式，就是把数据备份到文件库中，命令格式如下：</p>
<p>[root@localhost ~]# cpio -o[vcB] &gt; [文件丨设备]</p>
<p>各选项含义如下：</p>
<ul>
<li>-o：copy-out模式，备份；</li>
<li>-v：显示备份过程；</li>
<li>-c：使用较新的portable format存储方式；</li>
<li>-B：设定输入&#x2F;输出块为 5120Bytes，而不是模式的 512Bytes；</li>
</ul>
<p>比如，使用 cpio 备份数据的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#find /etc -print | cpio -ocvB &gt; /root/etc.cpio</span></span><br><span class="line"><span class="comment">#利用find命令指定要备份/etc/目录，使用&gt;导出到etc.cpio文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># II -h etc.cpio</span></span><br><span class="line">-rw--r--r--.1 root root 21M 6月5 12:29 etc.cpio</span><br><span class="line"><span class="comment">#etc.cpio文件生成</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“-i” 模式：指的是 copy-in 模式，就是把数据从文件库中恢复，命令格式如下：</p>
<p>[root@localhost ~]# cpio -i[vcdu] &lt; [文件|设备]</p>
<p>各选项的含义为：</p>
<ul>
<li>-i：copy-in 模式，还原；</li>
<li>-v：显示还原过程；</li>
<li>-c：较新的 portable format 存储方式；</li>
<li>-d：还原时自动新建目录；</li>
<li>-u：自动使用较新的文件覆盖较旧的文件；</li>
</ul>
<p>比如，使用 cpio 恢复之前备份的数据，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cpio -idvcu &lt; /root/etc.cpio</span></span><br><span class="line"><span class="comment">#还原etc的备份</span></span><br><span class="line"><span class="comment">#如果大家査看一下当前目录/root/，就会发现没有生成/etc/目录。这是因为备份时/etc/目录使用的是绝对路径，所以数据直接恢复到/etc/系统目录中，而没有生成在/root/etc/目录中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“-p” 模式：指的是复制模式，使用 -p 模式可以从某个目录读取所有文件，但并不将其备份到 cpio 库中，而是直接复制为其他文件。</p>
<p>例如，使用 -p 将 &#x2F;boot&#x2F; 复制到 &#x2F;test&#x2F;boot 目录中可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /tmp/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入/tmp/目录</span></span><br><span class="line">[root@localhost tmp]#rm -rf*</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除/tmp/目录中的所有数据</span></span><br><span class="line">[root@localhost tmp]# mkdir test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立备份目录</span></span><br><span class="line">[root@localhost tmp]# find /boot/ -print | cpio -p /tmp/test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份/boot/目录到/tmp/test/目录中</span></span><br><span class="line">[root@localhost tmp]# ls test/boot</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在/tmp/test/目录中备份出了/boot/目录</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="使用-cpio-命令提取-RPM-包中指定文件"><a href="#使用-cpio-命令提取-RPM-包中指定文件" class="headerlink" title="使用 cpio 命令提取 RPM 包中指定文件"></a>使用 cpio 命令提取 RPM 包中指定文件</h4><p>在服务器使用过程，如果系统文件被误修改或误删除，可以考虑使用 cpio 命令提取出原 RPM 包中所需的系统文件，从而修复被误操作的源文件。</p>
<p>RPM 包允许逐个提取包中文件，使用的命令格式如下：</p>
<p>[root@localhost ~]# rpm2cpio 包全名|cpio -idv .文件绝对路径</p>
<p>该命令中，rpm2cpio 就是将 RPM 包转换为 cpio 格式的命令，通过 cpio 命令即可从 cpio 文件库中提取出指定文件。</p>
<p>举个例子，假设我们不小心把 &#x2F;bin&#x2F;ls 命令删除了，通常有以下 2 种方式修复：</p>
<ol>
<li>将 coreutils-8.4-19.el6.i686 包（包含 ls 命令的 RPM 包）通过 -force 选项再安装一遍；</li>
<li>使用 cpio 命令从 coreutils-8.4-19.el6.i686 包中提取出 &#x2F;bin&#x2F;ls 文件，然后将其复制到相应位置；</li>
</ol>
<p>这里我们选择第 2 种方式。有读者可能会问，如何知道 ls 命令隶属于那个 RPM 包呢？很简单，使用 <code>rpm -qf</code> 命令即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qf /bin/ls</span><br><span class="line">coreutils-8.4-19.el6.i686</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看<span class="built_in">ls</span>文件属于哪个软件包</span></span><br></pre></td></tr></table></figure>

<p>在此基础上，我们只需从此 RPM 包使用 cpio 命令提取出 ls 命令文件，然后将其复制到对应位置即可，实现命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /bin/ls /root/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把/bin/ls命令移动到/root/目录下，造成误删除的假象</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">-bash: ls: command not found</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这时执行<span class="built_in">ls</span>命令，系统会报<span class="string">&quot;命令没有找到&quot;</span>错误</span></span><br><span class="line">[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm</span><br><span class="line">|cpio -idv ./bin/ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提取<span class="built_in">ls</span>命令文件到当前目录下</span></span><br><span class="line">[root@localhost ~]# cp /root/bin/ls /bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把提取出来的<span class="built_in">ls</span>命令文件复制到/bin/目录下</span></span><br><span class="line">[root@localhost ~]#ls</span><br><span class="line">anaconda-ks.cfg bin inittab install.log install.log.syslog ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到，<span class="built_in">ls</span>命令又可以正常使用了</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-SRPM源码包安装"><a href="#Linux-SRPM源码包安装" class="headerlink" title="Linux SRPM源码包安装"></a>Linux SRPM源码包安装</h3><p>前面章节我们介绍了如何使用 RPM 包安装软件，本节学习使用另一种 RPM 包，即 SRPM 源码包安装软件。</p>
<p>SRPM 包，比 RPM 包多了一个“S”，是“Source”的首字母，所以 SRPM 可直译为“源代码形式的 RPM 包”。也就是说，SRPM 包中不再是经过编译的二进制文件，都是源代码文件。可以这样理解，SRPM 包是软件以源码形式发布后直接封装成 RPM 包的产物。</p>
<p>表 1 列出了 RPM 包与 SRPM 包的几点不同。</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>文件名格式</th>
<th>直接安装与否</th>
<th>内含程序类型</th>
<th>可否修改参数并编译</th>
</tr>
</thead>
<tbody><tr>
<td>RPM</td>
<td>xxx.rpm</td>
<td>可</td>
<td>已编译</td>
<td>不可</td>
</tr>
<tr>
<td>SRPM</td>
<td>xxx.src.rpm</td>
<td>不可</td>
<td>未编译的源代码</td>
<td>可</td>
</tr>
</tbody></table>
<p>从表中可以看到，SRPM 包的命名与 RPM 包基本类似，唯一区别在于 SRPM 包多了“src”标志，即 SRPM 包采用“包名-版本号-发布次数-发行商-src.rpm”的方式进行命名，比如“<a target="_blank" rel="noopener" href="http://c.biancheng.net/mysql/">MySQL</a>-5.5.29-2.el6.src.rpm”。</p>
<p>此外，SRPM 包是未经编译的源码包，无法直接用来安装软件，需要经过以下 2 步：</p>
<ol>
<li>将 SRPM 包编译成二进制的 RPM 包；</li>
<li>使用编译完成的 RPM 包安装软件；</li>
</ol>
<p>前面章节已经介绍了如何使用 RPM 包安装软件，因此使用 SRPM 包安装软件的关键在于第一步，也就是如何将 SRPM 包编译为 RPM 包。</p>
<p>本节依然以安装 apache 为例，使用 SRPM 包安装软件（编译 SRPM 包）的方式有以下 2 种：</p>
<ol>
<li>利用 rpmbuild 命令可以直接使用 SRPM 包安装软件，也可以先将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件；</li>
<li>利用 *.spec 文件可实现将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件；</li>
</ol>
<h4 id="rpmbuild-命令的安装"><a href="#rpmbuild-命令的安装" class="headerlink" title="rpmbuild 命令的安装"></a>rpmbuild 命令的安装</h4><p>rpmbuild 命令也是一个程序，但是这个程序不会默认安装，所以要想使用 rpmbuild 命令就必须提前安装。这里我们使用 rpm 命令来安装 rpmbuild 命令，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost~]<span class="comment">#rpm -ivh /mnt/cdroin/Packages/rpm-build-4.8.0-27.el6.i686.rpm</span></span><br><span class="line">Preparing...</span><br><span class="line"><span class="comment">###################</span></span><br><span class="line">[100%]</span><br><span class="line">1:rpm-build</span><br><span class="line"><span class="comment">###################</span></span><br><span class="line">[100%]</span><br><span class="line"></span><br><span class="line">出现两个 100% 才证明 rpmbuild 安装成功。</span><br></pre></td></tr></table></figure>

<h4 id="rpmbuild命令安装SRPM包"><a href="#rpmbuild命令安装SRPM包" class="headerlink" title="rpmbuild命令安装SRPM包"></a>rpmbuild命令安装SRPM包</h4><p>如果我们只想安装 SRPM 包，而不用修改源代码，那么直接使用 rpmbuild 命令即可。使用 rpmbuild 安装 SRPM 包的命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpmbuild [选项] 包全名</span></span><br></pre></td></tr></table></figure>

<p>可使用如下 2 个选项：</p>
<ul>
<li>-rebuild：编译 SRPM 包生成 RPM 二进制包；</li>
<li>-recompile：编译 SRPM 包，同时安装。</li>
</ul>
<p>需要注意的是，SRPM 本质上仍属于 RPM 包，所以安装时仍需考虑包之间的依赖性，要先安装它的依赖包，才能正确安装。</p>
<p>这里我们选择使用 -rebuild 选项先将 SRPM 包编译成 RPM 二进制包，命令如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpmbuild -rebuild httpd-2.2.15-5.el6.src.rpm</span></span><br><span class="line">warning: InstallSourcePackage at: psm.c:244: Header V3 RSA/SHA256 Signature, key</span><br><span class="line">ID fd431d51: NOKEY</span><br><span class="line">warning: user mockbuild does not exist - using root</span><br><span class="line">warning: group mockbuild does not exist - using root</span><br><span class="line"><span class="comment">#警告为mockbuild用户不存在，使用root代替。这里不是报错，不用紧张</span></span><br><span class="line">…省略部分输出…</span><br><span class="line">Wrote: /root/rpmbuild/RPMS/i386/ httpd-2.2.15-5.el6.i386.rpm</span><br><span class="line">Wrote: /root/rpmbuild/RPMS/i386/httpd-devel-2.2.15-5.el6.i386.rpm</span><br><span class="line">Wrote: /root/rpmbuild/RPMS/noarch/httpd-manual-2.2.15-5.el6.noarch.rpm</span><br><span class="line">Wrote: /root/rpmbuild/RPMS/i386/httpd-tools-2.2.15-5.el6.i386.rpm</span><br><span class="line">Wrote: /root/rpmbuild/RPMS/i386/ mod_ssl-2.2.15-5.el6.i386.rpm</span><br><span class="line"><span class="comment">#写入RPM包的位置，只要看到，就说明编译成功</span></span><br><span class="line">Executing(%clean): /bin/sh -e/var/tmp/rpm-tmp.Wb8TKa</span><br><span class="line">+ <span class="built_in">umask</span> 022</span><br><span class="line">+ <span class="built_in">cd</span>/root/rpmbuild/BUILD</span><br><span class="line">+ <span class="built_in">cd</span> httpd-2.2.15</span><br><span class="line">+ <span class="built_in">rm</span> -rf /root/rpmbuild/BUILDROOT/httpd-2.2.15-5.el6.i386</span><br><span class="line">+ <span class="built_in">exit</span> 0</span><br><span class="line">Executing(-clean): /bin/sh -e/var/tmp/rpm-tmp.3UBWql</span><br><span class="line">+ <span class="built_in">umask</span> 022</span><br><span class="line">+ <span class="built_in">cd</span>/root/rpmbuild/BUILD</span><br><span class="line">+ rm-rf httpd-2.2.15</span><br><span class="line">+ <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>exit 0 是编译成功的标志，此编译过程产生的临时文件会自动删除。SRPM 包编译完成后，会在当前目录生成 rpmbuild 目录，整个编译过程生成的文件（软件包）都存在这里。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls /root/rpmbuild/</span></span><br><span class="line">BUILD RPMS SOURCES SPECS SRPMS</span><br></pre></td></tr></table></figure>

<p>通过 ls 命令可以看到，rpmbuild 目录下有几个子目录，其各自保存的文件类别如表 2 所示。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>BUILD</td>
<td>编译过程中产生的数据保存位置</td>
</tr>
<tr>
<td>RPMS</td>
<td>编译成功后，生成的 RPM 包保存位置</td>
</tr>
<tr>
<td>SOURCES</td>
<td>从 SRPM 包中解压出来的源码包（*.tar.gz）保存位置</td>
</tr>
<tr>
<td>SPECS</td>
<td>生成的设置文件的安装位置。第二种安装方法就是利用这个文件进行安装的</td>
</tr>
<tr>
<td>SRPMS</td>
<td>放置 SRPM 包的位置</td>
</tr>
</tbody></table>
<p>可以看到，编译好的 RPM 包保存在 &#x2F;root&#x2F;rpmbuild&#x2F;RPMS&#x2F; 目录下，可以使用如下命令进行验证：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#ll /root/rpmbuild/RPMS/i386/</span></span><br><span class="line">-rw--r--r-- 1 root root 3039035 11月19 06:30 httpd-2.2.15-5.el6.i386.rpm</span><br><span class="line">-rw--r--r-- 1 root root 154371 11月19 06:30 httpd-devel-2.2.15-5.el6.i386.rpm</span><br><span class="line">-rw--r--r-- 1 root root 124403 11月19 06:30 httpd-tools-2.2.15-5.el6.i386.rpm</span><br><span class="line">-rw--r--r-- 1 root root 383539 11月19 06:30 mod_ssl-2.2.15-5.el6.i386.rpm</span><br></pre></td></tr></table></figure>

<p>如此，我们就得到可直接安装软件的 RPM 包。实际上，使用 rpmbuild命令编译 SRPM 包经历了以下 3 个过程：</p>
<ol>
<li>先把 SRPM 包解开，得到源码包；</li>
<li>对源码包进行编译，生成二进制文件；</li>
<li>把二进制文件重新打包生成 RPM 包。</li>
</ol>
<h4 id="利用-spec-文件安装"><a href="#利用-spec-文件安装" class="headerlink" title="利用 *.spec 文件安装"></a>利用 *.spec 文件安装</h4><p>想利用 .spec 文件安装软件，需先将 SRPM 包解开。当然，我们可以使用 rpmbuild 命令解开 SRPM 包，但这里选择另一种方式，即使用 <code>rpm -i</code> 命令，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -i httpd-2.2.15-5.el6.src.rpm</span></span><br></pre></td></tr></table></figure>

<p>-i 选项用于安装 rpm 包时表示安装，但对于 SRPM 包的安装来说，这里只会将 .src.rpm 包解开后将个文件放置在当前目录下的 rpmbuild 目录中，并不涉及安装操作。</p>
<p>通过此命令，也可以在当前目录下生成 rpmbuild 目录，但与表 2 不同，此 rpmbuild 目录中仅有 SOURCES 和 SPECS 两个子目录。其中，SOURCES 目录中放置的是源码，SPECS 目录中放置的是设置文件。</p>
<p>接下来使用 SPECS 目录中的设置文件生成 RPM 包，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpmbuild -ba /root/rpmbuild/SPECS/httpd.spec</span></span><br></pre></td></tr></table></figure>

<p>其中，-ba 选项的含义是编译，会同时生成 RPM 二进制包和 SRPM 源码包。这里还可以使用 -bb 选项用来仅生成 RPM 二进制包。</p>
<p>命令执行完成，会在 &#x2F;root&#x2F;rpmbuild&#x2F; 目录下生成 BUILD、RPMS、SOURCES、SPECS 和 SRPMS 目录，RPM 包放在 RPMS 目录中，SRPM 包生成在 SRPMS 目录中。</p>
<p>以上两种方式都可实现将 SRPM 包编译为 RPM 二进制包，剩下的工作就是使用 RPM 包安装软件，这部分内容已在前面章节中讲过，因此不再赘述。</p>
<h3 id="Linux-RPM包依赖性（含解决方案）"><a href="#Linux-RPM包依赖性（含解决方案）" class="headerlink" title="Linux RPM包依赖性（含解决方案）"></a>Linux RPM包依赖性（含解决方案）</h3><p>RPM 软件包（包含 SRPM 包）的依赖性主要体现在 RPM 包安装与卸载的过程中。</p>
<p>例如，如果采用最基础的方式（基础服务器方式）安装 Linux 系统，则 gcc 这个软件是没有安装的，需要自己手工安装。当你使用 rpm 命令安装 gcc 软件的 RPM 包，就会发生依赖性错误，错误提示信息如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -ivh /mnt/cdrom/Packages/ gcc-4.4.6-4.el6.i686.rpm</span></span><br><span class="line">error: Failed dependencies: &lt;―依赖性错误</span><br><span class="line">cloog-ppi &gt;= 0.15 is needed by gcc-4.4.6-4.el6.i686</span><br><span class="line">cpp = 4.4.6-4.el6 is needed by gcc-4.4.6-4.el6.i686</span><br><span class="line">glibc-devel &gt;= 2.2.90-12 is needed by gcc-4.4.6-4.el6.i686</span><br></pre></td></tr></table></figure>

<p>报错信息提示我们，如果要安装 gcc，需要先安装 cloog-ppl、cpp 和 glibc-devel 三个软件，这体现的就是 RPM 包的依赖性。</p>
<p>除此之外，报错信息中还会明确给出各个依赖软件的版本要求：</p>
<ul>
<li>“&gt;&#x3D;”：表示版本要大于或等于所显示版本；</li>
<li>“&lt;&#x3D;”：表示版本要小于或等于所显示版本；</li>
<li>“&#x3D;”：表示版本要等于所显示版本；</li>
</ul>
<p>Linux 系统中，RPM 包之间的依赖关系大致可分为以下 3 种：</p>
<ol>
<li>树形依赖（A-B-C-D）：要想安装软件 A，必须先安装 B，而安装 B 需要先安装 C…….解决此类型依赖的方法是从后往前安装，即先安装 D，再安装 C，然后安装 B，最后安装软件 A。</li>
<li>环形依赖（A-B-C-D-A）：各个软件安装的依赖关系构成“环状”。解决此类型依赖的方法是用一条命令同时安装所有软件包，即使用 <code>rpm -ivh 软件包A 软件包B ...</code>。</li>
<li>模型依赖：软件包的安装需要借助其他软件包的某些文件（比如库文件），解决模块依赖最直接的方式是通过 <a target="_blank" rel="noopener" href="http://www.rpmfind.net/">http://www.rpmfind.net</a> 网站找到包含此文件的软件包，安装即可。</li>
</ol>
<p>以上 3 种 RPM 包的依赖关系，给出的解决方案都是手动安装，比较麻烦。在后续的章节中，我们将系统学习使用 yum 命令查询、安装、升级和卸载软件包的方法。</p>
<p>yum，全称”Yellow dog Updater,Modified”，CentOS 系统上的软件包管理器，它能够自动下载 RPM 包并安装，更重要的是，它可以自动处理软件包之间的依赖性关系，一次性安装所有依赖的软件包，无需一个个安装。</p>
<h3 id="Linux-yum是什么，yum源配置"><a href="#Linux-yum是什么，yum源配置" class="headerlink" title="Linux yum是什么，yum源配置"></a>Linux yum是什么，yum源配置</h3><p>前面分别介绍了使用 SRPM 源码包和 RPM 二进制包安装软件，这两种方法都比较繁琐，需要手动解决包之间具有依赖性的问题，尤其是库文件依赖，需要自行去 <a target="_blank" rel="noopener" href="http://www.rpmfind.net/">http://www.rpmfind.net</a> 网站上查找相关的 RPM 包。本节介绍一种可自动安装软件包（自动解决包之间依赖关系）的安装方式。</p>
<p>yum，全称“Yellow dog Updater, Modified”，是一个专门为了解决包的依赖关系而存在的软件包管理器。就好像 Windows 系统上可以通过 360 软件管家实现软件的一键安装、升级和卸载，Linux 系统也提供有这样的工具，就是 yum。</p>
<p>可以这么说，yum 是改进型的 RPM 软件管理器，它很好的解决了 RPM 所面临的软件包依赖问题。yum 在服务器端存有所有的 RPM 包，并将各个包之间的依赖关系记录在文件中，当管理员使用 yum 安装 RPM 包时，yum 会先从服务器端下载包的依赖性文件，通过分析此文件从服务器端一次性下载所有相关的 RPM 包并进行安装。</p>
<p>yum 软件可以用 rpm 命令安装，安装之前可以通过如下命令查看 yum 是否已安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -qa | grep yum</span></span><br><span class="line">yum-metadata-parser-1.1.2-16.el6.i686</span><br><span class="line">yum-3.2.29-30.el6.centos.noarch</span><br><span class="line">yum-utils-1.1.30-14.el6.noarch</span><br><span class="line">yum-plugin-fastestmirror-1.1.30-14.el6.noarch</span><br><span class="line">yum-plugin-security-1.1.30-14.el6.noarch</span><br></pre></td></tr></table></figure>

<p>可以看到，系统上已经安装了 yum。</p>
<p>使用 rpm 命令安装 yum 的具体方式可查看《<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/e3c78d6483a02a3c4d85f578.html">Linux怎么安装yum</a>》一节。</p>
<p>使用 yum 安装软件包之前，需指定好 yum 下载 RPM 包的位置，此位置称为 yum 源。换句话说，yum 源指的就是软件安装包的来源。</p>
<p>使用 yum 安装软件时至少需要一个 yum 源。yum 源既可以使用网络 yum 源，也可以将本地光盘作为 yum 源。接下来就给大家介绍这两种 yum 源的搭建方式。</p>
<h4 id="网络-yum-源搭建"><a href="#网络-yum-源搭建" class="headerlink" title="网络 yum 源搭建"></a>网络 yum 源搭建</h4><p>一般情况下，只要你的主机网络正常，可以直接使用网络 yum 源，不需要对配置文件做任何修改，这里对 yum 源配置文件做一下简单介绍。</p>
<p>网络 yum 源配置文件位于 &#x2F;etc&#x2F;yum.repos.d&#x2F; 目录下，文件扩展名为”<em>.repo”（只要扩展名为 “</em>.repo” 的文件都是 yum 源的配置文件）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls /etc/yum.repos.d/</span></span><br><span class="line">CentOS-Base.repo</span><br><span class="line">CentOS-Media.repo</span><br><span class="line">CentOS-Debuginfo.repo.bak</span><br><span class="line">CentOS-Vault.repo</span><br></pre></td></tr></table></figure>

<p>可以看到，该目录下有 4 个 yum 配置文件，通常情况下 CentOS-Base.repo 文件生效。我们可以尝试打开此文件，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># vim /etc/yum.repos.d/ CentOS-Base.repo</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line">mirrorlist=http://mirrorlist.centos.org/? release= <span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=os</span><br><span class="line">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<p>此文件中含有 5 个 yum 源容器，这里只列出了 base 容器，其他容器和 base 容器类似。base 容器中各参数的含义分别为：</p>
<ul>
<li>[base]：容器名称，一定要放在[]中。</li>
<li>name：容器说明，可以自己随便写。</li>
<li>mirrorlist：镜像站点，这个可以注释掉。</li>
<li>baseurl：我们的 yum 源服务器的地址。默认是 CentOS 官方的 yum 源服务器，是可以使用的。如果你觉得慢，则可以改成你喜欢的 yum 源地址。</li>
<li>enabled：此容器是否生效，如果不写或写成 enabled 则表示此容器生效，写成 enable&#x3D;0 则表示此容器不生效。</li>
<li>gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。</li>
<li>gpgkey：数字证书的公钥文件保存位置。不用修改。</li>
</ul>
<h4 id="本地-yum-源"><a href="#本地-yum-源" class="headerlink" title="本地 yum 源"></a>本地 yum 源</h4><p>在无法联网的情况下，yum 可以考虑用本地光盘（或安装映像文件）作为 yum 源。</p>
<p>Linux 系统安装映像文件中就含有常用的 RPM 包，我们可以使用压缩文件打开映像文件（iso文件），进入其 Packages 子目录，如图 1 所示：</p>
<blockquote>
<p>图片安装映像文件的 Packages 子目录](assets&#x2F;Linux&#x2F;2-1Z32P9423J01.gif)<br>图 1 安装映像文件的 Packages 子目录</p>
</blockquote>
<p>可以看到，该子目录下含有几乎所有常用的 RPM 包，因此使用系统安装映像作为本地 yum 源没有任何问题。</p>
<p>在 &#x2F;etc&#x2F;yum.repos.d&#x2F; 目录下有一个 CentOS-Media.repo 文件，此文件就是以本地光盘作为 yum 源的模板文件，只需进行简单的修改即可，步骤如下：</p>
<ol>
<li><p>放入 CentOS 安装光盘，并挂载光盘到指定位置。命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /mnt/cdrom</span></span><br><span class="line"><span class="comment">#创建cdrom目录，作为光盘的挂载点</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/cdrom /mnt/cdrom/</span></span><br><span class="line">mount: block device/dev/srO is write-protected, mounting read-only</span><br><span class="line"><span class="comment">#挂载光盘到/mnt/cdrom目录下</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改其他几个 yum 源配置文件的扩展名，让它们失效，因为只有扩展名是”*.repo”的文件才能作为 yum 源配置文件。当也可以删除其他几个 yum 源配置文件，但是如果删除了，当又想用网络作为 yum 源时，就没有了参考文件，所以最好还是修改扩展名。 命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /etc/yum.repos.d/</span></span><br><span class="line">[root@localhost yum.repos.d]<span class="comment"># mv CentOS-Base, repo CentOS-Base.repo.bak</span></span><br><span class="line">[root@localhost yum.repos.d]<span class="comment">#mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak</span></span><br><span class="line">[root@localhost yum.repos.d]<span class="comment"># mv CentOS-Vault.repo CentOS-Vault.repo.bak</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改光盘 yum 源配置文件 CentOS-Media.repo，参照以下方修改：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># vim CentOS-Media.repo</span></span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Media</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line"><span class="comment">#地址为你自己的光盘挂载地址</span></span><br><span class="line"><span class="comment">#file:///media/cdrom/</span></span><br><span class="line"><span class="comment">#file:///media/cdrecorder/</span></span><br><span class="line"><span class="comment">#注释这两个的不存在地址</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"><span class="comment">#把enabled=0改为enabled=1, 让这个yum源配置文件生效</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如此，本地 yum 源就配置完成了。</p>
<h3 id="Linux-yum命令详解（查询、安装、升级和卸载软件包）"><a href="#Linux-yum命令详解（查询、安装、升级和卸载软件包）" class="headerlink" title="Linux yum命令详解（查询、安装、升级和卸载软件包）"></a>Linux yum命令详解（查询、安装、升级和卸载软件包）</h3><h4 id="yum查询命令"><a href="#yum查询命令" class="headerlink" title="yum查询命令"></a>yum查询命令</h4><p>使用 yum 对软件包执行查询操作，常用命令可分为以下几种：</p>
<ul>
<li><p>yum list：查询所有已安装和可安装的软件包。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum list</span></span><br><span class="line"><span class="comment">#查询所有可用软件包列表</span></span><br><span class="line">Installed Packages</span><br><span class="line"><span class="comment">#已经安装的软件包</span></span><br><span class="line">ConsdeKit.i686 0.4.1-3.el6</span><br><span class="line">@anaconda-CentOS-201207051201 J386/6.3</span><br><span class="line">ConsdeKit-libs.i686 0.4.1-3.el6 @anaconda-CentOS-201207051201 J386/6.3</span><br><span class="line">…省略部分输出…</span><br><span class="line">Available Packages</span><br><span class="line"><span class="comment">#还可以安装的软件包</span></span><br><span class="line">389-ds-base.i686 1.2.10.2-15.el6 c6-media</span><br><span class="line">389-ds-base-devel.i686 1.2.10.2-15.el6 c6-media</span><br><span class="line"><span class="comment">#软件名 版本 所在位置（光盘）</span></span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
</li>
<li><p>yum list 包名：查询执行软件包的安装情况。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum list samba</span></span><br><span class="line">Available Packages samba.i686 3.5.10-125.el6 c6-media</span><br><span class="line"><span class="comment">#查询 samba 软件包的安装情况</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>yum search 关键字：从 yum 源服务器上查找与关键字相关的所有软件包。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum search samba</span></span><br><span class="line"><span class="comment">#搜索服务器上所有和samba相关的软件包</span></span><br><span class="line">========================N/S Matched:</span><br><span class="line">samba =============================</span><br><span class="line">samba-client.i686：Samba client programs</span><br><span class="line">samba-common.i686：Files used by both Samba servers and clients</span><br><span class="line">samba-doc.i686: Documentation <span class="keyword">for</span> the Samba suite</span><br><span class="line">…省略部分输出…</span><br><span class="line">Name and summary matches only, use<span class="string">&quot;search all&quot;</span> <span class="keyword">for</span> everything.</span><br></pre></td></tr></table></figure>
</li>
<li><p>yum info 包名：查询执行软件包的详细信息。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum info samba</span></span><br><span class="line"><span class="comment">#查询samba软件包的信息</span></span><br><span class="line">Available Packages &lt;-没有安装</span><br><span class="line">Name : samba &lt;-包名</span><br><span class="line">Arch : i686 &lt;-适合的硬件平台</span><br><span class="line">Version : 3.5.10 &lt;―版本</span><br><span class="line">Release : 125.el6 &lt;—发布版本</span><br><span class="line">Size : 4.9M &lt;—大小</span><br><span class="line">Repo : c6-media &lt;-在光盘上</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="yum安装命令"><a href="#yum安装命令" class="headerlink" title="yum安装命令"></a>yum安装命令</h4><p>yum 安装软件包的命令基本格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum -y install 包名</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>install：表示安装软件包。</li>
<li>-y：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 yes；</li>
</ul>
<p>例如使用此 yum 命令安装 gcc：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum jepos.d]<span class="comment">#yum -y install gcc</span></span><br><span class="line"><span class="comment">#使用yum自动安装gcc</span></span><br></pre></td></tr></table></figure>

<p>gcc 是 C 语言的编译器，鉴于该软件包涉及到的依赖包较多，建议使用 yum 命令安装。</p>
<h4 id="yum-升级命令"><a href="#yum-升级命令" class="headerlink" title="yum 升级命令"></a>yum 升级命令</h4><p>使用 yum 升级软件包，需确保 yum 源服务器中软件包的版本比本机安装的软件包版本高。</p>
<p>yum 升级软件包常用命令如下：</p>
<ul>
<li><code>yum -y update</code>：升级所有软件包。不过考虑到服务器强调稳定性，因此该命令并不常用。</li>
<li><code>yum -y update 包名</code>：升级特定的软件包。</li>
</ul>
<h4 id="yum-卸载命令"><a href="#yum-卸载命令" class="headerlink" title="yum 卸载命令"></a>yum 卸载命令</h4><p>使用 yum 卸载软件包时，会同时卸载所有与该包有依赖关系的其他软件包，即便有依赖包属于系统运行必备文件，也会被 yum 无情卸载，带来的直接后果就是使系统崩溃。</p>
<p>除非你能确定卸载此包以及它的所有依赖包不会对系统产生影响，否则不要使用 yum 卸载软件包。</p>
<p>yum 卸载命令的基本格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum remove 包名</span></span><br><span class="line"><span class="comment">#卸载指定的软件包</span></span><br></pre></td></tr></table></figure>

<p>例如，使用 yum 卸载 samba 软件包的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># yum remove samba</span></span><br><span class="line"><span class="comment">#卸载samba软件包</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-yum管理软件组方法"><a href="#Linux-yum管理软件组方法" class="headerlink" title="Linux yum管理软件组方法"></a>Linux yum管理软件组方法</h3><p>在安装 Linux 系统时，我们可以根据需要自定义安装软件包</p>
<p>选择“Customize now”</p>
<p>Linux 列出的许多软件包组，例如编辑器、系统工具、开发工具等。</p>
<p>yum 命令除了可以对软件包进行查询、安装、升级和卸载外，还可完成对软件包组的查询、安装和卸载操作。</p>
<h4 id="yum查询软件组包含的软件"><a href="#yum查询软件组包含的软件" class="headerlink" title="yum查询软件组包含的软件"></a>yum查询软件组包含的软件</h4><p>既然是软件包组，说明包含不只一个软件包，通过 yum 命令可以查询某软件包组中具体包含的软件包，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#yum groupinfo 软件组名</span></span><br><span class="line"><span class="comment">#查询软件组中包含的软件</span></span><br></pre></td></tr></table></figure>

<p>例如，查询 Web Server 软件包组中包含的软件包，可使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#yum groupinfo &quot;Web Server&quot;</span></span><br><span class="line"><span class="comment">#查询软件组&quot;Webserver&quot;中包含的软件</span></span><br></pre></td></tr></table></figure>

<h4 id="yum安装软件组"><a href="#yum安装软件组" class="headerlink" title="yum安装软件组"></a>yum安装软件组</h4><p>使用 yum 安装软件包组的命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#yum groupinstall 软件组名</span></span><br><span class="line"><span class="comment">#安装指定软件组，组名可以由grouplist查询出来</span></span><br></pre></td></tr></table></figure>

<p>例如，安装 Web Server 软件包组可使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#yum groupinstall &quot;Web Server&quot;</span></span><br><span class="line"><span class="comment">#安装网页服务软件组</span></span><br></pre></td></tr></table></figure>

<h4 id="yum命令卸载软件组"><a href="#yum命令卸载软件组" class="headerlink" title="yum命令卸载软件组"></a>yum命令卸载软件组</h4><p>yum 卸载软件包组的命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum groupremove 软件组名</span></span><br><span class="line"><span class="comment">#卸载指定软件组</span></span><br></pre></td></tr></table></figure>


<p>yum 软件包组管理命令更适合安装功能相对集中的软件包集合。例如，在初始安装 Linux 时没有安装图形界面，但后来发现需要图形界面的支持，这时可以手工安装图形界面软件组（X Window System 和 Desktop），就可以使用图形界面了。</p>
<h3 id="Linux源码包安装和卸载教程（以apache为例）"><a href="#Linux源码包安装和卸载教程（以apache为例）" class="headerlink" title="Linux源码包安装和卸载教程（以apache为例）"></a>Linux源码包安装和卸载教程（以apache为例）</h3><p>由于 Linux 操作系统开放源代码，因此在其上安装的软件大部分也都是开源软件，例如 Apache、Tomcat 和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/php/">PHP</a> 等。开源软件基本都提供源码下载，可采用源码安装的方式安装软件。</p>
<p>注意，本节使用的源码包，指的是软件所有源代码的压缩包，其后缀名为 “.tar.gz” 或 “.tar.bz2”；而 SRPM 源码包本质上属于 RPM 包，也就是源码的RPM包，其文件后缀为 “.src.rpm”。虽然都叫源码包，但不是一码事。</p>
<p>软件的源代码，也就是软件的原始数据，任何人都可以通过源代码查看该软件的设计架构和实现方法，但软件源代码无法再计算机中直接运行安装，需要将源代码通过编译转换为计算机可以识别的机器语言，然后才可以安装。</p>
<p>Linux 系统中，绝大多数软件的源代码都是用 C 语言编写的，少部分用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>（或其他语言）编写。因此要想安装源码包，必须安装 gcc 编译器（如果涉及 C++ 源码程序，还需要安装 gcc-c++）。</p>
<p>安装 gcc 之前，可先使用如下命令看看是否已经安装：</p>
<p>[root@localhost ~]# rpm -q gcc<br>gcc-4.4.6-4.el6.i686</p>
<p>如果未安装，考虑到安装 gcc 所依赖的软件包太多，推荐大家使用 yum 安装 gcc。具体安装方式可阅读《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/825.html">Linux yum命令</a>》一节。</p>
<p>除了安装编译器，还需要安装 make 编译命令。要知道，编译源码包可不像编译一个 hello.c 文件那样轻松，包中含大量的源码文件，且文件之间有着非常复杂的关联，直接决定着各文件编译的先后顺序，因此手动编译费时费力，而使用 make 命令可以完成对源码包的自动编译。</p>
<p>同样，在安装 make 命令之前，可使用如下命令查看其是否已经安装：</p>
<p>[root@localhost yum. repos.d]# rpm -q make<br>make-3.81-20.el6.i686</p>
<p>如果未安装，可使用 <code>yum -y install make</code> 命令直接安装 make。</p>
<p>安装好了 gcc 编译器和 make 编译工具，接下来学习使用源码包安装软件。</p>
<h3 id="Linux源码包安装软件"><a href="#Linux源码包安装软件" class="headerlink" title="Linux源码包安装软件"></a>Linux源码包安装软件</h3><p>本节仍然以安装 apache 为例，安装过程分为如下几步：</p>
<ol>
<li><p>下载 apache 源码包。该软件的源码包可通过官方网站 <a target="_blank" rel="noopener" href="http://httpd.apache.org/download.cgi#apache24">http://httpd.apache.org/download.cgi#apache24</a> 下载，得到的源码包格式为压缩包（ “.tar.gz” 或 “.tar.bz2” ）。</p>
<p>将各种文件分门别类保存在对应的目录中，应该成为合格 Linux 管理员约定俗成的习惯。Linux 系统中用于保存源代码的位置主要有 2 个，分别是 “&#x2F;usr&#x2F;src” 和 “&#x2F;usr&#x2F;local&#x2F;src”，其中 “&#x2F;usr&#x2F;src” 用来保存内核源代码，”&#x2F;usr&#x2F;local&#x2F;src” 用来保存用户下载的源代码。</p>
</li>
<li><p>将源码包进行解压缩，使用命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#tar -zxvf httpd-2.2.9.tar.gz|more</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入解压目录，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg httpd-2.2.9 httpd-2.2.9.tar.gz install.log install.log.syslog</span><br><span class="line">[root@localhost ~]<span class="comment"># cd httpd-2.2.9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>.&#x2F;configure 软件配置与检查。这一步主要完成以下 3 项任务：</p>
<ul>
<li><p>检测系统环境是否符合安装要求。</p>
</li>
<li><p>定义需要的功能选项。通过 “.&#x2F;configure–prefix&#x3D;安装路径” 可以指定安装路径。注意，configure 不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用 “.&#x2F;configure” 方式执行（”.&#x2F;“ 代表在当前目录下）。</p>
<p>“.&#x2F;configure” 支持的功能选项较多，可执行 “.&#x2F;configure–help” 命令查询其支持的功能，例如：</p>
<p>[root@localhost httpd-2.2.9]#.&#x2F;configure –help|more<br>#查询apache支持的选项功能（不是必需步骤）</p>
</li>
<li><p>把系统环境的检测结果和定义好的功能选项写入 Makefile 文件，因为后续的编译和安装需要依赖这个文件的内容。</p>
</li>
</ul>
<p>此步具体执行代码如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost httpd-2.2.9]<span class="comment"># ./configure --prefix=/usr/local/apache2</span></span><br><span class="line">checking <span class="keyword">for</span> chosen layout...Apache</span><br><span class="line">checking <span class="keyword">for</span> working <span class="built_in">mkdir</span> -p…<span class="built_in">yes</span></span><br><span class="line">checking build system type...i686-pc-linux-gnu</span><br><span class="line">checking host system type...i686-pc-linux-gnu</span><br><span class="line">checking target system typa...i686-pc-linux-gnu</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>

<p>–prefix 选项的含义为指定安装目录。</p>
<p>此命令没有加载其他功能，只是指定安装目录。需要说明的是，”&#x2F;usr&#x2F;local&#x2F;apache2” 目录不需要手工建立，安装完成后会自动建立（这个目录是否生成也是检测软件是否正确安装的重要标志）。</p>
</li>
<li><p>make 编译。make 会调用 gcc 编译器，并读取 Makefile 文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被 Linux 识别的可执行文件，这些可执行文件保存在当前目录下。</p>
<p>执行的编译命令如下：</p>
<p>[root@localhost httpd-2.2.9]# make</p>
<p>编程过程较为耗时，需要有足够的耐心。</p>
</li>
<li><p>正式开始安装软件，这里通常会写清程序的安装位置，如果没有，则建议读者把安装的执行过程保存下来，以备将来删除软件时使用。安装指令如下：</p>
<p>[root@localhost httpd-2.2.9]# make install</p>
<p>整个过程不报错，即为安装成功。</p>
<p>安装源码包过程中，如果出现“error”（或“warning”）且安装过程停止，表示安装失败；反之，如果仅出现警告信息，但安装过程还在继续，这并不是安装失败，顶多使软件部分功能无法使用。</p>
</li>
</ol>
<p>注意，如果在 “.&#x2F;configure” 或 “make” 编译中报错，则在重新执行命令前一定要执行 <code>make clean</code> 命令，它会清空 Makefile 文件或编译产生的 “.o” 头文件。</p>
<h4 id="Linux源码包卸载"><a href="#Linux源码包卸载" class="headerlink" title="Linux源码包卸载"></a>Linux源码包卸载</h4><p>通过源码包方式安装的各个软件，其安装文件独自保存在 &#x2F;usr&#x2F;local&#x2F; 目录下的各子目录中。例如，apache 所有的安装文件都保存在 &#x2F;usr&#x2F;local&#x2F;apache2 目录下。这就为源码包的卸载提供了便利。</p>
<p>源码包的卸载，只需要找到软件的安装位置，直接删除所在目录即可，不会遗留任何垃圾文件。需要读者注意的是，在删除软件之前，应先将软件停止服务。</p>
<p>以删除 apache 为例，只需关闭 apache 服务后执行如下命令即可：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rm -rf /usr/local/apache2/</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux源码包快速升级方法"><a href="#Linux源码包快速升级方法" class="headerlink" title="Linux源码包快速升级方法"></a>Linux源码包快速升级方法</h3><p>Linux 系统中更新用源码包安装的软件，除了卸载重装这种简单粗暴的方法外，还可以下载补丁文件更新源码包，用新的源码包重新编译安装软件。比较两种方式，后者更新软件的速度更快。</p>
<p>使用补丁文件更新源码包，省去了用 .&#x2F;configured 生成新的 Makefile 文件，还省去了大量的编译工作，因此效率更高。学完本节会对比有更深入的理解。</p>
<h4 id="Linux补丁文件的生成和使用"><a href="#Linux补丁文件的生成和使用" class="headerlink" title="Linux补丁文件的生成和使用"></a>Linux补丁文件的生成和使用</h4><p>Linux 系统中可以使用 diff 命令对比出新旧软件的不同，并生成补丁文件。</p>
<p>diff 命令基本格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># diff 选项 old new</span></span><br><span class="line"><span class="comment">#比较old和new文件的不同</span></span><br></pre></td></tr></table></figure>

<p>此命令中可使用如下几个选项：</p>
<ul>
<li>-a：将任何文档当作文本文档处理；</li>
<li>-b：忽略空格造成的不同；</li>
<li>-B：忽略空白行造成的不同；</li>
<li>-I：忽略大小写造成的不同；</li>
<li>-N：当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件；</li>
<li>-r：当比较目录时，递归比较子目录；</li>
<li>-u：使用同一输出格式；</li>
</ul>
<p>从生成补丁文件，到使用其实现更新软件的目的，为了让读者清楚地了解整个过程的来龙去脉，下面我们自己创建两个文件（分别模拟旧软件和新软件），通过对比新旧文件生成补丁文件，最后利用补丁文件更新旧文件，具体步骤如下：</p>
<ol>
<li><p>创建两个文件，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir test</span></span><br><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd test</span></span><br><span class="line"><span class="comment">#进入测试目录</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># vi old.txt</span></span><br><span class="line">our</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">lampbrother</span><br><span class="line"><span class="comment">#文件old.txt，为了便于比较，将每行分开</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># vi new.txt</span></span><br><span class="line">our</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">lampbrother</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">Beijing</span><br><span class="line"><span class="comment">#文件new.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 diff 命令，比较两个文件（old.txt 和 new.txt）的不同，并生成补丁文件（txt.patch），执行代码如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># diff -Naur /root/test/old.txt /root/test/new.txt &gt; txt. patch</span></span><br><span class="line"><span class="comment">#比较两个文件的不同，同时生成txt.patch补丁文件</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment">#vi txt.patch</span></span><br><span class="line"><span class="comment">#查看一下这个文件</span></span><br><span class="line">--/root/test/old.txt 2012-11-23 05:51:14.347954373 +0800</span><br><span class="line"><span class="comment">#前一个文件</span></span><br><span class="line">+ + + /root/test/new.txt 2012-11-23 05:50:05.772988210 +0800</span><br><span class="line"><span class="comment">#后一个文件</span></span><br><span class="line">@@-2, 3+2, 5@@</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">lampbrother</span><br><span class="line">+<span class="keyword">in</span></span><br><span class="line">+beijing</span><br><span class="line"><span class="comment">#后一个文件比前一个文件多两行（用+表示）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用补丁文件 txt.patch 更新 old.txt 旧文件，实现此步操作需利用 patch 命令，该命令基本格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># patch -pn &lt; 补丁文件</span></span><br><span class="line"><span class="comment">#按照补丁文件进行更新</span></span><br></pre></td></tr></table></figure>

<p>-pn 选项中，n 为数字（例如 p1、p2、p3 等），pn 表示按照补丁文件中的路径，指定更新文件的位置。</p>
<p>这里对 -pn 选项的使用做一下额外说明。我们知道，补丁文件是要打入旧文件的，但是当前所在目录和补丁文件中记录的目录不一定是匹配的，需要 “-pn” 选项来同步两个目录。</p>
<p>例如，当前位于 “&#x2F;root&#x2F;test&#x2F;“ 目录下（要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为 “&#x2F;root&#x2F;test&#x2F;dd.txt”，如果写入 “-p1”（在补丁文件目录中取消一级目录），那么补丁文件会打入 “root&#x2F;test&#x2F;root&#x2F;test&#x2F;old.txt” 文件中，这显然是不对的；如果写入的是 “-p2”（在补丁文件目录中取消二级目录），补丁文件会打入 “&#x2F;root&#x2F;test&#x2F;test&#x2F;old.txt” 文件中，这显然也不对。如果写入的是 “-p3”（在补丁文件目录中取消三级目录），补丁文件会打入 “&#x2F;root&#x2F;test&#x2F;old.txt” 文件中，old.txt 文件就在这个目录下，所以应该用 “-p3” 选项。</p>
<p>如果当前所在目录是 “&#x2F;root&#x2F;“ 目录呢？因为补丁文件中记录的文件目录为 “&#x2F;root&#x2F;test&#x2F;old.txt”，所以这里就应该用 “-p2” 选项（代表取消两级目录），补丁打在当前目录下的 “test&#x2F;old.txt” 文件上。</p>
<p>因此，-pn 选项可以这样理解，即想要在补丁文件中所记录的目录中取消几个 “&#x2F;“，n 就是几。去掉目录的目的是和当前所在目录匹配。</p>
<p>现在更新 “old.txt” 文件，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># patch -p3 &lt; txt.patch</span></span><br><span class="line">patching file old.txt</span><br><span class="line"><span class="comment">#给old.txt文件打补丁</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># cat old.txt</span></span><br><span class="line"><span class="comment">#查看一下dd.txt文件的内容</span></span><br><span class="line">our</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">lampbrother</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">Beijing</span><br><span class="line"><span class="comment">#多出了in Beijing两行</span></span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用补丁文件 txt.patch 对旧文件进行更新，使得旧文件和新文件完全相同。</p>
</li>
</ol>
<p>通过这个例子，大家要明白以下两点：</p>
<ol>
<li>给旧文件打补丁依赖的不是新文件，而是补丁文件，所以即使新文件被删除也没有关系。</li>
<li>补丁文件中记录的目录和当前所在目录需要通过 “-pn” 选项实现同步，否则更新可能失败。</li>
</ol>
<h4 id="给apache打入补丁"><a href="#给apache打入补丁" class="headerlink" title="给apache打入补丁"></a>给apache打入补丁</h4><p>本节仍以 apache 为例，通过从官网上下载的补丁文件 “mod_proxy_ftp_CVE-2008-2939.diff”，更新 httpd-2.2.9 版本的 apache。</p>
<p>这里使用的补丁文件，修补了 apache 代理 FTP 站点时，模块空指针引用拒绝服务攻击的漏洞（了解即可，不用深究）。</p>
<p>具体更新步骤如下：</p>
<ol>
<li><p>从 apache 官网上下载补丁文件；</p>
</li>
<li><p>复制补丁文件到 apache 源码包解压目录中，执行命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp mod_proxy_ftp_CVE-2008-2939.diff httpd-2.2.9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给旧 apache 打入补丁，具体执行命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd httpd-2.2.9</span></span><br><span class="line"><span class="comment">#进入apache源码目录</span></span><br><span class="line">[root@localhost httpd-2.2.9]<span class="comment"># vi mod_proxy_ftp_CVE-2008-2939.diff</span></span><br><span class="line"><span class="comment">#查看补丁文件</span></span><br><span class="line">--modules/proxy/mod_proxy_ftp.c (Revision 682869)</span><br><span class="line">+ + + modules/proxy/mod_proxy_ftp.c (Revision 682870)</span><br><span class="line">…省略部分输出…</span><br><span class="line"><span class="comment">#查看一下补丁文件中记录的目录，以便一会儿和当前所在目录同步</span></span><br><span class="line">[root@localhost httpd-2.2.9]<span class="comment"># patch - p0 &lt; mod_proxy_ftp_CVE-2008-2939.diff</span></span><br><span class="line"><span class="comment">#打入补丁</span></span><br></pre></td></tr></table></figure>

<p>为什么是 “-p0” 呢？因为当前在 “&#x2F;root&#x2F;httpd-2.2.9” 目录中，但补丁文件中记录的目录是 “modules&#x2F;proxy&#x2F;mod_proxy_ftp.c”，就在当前所在目录中，因此一个 “&#x2F;“ 都不需要去掉，所以是 “-p0”。</p>
</li>
<li><p>重新编译 apache 源码包，执行如下命令：</p>
<p>[root@localhost httpd-2.2.9]# make</p>
</li>
<li><p>安装 apache，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost httpd-2.2.9]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>打补丁更新软件的过程比安装软件少了 “.&#x2F;configure” 步骤，且编译时也只是编译变化的位置，编译速度更快。</p>
<p>注意，如果未安装过 httpd-2.2.9，就需要先打入补丁，再依次执行 “.&#x2F;configure”、”make”、<br>“make install” 命令。</p>
<p>patch 命令不仅可以给就文件打入补丁，还可以执行反操作，即恢复用补丁文件修改过的源文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost httpd-2.2.9]# patch -R &lt; modjDroxy_ftp_CVE-2008-2939.diff</span><br></pre></td></tr></table></figure>

<p>-R（大写）选项表示还原补丁。</p>
<h3 id="Linux脚本程序包及安装方法（以webmin安装为例）"><a href="#Linux脚本程序包及安装方法（以webmin安装为例）" class="headerlink" title="Linux脚本程序包及安装方法（以webmin安装为例）"></a>Linux脚本程序包及安装方法（以webmin安装为例）</h3><p>脚本程序并不多见，所以在软件包分类中并没有把它列为一类。它更加类似于 Windows 下的程序安装，有一个可执行的安装程序，只要运行安装程序，然后进行简单的功能定制选择（比如指定安装目录等)，就可以安装成功，只不过是在字符界面完成的。</p>
<p>目前常见的脚本程序以各类硬件的驱动居多，我们需要学习一下这类软件的安装方式，以备将来不时之需。</p>
<p>我们来看看脚本程序如何安装和使用。安装一个叫作 Webmin 的工具软件，Webmin 是一个基于 Web 的系统管理界面，借助任何支持表格和表单的浏览器（和 File Manager 模块所需要的<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a>），你就可以设置用户账号、apache、DNS、文件共享等。</p>
<p>Webmin 包括一个简单的 Web 服务器和许多 CGI 程序，这些程序可以直接修改系统文件，比如 &#x2F;etc&#x2F;inetd.conf 和 &#x2F;etc&#x2F;passwd。Web 服务器和所有的 CGI 程序都是用 Perl 5 编写的，没有使用任何非标准 Perl 模块。也就是说，Webmin 是一个用 Perl 语言写的、可以通过浏览器管理 Linux 的软件。</p>
<h4 id="webmin安装步骤"><a href="#webmin安装步骤" class="headerlink" title="webmin安装步骤"></a>webmin安装步骤</h4><p>首先下载 Webmin 软件，这里下载的是 webmin-1.610.tar.gz。</p>
<p>接下来解压缩软件，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tar -zxvf webmin-1.610.tar.gz</span></span><br></pre></td></tr></table></figure>

<p>进入解压目录，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd webmin-1.610</span></span><br><span class="line"></span><br><span class="line">执行安装程序 setup.sh，并指定功能选项，命令如下：</span><br><span class="line"></span><br><span class="line">[root@localhost webmin-1.610]<span class="comment"># ./setup.sh</span></span><br><span class="line">**************************</span><br><span class="line">* Welcome to the Webmin setup script,version 1.610 *</span><br><span class="line">**************************</span><br><span class="line">Webmin is a web-based interface that allows Unix-like operating</span><br><span class="line">systems and common Unix services to be easily administered.</span><br><span class="line">Installing Webmin <span class="keyword">in</span> /root/webmin-1.610...</span><br><span class="line">**************************</span><br><span class="line">Webmin uses separate directories <span class="keyword">for</span> configuration files and <span class="built_in">log</span> files.</span><br><span class="line">Unless you want to run multiple versions of Webmin at the same time</span><br><span class="line">you can just accept the defaults.</span><br><span class="line">Config file directory [/etc/webmin]:</span><br><span class="line"><span class="comment">#选择安装位置，默认安装在/etc/webmin目录下。</span></span><br><span class="line">如果安装到默认位置，则直接回车</span><br><span class="line">Log file directory [/var/webmin]:</span><br><span class="line"><span class="comment">#日志文件保存位置，直接回车，选择默认位置</span></span><br><span class="line">**************************</span><br><span class="line">Webmin is written entirely <span class="keyword">in</span> Perl.Please enter the full path to the</span><br><span class="line">Perl 5 interpreter on your system.</span><br><span class="line">Full path to peri (default /usr/bin/perl):</span><br><span class="line"><span class="comment">#指定Perl语言的安装位置，直接回车，选择默认位置，Perl默认就安装这里</span></span><br><span class="line">Testing Perl...</span><br><span class="line">Perl seems to be installed ok</span><br><span class="line">**************************</span><br><span class="line">Operating system name: CentOS Linux Operating system version: 6.3</span><br><span class="line">**************************</span><br><span class="line">Webmin uses its own password protected web server to provide access to the administration programs.</span><br><span class="line">The setup script needs to know:</span><br><span class="line">-What port to run the web server on.There must not be another web server already using this port.</span><br><span class="line">-The login name required to access the web server.</span><br><span class="line">-The password required to access the web server.</span><br><span class="line">-If the Webserver should use SSL (<span class="keyword">if</span> your system supports it).</span><br><span class="line">-Whether to start webmin at boot time.</span><br><span class="line">Web server port (default 10000):</span><br><span class="line"><span class="comment">#指定Webmin监听的端口，直接回车，默认选定 10000</span></span><br><span class="line">Login name (default admin):admin <span class="comment">#输入登录Webmin的用户名</span></span><br><span class="line">Login password:</span><br><span class="line">Password again:</span><br><span class="line"><span class="comment">#输入登陆密码</span></span><br><span class="line">The Perl SSLeay library is not installed.SSL not available.</span><br><span class="line"><span class="comment">#apache默认没有启动SSl功能，所以SSl没有被激活</span></span><br><span class="line">Start Webmin at boot time (y/n):y</span><br><span class="line"><span class="comment">#是否在开机的同时启动Webmin</span></span><br><span class="line">…安装过程省略…</span><br><span class="line">Webmin has been installed and started successfully.Use your web browser to go to</span><br><span class="line">http://localhost:10000/</span><br><span class="line">and login with the name and password you entered previously.</span><br><span class="line"><span class="comment">#安装完成</span></span><br></pre></td></tr></table></figure>

<p>在浏览器地址栏中输入”<a target="_blank" rel="noopener" href="http://192.168.2.199:10000/">http://192.168.2.199:10000/</a> “，然后输入用户名和密码，就可以登录到 Webmin 界面</p>



<div class="article-footer reveal fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/51ea15a6/">Linux命令总结</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/a531cc26/">git基本使用</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@Gentle Conspiracy</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.22.1';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.22.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img, .gallery img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@v2/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@v2/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@v2/dist/waline.js","css":"https://unpkg.com/@waline/client@v2/dist/waline.css","serverURL":"https://discuss.forever520.top/","commentCount":true,"pageview":false,"locale":{"placeholder":"有事可评论，无事更可评论！"},"emoji":["https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs","https://unpkg.com/@waline/emojis@1.1.0/qq"],"requiredMeta":["nick"],"lang":"zh-CN","wordLimit":500,"pageSize":50}, {
        el: '#waline_container',
        path: path,
        
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->

  
    <div class="iframe-container"><iframe frameborder="0" src="https://blog.ltyuanfang.cn/shizhong" width="100%" height="230px" scrolling="no"></iframe></div>
  
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Everlasting16108/html/css/clock5.css">
  
    <div style="height:60px;line-height:60px;font-size:14pt;font-weight:bold;text-align:center;color:pink;"><span id="hitokoto"><a href="#" id="hitokoto_text">"人生最大的遗憾,就是在最无能为力的时候遇到一个想要保护一生的人."</a></span><font color="pink">欢迎访问：<a href="https://al.forever520.top" target="_blank" >ZQ的资源站</a></font></div>
  
    <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script>
  
    <div style=" height:30px;line-height:30px;font-size:14pt;font-weight:bold;text-align:center;color:pink"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div>
  
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures1/js/yh3.js"></script>
  
    <div align="center"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://count.getloli.com/get/@LYcc?theme=rule34"></div>
  
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures1/js/mytime2.js"></script>
  
    <script src="https://myhkw.cn/api/player/166996049082" id="myhk" key="166996049082" m="1"></script>
  


  </div>
</body>
</html>
