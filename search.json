[{"title":"2024年","path":"/bda667c5/","content":"2024年 2024年，新年快乐，元旦快乐！ 随着新年的钟声渐渐敲响，我们共同迎接一片充满希望和机遇的未来。在这辞旧迎新的美好时刻，愿温暖和喜悦填满你们的心房，愿健康和幸运伴随你们每一个即将到来的日子。 让我们把握现在，珍惜相聚的时光，把爱和关怀传递给身边的每一个人。愿你们在新的一年中勇敢地追求梦想，坚韧不拔地克服挑战，享受每一个成功的果实。无论你们的旅程带领你们到哪里，都不要忘记，每一步都值得庆祝，每一天都值得感恩。 2024年，愿平安喜乐与你们同在，愿你们的世界被爱环绕，愿每个明天比今天更美好。新年快乐！ 通知：由于本人时间和精力有限，从今日起便不在维护本站，而是转向更加方便、便捷的新网站。地址：新网站。","tags":["新年","元旦，2024"],"categories":["新年","元旦，2024"]},{"title":"日记","path":"/undefined/","content":"日记 发现好久没有写博客了，实在是今年上半年太忙了，时间过的可真快呀，转眼已经一年过去了。","tags":["日记"],"categories":["日记"]},{"title":"从高质量发展到优质量发展","path":"/4abae2f4/","content":"从高质量发展到优质量发展。","tags":["日常"],"categories":["日常"]},{"title":"画江湖之不良人第六季","path":"/a5f92095/","content":"画江湖之不良人第六季 button{ background-color: white; border: 1px solid #008CBA; color: black; text-align: center; text-decoration: none; display: inline-block; font-size: 14px; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; cursor: pointer; } button:hover{ background-color: #008CBA; color: white; } 推荐使用火狐浏览器观影更佳 var dplayer5 = new DPlayer({\"element\":document.getElementById(\"dplayer5\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E5%8A%A8%E6%BC%AB/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA/%E7%AC%AC%E5%85%AD%E5%AD%A3/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA%20%E7%AC%AC6%E5%AD%A3%20%E7%AC%AC01%E8%AF%9D.mp4\"}}); 第01集 第02集 第03集 第04集 第05集 第06集 第07集 第08集 第09集 第10集 第11集 第12集","tags":["动漫","画江湖之不良人","国漫巅峰"],"categories":["国漫巅峰","动漫","画江湖之不良人"]},{"title":"半年见习期总结","path":"/93d51a56/","content":"420610353dcf436ad81980cf1736bf450b884918a245f15f2b6731bf15f6ff988550896ed9ec96cdab17c47db197ea6e443daf705d615dfbaed34e0b67577185758900a63a83b3b2d235ab2bd9789fcd1b48d920902b76c431dbfe87c4fb3d15bb33edf9af4053b4a64c9a6abf19bdaf63ecc7614452cbc0034c48ee2195b0e09ba6cbd11b5f6d70c42b3111352858e2aad7b93ef63e482eebad5bf1c631f4463eb741c61ddc3808bcf7972bfa9e88cb51d3fa78539152811823956aaa11ef87bfaf8ddc306b26f3377bace4e6d1b781171f4fdadd2420abd356ad494dcd1e3ca3afc7d5f5845b658adcaf9a330add6410a450b0491f0ca0a3173998e597b042af5cfb07df026169b5cbf3cfc884ba3c8eef3fdd975b78e8312e0a15843f2e5877647ae977a5d4be75d69d5f8054732cd986a3ff5d21f240fccb13055779d2a471fac1a26de8d51e1c59556189fcd248493c7b89fc8b017f5807112a0060a23f5116d48b1925bc386c5f24a4b03944531d88d4645a0728a3a34b24903ab2baf94234aed2ee208605495ec116b055aa95426d06cdb4a8dc1250fbce1d7605b3d6d7d0e1a0e202547e4d98735a131df033051d043db428a8b6fd0bc15864cbf64e6cd438d6f9c08d74b7696cd7564c136fe0801876b61c0ea2c029bc0d499c1c71d9838689e4c4b4a7ad8ced99c812469824dc9db578536bcc92b140b3443598d70083aaa02812966c1dd63a1ceb519d0d325e846b71cc094e877badec2dddef5a573e1e27264d323ddfe91bbd553b57bab0a2c114fb1f9529a0dab87a74f3b1a8aba366a0a8d8b6f4af0df725e365ea80a9cf09421c9f3883fa0ce8508d35e88e83aed3cf24b3182f1e802e4bbea5204a76748fbdebc93fedbb4917299199c97abff9d0a0537d50247d93dbb36f70e190d636fe20b9178d006586d2b701aad7878716b3cce67caae692e8c8e84730a07393750ddf52b4db93b2e18d6f9edb56d39ae201a642f144450d688d125102947919a4d7ed4af3151f91619e39954ca08b6e4c357e04632adb2a5aca4501b3228ac94ed6012cb01f91a1e9d1cea8b3e9cb2ea814e72f1f884074bba04428dd0314fb3e03f37a4374e30a72c845be700f50c599a063cc831e9d2224ddb0109e6443fc19662265815fe068d62cd54f7f1a5db4d8b0ecd3d844e682a847321d51646ef7f7536f61d659bce6e4b0f1a6c60bf36dbd3180db4de5d212ac7a928adbdb5643aa172199be1a101d964690f2b8aae3ff52882c0129f4d06775c4f9e718707ed4964386564deca92bef4b85d2426409e261a9649cfc5908ddc9918fc9d920c987b50f0f87718a2b23a256a4dac508ef24062ca66bf8ffc2a6df955442057d933baa241b2b8510c2080b997049a3ca20829f440b8ab416f5474c45d65dafe24d6e51ee6de131db2ae681559217f83556b5dd5bbc1c759836632c08b4b4530059efd7f4ddcdc41f1caf4d241468af70ea8c705834ba71ca99ba3ea01a3e5eb6d129cecc43615477be02ea60835d1ffd80b15024170f314a39fe0ad7c79637c1ce6860bd20b981ac136dc8a636ccfb4f0986545519ef37914e99ecca70f4a605ee9a948987ee4b4401fb595aefdd0a63e80bf5a6d05a7dda2bf6b7154515ab23330bc16f05b3eef8def23ac8c663382be1e73fe1f6cb7e5977a4c0fbc984505281c351aedfc79673003bf07a3ed822a0664617ff285856ca280343e95cac53fa322c12ba76625c67708af9c04e75dd8cd3f658a0e432ab8d4deb630b8c5911c8dac8baccc941db7afe71455a5727aa188a2991a985b646ebeb98978f992157360259e60a73ca21f79af003a335a6c1fac02a6658e0cd2fc41de4a191c6991929188e875d99c814e0f7bc2f87d2ac070dc49e4edb6cba5111fc3642a839861a3a7ab55246bf4ce86acd25d2408f2b0eb78ca5919edc55b5e662073bc73b164a477263ca06b84b316469aac0c26c0527e043f69603dc3c9fa82646581bf777a6fbbd13c33622e6ea940220500583adc5de7cce7b2663f60cffe08a86869770eab042e65b99ac2554cf3009ce33c78b3db0aa287f6c4c72c0ad1f4c766efa15b91a188de020c6556fd8ab6875f4ef921fb3b732e1cf5357cf1975cd8e0a67c63195ffc86952539cb598c95e993ab3fa3be482a1920c39b43b4f6fb13da9e7810d925e33c1be9c819e4213d704060653633254b3ed0926f666b2c72fe642a9b7ad62b8d993bb94c10afc4c3aef7e4035e5c65f7e0e1d6843b52e3e401d51c55a0c6dec3f1270c019fa5b1d1834fd082c77b30142716ba34da3b9c5c49a82d82a4649d277b7823e345b572d09b94a6f2c39ca63ed8041f350b0d1d560932f0fc5308e00abeabaa61361a1db10167eff50e33005a69af20ac47f43cbf24aaabf50f04b6ad872ac71ed4c5515c64494e65ff009ac4794ca5f3d0f95562ba19f79ef27b4345f102d87ea487b962a08782491164bb92cb6e13254de546f897e830f95a79e76ef4c73b9f57976a39bed4df63f3073e2a6e1cce39c43b2c221ad850d380dd2254e6e0ddf490c2c28ad1b8780ef9f6239779b7cfe19334386251dc8a3cd9bb7e4e6fec57b5e02d2f9397ea8de6cc10cd5c14b262a038d785a90660e3c30a0ecfdb9044129db230a16312aab27fb1457d2c71b1813c3663fc5e87cda50484b7bb54248d7e3d69daf987e047e3461806dfd6e49e1fbb0a0fc1e46a08b0c92cac22b475cf18dc66a21743b358cea93aceedf6daa80b511c5454c59e002784b5e8af8d001b377c13cfe4f7ff63ac2b768e2ba083ac107c9147df81bcac6e0463249e0147545ff8aa8d841682919bc70b068d4183cb739e49e251871db4221c112a0a78538f9a1cab0679453cfd27c8db68b4600ae9309393a4e3e11518d58289865e1b51ba460af8fb17ac597bd624656f057cdd8e980332d951e0caf893f09e281bdc97ace28683d093752172daad3298851506902cb32ec390db22fa11a0cc0e9bbf860c47698f700b210e401f4744c9edf084c796c6fe66d07dab638dbac2de94af33ea117f4bd4f9b7b75545a7a9f197f95e53be5e9c3d73283108d14b8cbe75a6caff464108f2bc8f73861588b581edff9133f7d3016ab9939b486b33f940ea31abd24ae4f81c827a281221ca2481dcf9d1fa477a1f57faf1b179d9176c7f84c3c470db846b5536a8cab89b55dea2792e68bdbc5a93a8a4a27eceb68eca3144245070040c8487b03c4a3de4741fb279e3e54717ea70fdfd324fb3f5fd64b1905d80872d6ae356d06127c0f4844d175f8043ecffd8401769b802b8fe1fa0eb33c2760a616cc21e43fbcb651b9392860b67be3a58005d3edf14644b67fb8d9b5c218e1eefc3f00afb87cdc6c4fbe6401ef31e344b2d41a1f8b47433d69b102f19cdf8add831526d66c8cd93b0ac7f7f6de3d8ceff1eea1b8ae57ab1a960f0cdba1d33f76870943691a02557a46f1a296b9ed830008e5c55c509235e993bdd64aad791262c833edb63c1b72b9ae2483232337ee32c78bdd83514488631acc1bd6a0bfa9835121c9296a0628ca52d01ee3b69f924a0a8338d3ec47b489afd286d127b001dab2d7f20c1d9617c9c3f56f71d700c81dc3ab33de11777dc1fa15f54c18bdbb1089e2b3d2358d045fcb9f54351916eba43b0403b98155064bb9e428abb8eea7a87d068bd5ba428cb53ca98e71915f6d49df856955dc69a42489035bda00a04edcae26407bb95be0c5af2f1cee2a816f72124cab4868d5ddb3dc1347181242d6a332c95d8f6dae05234e24e598ab2f15ef6982aa56e04fc15d52cee21d8febc804a468dd7bd3f56b6aa7cac6b47211cf79356a267e592053a4621a8c3fc32a410b1a9a9c8728d6173d911db53dbb35ca25cf1ace0a01c9d69ee2cece571feb966686a0fdbda40551a660baaad0916351525f0f41e774ba81961a0d06b13b6b25f24dc31f3b7be796d69d09d277474796424515bb9223e6d66f68d1e5b85a0ab4f91e207c5236000af390b632dc735da02510be76a41179999114c9de6c80c1282f38516e185f37b95ef4cc5d6c1b300a7ed5a6cb922ad147620747b863f4887dd4cc4b6ad3e3518f6501917ebcd01cea88d3333fc29e2869ef4cc4327313582c65a544c6ddf2fe6f1d98da37f843167f4b46dde10b3b4967b7e4c52636024eeb040401baf42d4d01176f82068dab94721588639649e49ac8484deaa6e02fbfb73212bd17d6cae072347da2046172c6302bb5d10ac06da1153526a683082264844e165a46d4b2c88f490cabc322bc74948b6e807399cbcfe84cc663c25a48d94f14cec5b3e90d3b6c8f587fe8fb66dffa1d3d0d96bd70cc4b2d0846e4ec719c2b4b5ba5769016d9ec08cfa67b3eaf2d197ad343d98b798d0a195deedf14af4915b442c017f10175d0bb86366186bb24b5152884df87028ce60fa0cb05788837550cd597889ad5751d21ad1a1549a4c8da83b01eceea20c9eb2023ebb21c4c7d9b779914d95e658f32a9c1b0da40a2def36dc8c15e41ae1db04e02999f0e75987bf4588a7c1071e85a37c86ab45acbc4cbc0299f5534effbbaecb51a425653becfef34a2c6d4b056fc5bec3eac7cbb8e1748fe63cf84fa1fec664076b2999b3cc99d6f9d03654a09c7a641722eed185b8c05ffd570c40d586cae551402dcb59069b4d09edd54b0823190fe4b97abe034d046ea877eba0006b3f803838379627becf49b393d91ce21d851b8f009577c123a0938c429f983c364ac984a9201e4d5c6ebec9da048a5ca45f63cd7704f179df79a24f92e6a1accf9691291df23405b93b40631541bd67f3f1aaac0f021562a7205822e3bd04a31c47f17ee7a193e459d6bc8b644f89d7281a79d357f336ba22da4588f868af245dc85fa39cd1f8b18a3b62cd5f2875cef65b19a466ec77f9ce8a60b36b0ee4c77f4c07ccc3ec11e2dff6b968d038864f564dacde84b88cbb4cb66729bed87239bdfadcee7d406b8005e9aba83fcdc4f32e0b376865c766952b362a59209dbf8263cbae89572c3b4367fa7084610fdce05de0976bc6012c49e9525ecf5566ad25c8918f2627827728b480c19c20f6ddbed070b9c32662218050064632b96b8bc92f88805b34a1be197377de038a225bc1a9e0d2f30ddd96d0e0cdca3f41e818d09dc7f8e9732cb841ed1c564d3edb10315abe11dd607b43ece0a0261cdae20f9155ca26a1e7c930ac6d9ac7769fd294eec0a95866fcd99deb5f4757626d4fbf241438acb496914c15d567eb6d00a8313dd657a8060d79f992a3a6e37835540383b000ccc59fa309011d1f3273b5886b00b0a40f3e6b0f6613d80e84c40ea198ae80bc4862042a5228028a5e29fb18674b79482644d5bdc9b580ba9f9585da6ef71e67b6a8f0a3c692bb6ef442ebbfcdc84a1b9798f6ab44a1529079dbc52ff301eb8a8da478e7fb95c19325900144e8f1937e6dc4cdd7fcf5c9b4a057f45c7bdbbfeab0371eac2c8967bcf50a094ec2a907f2b891b6cbb8f517a071cd636565f459a52b74fa5904b73ac3067272c7b92d4943d09aa1bd9a73eada180d1e89e4b8be06f4b6aa11abf3a811f0491de6ae872dc6e022439fe5b51709d1864bf669c2be837ac769185b6ed531c92983ef70bde2f27296001f010107740568fabade2e7e49976496152bbe49bcfec4d18c582b1cb0760b81873eff52510a8e602620c0897ed0db87a73ae349ad23d62f5e75fb7024576e40e7bd95cf858e7cacae416f60bb6acdd40e3d437f6fd80932e40f8bba1f4b3a078b7f34ea3c4289947d56a6c0c6b2631daf47321b56f16855fdf46dd3e8a218a4acfb35838feaba35bd107d09831e0248533cd72126e14461afbff88f0838e1f1ce52fabadaef856a1f06efbc3bfdbad2bbe5633b7929d544db4c2ef1d35d16e3de6358e1d625505906aea49e732b7981d95960aa28e18b844fec169a8e527edf5d766e0132ab12d2426beabd1b1e0e70e8dfba805264fa99854590900108fcdf9af732e5c4602a7d9f8aa639208d24d16bf87e2359abe54d9503385565e09c107ee86c12546d2a1e5203edd176dccc747692010ea102aedc94f0a612e2fff2b849ee2765f574edfdb6be429ce139b91935d16207529f00ee759ff52d17843ebc1d71d25ad49ac43f8c440efb20f0c933ddc695eba3e5897ef981a0503b5edd3901ef36de8f19a7b81047dc8080eaca6f5b88dd230b64335f883f1b3b417fda0c5309752e6003fdc2e204bccc755dea1d6ecafb42928d42fb07ec5ef94dc3d8200356f5a5998e89dd5683be646b463e22529ae26243abea7cd903d62738405e017f2a405f8e9ba64a920d440d57b28032d27914e4f1836979bdefaf76ce817c3fc18699fbf2db4255ea174f5a2e5ffeaffc1dfa402b1a8d321bb8a953e7bdcf9812ae1b77961af83b1d60e9d2059626a05b3759c3f5ce169dc755b1dbb3e93b9c2892fe919e1ec25ab6f5d155a84a3a852481da586c6cbad27a23d88c72c97ee7760347b8a6f35fd3c4eba66f94681c6b31e25237569e26f7792905e4c5475dd196c1573a8ead6e064b4d76725b0e185d70b2f76261a2cf5edb5cd47d25001ce689741d059e665d720ad74929f552f5af98cef20103ff55f015fbed9be6eb8e32daba6f0578f2ba89c1cd5b120df294b23ac029cb0bd232979481ebaa5173749c105ec930779f543669539a73a3c09e07746364953745fe7af5d7d5f788f0f1d1f2e7debc4e8c54fdf43ce5f27db638c6b579a23414a659f1e9fc77ed24364870a51b6a28d9e355fd3e7a868cf111319966f34ba34012753e51b43262858467c8f97e43a39cb070ddf33bccec906ffbf8a3bc7912f3f89ddf740c0cda21a7d1215be6d79bca590a1338f4664cc4f267dda555be806fe31ed0a3344ff477151063c432a8c85e02d2244045a773524afb6f8ac50c6ab0043e99fc1e0a2f232e6843d410c1deb6a3383ac1d70f983550b2899889f5caf7bd1912ae83d6a46d2b3c109ebf76412ebb0b75befbe5c60b76f5c11accd4f31cf6d81cc42324afc24a48c8fa262f4f69f01f77a3281c66919660862ab76e2a27414fdeaf3407af0c286821cca283fe8eced669c972aeff93d51c24c4cc50d2f42f5f742da3c01899c10cf9c691c7bf339724ef5bbae2bae8ec98d7b16254538d996cd1b71af11e7843148423c43627bc555d920575cee29a1a1b56eb82c686b5e45faacf8eb6bac68c41a616c3cccd2df9d7294a3b657dc5833c3c5abbe 您好, 这里需要密码.","tags":["公司","半年","见习期总结"],"categories":["公司","半年","见习期总结"]},{"title":"新年快乐","path":"/64c9b539/","content":"新年快乐 新年快乐“爆竹声中一岁除，春风送暖入屠苏。”在这里祝大家新年快乐、身体健康、工作顺利、万事如意、兔年吉祥！ 今年过年没有回家，家里寄来了很多肉，能让我安稳度过这短短七天假期了。现在网络这么发达，虽隔着千里万里，但不影响之间的交流沟通，不想家是不可能滴，下次要早早回家。 除夕吃团年饭、吃大餐，春节休息，初二又吃大餐，直到今天上班啦。说做了啥事没有，每天不就吃喝拉撒，要说有啥不一样的事吧，那就是初二晚上去电影院看了春节档上映的新电影-《满江红》，沈腾、张译、岳云鹏、雷佳音等主演，张艺谋导演。感觉拍的还是很不错滴，推荐。 满江红·写怀岳飞〔宋代〕怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，朝天阙。诗词节选 岳飞（1103年3月24日～1142年1月27日），男，字鹏举，相州汤阴（今河南省汤阴县）人。南宋时期抗金名将、军事家、战略家、民族英雄 、书法家、诗人，位列南宋“中兴四将”之首。岳飞从二十岁起，曾先后四次从军。自建炎二年（1128年）遇宗泽至绍兴十一年（1141年）止，先后参与、指挥大小战斗数百次。1142年1月，以莫须有的罪名，与长子岳云、部将张宪一同遇害。宋孝宗时，平反昭雪，改葬于西湖畔栖霞岭，追谥武穆，后又追谥忠武，封鄂王。岳飞是南宋最杰出的统帅，他重视人民抗金力量，缔造了“连结河朔”之谋，主张黄河以北的抗金义军和宋军互相配合，夹击金军，以收复失地。岳飞的文学才华也是将帅中少有的，他的不朽词作《满江红》，是千古传诵的爱国名篇。葬于西湖畔栖霞岭。","tags":["兔年","2023","满江红"],"categories":["兔年","2023","满江红"]},{"title":"Vue.js框架","path":"/e3779d93/","content":"Vue.js框架 Vue.js框架-莫渝新一、简介 二、发展历程 三、技术对比 四、应用场景 简介：渐进式JavaScript框架Vue 是一套用于构建用户界面的渐进式框架。 对渐进式的理解：每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求有强有弱，它的强势程度会影响在业务开发中的使用方式。 Vue的定位：我在做Vue的过程中也在不停地思考它的定位，他和其他框架的区别就是渐进式的想法，一步一步慢慢用，不是说你必须一竿子把所有的东西都用上。使用Vue，可以在原有大系统的上面，把一两个组件改用它实现。 发展历程框架出现尤雨溪：在我使用一些现有框架去完成一些特殊处理的时候发现这些框架并不能真正解决我的问题，第一个使用过的框架是Backbone，但这个更像是一个应用程序框架，它不会给你任何的视图互动管理；Angular在你的视图上提供了数据绑定和状态同步的同时，也它决定了你写代码的形式，不能更好的适应我们在做的项目，因为那些项目更多关注在交互的部分，而不是如何做一个应用，我开始想如何让自己的工作更有效率，然后就有了自己写一个框架的想法。一开始的目标就是去提供一个十分简单专注的工具，只是将一些DOM和JS对象同步，在这之后，我们开始扩充范围以及将更多的模块加入到生态系统，最终形成一个框架。我最开始是希望做一个让自己用的舒服的框架，当时把框架分享到GitHub的时候，大概有了几百个用户进行使用，当初发布这个框架并没有想着把它作为一个持续的项目，它更像是一个音乐家做一张专辑来玩玩，你发布这首曲子只是因为你享受制作它，并且希望其他人能够听到它，编写Vue.js就像我在创造一些人们真实在用的工具，而不是在做一些展示给上司看的工作。 经历阶段图 技术对比(Vue PK jQuery)底层差异一、虚拟DOM，文档对象模型（Dcoument Object Model） 二、数据驱动 三、事件驱动 四、MVVM 前面三种区别都无法直接体现出来，但是他们的目的都是为了提升数据传输和处理的速度。在这里就做过多的阐述。最能体现区别的是Vue的MVVM模型 图 M: 模型（Model）,对应data中的数据 V: 视图（view）:模板 VM:视图模型（ViewModel）vue实例对象 图 图 图图 应用场景(可行性探讨)实际生产问题讲解假设场景： 多端运行，Vue.js支持一套代码多端运行，Vue.js开发的项目，既有移动端又有pc端，但是移动端和pc端展示的内容不一样，同一个组件样式也不一样，移动端展示内容比pc端少，那这个时候在一个项目种怎么做的？ 两种办法： 1）一套资源，根据判断是否是移动设备而选择加载不同的CSS。 2）路由写两份，一份移动端的，一份pc端的，这两份路由地址相同，对应的组件不同，在路由的入口文件里去判断渲染pc的路由还是移动端的路由。 Vue.js与ECharts兼容性问题:Vue2.0中一般旧一些的脚手架Vue-cli版本会与echarts有不兼容问题导致echarts挂载不上init of undefined。 深度解析：echarts5.0多了.esm.js 文件，之前的版本是没有的，这是个特意给 ESM模块导入使用的。 解决办法： 1）旧版本代替。 2）使用命令import * as echarts from ‘echarts’ 建议学习Vue3.0：Vue3.0会解决诸多问题，例如封装echarts、方法deep:true、深度监听 实际生产中可尝试应用场景 二次开发、优化CIMS施工平台:目前的手机端业务是我们公司开发得比较少的一块，而能结合手机进行 开发基于Java + Vue微服务的三方兼容客户端:目前的手机端业务是我们公司开发得比较少的一块，而能结合手机进行 手机端业务、基于架构实现大数据平台:目前的手机端业务是我们公司开发得比较少的一块，而能结合手机进行","tags":["学习","前端","Vue"],"categories":["前端","Vue","学习"]},{"title":"Java的发展历史","path":"/dc3ed03/","content":"Java的发展历史 一1.Java的发展历史1.2 为什么叫Java20世纪90年代，单片式计算机系统诞生，单片式计算机系统不仅廉价，而且功能强大，使用它可以大幅度提升消费性电子产品的智能化程度。 1991年，Sun公司成立一个有詹姆斯.高斯林(James.Gosling)领导的名为Green项目。基于当时C++较为有优势但由于其过于复杂和庞大，决定在其基础上进行改造升级。于是Oak语言诞生（Java的前身），一开始是想要做高端互动交互式的电视机顶盒失败，没人投资，所以被并回Sun公司。过了两年1994年，Oak技术包括源代码全部免费公开，让当时的网页由静态转成动态，技术性的革新轰动一时。1995年，Oak注册登记时，发现名字被占用了，于是更名为Java。 1.3Java的标准划分 版本 描述 Java EE 企业版，适用于服务器，目前已成为企业运算、电子商务等领域的热门技术 Java SE Java 2 Standard Edition—标准版，适用于一般的计算机，开发PC机上的应用软件 Java ME Java 2 Micro Edition—微型版，适用于手持设备，进行应用开发，如手机游戏、名片管理等 1.4Java语言的特点及历史简单、面向对象、分布式、解释执行、鲁棒性、安全、体系结构中立、可移植性、高性能、多线程以及动态性。 版本 描述 1991年1月 Sun公司成立了Green项目小组,专攻智能家电的嵌入式控制系统 1991年2月 放弃C++,开发新语言，命名为“Oak” 1991年6月 James Gosling开发了Oak的解释器 1992年1月 Green完成了Green操作系统、Oak语言、类库等开发 1992年11月 Green计划转化成“First Person”，一个Sun公司的全资母公司 1993年2月 获得时代华纳的电视机顶盒交互系统的订单，于是开发的重心从家庭消费电子产品转到了电视盒机顶盒的相关平台上。 1994年6月 First Person公司倒闭，员工都合并到Sun公司。Live oak计划启动了，目标是使用Oak语言设计出一个操作系统。 1994年7月 第一个Java语言的Web浏览器WebRunner（后来改名为Hot Java），Oak更名为Java。 1994年10月 Van Hoff编写的Java编译器用于Java语言 1995年3月 在Sun World大会，Sun公司正式介绍了Java和Hot Java。 1996年1月 JDK1.0发布 1997年2月 J2SE1.1发布 1998年12月 J2SE1.2发布 1999年6月 发布Java的三个版本：J2SE、J2EE、J2ME 2000年5月 J2SE1.3发布 2001年9月 J2EE1.3发布 2002年2月 J2SE1.4发布 2004年9月 J2SE1.5发布，将J2SE1.5改名JavaSE5.0 2005年6月 JavaSE6.0发布,J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为JavaME 2006年12月 JRE6.0发布 2006年12月 JavaSE6发布 2009年12月 JavaEE6发布 2009年4月 Oracle收购Sun 2011年7月 JavaSE7发布 2014年3月 JavaSE8发布 2.Java的发展方向Java的更新速度快，每隔一段时间都会进行一次版本迭代以此来适应新技术的发展趋势。API稳定更新，复用性稳定强化，可实现跨平台操作，加上Java本身具有的很大的开放性和可扩展性，我相信一个语言只要不断发展，就很难被时代淘汰。 ​ 1、Java企业级应用开发 ​ 目前Java在许多行业的企业信息应用方面有很多，比如邮箱、物流、医疗、股票、金融等信息系统。这些和目前的主流行业密切相关，所以Java的开发者需求还是很大的。 ​ 2、Java网站建设 ​ Java的编程语言可以是网站的结构更加紧密，访问更加流畅，更能适应新的要求。虽然以目前的市场分析来看，Java做网站的成本太高，对硬件设备的要求也高，中小企业都会偏向于用PHP语言进行开发，但是在很多大企业中还是用Java语言的比较多。 ​ 3、ERP办公自动化 ​ ERP是企业资源计划，包含整个财务、生产、物流、人力资源等的一个整合的系统，ERP是一个很广泛的概念，所有行业所有企业的资源计划都统称ERP。同样也可以使用Java语言进行开发，使网站的结构更加稳定紧密。 ​ 4、Android应用开发 ​ Android是全球最大的智能手机操作系统，但在近几年快速兴起的小程序和H5的冲击下，导致Android原生开发门槛增高，公司对于Android开发工程师的要求也提高了，这就要求学习Android的程序员们技术精益求精。Android应用的主要开发语言就是java ​ 5、Java游戏开发 ​ Java同样可以用来编写游戏脚本，如Bean、Shell、Groovy等脚本语言可以方便、无缝和Java语言进行交互，这些极大地促进Java游戏编程。 二前言世界上并没有完美的程序，因为写程序本来就是一个不断追求完美的过程。同样没有一门语言在一诞生就是完美的，不变的唯有变化。Java诞生至今已经不仅仅是一门语言，背后所涵盖的是一个庞大的技术体系。 网上每隔一段时间就能见到几条“未来X语言将会取代Java”的新闻，此处“X”可以用Kotlin、Golang、Dart、JavaScript、Python等各种编程语言来代入。这大概就是长期占据编程语言榜单第一位的烦恼，天下第一总避免不了挑战者相伴。 在过去二十年Java的发展是孤独求败的，在未来，Java也在迎接着各种挑战，这种挑战来自云原生、容器化、也来自其他设计更完善的语言，相信身怀各种绝技的Java会焕发出更加夺目的光彩，重新攀登另一个高峰。 接下来的内容主要围绕Java、JavaWeb技术栈的发展之路。 Java发展史Java是在1991年由SUN公司的James Gosling（Java之父）及其团队所研发的一种编程语言，第一个版本耗时18个月，最开始命名为Oak（一种橡树）。Java现在广泛应用于各种大型互联网应用，其设计的最初动机主要是平台独立（即体系结构中立）语言的需要，可以嵌入到各种消费类电子设备（家用电器等），但市场反应不佳。 随着1990年代互联网的发展，SUN公司看到了Oak在互联网上的应用场景，在1995年更名为Java（印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名），随着互联网的崛起，Java逐渐称为重要的Web应用开发语言。Java的发展可以主要看JavaWeb的发展，Java也见证了互联网的发展过程。 发展至今，Java不仅是一门编程语言，还是一个由一系列计算机软件和规范组成的技术体系，Java 是几乎所有类型的网络应用程序的基础，也是开发和提供嵌入式和移动应用程序、游戏、基于 Web 的内容和企业软件的全球标准。 从笔记本电脑到数据中心，从游戏控制台到科学超级计算机，从手机到互联网，Java 无处不在！ 97% 的企业桌面运行 Java 美国有 89% 的桌面（或计算机）运行 Java 全球有 900 万 Java 开发人员 开发人员的头号选择 排名第一的部署平台 有 30 亿部移动电话运行 Java 100% 的蓝光盘播放器附带了 Java 有 50 亿张 Java 卡在使用 1.25 亿台 TV 设备运行 Java 前 5 个原始设备制造商均提供了 Java ME 数据来源：https://www.java.com/zh_CN&#x2F;about&#x2F; 说到Java自然离不开JDK、JVM、JRE，三者有什么关系。 JDK（Java Development Kit）Java开发工具包，包含Java语言、Java虚拟机、Java类库，是支持Java程序开发的最小环境。 JVM（Java Virtual Machine）Java虚拟机，运行于各种操作系统Linux，Windows，Solaris等之上，执行编译好的Java字节码class文件。 JRE（Java Runtime Environment）Java运行时环境，包含JavaSE中核心类库API和Java虚拟机，简单理解为JVM+核心类库API。 接下来主要围绕JDK的发展，和JVM中常见的GC收集器及算法描述。 JDK发展史 1991年4月，Java之父James Gosling带领绿色计划（Green Project）项目启动，定位于消费电子产品（机顶盒、冰箱、收音机）运行架构的Oak语言诞生，这也是Java的前身，但是市场反响一般。 1995年5月23日，随着互联网浪潮在1995年兴起，Oak迅速蜕，Java语言诞生，在SunWorld大会上发布Java1.0，第一次提出Write Once，Run Anywhere的口号。 1996年1月23日，JDK1.0发布，纯解释型的Java虚拟机（Sun Classic VM）、Applet、AWT等诞生。 1996年4月，十个最主要的操作系统和计算机供应商声明将在其产品中嵌入Java技术， 1996年5月底，Sun于美国旧金山举行了首届JavaOne大会，从此JavaOne成为全世界数百万Java开发者每年一度的技术盛会。 1996年9月，已有大约8.3万个网页应用了Java技术来制作。 1997年2月19日，Sun公司发布了JDK1.1，代表技术：JAR文件格式、JDBC、JavaBeans、RMI等，Java语法也进行了增强，内部类（Inner Class）和反射（Reflection）出现。 1998年12月4日，JDK1.2发布，这是一个里程碑式的重要版本，工程代号为Playground（竞技场），这个版本代表性技术非常多，如EJB、JavaPlug-in、Swing、JavaIDL等，还有使用极为频繁的Collections体系工具类等，并且这个版本中Java虚拟机第一次内置了JIT（Just In Time）即时编译器，后续还发布了JDK1.2.1和JDK1.2.2两个小版本升级。在JDK1.2中曾经共存过ClassicVM、HotSpotVM、ExactVM三个虚拟机，其中HotSpot是作为附加程序提供。也是在这个版本中Sun开始拆分对应的Java产品线，Sun在这个版本中把Java技术体系拆分为三个方向： 分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition） 面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition） 面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition） 1999年4月27日，HotSpot虚拟机诞生，HotSpot最初由Longview Techno-logies公司研发，后来在1997年被Sun公司收购，后来它成为JDK 1.3及之后所有JDK版本的默认Java虚拟机。 2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布。JDK 1.3的改进主要体现在Java类库上（如数学运算和新的Timer API等），此外一直作为扩展服务的JNDI服务也开始作为一项平台级服务被提供，还有基于CORBA IIOP协议来实现通信段RMI也出现了。 2001年5月17日，JDK1.3的修订版JDK1.3.1发布，工程代号Ladybird（瓢虫）。从JDK1.3开始，Sun公司维持着稳定的开发节奏，大概每个两年发布一个主要版本，期间发布的各个修订版本以昆虫作为工程代号。 2002年2月13日，JDK 1.4发布，工程代号为Merlin（灰背隼）。JDK 1.4是标志着Java真正走向成熟的一个版本。Compaq、SAS、Fujitsu、Symbian、IBM等一众大公司参与功能规划，甚至实现自己的独立发行版本。哪怕在二十年后的今天一些主流功能也可以在JDK1.4上运行，这个版本的主要代表技术包含正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器等等。 2002年9月16日，工程代号为Grasshopper（蚱蜢）的JDK1.4.1修订版发布。在这一年前后微软平台的.NET Framework发布，至此Java平台和.NET平台的竞争开始拉开了序幕。但似乎Java的开源策略更胜一筹，终于在2014 年 11 月 12 日，微软正式宣布了.NET Core 的开源。 2003年6月26日，工程代号为Mantis（螳螂）的JDK1.4.2修订版发布。 2004年9月30日，JDK 5发布，工程代号为Tiger（老虎），Sun公司从这个版本开始放弃JDK 1.x的命名方式，将产品版本号修改成了JDK x，JDK1.2以来Java语言在语法上的改动都不大，该版本在语法易用性上做出了非常大的改进，如自动装箱、泛型、动态注解、枚举、可变长参数、foreach等。此外改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包（由Doug Lea大师带Java进入了并发时代）等，JDK 5是官方声明可以支持Windows 9x操作系统的最后一个版本。 2006年11月13日，JavaOne大会上，Sun公司宣布计划要把Java开源，随后在一年多的时间内，陆续的将JDK各部分在GPL V2协议下公开源码，随后并建立了OpenJDK组织对这些源码进行独立管理，除了极少部分的产权代码，OpenJDK几乎拥有了SunJDK 7中的全部代码。 2006年12月11日，JDK6发布，工程代号为Mustang（野马）。在这个版本中，Sun公司终结了从JDK 1.2开始已经有八年历史的J2EE、J2SE、J2ME的产品线命名方式，启用Java EE 6、Java SE 6、Java ME 6的新命名来代替。在JDK 6中提供了众多改进，如通过Mozilla JavaScript Rhino引擎提供初步动态语言支持，提供编译器注解处理器（Annotation Processor这也是Lombok的原理，通过注解生成模板代码）和微型HTTP服务器API，以及对虚拟机内部锁、同垃圾收集、类加载机制等方面进行了大量优化改动。在JDK 6发布以后由于代码的复杂化，Java开源、开发JavaFx、世界经济危机以及Oracle对Sun的收购提案等原因，Sun公司内忧外患自顾不暇，原本稳定的开发进度也受到了很大的影响，使得JDK 6的生命周期也持续了很久，一共发布了211个更新补丁，最终版本为Java SE 6 Update 211，于2018年10月18日发布。 2009年2月19日，工程代号为Dolphin（海豚）的JDK 7发布，这是其第一个里程碑版本，按照规划，共有十个里程碑版本发布，最后一个里程碑版本发布与2010年9月9日，由于各种原因JDK 7没有按照原计划完成。JDK 7开发阶段Sun公司在技术竞争和商业竞争中都深陷泥潭，已经无力推动开发进展，为了尽快完成JDK 7的发布，因此裁掉了大部分原定的功能，对于原定的Lambdax项目、Jigsaw项目、动态语言支持、Gabage-First垃圾收集器、Coin项目只匆匆交付了处于Experimental状态的G1垃圾收集器（直到2012年4月的Update 4中才开始正式商用），其余项目延期到JDK 8中。Oracle从JDK 7开始进行接手，迅速展现出了其极具商业化的处世风格，面对Java中使用最广泛的Java SE免费产品线，定义了一套新的商业版产品Java SE Support ,此外JDK 7计划维护到2022年，已经面向付费用户发布了211个补丁，最新版本为JDK 7 Update 211。 2009年4月20日，Oracle宣布正式以74亿美元的价格收SUN公司，一代巨头由此没落，Java商标正式划归Oracle所有，Java语言本身并不属于哪间公司所有，它由JCP组织进行管理。此外Oracle还收购了BEA公司，JavaEE服务器Weblogic就是该公司的产品。 2011年7月28日，JDK7发布，做出的改进：提供新的G1收集器、加强对非Java语言的调用支持、可并行的类加载架构等。 2014年3月18日，Oracle公司发布JDK 8，从此使用JEP（JDK Enhancement Proposals）来定义和管理纳入新版JDK发布范围的功能特性，JDK 8中实现了JDK7中定义并且未完成的功能，其中也有被延期到JDK 9的Jigsaw模块化功能。 JEP 126 Lambda函数表达式支持 JEP 104 内置Nashorn JavaScript引擎 JEP 150 新的时间日期API JEP 122 移除HotSpt永久代 2017年9月21日，Oracle公司发表 JDK 9，这其中较为显著的功能就是在JDK 7时期已经规划的Jigsaw模块化功能，为何屡次发布都未能如约而至，前期可能是技术埋坑，后面遭到了以IBM和RedHat联合的等JCP委员抵抗，否决模块化提案，这种做法无疑是革了模块化支持本身就比较好的IBM的命，面对如此抵抗，Oracle丝毫没有退让，宁愿摒弃JSR独立研发，也要推行Jigsaw的发展，如果成真，想必Java也会面临如Python2和Python3的巨大不同，好在最终达成一直协议，Java还是那个完整的Java。JDK 9还提供了JS Shell、JLink、JHSDB等增强。JDK 9之后，Java也以更加敏捷的交付方式如期而至，每年的3月和9月发布一个版本，美6个月发布一个版本，每三年一个LTS版本，目的是避免众多功能交付在一个捆绑JDK的风险，并且提出了孵化器模块（Incubator）和预览特性（Preview）两个概念。也是在这个版本中CMS开始被废弃。 2018年3月20日，Oracle公司发布JDK 10,主要对内部进行重构，统一源仓库，统一垃圾收集器接口，统一即时编译器接口（引入Graal几时编译器，这里也埋下一个伏笔），这些改进对于用户并不明显，但对后期的版本打下了良好的基础。 2018年3月，同样发生了比较重要的一件事，Oracle正式宣布Java EE成为历史名称，曾经拥有着无数光辉的Java EE产品线（至今仍使用较为广泛的JDBC、JMS、Servlet等组件）被Oracle扫地出门，全部打包赠送给Eclipse基金会，并且不能使用Java商标，并且更名为Jakarta EE。 2018年10月，自1996年以来每年一度的已经举办了22年的JavaOne大会，没有人预测到这也是最后一届，同年6月Java Mission Control的开发团队也被Oracle解散。 2018年9月25日，JDK 11发布，这也是一个LTS（long-term support）版本，包含17个JEP，同时被引入的还有ZGC这样革命性的垃圾收集器，好比G1的诞生，比G1又更具神秘感。同时Oracle也调整了JDK的授权许可证，把以前的商业许可证授权给OpenJDK，官方宣布同时发布两个JDK，一个是Oracle OpenJDK，一个是OracleJDK，共享大部分源码近乎一致，个人均可免费使用，OpenJDK有半年的更新支持，OracleJDK商用必须付费，且支持三年的更新。因此Java收费纯属谣言，商业用户如果想使用最新的版本支持就必须付费。 2019年3月20日，JDK 12发布，RedHat接手了OpenJDK 8和OpenJDk 11的管理和维护权。在JDK 12中包含了8个JEP，主要有Switch表达式和JMH测试套件，最引人注目的就是Shenandoah垃圾收集器，作为首个在JDK 7以后非Oracle开发的垃圾收集器，其目标与ZGC一致，这种竞争关系，立马得到了Oracle的抵制，在OracleJDK中剔除代码，因此Oracle JDK和OpenJDK的隔离性又如历史在JDK9中开始重演，至于后续Java的发展，以及迎接的挑战也是任重而道远，这取决于Oracle的产品线的定制和JCP的决策了。 2019年在9月17日，JDK 13发布，这个版本主要通过改善Java SE平台和JDK的性能，稳定性和安全性来提高开发人员的生产力。共包含了5个JEPs和一个Unicode 12.1的支持总共6大主要新特性。 Support for Unicode 12.1 java.lang.Character支持Unicode Character12.1库，相比12.0库新增554个字符。 JEP 351: ZGC Uncommit Unused Memory ZGC增强了对未使用堆内存返还操作系统的能力，ZGC对堆内存的控制能力也从4TB提升至16TB，这个版本对ZGC进行了性能的增强。 JEP 350: Dynamic CDS Archiving 动态归档能力，HostSpotVM对AppCDS的一个增强。 JEP 354: Switch Expressions (Preview)switch表达式的引入，在后面的JDK 17中又继续对其功能进行了增强。 JEP 355: Text Blocks (Preview)增加了Java语言对文本块的支持，但这只是作为一个预览性质的功能，通过””” “””来放置多行代码。 JEP 353: Reimplement the Legacy Socket API 重新实现了java.net.Socket and java.net.ServerSocket 类提供的APIs。 2020年3月17日，JDK 14发布，这个版本主要是对JDK历史版本的一些增强，也引入了一些新增的功能. JEP 359: Records (Preview) 新增了java.lang.Record类，Record是一种轻量级的class，可以看做是数据结构体。Java作为面向对象的语言诞生以来，在大型项目中的优势就体现出来了，但是也有一点不好，过于繁琐，一个POJO JavaBean必须包含get、set等方法，Record主要就是解决这类问题的，类似于Lombok的功能。 JEP 365: ZGC on Windows JEP 364: ZGC on macOS JEP 345: NUMA-Aware Memory Allocation for G1 G1的NUMA感知内存分配。这样可以提高使用非均匀内存体系结构（NUMA）的大型计算机的性能。 JEP 349: JFR Event Streaming 通过启用工具以异步方式订阅Java Flight Recorder事件，这可以对JVM进行更实时的监视。 JEP 363: Remove the Concurrent Mark and Sweep (CMS) Garbage Collector，CMS作为一款主打老年代的并发垃圾收集器，虽然历任JDK中都没有被设置为默认的垃圾收集器，但是在解决STW问题时也是有着举足轻重的地位的，从JDK 7开始筹备到JDK 9作为默认的G1垃圾收集器，一度被认为CMS的升级版，在次CMS也开始走下历史舞台。 JEP 366: Deprecate the ParallelScavenge + SerialOld GC Combination 随着每一代JDk中对垃圾收集器的升级以及新的垃圾收集器的引入，ParallelScavenge + SerialOld（Oracle指出很少有人使用）组合的GC也被弃用了，并在不久的将来被移除，完成了自己的历史使命。 2020年9月15日，JDK 15发布，按照规划路线，JDK 14也停止更新，JDK 15虽然不是LTS版本，但也引入了一些开创性的功能和对早期版本功能的一些优化。 JEP 371: Hidden Classes， JEP 378: Text Blocks，在JDK 13已经发布的二次预览版本，对于文本块的支持非常友好。 JEP 377: ZGC A Scalable Low-Latency Garbage Collector (Production)，这个支持应该算是比较重要的，相比于JDK 11作为实验性质而引入的ZGC，在这两年中ZGC现在已准备好用于生产，不再标记为实验特征，可以直接使用 -XX:+UseZGC开启ZGC，不再需要XX:+UnlockExperimentalVMOptions额外的配置。需要注意的是在OracleJDK中使用的是ZGC，而在OpenJDK中使用的是Shenandoah GC，使用命令-XX:+UseShenandoahGC开启。 2021年3月16日，JDK 16发布，这部分依旧是一些功能的优化升级。 JEP 389: Foreign Linker API (Incubator)提供静态键入的纯-java访问本机代码的API。 JEP 393: Foreign-Memory Access API (Third Incubator)提供了操作外部内存能力的API。 JEP 380: Unix domain sockets java.nio.channels, SocketChannel和ServerSocketChannel新增了对UNIX套接字的支持。 JEP 338: Vector API (Incubator) 提供孵化器模块的初始迭代，JDK.INCUBATOR.Vector，以表达在运行时可靠地编译的向量计算到支持的CPU架构上的最佳矢量硬件指令，从而实现对等效标量计算的卓越性能。这一点在JDK 17上持续增强。 JEP 376: ZGC Concurrent Stack Processing，ZGC的并发标记，不同于CMS的标记，ZGC的标记只有三个阶段，且每一个阶段的操作，无论是标记还是清理都是并发操作，大大降低了STW的时间，几乎零延时。这也算是Java在垃圾回收中比较开创性的变革。 JEP 387: Elastic Metaspace，JDK16对元数据区切分为更小的内存块，并将不再使用的内存快速返还给操作系统，对于频繁加载和卸载类的应用来说这一优化可以产生大量的空闲内存，提升整个JVM的性能。 JEP 397: Sealed Classes (Second Preview)，对JDK内部方法提供强制的封装，在JDK 17依然进行了升级优化。 JEP 395: Records，从JDK 14作为预览版被提供在，这里已经升级为正式版功能。 JEP 392: Packaging Tool，新的打包工具，在JDK 14中通过JEP343被提案，在JDK 15中被孵化，在JDK 16中被提升为正式支持使用，通过jpackage命令支持native可执行程序打包。 2021年9月14日，JDK17发布，这也是在JDK 11之后的下一个LTS版本，JDK 17也是Java六个月发布节奏下的最新的长期支持（LTS）发布，主打安全、性能、稳定为特性，并且官方计划支持到2029年9月。在这个版本中包含了14个JEPs更新。 JEP 356: Enhanced Pseudo-Random Number Generator 伪随机数增强器 JEP 391: macOS AArch64 Port 新平台的支持 JEP 410: Remove the Experimental AOT and JIT Compiler 移除了实验性质的AOT和JIT编译器 JEP 411: Deprecate the Security Manager for Removal 弃用安全管理器 JEP 406: Pattern Matching for switch (Preview) switch表达式，这可能是一个让switch翻身的功能。 JEP 412: Foreign Function and Memory API (Incubator) 外函数和内存相关的API，在JDK 14和JDK 15中引入的孵化API，使Java程序能够与Java运行时之外的代码和数据互操作，通过有效地调用外部函数（即，JVM之外的代码），并通过安全访问异物，这些API使Java程序能够调用本机库并进入本机数据而不提供Java本机接口（JNI）的脆性和复杂性。 JEP 414: Vector API (Second Incubator)允许表达在运行时可靠地编译的向量计算以支持的CPU架构上的优化矢量指令，从而实现优于等效标量计算的性能 更多JEP：JEPs 更多JDK版本变更信息：JDK Release Notes JVM家族 JDK 1.0，1996年引入Sun Classic VM，虚拟机鼻祖，世界上第一款商用Java虚拟机。 JDK 1.2，Solaris平台发布Exact VM，已经初具现代高性能虚拟机雏形，出现热点探测、即时编译等。但是生命周期短暂，这一时期并存Sun Classic VM、Exact VM、HotSpot VM，可通过命令切换。 JDK 1.3，HotSpot VM成为默认选择，Exact VM依然为备用选择。 JDK 1.4，Classic VM才完全退出商用虚拟机的历史舞台，与Exact VM一起进入了Sun Labs Research VM之中。HotSpot继承了Sun公司两款虚拟机的优点，自此之后HotSpot VM也一直成为OracleJDK和OpenJDK中默认的虚拟机。得益于Sun和Oracle两大巨头在不同时期的影响力，HotSpot也成为了使用最为广泛的虚拟机。 Mobile&#x2F;Embedded VM，这是一款面向JavaME产品线的虚拟机。主打移动端和嵌入式设备市场。只留下了客户端编译器（C1），去掉了服务端编译器（C2）；只保留Serial&#x2F;Serial Old垃圾收集器，去掉了其他收集器等，是一款小家碧玉型产品。 BEA JRockit，号称最快的虚拟机，天下武功唯快不破，当然也有可能每一家都这么宣传，后来BEA公司也被Oracle收购，由于其设计架构与HotSpot大相径庭，因此只有少部分监控相关的优势被吸纳进去，天下武功，九九归一。 IBM J9，内部名称曾定义为IT4J（IBM Technology for Java Virtual Machine）,太长的名字，因此也看出名字的重要性，至今仍然活跃，与之对应的是可以更好的兼容在IBM的小型机运行平台，模块化也是其显著的优势和特点，因此可以按需启用，消耗较小的资源，提供更大的优势。 BEA LiquidVM&#x2F;Azul VM 相比于大名鼎鼎的HotSpot、JRockit、J9等通用型的多平台兼容的JVM，还有一种与特定平台，硬件绑定的专有化虚拟机，BEA的Liquid VM不需要依托于其他操作系统，本身就已经系统化，直接运行在自家Hypervisor系统上。Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于自家专有硬件Vega上的虚拟机，可以管理大量的CPU和内存，使用的是有名的PGC和C4收集器。随着业务线的调整，2010年，Azul转型软件业务，把全部精力投入到Zing（以软件的方式达到接近Vega系统的虚拟机）的研发中，而HotSpot在JDK 11和JDK 12中的ZGC和Shenandoah也才达到同等目标，JVM的发展竞争也渐激烈。 除了上面提到的使用广泛或者名气比较大的商用虚拟机外，也存在一些对整个Java虚拟机产生深渊影响的产品。 Apache Harmony，Harmony中的DRLVM，这是一个兼容JDK 5和JDK 6的平台，可以运行Eclipse、Tomcat、Maven等程序，一直没有获取TCK授权，在Oracle收购Sun之后，Apache一度退出JCP组织，这也是Java社区历史上最为割裂的一件事。直到OpenJDK的诞生，Harmony的优势被极大的抵消，项目的最大参与者IBM也宣布退出，虽然Harmony从诞生起就没有大规模商用，但是Harmony的代码被吸收进IBM的JDK 7和Google Android SDK，这也对Android的发展产生了深远影响，似乎某种程度圆了Java诞生之初Sun就设定的路线，主打移动端的嵌入式设备路线。 Microsoft JVM，可曾想到微软当初也设计过自己的Java虚拟机，但被Sun以侵权告退，并且终止了Java虚拟机的研发，也许正因如此才诞生了.NET平台，能让你强大的永远是你的对手，微软也在一次证明了自己的强大。 Java虚拟机的发展也进入到一种百花齐放，百家争鸣的局面，除了大规模的服务器级别的虚拟机外，也存在一些小型的虚拟机平台。 KVM，Android、IOS等智能手机操作系统出现前广泛使用的手机平台。 JCVM，Java虚拟机的一个子集，如智能卡，SIM卡，信用卡等，通常用作加密模块。 Squawk VM，由Sun开发曾用于Java Card的嵌入式虚拟机实现。 JavaInJava，Sun公司开发的一个实验性质的虚拟机，通过元循环证明一门语言可以自举，通过Java来实现Java语言的运行环境，没有编译器，通过解释模式来运行。 Maxine VM，一个类似于JavaInJava的产品，效率跟高，接近于HotSpot。 Jikes RVM，由IBM研发的一个实验性质的项目，类似于JavaInJava。 http://IKVM.NET，基于.NET平台实现的Java虚拟机，通过Mono实现了一定的跨平台能力。 Java经过了这么多年的发展，经历过公司更替，经历过组织割裂，沧海桑田，都使其走了过来，在互联网快速发展的今天，这是一个最好的时代，也是一个最坏的时代，挑战与机遇并存，Oracle公司推出的Graal VM也被官方称为Universal VM，这也是未来最有可能替代HotSpot VM的产品，也将承担起Java迎接更大的挑战。 GC算法Java语言最大的优势就是垃圾自动回收，不需要开发者去关心内存管理的事情，可以专注于业务逻辑开发。内存自动回收的核心GC算法，每一种GC都是基于不同的算法理论来实现的，因此算法对GC的性能、回收等都起着至关重要的作用。GC算法之间没有好坏之分，只有适合或不适合，每一个GC算法也不是一蹴而就的，是经过无数的迭代改进诞生的。 引用计数算法，这个算法的原理很简单，在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。但是在主流的垃圾收集器中都没有使用过这种算法，当出现两个对象之间互相引用，但是这两个对象又没有实际被使用的场景，会导致引用计数都不能清零，成为无法回收的垃圾。 可达性分析算法，这是主流虚拟机都在使用的一种垃圾回收算法，通过一些GC Roots来向下搜索，形成一个个引用链，如果某个对象没有到达GC Roots的引用链，那么就判定这个对象可回收，也就解决了引用计数算法里面判定的问题。因此也定义了一些常见的GC Roots。 虚拟机栈（栈帧中的本地变量表）中引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 标记-清除算法，Mark-Sweep，算法分为标记清除两阶段，首先对需要回收的对象进行统一标记，在标记结束后，统一回收，也可以统一标记存活对象，统一回收未标记对象。这个算法是最基础的，但是也有很多问题，比如大量的标记和清除，会导致两个阶段的效率都不同程度的降低，其次是标记清除后空间的不连续性，不利于大对象的分布，并由此触发下一次GC。 标记-复制算法，Semispace-Copying，使用的是半区复制的思路，与清除所不一样的是，复制算法，将新生代既定内存区域按照1:1分为两部分，把存活对象迁移至其中一个半区，然后清理已使用过的空间，这种算法复制过程通过指针移动来实现，因此带来的开销是内存空间开销，会消耗大量的内存。从某种程度上标记-复制解决了标记-清理在处理大量可回收对象时遇到的效率问题，但是空间消耗是其要面对的另一个问题。因此对于这种情况，考虑到大部分场景的对象都是朝生夕灭，存活周期较短，将新生代按照比例1:8划分为Survivor:Eden区，Survivor又划分为From和To两个区域，每次分配内存只使用Eden和其中一块Survivor（From）。发生垃圾收集时，将Eden和Survivor（From）中仍然存活的对象一次性复制到另外一块Survivor(To)空间上，然后直接清理掉Eden和已用过的那块Survivor（From）空间，清空后存在一个From-&gt;To的转变，出现From和To的角色互换，总是保证在发生GC之前保证To区域是空闲的。当Survivor不足以承担一次MinorGC时就需要通过分配担保（Handle Promotion）机制来将一些对象迁移到老年代。 标记-整理算法，Mark-Compact，相当于是标记-清除，标记-复制算法的优势整合，标记阶段通标记-清除算法的标记阶段一致，但是在标记结束后不直接清理，而是让存活对象向内存空间另一端移动，这点类似于复制的处理。标记-整理算法是建立在是否移动回收后的存活对象这个风险点之上的，移动对象会加大延迟，STW现象(Stop-The-World:执行垃圾收集算法时,Java应用程序的其他所有线程 (除了垃圾收集线程之外的线程)都被挂起)更为显著，但是带来的好处是移动对象后整片的内存区域可以提高吞吐量，因此在HotSpot VM中关注吞吐量的Parallel Scavenge GC是基于标记-整理算法实现的，关注延迟的CMS是基于标记-清除算法实现的。 垃圾收集器在《Java虚拟机规范》中并没有规定垃圾应该如何回收，只是提出了这样一种理论，因此不同的厂商也有不同的实现方式，在众多的JVM中也存在着形形色色的GC，在此主要说的也是HotSpot VM中出现过的垃圾收集器。在JDK 7之前也就是G1出现之前，垃圾收集器是分代收集的按照新生代和老年代有不同的GC来进行内存回收，在G1之后出现的GC基本都是面向全堆栈回收，因此也可以对GC做不同的分类。 新生代GC Serial GC，这是最基础也是历史最悠久的收集器，在JDK 1.3.1之前，HotSpot中新生代唯一的收集器选择，在进行收集的时候会暂停所有工作线程直到收集结束，由于其单线程模式，也导致了STW时间过长，用户应用处于长时间假死状态，非常影响用户体验。但也是所有收集器中内存资源消耗最少的，在单核或者核心较小的服务器环境，也能体现出其特有的优势。在客户端模式下是一个不错的选择。 ParNew GC，实质上是Serial的多线程版本，除了在收集垃圾采用多线程并行收集外，其他地方与Serial并无较多差异，是不少在服务端模式下运行的虚拟机的首选新生代收集器。除了Serial，只有ParNew可以用CMS配合使用。 Parallel Scavenge GC，基于标记复制算法实现的收集器，其目标在于达到一个可控制的吞吐量（处理器用于运行用户代码时间与处理器总消耗时间的比值），良好的响应速度可以提高用户体验，高吞吐量可以最高效率的利用处理器资源，尽快完成运算任务，适合运算多而交互少的分析任务。 老年代GC Serial Old GC，相对于Serial收集器，Serial Old专用于处理老年代GC，使用标记整理算法，主要也是在客户端模式下使用，如果在服务端模式下，在JDK 1.5之前与Parallel Scavenge配合使用，或者作为CMS失败后的预案，在Concurrent Mode Failure时使用。 Parallel Old GC，PArallel Old是Parallel Scavenge的老年代版本，基于标记整理算法，支持多线程并发收集，在JDK 6提供，在Parallel Old出现之前，Parallel Scvenge只能和Serial Old搭配使用，比较尴尬，CMS无法与之配合，而Serial Old又不适合服务端模式，因此在此之前使用较多的也是ParNew + CMS组合。在吞吐量优先的场景中，PS + PO的组合实至名归。 CMS GC，JDK 5推出的一个划时代意义的收集器，首款真正做到了并发收集的垃圾收集器，实现了垃圾收集线程与用户线程同时运行。无法与Parallel Scavenge配合工作，因此CMS的出现也巩固了ParNew的地位。CMS使用了标记清除算法，一般分为四个阶段，初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清除，由于初始标记和并发标记的存在，大大减小了STW的时间，但是CMS无法很好的处理浮动垃圾（并发清理阶段，用户线程产生的垃圾，无法被及时清除，保留在下一个GC阶段），为了处理浮动垃圾，CMS需要老年代预留一部分内存，通过设定的阈值来确定GC的时机。CMS也是在一次次不完美的过程中尝试完美。 G1 GC，G1在JDK 7中进入Experimental状态，在JDK 8中日趋成熟，在JDK 9中开始正式成为HotSpot的默认GC，替代了服务端主打的PS + PO组合收集器，此后也在Oracle官方被称为全功能垃圾收集器（Full-Featured Garbage Collector）,主要面向服务端。G1是垃圾收集器发展史上具有里程碑式的成果，开创了面向局部收集的设计，每一个Region都可以扮演新生代的Eden、Survivor或者老年代空间。 低延迟垃圾收集器（衡量指标：内存占用、吞吐量、延迟） Shenandoah GC，第一款不是Sun或者Oracle设计的GC，甚至在OracleJDK 12中被明确拒绝的GC，因此只能存在与OpenJDK中，开源比收费的功能反而更多。相比于G1更像是G1的继承者，多线程Full GC的支持、类似于Region的设计有着优于G1的更多设计，都是为了降低延迟。 Z GC，JDK 11开始加入的GC，与Shenandoah目标类似，但设计思路又大有不同，Shenandoah更类似于G1的延伸，ZGC更像Azul公司PGC和C4的复刻。ZGC使用染色指针技术来作为其标志性的并发整理算法实现，支持更大的内存管理和更高效的垃圾收集。 Epsilon GC，JDK 11中依然出现了一个实验性质的GC，不能够进行垃圾收集的垃圾收集器，相比于G1、Shenandoah、ZGC复杂的垃圾收集算法和设计实现，Epsilon有点反其道而行之的意味，事实上一个GC的功能不仅仅是回收这个动作，还要负责堆管理布局，对象分配以及与解释器的协同工作等，如果在某些不需要回收仍然可以正常运行的Java虚拟机系统中Epsilon似乎是一种更好的选择。解决问题的方式固然重要，处理问题的思路也很重要。 之所以存在这么多的垃圾收集器，也就说明了没有一个完美的GC来适应所有场景，因此面对不同的场景，分代收集和全堆栈收集也给JVM调优指明了思路，了解不同GC的设计特点，才能更好的选择。 无论是JDK、GC、GC算法哪一个时间线，都可以无限的延伸下去，不是三言两语可以解释清楚的。这里也仅仅介绍梳理了一下发展过程，在JVM不断的演变之中，一些传统的认知也在被更替，比如所谓的Java中对象是在堆内存分配，随着逃逸分析，栈上分配，标量替换等更先进的技术发展出以后，Java中对象的分配也不是一成不变的，是按照具体的情况来分配的。 JavaWeb发展Java发展最为广泛的就是在互联网领域，这其中既包含了官方对于Web方向发展的一些规范及实现，也有非常出色的产品，如体系庞大且上手友好的Spring，也有小而美的JFinal、Vert.x等，未来将是云原生，提倡Serverless无服务模式的，Java无论是JDK层面还是GC、Web框架层面也涌现了一批优秀的框架，正在跃跃欲试，如Spring Native、Spring WebFlux、RedHat Quarkus、Eclipse MicroProfile、Oracle Helidon等反应式、云原生框架，去打造一个全新的轻量级微服务时代。 JavaEE在Java的三条产品线中发展的最好的无疑是JavaSE，但是使用最为广泛的当属JavaEE（Java Platform, Enterprise Edition）。发展至今，JavaEE 提供了一个丰富的企业软件平台，拥有超过20 种符合 Java EE的实现。 Java EE 是利用 Java Community Process 开发的，业界专家、商业组织和开源组织、Java 用户组以及数不清的个人为此做出了巨大贡献。每个版本都集成了符合业界需求的新特性，提高了应用可移植性，提高了开发人员的工作效率。 JavaEE定义了十三种常用的核心技术规范。 JDBC：Java Database Connectivity，定义了Java程序如何和数据库建立连接的接口规范。 JNDI：Java Naming and Directory Interface，相当于一个目录服务，关联服务名称与服务对象，通过名称来直接访问与其关联的对象，譬如将数据源通过名称与数据源对象绑定。 EJB：Enterprise JavaBean，构建企业级应用服务的一套体系，是一个体系庞大的规范，经历了1.0，2.0，3.0的阶段。 RMI：Remote Method Invocation，RMI协议能够让在某个Java虚拟机上的对象，像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它使用了序列化方式在客户端和服务器端传送数据。 Servlet：Server Applet，Servlet是一种小型的Java程序，它扩展了Web服务器的功能。作为一种服务器端的应用，当被请求时开始执行。如常用的Tomcat就是一种实现了Servlet的Web容器。 JSP：Java Server Pages，其本质也是Servlet，相比于Servlet处理用户请求，JSP侧重于视图层的渲染，提高了通过Servlet输出HTML DOM的效率。 XML：EXtensible Markup Language，XML是一种用于标记电子文件使其具有结构性的标记语言。它被用来共享数据。XML的发展和Java是相互独立的，但是它和Java有着相同的目标，即平台独立性。通过Java和XML的组合，可以得到一个完美的具有平台独立性的解决方案。 JMS：Java Message Service，JMS是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。ActiveMQ就是完全实现了JMS规范的消息队列。 Java IDL：Java Interface Description Language，IDL是用来描述软件组件接口的一种计算机语言。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。 JTS：Java Transaction Service，JTS是一个组件事务监视器。JTS是CORBA OTS事务监控的基本实现。JTS规定了事务管理器的实现方式。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。。 JTA：Java Transaction API，Java的事务API，原则上事务一般基于数据库来实现，但是JTA为JavaEE平台提供了分布式事务服务，它隔离了事务与底层的资源，实现了透明的事务管理方式，如Seat。 JavaMail：JavaMail是用于存取邮件服务器的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器和POP服务器。 JAF：JavaBean Activation Framework，JavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成Java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF。 更多的JavaEE规范：https://www.oracle.com/cn/java/technologies/java-ee-glance.html Java™ EE 平台文档 Java EE 8 文档 Java EE 7 及早期版本 API 文档 Java EE 8 Java EE 7 Java EE 6 Java EE 5 规范 Java EE 8 Java EE 7 Java EE 6 Java EE 5 基于JavaEE的框架由Sun公司发起的有EJB、JPA等，这些框架在设计初期，考虑到的规范众多，难于上手，因此没有很好的市场效应，EJB经历了1.0、2.0、3.0版本的大迭代，尤其是EJB3.0和之前的产品差异巨大，而JPA也被Hibernate一统持久化框架市场，做到了ORM领域的顶流产品。 SpringJava诞生于1995年，赶上了互联网发展的浪潮，但Spring并不是伴随着Java产生的，因此在前近十年没有Spring的阶段，Java Web的开发也度过了一个黑暗漫长的阶段。Spring 由 Rod Johnson 创立，2004 年发布了 Spring 框架的第一版，其目的是用于简化企业级应用程序开发的难度和周期。 Spring使得Java开发变得更为简单，可以快速的构建出一个Java企业级应用，而且支撑对市面上大多数的Java框架的整合，正如其名，给Java程序员带来了春天，几乎人人都是Spring程序员。Spring特性可以概括为以下几点。 Spring is everywhere Spring is flexible Spring is productive Spring is fast Spring is secure Spring is supportive Spring是主打B&#x2F;S架构的Java一站式企业级开发框架。每一个技术的出现不是一蹴而就的是经过一步步的演变而来的，Spring并不能见证Java Web的整个发展过程，但是重要的统一集大成者。这里主要介绍在Spring诞生前后以及目前Java Web开发过程中主要的技术栈体系发展过程。 远古时代（无Spring或者同类框架） 静态网页：代表技术包括XML、HTML、XSLT等。1994 年，网景公司发布了 Navigator 浏览器，早期的网站不能和用户交互，只能用来展示一些信息。 Servlet：Servlet是Service Applet的简称，可以用来处理用户请求，并且输出返回结果到页面可以实现用户和网站的交互功能。Servlet也在不同时期的JavaEE规范中不断完善。 JSP：全称为Java Server Pages，Sun公司借鉴微软的asp作为Java Web应用的视图层，其本质仍为Servlet，但是区别在于JSP更加专注于视图渲染。 Model1：通过JSP、JavaBean来实现，已经对代码进行了简单的分层，JSP可以直接编写HTML DOM和JavaScript代码，并且借助el和jstl表达式直接获取到9大内置对象的值，使得前后端之间的交互更为灵活，但是大量的前后端代码耦合使得后期维护异常困难，需要开发人员同时熟悉前后端技术，对开发人员要求较高。 Model2：通过JSP、JavaBean、Servlet来实现，已经具有MVC分层概念了JSP作为V，JavaBean作为M，Servlet作为C，实现了代码的解耦，更加易于扩展。这里要区分三层（业务逻辑层、数据持久化层和表现层）架构与MVC，不能混为一谈，表现层又分为模型、视图和控制器，对应MVC。 Struts1&#x2F;XWork&#x2F;WebWork：这几个之所以放到一块，是因为有很多相似的地方，这是比较早期的控制层框架了，WebWork建立在xWork之上，Struts1与Servlet API耦合较深，表现层技术单一，WebWork已经支持更多的视图层技术，如FreeMarker和XSLT，并且可以通过OGNL表达式访问栈值。 Struts2：Apache赞助的 一个开源项目，整合Struts1、WebWork优势，Struts2采用了WebWork的设计核心，使用拦截器来处理用户请求，从而允许用户的业务逻辑控制器与Servlet API分离，达到深层解耦的目的，Struts2控制器组件是Struts2框架的核心，所有MVC框架都是由控制器组件为核心的。Struts2的控制器由FilterDispatcher和业务控制器Action两部分组成，每一个用户拦截器通过继承实现。 Hibernate诞生在2001年11月，一个基于JPA规范的ORM框架，让程序员只关心对象之间的关联关系，忽略SQL语句，自动生成相关的SQL，因其上手难度高，功能体系庞大，在发展过程中逐渐被半自动ORM框架Mybatis（早期名称ibatis）占据了一部分市场，至此Java的开发已经逐步进入框架时代，等待着Spring带来的大一统时代。 Spring时代（进入人人都是Spring程序员时代） SSH：指的是以Spring、Struts2、Hibernate为核心技术栈的web应用技术框架，也可以继续借助Spring强大的整合能力来引入第三方依赖框架。 SSM：指的是以Spring，SpringMVC，Mybatis为核心技术体系的Web应用技术栈。相比于SSH框架，无论是Struts2的设计，基于类的请求拦截，还是全ORM映射的Hibernate，这些元素都过于重量，不适合瞬息万变的互联网环境，需要更加建议轻量级的实现方式来替代，因此诞生了SSM，SpringMVC有着Spring的天然优越性，SpringMVC容器是Spring容器的子容器，子容器可以共享父容器的Bean，并且基于方法的SpringMVC缓存在处理大量并发请求的场景下更具有优势，Mybatis更加是和复杂查询场景，而实际业务场景中也是如此，这也降低了使用Hibernate的门槛成本。 Spring Boot：即便SSM已经简化了在Struts2和Hibernate中复杂的配置关系，但是传统的Web项目依然存在大量的配置项，从web.xml到applicationContext.xml，再到SpringMVC等第三方xml，依然需要大量配置，仍有一定的学习成本，SpringBoot简化配置，根据常用的开发经验，简化maven依赖（即spring-boot-starter-和-spring-boot-starter），总结了一套体系化配置参数，约定大于配置（即application.properties和application.yml），并且内置Tomcat（SpringBoot2.x中已经切换到了undertow，拥有更高的并发处理能力）真正做到了一键启动。 Spring Cloud NetFlix：基于Spring Boot强大的配置能力，传统项目在处理一个业务复杂的系统时候，体量巨大，不便于需求迭代和业务开发，牵一发而动全身，部署应用时也需要更大的内存、CPU等资源消耗，因此可以对一个复杂的项目进行拆分，在业务场景上做到服务分治，在技术方案中利用Spring Boot快速构建，相得益彰，Spring Cloud诞生了。Spring Cloud并不特指某个具体的技术，而是一系列现有成熟技术的整合，官方的解释就是SpringBoot构建一切，Spring Cloud协调一切。Spring Cloud NetFlix是由NetFlix公司开源的一套微服务组件库，包含常见的微服务组件。 Eureka 基于AP的服务发现 Zuul 网关组件 Hystrix 熔断、限流组件 Ribbon 负载均衡 Feign 远程调用 Zipkin 链路追踪 Config 配置中心 随着微服务的发展，这些组件也许不是最好的解决方案，但是依然是一套完善的生态体系，可以应对大部分的业务场景。 Spring Cloud AliBaba：同样提供了一站式的分布式应用解决方案，属于现在比较热门，先进的微服务解决方案，基于微服务的思想，提供了更好用的组件库，常见组件包含。 Nacos 整合服务发现和配置中心，支持AP和CP场景 Sentinel 哨兵，更为优越的限流解决方案 更多基于Spring Cloud的微服务解决方案，当然也有其他的微服务解决方案，比如k8s本身就可以作为微服务解决方案，还有Zero Ice，Apache ServiceComb等。 未来发展 展望未来（以容器化、云原生、反应式为关键特征） Quarkus Spring Native kubernetes 随着容器化技术Docker、Kubernetes，让云原生似乎成为了未来的发展方向，云原生（Cloud-Native）这个概念最早由Pivotal公司的Matt Stine于2013年首次提出，提到云原生首先想到的关键词可能就是容器化、微服务、Lambda，服务网格等，当然这些是必要元素，但是不代表拥有这些元素就是云原生应用，很多应用的部署只能说是基于云来完成，比如私有云、公有云，这也是未来的趋势。云原生本质上不是部署，而是以什么方式来构建应用，云原生的最终目的是为了提高开发效率，提升业务敏捷度、扩容性、可用性、资源利用率，降低成本。 个人认为，未来应用发展不应该像Spring Cloud时代过分关注于组件的功能，组件的本身是服务于业务场景的，而组件更应该依托于容器化部署方式来实现其功能，在这一点上来说Spring的脚步对比Quarkus确实略慢一筹，期待未来百花齐放的云原生时代。 架构发展互联网如今也在深刻的影响着人们的生活，无处不在，不仅拉近了人们之间的距离，也在影响着人们的交流方式、生活方式等等。互联网快速发展的同时网站的技术架构也经历了无数次的迭代，从简单到复杂。按照演变过程来说可以大致分为三个阶段，这也是网站由小到大的一个过程。 单一架构 集群架构 分布式架构 单一架构没有一个网站上线初期就会拥有庞大体量的用户，只不过在信息爆炸的今天这个过程可能会在不断缩短，比如抖音等短视频软件的快速扩展。就拿庞大的电商平台淘宝来说，也是经历了近十几年的发展，从一个功能单一的小网站，发展到今天巨无霸的体量，感兴趣的可以看一下《淘宝技术这十年》，带你认识一个巨型网站从小到大，从简单到复杂的过程。 在单一架构时代，不需要太多的服务器，也不需要过多的中间件来支持，往往依赖简单的技术栈体系就能支撑一个网站的运行，早期也诞生过不少优秀的组合，甚至今天依然也在沿用。 LNMP&#x2F;WAMP LNMP一般指Linux、Nginx、MySQL、PHP，WAMP一般指Windows、Apache、MySQL、PHP，这种网站体系机构简单，单服务器可以部署所有资源（all in one），部署方便有很多现成的镜像包，一键启动建站的作用，区别的就是前者支持Linux环境，后者运行在Windows环境，Nginx和Apache都是静态服务器，处理一些简单嵌入式脚本语言，适用于业务简单、用户体量小的网站。 图 Tomcat + DB，这种架构Tomcat作为动态服务器，不仅可以处理静态资源，也可以处理动态资源，适用于更复杂一些的业务场景，这里的DB指的是不限于MySQL如Oracle、DB2、SQLServer等常见关系型数据库。一般使用这种架构就有必要对部署服务器进行拆分，如把服务器资源分为应用服务器和DB服务器。 图 集群架构当网站发展到一定规模，用户数量增多，相应的服务器也要进行扩增，如果业务流程相对不复杂的场景，不过多考虑业务代码的维护，只需要对服务器资源进行扩容，增加服务器数量即可，这个时候服务器的维护成本将会提高，对于一些经常访问的数据可以使用缓存服务器来降低关系型数据库的压力，对于关系西数据库可以采取读写分离达到高可用（HA）的目的，对于业务产生的文件可以增加共享文件服务器，降低应用服务器的磁盘压力。 当然这里只是简单描绘了集群架构的一种模式，实际业务场景可能更为复杂，技术涉及到细节实现往往会有更多的问题需要处理，以上所描述的集群模式仅在传统单一架构模式对服务器横向扩容，所有的业务依然冗余在一块，很有可能存在牵一发而动全身的影响，比如某一个功能点的用户访问激增从而拖垮整个服务，而扩容只能进行整体扩容，浪费较多的服务器资源，不能进行有针对性的扩容，难以实现弹性伸缩。一致性（Consistency），可用性（Avilable）。 图 分布式架构分布式架构更侧重于部署形式，微服务架构更侧重于应用架构，在微服务出现之前还有一种传统SOA架构，面向服务架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来，发展至今这种传统的SOA架构似乎已经过时，微服务架构成为各企业热衷的潮流。相对于单体架构而言，微服务架构体现在微，如何拆分就成了关键。一般会对业务进行水平拆分和垂直拆分。 垂直拆分 对业务的不同进行分类，不同的业务划分到不同的应用和数据库中。这种拆分往往是根据系统的改造，将原来的功能模块按照更加细粒度的拆分成多个弱耦合的服务。 水平拆分 数据库层面的水平拆分，就是将一个数据表中的数据按照某种规则分化到不同的数据库中，也就是分库分表。应用层面的水平拆分，最经典的就是将整个应用分层。数据库访问层和业务逻辑层拆分、网关层和业务逻辑层拆分等等。 更为精细的可以参考AKF原则进行服务拆分，AKF 立方体也叫做scala cube，它在《The Art of Scalability》一书中被首次提出，旨在提供一个系统化的扩展思路，AKF 把系统扩展分为三个维度。 X 轴：直接水平复制应用进程来扩展系统。 Y 轴：将功能拆分出来扩展系统。 Z 轴：基于用户信息扩展系统。 这里就不再展开描述，有兴趣的可以搜索相关资料。 微服务架构体系最明显的特征就是前后端分离，服务之间通过RPC调用，分工明确职责单一。 图 参考资料： 微服务理论：https://martinfowler.com/articles/microservices.html 《深入JVM虚拟机第三版》","tags":["学习","Java"],"categories":["Java","学习"]},{"title":"核酸检测志愿者","path":"/aeb36da8/","content":"核酸检测志愿者 2022年11月18日-30日，我有幸报名参加了公司核酸检测志愿者，主要工作是扫大家的健康码、核酸码、录身份证，减轻医务工作者繁杂的操作。 不经历风雨，怎能见彩虹。在接近两周的核酸检测时间中，大家都积极响应，小朋友、大人、老人们有序组织排队，无论阴晴冷暖，天气如何变化，大家的热情时刻温暖着我们的心。“明天还要做吗？要做到几号呀？”也是大家与我们共同关心的问题。小朋友们作“管长”时的喜悦，老年人出现问题并解决时的满脸笑容，还有大家给予我们的鼓励与肯定，是我们的力量源泉。感谢大家一路来积极的配合社区防疫工作。疫情不是儿戏，坚持“人民至上、生命至上”。 疫情无情人有情。一路走来，不知不觉中也走过了三年抗疫时光，时间过得真快呀！四年大学时光如白驹过隙，眨眼即逝。我想我是幸运的，既度过过一年美好的大学生活，也度过了疫情肆虐的后三年，上过网课，但期末考试都是线下在学校教室考的。封校的生活在上课与跑步中慢慢度过。随着病毒的变异，做核酸的次数也逐渐增多，每周五做一次核酸，周末就可以外出校门，但这也不是一尘不变的，还得看外面的疫情发展情况，有假条才是正确的外出方式。疫情之下的校园生活也不乏是多姿多彩的。 到了公司之后就经常回想以前的往事，回忆我那一去不复返的、五味杂陈的、酸甜苦辣的人生。我依稀记得夏天的网吧、下河抓虾、油菜花、甘蔗、钓龙虾、捉青蛙、棉花、螃蟹、蚯蚓、鱼、电脑放的第一首歌-棉花糖、鸟等，夏天的农村经常停电，大家在楼下唠嗑，一家人在楼顶过夜，数着满天繁星如梦，真是太奇妙了。还记得小时候同爸妈睡在一间房，但我那个床头是在门外露出一点，睡觉的时候看着黑黑的楼道心里是无比的害怕，换了房间之后，夏天的雷阵雨也会让我觉得是“世界末日”，电闪雷鸣且停电的夜晚印在了我的心里。 大班、幼儿园再到小学四年级，一溜烟的过去了，五年级到九年级去到了镇里，寄宿生的生活也就此开始，三国杀、弹珠、卡牌、篮球、羽毛球、排球、跳绳、丢沙包、手机等，高一一个宿舍、高二分班一个宿舍、高三因为换新校区又是一个宿舍，初中高中热水都要自己去打，区别在于高中有了水卡、餐卡。想到高三，就让我想起两件非常难过的回忆，记不清是2012、13还是14年了，我敬爱的爷爷离开了，高三这年，我亲爱的外公也离开了我们，他们都去到了没有病痛折磨的天堂了，操劳了大半辈子，也没有再好好体验下这人间。 爷爷和外公都是因肺癌离开了我们，在我的记忆当中，从来没有见过外公抽烟，后来得知年轻时外公经常吸烟，外公高高瘦瘦的，大半辈子都在农村种田，后来生活条件好了去到了县城，记得有一次走人家，晚上人住的地方不够，所以我和外公去到外面只容得下一张床的黄土房子里睡觉，很开心、很激动。爷爷很严肃，看我练字，和我下象棋，我就没赢过。以前爸妈打我我就会哭着去到爷爷奶奶家过夜。有一次爸妈吵架时爸爸摔了一个计算机，我印象很深刻。日子总是要一天一天的过，都是会白头到老的人了。我很悔恨啊，我居然不知道外公的全名，我们那里的方言不是叫外公，但我在很长的一段时间都不知道外公的全名，我要去问问我妈妈了。奶奶和爷爷照顾老爷时，我曾拿爷爷的手机玩网络游戏，那时的我太年轻了，不知道流量啥的，玩了100多的话费。祝愿奶奶、外婆还有我们所有人长命百岁，福如东海、寿比南山！ 2019年12月-2022年12月，三年的疫情宣告结束了，在党和全国上下各族人民的共同努力下，随着新的”二十条“的发布与解读，全国各地都开始解除风控，一夜之间仿佛又回到了没有疫情的三年前，除了大家都还带着口罩外，都在备药预防，病毒的重症率与致死率都大幅降低，一般七天之内大家都能康复了，12月13日零时行程卡也宣告下线，这折磨了全国、全社会人民的可恶病毒终于被我们所战胜，未知才会恐惧，随着科学技术的迅猛发展，美好的生活在等待着我们！ 下面是公司两篇公众号的文章： 文章一星夜集结、同心抗疫，公司在行动……2022-11-21 17:34 发表11月21日，公司积极响应社区核酸检测志愿者征集的号召，公司员工踊跃报名，短时间内迅速集结了一支防疫志愿者团队，义无反顾参与到疫情防控支援工作中，勇担防控责任，轮流排班，积极投身社区两个检测点的防疫工作，在疫情防控中当先锋、做表率。石雨萌昨天我是体验派，今天我是行动派。也是在今天，我遇见了一群可爱的人。社区工作者反复提醒我保护好自己，“大白”姐姐耐心教导我如何穿脱防护服，保安大叔一直守护在队伍旁……他们的身影出现在篮球场的各个角落；还有帮助老人操作手机的年轻人，他们像极了我教奶奶用手机的样子，十分亲切。疫情无情，人却有情。有这样一群人付出真心，传递爱心，给人民安心，我们的生活怎么能不幸福？很幸运，我也能成为给人安心的一份力量，以绵薄之力，站在疫情防控排查一线，为我国防疫工作贡献自己的力量。李家宁短短一段时间的防疫志愿工作，让我理解了医护工作者的辛苦。我看着他们在一个核酸检测点结束工作后立即赶到下一个检测点，继续投身其中，我看着他们穿着防护服始终坚守在岗位。那看起来不是很厚的防护服，只有亲身体验过才能知道有多么难受。维持核酸检测队伍的秩序、帮没有智能手机的老人代领核酸码、整理核酸检测物资……以往自己做完核酸就能离开，有了这一次的经历，我了解到了各个环节的种种不易，领悟到做防疫工作时细心、耐心、责任心缺一不可。在这个过程中，最令我觉得不容易的是与人的沟通，而最令我感到暖心的也是与人的沟通。很多老人找不到手机上的健康码在哪里，我需要一步一步告诉他们如何操作，不能说得太快，要耐心指导他们，一遍又一遍，一个人又一个人。当他们健康码被调出来后，一句又一句的感谢让我觉得做这些都值得。从被人服务到服务他人，责任感与自豪感也随着身份与行为的改变涌入心间。如果有下一次，我依然会报名成为志愿者，但我更希望以后没有疫情，让我再没有成为防疫志愿者的机会。下一步，公司将在做好自身疫情防控工作的同时，持续与政府相关部门对接，积极响应疫情防控工作号召，主动履行社会责任，用实际行动彰显企业的责任与担当。 文章二不惧风雨，奋力前行，以爱之名，共同战“疫”郝爱杰 2022-11-26 10:48 发表公司志愿者积极行动，投身到抗击疫情的志愿者服务队伍中，充分发挥先锋模范作用，勇于担当，齐心协力，共抗疫情。志愿者中有他们的身影，钟俊强在公司A区篮球场采集点负责核酸检测的信息录入工作，同时为居民发放检测管和采样棉签，工作要求细致，不能出任何差错。大多数老人、小孩没有健康码，需要人工输入姓名、身份证、电话号码，工作时戴着手套点击手机界面灵敏度下降，需要耐心仔细多次输入。面对繁琐的工作程序，他一直坚守岗位，做好工作，耐心护航。潘润在B区参加现场秩序管理，在工作中听从社区领导的安排，克服困难，任劳任怨，认真负责，服务到位。公司志愿者用实际行动践行着党的二十大精神，坚持人民至上，不畏风雨，不畏风险、冲锋在前。疫情就是命令，防控就是责任，行动彰显担当。积极作为、奋力前行、奔赴“疫”线，化小爱为大爱，只愿驱散新冠阴霾，换得岁月静好，与家人幸福安康，共享冬日之暖意。","tags":["核酸检测志愿者","疫情","志愿者","故事"],"categories":["核酸检测志愿者","疫情","志愿者","故事"]},{"title":"2022个人总结","path":"/b6639768/","content":"fe39ff840f9f83e271835236a8048b467264523ffe7f1b810b80296f4c4cd14244568c59c3223045a49cb0fd052e07f6c96ccf31b6c8dae6aa93d1bc306445fa7c11eac282e0103a3b7a80616e09d4443b7aad784086343a77a03221ab7d324db5b398b21e325d36e8d1636f841b1e3a3a1709eeea99daf069bff3f3c8e34f07c794cf7004967396c4a9b2cb7c34abfbd5258790bad338f6cf1f3bee37a63284806bae6b1359d2188e6ae66ff64fdfe4c146f15632bef817e44ca761d9c0363207d262a577eb68e9c8550ec65589d9e88baaaba0b2ec8ff494320bc4b9c7efc9281684359af087d060b52b63fc993a24d8d6cdf2830f746ffc3f5543f8020d631e88b07f1c0fbcdc1e02e987e60e5b42538d040698f84faefc23f14f20a083b8e3218fb348b0e8e662ce69eff084198e75a84780a656e3e293c159388e32e8a6110139238fd02196f6509b9972b1b1a280d18f254b17f5b7ddf8c83b43eb63f48b8d64046e3317b0e72c2995e0d1084bcd17b72e62c094e673491897f191db27d78c4a53b21ec793127e91cf939c1353b23bdeec33e97342cd04fe361db543eca5c977052a228447e4fe0006ebbb35999a143ed16e3f0657609970b2a31226572361a17ad8defb396580906e87a8c88ae83243f6a74d741c092bd476029c05b8436b04ecc37fa49a067cc719b0c3299a705224654ee1a3105ac4d63ee821648ebc00fdfde621e8d1e00050ea7fc750e064ff3bcd1295db1d3bb5db52795f58970e6ab3da5fe367e199173ddb1eb9bc2a77e743e242075f0a0081035f9239556b1cfc5d9b828b5a736c136ab290944afdbde452d451c16255805b7718aff83a70d29c8b34cf2ac851363bd4ae087540fd337be114a258c4f6635ce7a78ed8c51acadf73399b7f1893621eff5de4dc02323df19a09c9070b9b695eb46b4f53661456cede029522f17df02d5a3d3c03e5582710a7a402aa80017da98ac227483bf5022c24754a95b8b2dc1d6f7759545ea28727ca2391860d88c64177eb7ed82914da0145c01143d979c7e6a718f524dee85e0c67b3f47d94cd9afcdb5f52469719e8ab1cad34ce2021f572cf4a188f3da3ecfebef1387952fc4f3030bbc0b5daac7805ee14b4ffc9969d60bbf322abad730722aecf4c1b2f43c628179100514f9f88e58efa9048bac95a247dffb82f573fe1b7923bdee4832dd87bd5aa621d8c47120fb02fd6004848303999bea595f041279b0922d70d18de9a5bee9cf488a5159e9095a608fa6d3f84a4408a305db158c71e02ff194853b04d2605302ff4595fb5f697e6b8757a13447ef850aa030af6e0ee271c1a7fca49d2eb7eecffb3fabd79836d82ca16c939e58aa9b82beb8ca5f5890d4cbcec64c6e66890835032459fcc5134d46c5a02d91abf9a9a007b0df580fb5460d4c70e59f96130e9072ffd9aa472521ee9b643f8240a7b7ca50d8dadcd88caa4f5e68fe72cb593f1c8853b2c86864f864a1c0d584b3f030cf56bb62d9d0a82a0a4954bbb97332d855782172d7a0b073aee2b02885dc998cae44b4eef23f450043d67b7641b697fb1393b02dcf393f4f7d72b7be6f8e029bfdc066f3e0c2bb785444edea2ee0708087be6987a63c118671f8e4bdf4a3904719b096f4d10a12a9db90db41a877d7e1e34dd67dab890585d3a089a3e51a89f443bfd7f9999923b08003bbcb8236c81488fdb7079273536368ff0427459d92e5c19649a1da29e8d953f549efe421a5f1a27de51b8de1f42cdad95481830e8522b31085722e4047fc15bd0580479a74006f49506adaf14d0c534e27534f42d3e31f7dc5fceb185feb39053df5fe40094e9b7ae2e2565cb2256e8685ad1024a85dd31338c4dc3e89b8cb93de086563baf485e01094c5c1565491637144e2dd2d020639ce45be562792c5ccc77f9cf60bc6c23c55468494e7ab64fa78f446fe75e1570171f53049f2c0e66bb70542eea6a950b05c76c75a2ae711a4256bb3cb82c8875ddf3ee0bfc52d8311fa6da5a70a656dce37b3cce834768659985f94599efafafbd2aa8c89b92ea2f00ad64ebba0f4a2e8a23442437cb6724d1863638beef80841d74cedaa83921aabc351048e48d6ae50d6e7ff72ca128e42d4b691e1cd4feb0a39ab5ffcb5aaf467c57d98baa0bd745c89d7de787371127800743998162f67a32d74e99fbed68dd2690b8ab57f83a1d6c32c8e661b359810b4d91f074007474b8cf92e1055055c39ae36091fcb24221a409d54e0671e5f7dca22d97ba4963fb5c280cf9ab05fedf3dcbe9fbdf81224df95552989794f0c1d84651f6bef02b4ec0ff5ace1830d86afe375f1bfefe7d1bb24393e0bd225c6d74fc34ce16e81b5dab61ffdc888f51a3bf95e8276aaed493e647bd29f6c3caf2aaa897d1ab04e552c67d559c082bf8e3b8d24b26a2b950338a034753ba4d236e3ec4c0159246e4323f77d986c6b16881f7daffc43c4bd5663dc873a5a9769fbed934c2662cf73790373009dd54f8c978f9d09b2f34637fedfb52aef24e6f5f71b8829e29acce6122a6beaf8ebb5d75e49b873972a6f271fdfa0ada8dd34b7ff81f46c1a992f896587edfc656b5cf79e7ceedcbc4f609df16e3ba2fedd899e43b04c02caa01153f5917cfbf0f823c8cf134f7700bf347a342a1c51d93957596bf54c2bbf05e3eb88b8fcb3f5827e401f8e8ed3e0d4b6656a73b01d08cca11994073e304600cb1827c0c6401e1b462063c5603a2da63b0d69e1eabfb90e7dccb866c9948e2cfa7bbeb0c7dbce0b4b10e9e6bd93da5e24ec35c4349221c8e3d814699ad60ecd0391f66fca4fac725c7068426dc9348f2d4b9706ad68b53e0217b0c7072d68f55f4011cf25b36a2278657cec6e07e9ae172b0743f187551713f64684719efc66c006d307dbb48a3e0465e229d8e2bb34a8faeb088bfa3972c5d11e4be46e7132b7c650b3c6cfdf6fb789c3b88cab1a850a0461dbb0a4f821c8cf2952c69b6d10720d566b5e4ebc25a1cd2e427a9a9bf2a0bcbb0eeccbe5524e38b58701cb0f05c02a876a1d9fd91b43b94f0b4cf3ba7cdb6cc1cbe0e6c24ecefe3939c220b3ffd38c1414775bb407b3e1cb09754c76813e8447b40bb63ec3501f18d34a051354944d7a9663ccbc405e3ff01c4b134a043da014c3a3aeabcff876592240e2ccb0b2dd52200baf4cb6b59ddaf4b79a28db4aa9f303c9d3e1e7029e573c958e44bf6544dcaf0d4cda1a27aaadb42fc9dd0c2100ea942395283a13adceade24656ae6a4d58a46afcd34144580e6ef8234293db61b394143edea3139a357421b7ef853f9686ae92206a82bf37eaf24345cc8cb77dab8835868d499e07d097058d98445428abbf4a09aff4f797914e100ee10d40eaebc7004a0b0b08cb2057bacc99ebaeb9ea43c0bac2e9bcec83c27396b6363ca1757d23f247531c83580b67f57fc9c667c8a8b356cb4dce123dd94f26d6f8790dadcfeff0d989a768c0c4991a07c3f319a18426cd40969bc2e1bac5f149e5567539219926f181e9bd30a58eff91a62b1cbc9846380365f9024e60cfd1e6d3890bc427daeb23460260c1b2ee27916d528a85157190801a6d4a659c5abae92b486db775b95c6aafa6532f5d9d07c1fe0629e29bd24787c28bc18e5042db1a97f106b8e0d2c4627aed12a60a7d00c81413160c0364669c5fd620950edf4c4ffb91f0e6d503c056ef2d4521ccd55022785fc61340750042e1e92d8d37efd880ea067f020699a25072110b53420dec1a5bb5aa3eac6845234737488f137643480e42b1dbf960470f38b489f8fae3b23915b39879fd37c1db3c3cfaac151997a577be7efc4f89c6df8d7621781b3c2c9af611d77eaeb4883bb27c98e6e39d9f5bfaa8c295c86cb3024b134adcb70878de09779a834e85ffda14d2020d631811e3f5e24740d37888f48001fe891a04f24cff842853b2ffae03f6a9f4a7dcb59eb29c77e5b1ca2841a7dcc0053168f2dfa36955064fd9ffb9c0b0486e62188ed54cb190a023adf182ad7d5cc021056786b3b4dbf06ea610b6f05f8d3d5c567c2fada8d648adcaf9e0c41b94b6d9a90900b49efad10e60ee1cff6e51c9797bf48b7d08d79e075fe8d0d10126929eeff48aa95a38a5896fdbeeb66bb9feb74cfb8c69df25af17df19251a32cb160894ea59d18401490b2ace25c759aeff89bf13390e32967467d400d1bbcba5f4a67667f59d077d234a9204ff66a6cb03680d054352fafd70b80b531f11d396634fbd4ae3b28aac0aaa789585605bc9126141d1376953986d5b2a1038f1f131a20a260a0af5328b0466f2832b5064fa21a519aeb8150cbeeef9e37300e60c302e517627a5da78349ab3b220eb9907088c2c560efb4d035f27e6c965cda6bd73fbd0e134019dae0a4f7a0847dc4f4dc53315d5b90bbdb4f83f5a081b30f1669d4f4ee8710528118f68c050c762e7e7527f603bd9ba71fc1d5191f26c8bd0651697093f3e1fbb06e6d4edcecdce8edc10b39e6232745c20ad33af8ef473ed0658735bd05d9562e09ff11ca644412139549dd80e7feee63723b63c249b49971a25a9328fefa7c8f5b67e99c20c2aad200eb66e18b95279b25cdfdda1870678f547c50055d2b315ad3291cb7ac2dce3e21890bc4fa651a7733ef7033483d4418dd918dcbd2875b938f529d04cca063dd7e2a45a96fb1bf68b0b62e826c13896c893dc8c54a7c2e3e9aa25b21d09b6682810d68891956533e5864d19c1a0dd20d4c9a4759ea89865da47500c9541dae97735862ccaa0b8a2717b5029010afd8d13af5d4ec990c3f1adc8e8c9ce2b0e220d7ce62a11564ca957f0163dec77127ec862d2c3bee379eab882060809659f684c7f7d25d1393179053cbaaa82728352d85c8e8280fa6a0b1f8e5de59855431d90dbe6f8cc7c1c5ebfd57d8830347739e4c737485e99f1da42b542a3c50ac7492c6a0d252e1fe61340aa0c68a460e4ee3ee579971ad635ed5e9896de9ce81cd02f4ca17b64b95349da7e32b6be01178a70f5cb6ada069dff1bddbadb51d36f1c96d1cae4cc7ae9e4b14903735bf3a9fcf1b490358dbcdc0a42a42359341261346a9848d26e0c1ab56e86c7c43a812f5c0d70540eff4d3fa621ed15b4bc1eb544cbef26435b7d787687849d321029e32 您好, 这里需要密码.","tags":["2022","个人总结"],"categories":["2022","个人总结"]},{"title":"SpringBoot实现前后端分离的跨域访问（Nginx）","path":"/a0a36649/","content":"SpringBoot实现前后端分离的跨域访问（Nginx） 序言使用Nginx反向代理，可以解决跨域无权和Session丢失的问题，十分方便。下面我们以前后端分离为案例，展开Nginx的使用教程。 配置和启动Nginx下载地址Nginx下载传送门：http://nginx.org/en/download.html 注意事项：下载之后，记得解压到全英文路径，避免中文路径导致Nginx启动失败。 修改配置打开nginx.conf ，清空配置项，然后将下面的配置信息原封不动拷贝进去： 1234567891011121314151617181920212223242526272829303132333435363738worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #前端页面服务器 server &#123; #监听端口和域名 listen 7000; server_name localhost; #添加头部信息 proxy_set_header Cookie $http_cookie; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #添加拦截路径和代理地址 location /api/ &#123; proxy_pass http://localhost:8080/; #注意：使用代理地址时末尾记得加上斜杠&quot;/&quot;。 &#125; #添加拦截路径和根目录 location / &#123; root html/hehe; #注意：使用&quot;/&quot;拦截全路径的时候记得放在最后。 index index.html index.htm; #index表示首页 &#125; &#125;&#125; 快速启动在Windows 环境中： 快速启动Nginx：右键管理员模式，运行nginx.exe。 快速关闭Nginx：在nginx主目录，添加关闭Nginx的命令。 其中结束Nginx.bat的具体内容如下： 1taskkill /f /im nginx.exe 部署前端页面前后端分离后，可以直接将静态资源（例如前端页面）部署到Nginx的html目录。这里我们在$nginx_home&#x2F;html目录下创建一个名为hehe的文件夹，并添加一个页面（index.html）用于跨域访问测试，index页面内容如下： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Page Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;前台系统7000&lt;/h2&gt;&lt;p id=&quot;info1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;info2&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url: &#x27;http://localhost:7000/api/user/login/verifyCode&#x27;, type: &quot;POST&quot;, success: function (data) &#123; //1.获取验证码 $(&quot;#info1&quot;).html(&quot;跨域访问成功:verifyCode:&quot; + data); //2.核对验证码 $.ajax(&#123; url: &#x27;http://localhost:7000/api/user/login/checkVerifyCode&#x27;, type: &quot;POST&quot;, success: function (data) &#123; $(&quot;#info2&quot;).html(&quot;跨域访问成功:checkVerifyCode:&quot; + data); &#125; &#125;); &#125;, error: function (data) &#123; $(&quot;#info1&quot;).html(&quot;跨域失败!!&quot;); &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 启动后端系统首先在POM文件添加Web依赖，然后编写控制层，提供对外的访问接口。默认启动端口是8080. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.hehe;@SpringBootApplication@RestController@RequestMapping(&quot;/user/login/*&quot;)public class SpringBootNginxApplication &#123; //在拦截器打印访问URL @Bean public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new HandlerInterceptor() &#123; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; if(response.getStatus()/100&gt;=4)&#123; System.err.println(&quot;访问URL:&quot;+request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)); &#125;else &#123; System.out.println(&quot;访问URL:&quot;+request.getRequestURI()); &#125; &#125; &#125;); &#125; &#125;; &#125; //提供验证码 @RequestMapping(&quot;verifyCode&quot;) public String verifyCode(HttpServletRequest request) &#123; request.getSession().setAttribute(&quot;verifyCode&quot;, &quot;N7GX&quot;); return request.getSession().getId() + &quot;:&quot; + request.getSession().getAttribute(&quot;verifyCode&quot;); &#125; //核对验证码 @RequestMapping(&quot;checkVerifyCode&quot;) public String checkVerifyCode(HttpServletRequest request) &#123; return request.getSession().getId() + &quot;:&quot; + request.getSession().getAttribute(&quot;verifyCode&quot;); &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringBootNginxApplication.class, args); &#125;&#125; 测试跨域访问打开浏览器，访问 http://localhost:7000/api/user/login/verifyCode ，可以看到后台获取的Session和第一次生成的验证码。如图: 打开浏览器，访问 http://localhost:7000/api/user/login/checkVerifyCode ，可以看到后台获取的Session和第二次取出的验证码。 由上图可以看到，跨域访问成功，并且Session没有丢失。 Nginx跨域总结Nginx VS CORS简单来说，Nginx是间接跨域，而CORS则实现了直接跨域。Nginx的反向代理“欺诈了”浏览器，所以浏览器和服务器都认为是同源访问，所以Session不会丢失。 （PS：如果发生跨域访问，服务器会每次都创建新的Session，所以才造成了前后端分离的Session丢失问题。） 至于CORS这种跨域机制的安全性和灵活性更高，但需要自己解决跨域访问Session丢失的问题，通常情况可以采用Session+Redis来实现Session共享。） Nginx跨域实现过程:第1步：http://localhost:7000/index.html第2步：http://localhost:7000/api/user/login/verifyCode 第1步是打开页面，第2步是在这个页面发起AJAX请求，并且请求的域名端口均与当前访问页面相同，属于同源操作，所以浏览器不会报出跨域禁止的错误。 第3步：http://localhost:8080/user/login/verifyCode 第3步是本案例最为关键的一步，真正的跨域操作由Nginx的proxy_pass进行完成，并成功将验证码信息以代理的身份返回给浏览器，让浏览器处于同源访问后台的错觉。打开F12可以看到代理服务器： 关于proxy_pass 斜杠”&#x2F;‘ 的坑通常情况下，建议大家在代理地址末尾加上”&#x2F;“ ，表示转发后就是proxy_pass直接拼接映射路径。 Nginx代理效果：转发前URL：http://localhost:7000/api/user/login/verifyCode转发后URL：http://localhost:8080/hehe/user/login/verifyCode 12345678910 server &#123; listen 7000; server_name localhost; #正确示范: 末尾加斜杠&quot;/&quot; location /api/ &#123; proxy_pass http://localhost:8080/hehe/; &#125; &#125; 如果代理地址末尾没有加斜杠的话，表示转发后也是proxy_pass直接拼接映射路径，但是，拼接的时候会少了个”&#x2F;“，这样会引发访问路径错误。 Nginx代理效果：转发前URL：http://localhost:7000/api/user/login/verifyCode转发后URL：http://localhost:8080/heheuser/login/verifyCode 12345678910 server &#123; listen 7000; server_name localhost; #错误示范: 末尾无斜杠 location /api/ &#123; proxy_pass http://localhost:8080/hehe; &#125; &#125; 为了更方便大家，看到在Nginx调整了proxy_pass有无斜杠的区别，楼主在控制台打印了每次请求访问的URL地址，这样更加清晰： 具体做法：关闭Nginx 将代理地址修改为：proxy_pass http://localhost:8080/hehe ，然后启动Nginx，在浏览器访问http://localhost:7000/api/user/login/verifyCode，然后查看控制台打印的URL信息。清楚的看到了因为少了斜杠而导致拼接成错误路径，如下：","tags":["SpringBoot","Nginx"],"categories":["SpringBoot","Nginx"]},{"title":"BigDecimal","path":"/5b0774c7/","content":"BigDecimal BigDecimal概述Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。 一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。 BigDecimal所创建的是对象，故我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。 BigDecimal常用构造函数常用构造函数 BigDecimal(int) 创建一个具有参数所指定整数值的对象 BigDecimal(double) 创建一个具有参数所指定双精度值的对象 BigDecimal(long) 创建一个具有参数所指定长整数值的对象 BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象 使用问题分析使用示例： 12345BigDecimal a =new BigDecimal(0.1);System.out.println(&quot;a values is:&quot;+a);System.out.println(&quot;=====================&quot;);BigDecimal b =new BigDecimal(&quot;0.1&quot;);System.out.println(&quot;b values is:&quot;+b); 结果示例： 123a values is:0.1000000000000000055511151231257827021181583404541015625=====================b values is:0.1 原因分析： 1）参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 2）String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言， 通常建议优先使用String构造方法。 3）当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。 BigDecimal常用方法详解常用方法 add(BigDecimal) BigDecimal对象中的值相加，返回BigDecimal对象 subtract(BigDecimal) BigDecimal对象中的值相减，返回BigDecimal对象 multiply(BigDecimal) BigDecimal对象中的值相乘，返回BigDecimal对象 divide(BigDecimal) BigDecimal对象中的值相除，返回BigDecimal对象 toString() 将BigDecimal对象中的值转换成字符串 doubleValue() 将BigDecimal对象中的值转换成双精度数 floatValue() 将BigDecimal对象中的值转换成单精度数 longValue() 将BigDecimal对象中的值转换成长整数 intValue() 将BigDecimal对象中的值转换成整数 BigDecimal大小比较java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法 1int a = bigdemical.compareTo(bigdemical2) 返回结果分析： 123a = -1,表示bigdemical小于bigdemical2；a = 0,表示bigdemical等于bigdemical2；a = 1,表示bigdemical大于bigdemical2； 举例：a大于等于b 1new bigdemica(a).compareTo(new bigdemical(b)) &gt;= 0 BigDecimal格式化由于NumberFormat类的format()方法可以使用BigDecimal对象作为其参数，可以利用BigDecimal对超出16位有效数字的货币值，百分值，以及一般数值进行格式化控制。 以利用BigDecimal对货币和百分比格式化为例。首先，创建BigDecimal对象，进行BigDecimal的算术运算后，分别建立对货币和百分比格式化的引用，最后利用BigDecimal对象作为format()方法的参数，输出其格式化的货币值和百分比。 123456789NumberFormat currency = NumberFormat.getCurrencyInstance(); //建立货币格式化引用 NumberFormat percent = NumberFormat.getPercentInstance(); //建立百分比格式化引用 percent.setMaximumFractionDigits(3); //百分比小数点最多3位 BigDecimal loanAmount = new BigDecimal(&quot;15000.48&quot;); //贷款金额BigDecimal interestRate = new BigDecimal(&quot;0.008&quot;); //利率 BigDecimal interest = loanAmount.multiply(interestRate); //相乘System.out.println(&quot;贷款金额:\\t&quot; + currency.format(loanAmount)); System.out.println(&quot;利率:\\t&quot; + percent.format(interestRate)); System.out.println(&quot;利息:\\t&quot; + currency.format(interest)); 结果： 1贷款金额: ￥15,000.48 利率: 0.8% 利息: ￥120.00 BigDecimal格式化保留2为小数，不足则补0： 123456789101112131415161718192021222324252627public class NumberFormat &#123; public static void main(String[] s)&#123; System.out.println(formatToNumber(new BigDecimal(&quot;3.435&quot;))); System.out.println(formatToNumber(new BigDecimal(0))); System.out.println(formatToNumber(new BigDecimal(&quot;0.00&quot;))); System.out.println(formatToNumber(new BigDecimal(&quot;0.001&quot;))); System.out.println(formatToNumber(new BigDecimal(&quot;0.006&quot;))); System.out.println(formatToNumber(new BigDecimal(&quot;0.206&quot;))); &#125; /** * @desc 1.0~1之间的BigDecimal小数，格式化后失去前面的0,则前面直接加上0。 * 2.传入的参数等于0，则直接返回字符串&quot;0.00&quot; * 3.大于1的小数，直接格式化返回字符串 * @param obj传入的小数 * @return */ public static String formatToNumber(BigDecimal obj) &#123; DecimalFormat df = new DecimalFormat(&quot;#.00&quot;); if(obj.compareTo(BigDecimal.ZERO)==0) &#123; return &quot;0.00&quot;; &#125;else if(obj.compareTo(BigDecimal.ZERO)&gt;0&amp;&amp;obj.compareTo(new BigDecimal(1))&lt;0)&#123; return &quot;0&quot;+df.format(obj).toString(); &#125;else &#123; return df.format(obj).toString(); &#125; &#125;&#125; 结果为： 1234563.440.000.000.000.010.21 BigDecimal常见异常除法的时候出现异常1java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result 原因分析： 通过BigDecimal的divide方法进行除法时当不整除，出现无限循环小数时，就会抛异常：java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result. 解决方法： divide方法设置精确的小数点，如：divide(xxxxx,2) BigDecimal总结总结 在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。 尽量使用参数类型为String的构造函数。 BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。 工具类推荐123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252package com.vivo.ars.util;import java.math.BigDecimal;/** * 用于高精确处理常用的数学运算 */public class ArithmeticUtils &#123; //默认除法运算精度 private static final int DEF_DIV_SCALE = 10; /** * 提供精确的加法运算 * * @param v1 被加数 * @param v2 加数 * @return 两个参数的和 */ public static double add(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); &#125; /** * 提供精确的加法运算 * @param v1 被加数 * @param v2 加数 * @return 两个参数的和 */ public static BigDecimal add(String v1, String v2) &#123; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.add(b2); &#125; /** * 提供精确的加法运算 * @param v1 被加数 * @param v2 加数 * @param scale 保留scale 位小数 * @return 两个参数的和 */ public static String add(String v1, String v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.add(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString(); &#125; /** * 提供精确的减法运算 * @param v1 被减数 * @param v2 减数 * @return 两个参数的差 */ public static double sub(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2).doubleValue(); &#125; /** * 提供精确的减法运算。 * @param v1 被减数 * @param v2 减数 * @return 两个参数的差 */ public static BigDecimal sub(String v1, String v2) &#123; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.subtract(b2); &#125; /** * 提供精确的减法运算 * @param v1 被减数 * @param v2 减数 * @param scale 保留scale 位小数 * @return 两个参数的差 */ public static String sub(String v1, String v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.subtract(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString(); &#125; /** * 提供精确的乘法运算 * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /** * 提供精确的乘法运算 * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static BigDecimal mul(String v1, String v2) &#123; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.multiply(b2); &#125; /** * 提供精确的乘法运算 * @param v1 被乘数 * @param v2 乘数 * @param scale 保留scale 位小数 * @return 两个参数的积 */ public static double mul(double v1, double v2, int scale) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return round(b1.multiply(b2).doubleValue(), scale); &#125; /** * 提供精确的乘法运算 * @param v1 被乘数 * @param v2 乘数 * @param scale 保留scale 位小数 * @return 两个参数的积 */ public static String mul(String v1, String v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.multiply(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString(); &#125; /** * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到 * 小数点以后10位，以后的数字四舍五入 * @param v1 被除数 * @param v2 除数 * @return 两个参数的商 */ public static double div(double v1, double v2) &#123; return div(v1, v2, DEF_DIV_SCALE); &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 * 定精度，以后的数字四舍五入 * @param v1 被除数 * @param v2 除数 * @param scale 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1, double v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 * 定精度，以后的数字四舍五入 * @param v1 被除数 * @param v2 除数 * @param scale 表示需要精确到小数点以后几位 * @return 两个参数的商 */ public static String div(String v1, String v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v1); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).toString(); &#125; /** * 提供精确的小数位四舍五入处理 * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); return b.setScale(scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供精确的小数位四舍五入处理 * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static String round(String v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b = new BigDecimal(v); return b.setScale(scale, BigDecimal.ROUND_HALF_UP).toString(); &#125; /** * 取余数 * @param v1 被除数 * @param v2 除数 * @param scale 小数点后保留几位 * @return 余数 */ public static String remainder(String v1, String v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); return b1.remainder(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString(); &#125; /** * 取余数 BigDecimal * @param v1 被除数 * @param v2 除数 * @param scale 小数点后保留几位 * @return 余数 */ public static BigDecimal remainder(BigDecimal v1, BigDecimal v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; return v1.remainder(v2).setScale(scale, BigDecimal.ROUND_HALF_UP); &#125; /** * 比较大小 * @param v1 被比较数 * @param v2 比较数 * @return 如果v1 大于v2 则 返回true 否则false */ public static boolean compare(String v1, String v2) &#123; BigDecimal b1 = new BigDecimal(v1); BigDecimal b2 = new BigDecimal(v2); int bj = b1.compareTo(b2); boolean res; if (bj &gt; 0) res = true; else res = false; return res; &#125;&#125;","tags":["Java","BigDecimal"],"categories":["Java","BigDecimal"]},{"title":"Nginx的6大应用场景","path":"/9341b859/","content":"Nginx的6大应用场景 一、HTTP服务器Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。 1、 首先在文档根目录Docroot(/usr/local/var/www)下创建html目录, 然后在html中放一个test.html; 2、 配置nginx.conf中的server 123456789101112131415user mengday staff;http &#123; server &#123; listen 80; server_name localhost; client_max_body_size 1024M; # 默认location location / &#123; root /usr/local/var/www/html; index index.html index.htm; &#125; &#125;&#125; 3、访问测试 http://localhost/指向/usr/local/var/www/index.html, index.html是安装nginx自带的html http://localhost/test.html指向/usr/local/var/www/html/test.html 注意：如果访问图片出现403 Forbidden错误，可能是因为nginx.conf 的第一行user配置不对，默认是#user nobody;是注释的，linux下改成user root; macos下改成user 用户名 所在组; 然后重新加载配置文件或者重启，再试一下就可以了， 用户名可以通过who am i 命令来查看。 4、指令简介 server : 用于定义服务，http中可以有多个server块 listen : 指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口 server_name : 服务名称，用于配置域名 location : 用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式, &#x2F; 表示匹配任意路径, 当客户端访问的路径满足这个uri时就会执行location块里面的代码 root : 根路径，当访问http://localhost/test.html，“&#x2F;test.html”会匹配到”&#x2F;”uri, 找到root为/usr/local/var/www/html，用户访问的资源物理地址&#x3D;root + uri = /usr/local/var/www/html + /test.html=/usr/local/var/www/html/test.html index : 设置首页，当只访问server_name时后面不跟任何路径是不走root直接走index指令的；如果访问路径中没有指定具体的文件，则返回index设置的资源，如果访问http://localhost/html/则默认返回index.html 5、location uri正则表达式 .：匹配除换行符以外的任意字符 ?：重复0次或1次 +：重复1次或更多次 *：重复0次或更多次 \\d：匹配数字 ^：匹配字符串的开始 $：匹配字符串的结束 &#123;n&#125;：重复n次 &#123;n,&#125;：重复n次或更多次 [c]：匹配单个字符c [a-z]：匹配a-z小写字母的任意一个 (a|b|c): 属线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括括住，匹配符合a字符 或是b字符 或是c字符的字符串 \\反斜杠：用于转义特殊字符 小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 二、静态服务器在公司中经常会遇到静态服务器，通常会提供一个上传的功能，其他应用如果需要静态资源就从该静态服务器中获取。 1、在/usr/local/var/www下分别创建images和img目录，分别在每个目录下放一张test.jpg 1234567891011121314151617181920212223http &#123; server &#123; listen 80; server_name localhost; set $doc_root /usr/local/var/www; # 默认location location / &#123; root /usr/local/var/www/html; index index.html index.htm; &#125; location ^~ /images/ &#123; root $doc_root; &#125; location ~* \\.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123; root $doc_root/img; &#125; &#125;&#125; 自定义变量使用set指令，语法 set 变量名值;引用使用变量名值;引用使用变量名; 这里自定义了doc_root变量。 静态服务器location的映射一般有两种方式： 使用路径，如 &#x2F;images&#x2F; 一般图片都会放在某个图片目录下， 使用后缀，如 .jpg、.png 等后缀匹配模式 访问http://localhost/test.jpg会映射到$doc_root/img 访问http://localhost/images/test.jpg当同一个路径满足多个location时，优先匹配优先级高的location，由于^~的优先级大于~, 所以会走/images/对应的location 常见的location路径映射路径有以下几种： = 进行普通字符精确匹配。也就是完全匹配。 ^~ 前缀匹配。如果匹配成功，则不再匹配其他location。 ~ 表示执行一个正则匹配，区分大小写 ~* 表示执行一个正则匹配，不区分大小写 /xxx/常规字符串路径匹配 / 通用匹配，任何请求都会匹配到 location优先级当一个路径匹配多个location时究竟哪个location能匹配到时有优先级顺序的，而优先级的顺序于location值的表达式类型有关，和在配置文件中的先后顺序无关。相同类型的表达式，字符串长的会优先匹配 以下是按优先级排列说明： 等号类型（&#x3D;）的优先级最高。一旦匹配成功，则不再查找其他匹配项，停止搜索。 ^~类型表达式，不属于正则表达式。一旦匹配成功，则不再查找其他匹配项，停止搜索。 正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。 常规字符串匹配类型。按前缀匹配。 &#x2F; 通用匹配，如果没有匹配到，就匹配通用的 优先级搜索问题：不同类型的location映射决定是否继续向下搜索 等号类型、^~类型：一旦匹配上就停止搜索了，不会再匹配其他location了 正则表达式类型(~ ~*）,常规字符串匹配类型/xxx/: 匹配到之后，还会继续搜索其他其它location，直到找到优先级最高的，或者找到第一种情况而停止搜索 location优先级从高到底： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 1234567891011121314151617181920212223242526272829303132333435363738location = / &#123; # 精确匹配/，主机名后面不能带任何字符串 / [ configuration A ]&#125;location / &#123; # 匹配所有以 / 开头的请求。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration B ]&#125;location /documents/ &#123; # 匹配所有以 /documents/ 开头的请求，匹配符合以后，还要继续往下搜索。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration C ]&#125;location ^~ /images/ &#123; # 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。 # 所以，即便有符合的正则表达式location，也不会被使用 [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif jpg jpeg结尾的请求。 # 但是 以 /images/开头的请求，将使用 Configuration D，D具有更高的优先级 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，还会继续往下搜索 [ configuration F ]&#125;location = /test.htm &#123; root /usr/local/var/www/htm; index index.htm;&#125; 注意：location的优先级与location配置的位置无关。 三、反向代理反向代理应该是Nginx使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 反向代理通过proxy_pass指令来实现。 启动一个Java Web项目，端口号为8081，可以利用 Spring Boot 快速搭建一个项目：https://github.com/vehang/ehang-spring-boot 1234567891011121314server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:8081; proxy_set_header Host $host:$server_port; # 设置用户ip地址 proxy_set_header X-Forwarded-For $remote_addr; # 当请求服务器出错去寻找其他服务器 proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; &#125;&#125; 当我们访问localhost的时候，就相当于访问localhost:8081了。 四、负载均衡负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。 负载均衡通过upstream指令来实现。 1. RR(round robin :轮询 默认)每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器down掉，能自动剔除。轮询是默认配置，不需要太多的配置 同一个项目分别使用8081和8082端口启动项目 1234567891011121314151617upstream web_servers &#123; server localhost:8081; server localhost:8082; &#125;server &#123; listen 80; server_name localhost; #access_log logs/host.access.log main; location / &#123; proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; &#125; &#125; 访问地址仍然可以获得响应http://localhost/api/user/login?username=zhangsan&amp;password=111111，这种方式是轮询的 2. 权重指定轮询几率，weight和访问比率成正比, 也就是服务器接收请求的比例就是各自配置的weight的比例，用于后端服务器性能不均的情况,比如服务器性能差点就少接收点请求，服务器性能好点就多处理点请求。 12345upstream test &#123; server localhost:8081 weight=1; server localhost:8082 weight=3; server localhost:8083 weight=4 backup;&#125; 示例是4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083 3. ip_hash上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候(采用了session保存数据)，这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream test &#123; ip_hash; server localhost:8080; server localhost:8081;&#125; 4. fair(第三方)按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应 12345upstream backend &#123; fair; server localhost:8080; server localhost:8081;&#125; 5. url_hash(第三方)按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream backend &#123; hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081;&#125; 以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用。 五、动静分离动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。 123456789101112131415161718192021222324252627upstream web_servers &#123; server localhost:8081; server localhost:8082; &#125;server &#123; listen 80; server_name localhost; set $doc_root /usr/local/var/www; location ~* \\.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123; root $doc_root/img; &#125; location / &#123; proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root $doc_root; &#125; &#125; 六、其他1.return指令返回http状态码 和 可选的第二个参数可以是重定向的URL 123location /permanently/moved/url &#123; return 301 http://www.example.com/moved/here;&#125; 2. rewrite指令重写URI请求 rewrite，通过使用rewrite指令在请求处理期间多次修改请求URI，该指令具有一个可选参数和两个必需参数。 第一个(必需)参数是请求URI必须匹配的正则表达式。 第二个参数是用于替换匹配URI的URI。 可选的第三个参数是可以停止进一步重写指令的处理或发送重定向(代码301或302)的标志 123location /users/ &#123; rewrite ^/users/(.*)$ /show?user=$1 break;&#125; 3. error_page指令使用error_page指令，您可以配置NGINX返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他URI。在以下示例中，error_page指令指定要返回404页面错误代码的页面(&#x2F;404.html)。 1error_page 404 /404.html; 4. 日志访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开log_format、access_log注释 1234567log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;access_log /usr/local/etc/nginx/logs/host.access.log main;gzip on; 5. deny 指令12345# 禁止访问某个目录location ~* \\.(txt|doc)$&#123; root $doc_root; deny all;&#125; 6. 内置变量nginx的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。 $args：#这个变量等于请求行中的参数，同$query_string $content_length：请求头中的Content-length字段。 $content_type：请求头中的Content-Type字段。 $document_root：当前请求在root指令中指定的值。 $host：请求主机头字段，否则为服务器名称。 $http_user_agent：客户端agent信息 $http_cookie：客户端cookie信息 $limit_rate：这个变量可以限制连接速率。 $request_method：客户端请求的动作，通常为GET或POST。 $remote_addr：客户端的IP地址。 $remote_port：客户端的端口。 $remote_user：已经经过Auth Basic Module验证的用户名。 $request_filename：当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme：HTTP方法（如http，https）。 $server_protocol：请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。 $server_addr：服务器地址，在完成一次系统调用后可以确定这个值。 $server_name：服务器名称。 $server_port：请求到达服务器的端口号。 $request_uri：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri：不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri：与$uri相同","tags":["Nginx"],"categories":["Nginx"]},{"title":"Stellar主题自定义侧边栏教程「萌新向」","path":"/9b8cc433/","content":"Stellar主题自定义侧边栏教程「萌新向」 原文地址:Stellar主题自定义侧边栏教程「萌新向」 - SkyReeves 开篇废话在使用大佬@xaoxuu 开发的Stellar Hexo博客主题时，发现大佬的侧边栏不仅简介美观，还巨特娘的实用有木有！ 原本Stellar使用文档里也有设置教程 但是对于本萌来说还是犹如天书 不过在本萌的不懈努力下还是攻克了这道难题，记录成了这篇文章 具体步骤先看一下大佬的侧边栏: 这里的侧边栏由3部分组成 分组 折叠标签组 折叠标签 我们遇到的第一个难题就是 如何设置分组名为了方便展示，以下以本站的便笺页面为例进行讲解 创建分组在source/_data/projects.yml中增加一个项目： 123456789Notes: title: 便笺 description: index: false # 不在wiki列表中索引这个项目 sidebar: [toc] tags: 笔记 sections: &#x27;Hexo笔记&#x27;: [100, 199] &#x27;游戏&#x27;: [200, 299] 最后sections下的Hexo笔记和游戏便是我创建的分组 后面的区间值用于指定页面归属哪一个分区，在后面会讲 你有多少分组就写多少条，后面给不同的区间就行 注意： 在本站主题配置文件_config.yml里，便笺页面是以notes表示的 123456sidebar:... menu: post: &#x27;[主页](/)&#x27; notes: &#x27;[便笺](/notes/)&#x27; about: &#x27;[关于](/about/)&#x27; 所以上面增加的控制项是Notes 如果你是在其他页面编辑侧边栏 需要根据你自己的页面设置新增项的名称 第二个问题 创建折叠标签侧边栏里的折叠标签其实可以把他们理解为一篇文章 折叠标签就是文章的标题 标签展开后则是文章的分段目录 所以创建一个折叠标签其实就是写一篇文章而已 在scurce/notes/目录下新建一个文件夹，文件夹名称随意，只要你自己能分清楚就行 与上一步创建分组时一样，根据你自己的页面在对应的文件夹下操作 再在文件夹里创建一个index.md文件 如下图所示： 我这里就是在notes下新建了一个站点美化文件夹 再在里面创建index.md 我们可以看到这就是一篇md格式的文章 关键在于编辑index.md文件： 123456789101112---menu_id: noteslayout: wikiwiki: Notesbreadcrumb: falsetitle: 站点美化order: 101comments: false---## 这里title的值就是页面最终呈现的折叠标签名，本例中即为站点美化 标签归组接着说上面编辑的内容 order的值的作用就是将它定义到上个步骤里创建的分组里 比如上一步我在source/_data/projects.yml将[100,199]这个区间赋予给了Hexo笔记，我这里的order的值是101，在100至199这个区间内，所以页面最终的效果就是把站点美化归类到Hexo笔记这个分组下，如下图： 至此一个折叠标签做好了 至于index.md里除了title和order外的其他项 layout 的值固定为wiki，与第二项一同作用于侧边栏，如果没有它们侧边栏也会消失 wiki 的值写你在source/_data/projects.yml中新增的项目名 breadcrumb: false 表示本页面不显示顶部导航，如果你需要显示的话，把这一行删除即可 comments: false 表示本页面不启用评论版块，需要启用评论板块的话把值改成true 创建多个分组与多个折叠标签组当我们需要在侧边栏里写入多个折叠标签时 则与上一步一样，在scurce/notes/目录下再新建一个文件夹 再说一次，这是以本站的便笺页为例在操作，实际需要根据你自己的页面在对应的文件夹下进行 里面再新建一个index.md文件 通过给title和order不同的值来实现不同的标签名和分组 比如我在另一个文件夹里创建了一个新的index.md文件，title我定为博主游玩推荐，order值定为201，则最终在页面的效果就是一个名为博主游玩推荐的标签位于游戏分组下 题外话这里我们讨论的是在便笺页面里的侧边栏设置 那要是我连便笺页都没有怎么办 在blog所在的文件夹终端里执行： 1hexo new page &quot;notes&quot; 这会在scurce目录下创建 notes 文件夹，页面内容可以在里面的的 index.md 里编辑 然后在主题配置文件里将 sidebar.menu.notes 的注释取消掉，例如： 1234sidebar: menu: post: &#x27;[主页](/)&#x27; notes: &#x27;[便笺](/notes/)&#x27; 最终页面文件的构成如下： 在红框的index.md文件里编辑便笺主页内容 在蓝框的index.md文件里编辑Hexo笔记分组下的站点美化页 在绿框的index.md文件里编辑游戏分组里的博主游玩推荐页","tags":["教程","Stellar"],"categories":["教程","Stellar"]},{"title":"springboot利用ThreadPoolTaskExecutor多线程批量插入百万级数据","path":"/52fb8850/","content":"springboot利用ThreadPoolTaskExecutor多线程批量插入百万级数据 前言开发目的：提高百万级数据插入效率。采取方案：利用ThreadPoolTaskExecutor多线程批量插入。采用技术：springboot2.1.1+mybatisPlus3.0.6+swagger2.5.0+Lombok1.18.4+postgresql等。 具体实现细节application-dev.properties添加线程池配置信息123456789# 异步线程配置# 配置核心线程数async.executor.thread.core_pool_size = 30# 配置最大线程数async.executor.thread.max_pool_size = 30# 配置队列大小async.executor.thread.queue_capacity = 99988# 配置线程池中的线程的名称前缀async.executor.thread.name.prefix = async-importDB- spring容器注入线程池bean对象123456789101112131415161718192021222324252627282930313233@Configuration@EnableAsync@Slf4jpublic class ExecutorConfig &#123; @Value(&quot;$&#123;async.executor.thread.core_pool_size&#125;&quot;) private int corePoolSize; @Value(&quot;$&#123;async.executor.thread.max_pool_size&#125;&quot;) private int maxPoolSize; @Value(&quot;$&#123;async.executor.thread.queue_capacity&#125;&quot;) private int queueCapacity; @Value(&quot;$&#123;async.executor.thread.name.prefix&#125;&quot;) private String namePrefix; @Bean(name = &quot;asyncServiceExecutor&quot;) public Executor asyncServiceExecutor() &#123; log.warn(&quot;start asyncServiceExecutor&quot;); //在这里修改 ThreadPoolTaskExecutor executor = new VisiableThreadPoolTaskExecutor(); //配置核心线程数 executor.setCorePoolSize(corePoolSize); //配置最大线程数 executor.setMaxPoolSize(maxPoolSize); //配置队列大小 executor.setQueueCapacity(queueCapacity); //配置线程池中的线程的名称前缀 executor.setThreadNamePrefix(namePrefix); // rejection-policy：当pool已经达到max size的时候，如何处理新任务 // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); //执行初始化 executor.initialize(); return executor; &#125;&#125; 创建异步线程 业务类12345678910111213141516@Service@Slf4jpublic class AsyncServiceImpl implements AsyncService &#123;@Override@Async(&quot;asyncServiceExecutor&quot;)public void executeAsync(List&lt;LogOutputResult&gt; logOutputResults, LogOutputResultMapper logOutputResultMapper, CountDownLatch countDownLatch) &#123; try&#123; log.warn(&quot;start executeAsync&quot;); //异步线程要做的事情 logOutputResultMapper.addLogOutputResultBatch(logOutputResults); log.warn(&quot;end executeAsync&quot;); &#125;finally &#123; countDownLatch.countDown();// 很关键, 无论上面程序是否异常必须执行countDown,否则await无法释放 &#125; &#125;&#125; 创建多线程批量插入具体业务方法1234567891011121314151617@Overridepublic int testMultiThread() &#123; List&lt;LogOutputResult&gt; logOutputResults = getTestData(); //测试每100条数据插入开一个线程 List&lt;List&lt;LogOutputResult&gt;&gt; lists = ConvertHandler.splitList(logOutputResults, 100); CountDownLatch countDownLatch = new CountDownLatch(lists.size()); for (List&lt;LogOutputResult&gt; listSub:lists) &#123; asyncService.executeAsync(listSub, logOutputResultMapper,countDownLatch); &#125; try &#123; countDownLatch.await(); //保证之前的所有的线程都执行完成，才会走下面的； // 这样就可以在下面拿到所有线程执行完的集合结果 &#125; catch (Exception e) &#123; log.error(&quot;阻塞异常:&quot;+e.getMessage()); &#125; return logOutputResults.size(); &#125; 模拟2000003 条数据进行测试 多线程测试 2000003 耗时如下：耗时1.67分钟 本次开启30个线程，截图如下： 单线程测试2000003 耗时如下：耗时5.75分钟 检查多线程入库的数据，检查是否存在重复入库的问题：根据id分组，查看是否有id重复的数据，通过sql语句检查，没有发现重复入库的问题 检查数据完整性： 通过sql语句查询，多线程录入数据完整 测试结果不同线程数测试： 总结通过以上测试案列，同样是导入2000003 条数据，多线程耗时1.67分钟，单线程耗时5.75分钟。通过对不同线程数的测试，发现不是线程数越多越好，具体多少合适，网上有一个不成文的算法：CPU核心数量*2 +2 个线程。附：测试电脑配置","tags":["SpringBoot","Java","ThreadPoolTaskExecutor","线程"],"categories":["SpringBoot","ThreadPoolTaskExecutor","Java","线程"]},{"title":"SQL Server中的内置函数","path":"/cd25f69d/","content":"SQL Server中的内置函数 SQL Server中的内置函数前言：在Transact-SQL语言中，函数被用来执行一些特殊的运算以支持SQL Server的标准命令。SQL Server包含多种不同的函数用以完成各种工作，每一个函数都有一个名称，在名称之后有一对小括号，如：GETDATE()。大部分的函数在小括号中需要一个或多个参数。 常用的几类函数： 转换函数 用来实现数据类型之间的转换 字符串函数 用于控制返回给用户的字符串 日期函数 用于操作日期值 数学函数 用于对数值进行代数运算 系统函数 获取有关SQL Server中对象和设置的系统信息 其他函数 SQL Server中其他常用的函数 一、转换函数 函数名 描 述 示 例 CAST 将一种数据类型的表达式转换为另一种数据类型的表达式 SELECT CAST(12345 AS VARCHAR(5)) 返回：字符串12345 CONVERT 将一种数据类型的表达式转换为另一种数据类型的表达式 SELECT CONVERT(VARCHAR(5),12345) 返回：字符串12345 二、字符串函数 函数名 描 述 示 例 CHARINDEX 寻找一个指定的字符串在另一个字符串中的起始位置 SELECT CHARINDEX(‘Server’,‘SQL Server课程’,1) 返回：5 DATALENGTH 返回用来表示任何表达式的字节数 SELECT DATALENGTH(‘SQL Server’) 返回：10 LEN 返回传递给它的字符串长度 SELECT LEN(‘SQL Server课程’) 返回：12 UPPER 把传递给它的字符串转换为大写 SELECT UPPER(‘sql server课程’) 返回：SQL SERVER课程 LOWER 把传递给它的字符串转换为小写 SELECT LOWER(‘SQL SERVER课程’) 返回：sql server课程 LTRIM 清除字符左边的空格 SELECT LTRIM(’ 数据库 ‘) 返回：数据库 （后面的空格保留） RTRIM 清除字符右边的空格 SELECT RTRIM(’ 数据库 ‘) 返回： 数据库 （前面的空格保留） LEFT 从字符串左边返回指定数目的字符 SELECT LEFT(‘SQL Server课程’,3) 返回：SQL RIGHT 从字符串右边返回指定数目的字符 SELECT RIGHT(‘SQL Server课程’,2) 返回：课程 SUBSTRING 从字符串中间返回指定数目的字符 SELECT SUBSTRING(‘SQL Server课程’,5,6) 返回：Server REPLACE 替换一个字符串中的字符 SELECT REPLACE(‘SQL Server课程’,‘课程’,‘数据库’) 返回：SQL Server数据库 REVERSE 按相反顺序返回字符串表达式 SELECT REVERSE(‘SQL Server课程’) 返回：程课revreS LQS STUFF 在一个字符串中，删除指定长度的字符，并在该位置插入一个新的字符串 SELECT STUFF(‘MySQL课程’,1,2,‘我的’) 返回：我的SQL课程 SPACE 返回由重复的空格组成的字符串 SELECT SPACE(5) 返回：返回5个空格 REPLICATE 返回多次复制后的字符表达式 SELECT REPLICATE(’+’,3) 返回：+++ PATINDEX 返回指定表达式中某模式第一次出现的起始位置 SELECT PATINDEX(’%数据%’,‘MySQL数据库入门’) 返回：6 STR 返回由数字数据转换来的字符数据 SELECT STR(123.45,6,1) 返回：123.5 CHAR 将int ASCII代码转换为字符 SELECT CHAR(65) 返回：A 三、日期函数 函数名 描 述 示 例 GETDATE 取得当前的系统函数 SELECT GETDATE() 返回：今天的日期 DATEADD 将指定的数值添加到指定的日期部分后的日期 SELECT DATEADD(mm,4,‘2020-5-6’) 返回：2020-9-6 DATEDIFF 两个日期之间的指定日期部分的间隔 SELECT DATEDIFF(mm,‘2019-3-25’,‘2020-5-6’) 返回：14 DATENAME 日期中指定日期部分的字符串形式 SELECT DATENAME(dw,‘2020-5-6’) 返回：星期三 DATEPART 日期中指定日期部分的整数形式 SELECT DATEPART(yy,‘2020-5-6’) 返回：2020 DAY、MONTH、YEAR 返回一个整数 SELECT MONTH(GETDATE()) 返回：5 四、数学函数 函数名 描 述 示 例 RAND 返回从0到1之间的随机float值 SELECT RAND() 返回：0.9857313976146 ABS 返回数值表达式的绝对值 SELECT ABS(-45) 返回：45 ASCII 返回字符表达式中最左侧的字符的ASCII代码值 SELECT ASCII(‘a’) 返回：97 CEILING 返回大于或等于指定数值、表达式的最小整数 SELECT CEILING(43.5) 返回：44 FLOOR 返回小于或等于指定表达式的最大整数 SELECT FLOOR(43.5) 返回：43 PI 返回PI的常量值 SELECT PI() 返回：3.14159265358979 POWER 返回数值表达式的幂值 SELECT POWER(5,2) 返回：25 SQUARE 返回指定浮点值的平方 SELECT SQUARE(2.3) 返回：5.29 ROUND 将数值表达式四舍五入为指定精度 SELECT ROUND(43.543,1) 返回：43.500 SIGN 对于正数返回+1，对于负数返回-1，对于0则返回0 SELECT SIGN(-43) 返回：-1 SQRT 返回浮点表达式的平方根 SELECT SQRT(9) 返回：3 五、系统函数 函数名 描 述 示 例 CONVERT 用来转变数据类型 SELECT CONVERT(VARCHAR(5),12345) 返回：字符串12345 CURRENT_USER 返回当前用户的名称 SELECT CURRENT_USER 返回：你登录的用户名 DATALENGTH 返回用于指定表达式的字节数 SELECT DATALENGTH(‘SQL Server课程’) 返回：14 HOST_NAME 返回当前用户所登录的计算机名字 SELECT HOST_NAME() 返回：你所登录的计算机的名字 SYSTEM_USER 返回当前所登录的用户名称 SELECT SYSTEM_USER 返回：你当前所登录的用户名 USER_NAME 从给定的用户ID返回用户名 SELECT USER_NAME(1) 返回：从任意数据库中返回“dbo” 六、其他函数 函数名 描 述 示 例 ISDATE 判断有效日期或时间值，则返回1；否则，返回0 SELECT ISDATE(‘2020-2-29’) 返回：1（有效，因为2020年2月有29天） ISNULL 使用指定的替换值替换NULL SELECT sName,ISNULL(sScore,0) FROM student 返回：将student表中sScore列中值为“NULL”的，替换为0 NULLIF 如果两个指定的表达式相等，则返回空值 SELECT NULLIF(‘SQL’,‘SQL’) 返回：NULL ISNUMERIC 确定表达式是否为有效的数据类型，则返回 1；否则，返回 0 SELECT ISNUMERIC(3) 返回：1（int,numeric,bigint, money,smallint,smallmoney tinyint,float,decimal,real） COALESCE 返回其参数中第一个非空表达式 SELECT COALESCE(NULL,NULL,N’A’,NULL,NULL) 返回：A","tags":["数据库","SqlServer"],"categories":["SqlServer","数据库"]},{"title":"基于Vue+SpringBoot的支付宝支付功能","path":"/e7f97db4/","content":"基于Vue+SpringBoot的支付宝支付功能 1、演示说明1-1、先来看看最终效果： 2-1、说明 这并不是真正的支付，是支付宝提供的一个测试。之所以没有使用正式的支付，是因为支付宝（微信也是）不提供个人开发者功能，只有商户审核通过了才可以有这个功能。所有这里使用的是沙箱测试。 2、环境准备2-1、我们要去支付申请一个沙箱测试账号 https://openhome.alipay.com/platform/appDaily.htm?tab=info2-2、生成 RSA2，这里是需要下载一个支付宝提供的客户端 https://docs.open.alipay.com/291/1059712-3、下载 【沙箱版支付宝】 因为这是测试环境，所有所有的金额都是测试。不可以使用我们正式的支付宝。 3、环境搭建3-1：前端环境搭建1、首先你只需要写一个这样的页面就好了，提供四个参数 123456789101112this.$axios.post(&#x27;url&#x27;,this.payInfo).then(resp =&gt; &#123; // 添加之前先删除一下，如果单页面，页面不刷新，添加进去的内容会一直保留在页面中，二次调用form表单会出错 const divForm = document.getElementsByTagName(&#x27;div&#x27;) if (divForm.length) &#123; document.body.removeChild(divForm[0]) &#125; const div = document.createElement(&#x27;div&#x27;) div.innerHTML = resp.data // data就是接口返回的form 表单字符串 document.body.appendChild(div) document.forms[0].setAttribute(&#x27;target&#x27;, &#x27;_blank&#x27;) // 新开窗口跳转 document.forms[0].submit() &#125;) 3-2：后端环境搭建主要的pom 123456789101112&lt;!-- 支付宝支付jar包 --&gt;&lt;dependency&gt;\t&lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;\t&lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;\t&lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- fastjson --&gt;&lt;dependency&gt;\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\t&lt;artifactId&gt;fastjson&lt;/artifactId&gt;\t&lt;version&gt;1.2.48&lt;/version&gt;&lt;/dependency&gt; AlipayConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.xdx97.framework.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;/** * 配置文件读取 * @author 小道仙 * @date 2020年2月18日 */@Configuration@ConfigurationProperties@PropertySource(&quot;classpath:config/alipay.properties&quot;)@Data@Componentpublic class AlipayConfig &#123; /** * 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号 */ private String appId; /** * 商户私钥，您的PKCS8格式RSA2私钥 */ private String privateKey; /** * 支付宝公钥, */ private String publicKey; /** * 服务器异步通知页面路径需http://格式的完整路径，不能加?id=123这类自定义参数 */ private String notifyUrl; /** * 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数 */ private String returnUrl; /** * 签名方式 */ private String signType; /** * 字符编码格式 */ private String charset; /** * 支付宝网关 */ private String gatewayUrl; /** * 支付宝网关 */ private String logPath;&#125; PayController12345678910111213141516171819202122232425262728293031323334import com.alipay.api.AlipayApiException;import com.xdx97.framework.service.PayService;import com.xdx97.framework.entitys.pay.AlipayBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;/** * 支付宝沙箱测试 * @author 小道仙 * @date 2020年2月17日 */@RestControllerpublic class PayController &#123; @Autowired private PayService payService; /** * 阿里支付 * @param tradeNo * @param subject * @param amount * @param body * @return * @throws AlipayApiException */ @PostMapping(value = &quot;order/alipay&quot;) public String alipay(String outTradeNo, String subject, String totalAmount, String body) throws AlipayApiException &#123; AlipayBean alipayBean = new AlipayBean(); alipayBean.setOut_trade_no(outTradeNo); alipayBean.setSubject(subject); alipayBean.setTotal_amount(totalAmount); alipayBean.setBody(body); return payService.aliPay(alipayBean); &#125;&#125; AlipayBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 支付实体对象 * 根据支付宝接口协议，其中的属性名，必须使用下划线，不能修改 * @author 小道仙 * @date 2020年2月18日 */public class AlipayBean &#123; /** * 商户订单号，必填 * */ private String out_trade_no; /** * 订单名称，必填 */ private String subject; /** * 付款金额，必填 * 根据支付宝接口协议，必须使用下划线 */ private String total_amount; /** * 商品描述，可空 */ private String body; /** * 超时时间参数 */ private String timeout_express= &quot;10m&quot;; /** * 产品编号 */ private String product_code= &quot;FAST_INSTANT_TRADE_PAY&quot;; public String getOut_trade_no() &#123; return out_trade_no; &#125; public void setOut_trade_no(String out_trade_no) &#123; this.out_trade_no = out_trade_no; &#125; public String getSubject() &#123; return subject; &#125; public void setSubject(String subject) &#123; this.subject = subject; &#125; public String getTotal_amount() &#123; return total_amount; &#125; public void setTotal_amount(String total_amount) &#123; this.total_amount = total_amount; &#125; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getTimeout_express() &#123; return timeout_express; &#125; public void setTimeout_express(String timeout_express) &#123; this.timeout_express = timeout_express; &#125; public String getProduct_code() &#123; return product_code; &#125; public void setProduct_code(String product_code) &#123; this.product_code = product_code; &#125;&#125; PayService12345678910111213141516import com.alipay.api.AlipayApiException;import com.xdx97.framework.entitys.pay.AlipayBean;/** * 支付服务 * @author Louis * @date Dec 12, 2018 */public interface PayService &#123; /** * 支付宝支付接口 * @param alipayBean * @return * @throws AlipayApiException */ String aliPay(AlipayBean alipayBean) throws AlipayApiException;&#125; PayServiceImpl123456789101112131415import com.xdx97.framework.service.PayService;import com.xdx97.framework.utils.pay.Alipay;import com.xdx97.framework.entitys.pay.AlipayBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.alipay.api.AlipayApiException;@Servicepublic class PayServiceImpl implements PayService &#123; @Autowired private Alipay alipay; @Override public String aliPay(AlipayBean alipayBean) throws AlipayApiException &#123; return alipay.pay(alipayBean); &#125;&#125; Alipay12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.xdx97.framework.config.AlipayConfig;import com.xdx97.framework.entitys.pay.AlipayBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import com.alibaba.fastjson.JSON;import com.alipay.api.AlipayApiException;import com.alipay.api.AlipayClient;import com.alipay.api.DefaultAlipayClient;import com.alipay.api.request.AlipayTradePagePayRequest;/** * 支付宝支付接口 * @author 小道仙 * @date 2020年2月18日 */@Componentpublic class Alipay &#123; @Autowired private AlipayConfig alipayConfig; /** * 支付接口 * @param alipayBean * @return * @throws AlipayApiException */ public String pay(AlipayBean alipayBean) throws AlipayApiException &#123; // 1、获得初始化的AlipayClient String serverUrl = alipayConfig.getGatewayUrl(); String appId = alipayConfig.getAppId(); String privateKey = alipayConfig.getPrivateKey(); String format = &quot;json&quot;; String charset = alipayConfig.getCharset(); String alipayPublicKey = alipayConfig.getPublicKey(); String signType = alipayConfig.getSignType(); String returnUrl = alipayConfig.getReturnUrl(); String notifyUrl = alipayConfig.getNotifyUrl(); AlipayClient alipayClient = new DefaultAlipayClient(serverUrl, appId, privateKey, format, charset, alipayPublicKey, signType); // 2、设置请求参数 AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest(); // 页面跳转同步通知页面路径 alipayRequest.setReturnUrl(returnUrl); // 服务器异步通知页面路径 alipayRequest.setNotifyUrl(notifyUrl); // 封装参数 alipayRequest.setBizContent(JSON.toJSONString(alipayBean)); // 3、请求支付宝进行付款，并获取支付结果 String result = alipayClient.pageExecute(alipayRequest).getBody(); // 返回付款信息 return result; &#125;&#125; alipay.properties下面需要配置你的沙箱账号和，密钥 123456789101112131415161718# 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号appId: # 商户私钥，您的PKCS8格式RSA2私钥privateKey: # 支付宝公钥,查看地址：https://openhome.com/platform/keyManage.htm 对应APPID下的支付宝公钥。publicKey: # 服务器异步通知页面路径需http://格式的完整路径，不能加?id=123这类自定义参数notifyUrl: # 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数returnUrl: http://localhost:8080/#/pay/success# 签名方式signType: RSA2# 字符编码格式charset: utf-8# 支付宝网关gatewayUrl: https://openapi.alipaydev.com/gateway.do# 支付宝日志logPath: &quot;C:\\\\&quot;","tags":["SpringBoot","Vue","支付宝支付"],"categories":["SpringBoot","Vue","支付宝支付"]},{"title":"SpringBoot+Vue实现微信扫码支付、退款功能","path":"/aa578cc6/","content":"SpringBoot+Vue实现微信扫码支付、退款功能 来源：blog.csdn.net&#x2F;weixin_52210557&#x2F;article&#x2F;details&#x2F;124521459 直接上代码，在order模块添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt;&lt;/dependency&gt; 在配置类添加申请的商家号信息 123456#关联的公众号appidweixin.pay.appid=wxXXXXXXX#商户号weixin.pay.partner=XXXXXXXXX#商户keyweixin.pay.partnerkey=XXXXXXXXXX 添加微信生成二维码service 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Servicepublic class WeiXinServiceImpl implements WeiXinService &#123; @Autowired private PaymentInfoService paymentInfoService; @Autowired private OrderInfoService orderInfoService; @Autowired private WeiXinService weiXinService; //生成支付的二维码 @Override public Map createNative(Long orderId) &#123; //支付记录表添加数据 //根据单号查询订单相关信息 OrderInfo orderInfo = orderInfoService.getById(orderId); if (orderInfo == null)&#123; throw new OrderException(20001,&quot;订单不存在&quot;); &#125; //添加订单状态 paymentInfoService.savePaymentInfo(orderInfo,PaymentTypeEnum.WEIXIN.getStatus()); //调用微信接口返回二维码 try &#123; //2 调用微信接口，得到二维码地址等信息 //封装传递微信地址参数 Map paramMap = new HashMap(); paramMap.put(&quot;appid&quot;, ConstantPropertiesUtils.APPID); //公众号id paramMap.put(&quot;mch_id&quot;, ConstantPropertiesUtils.PARTNER); //商户号 paramMap.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); //随机字符串，调用工具类 Date reserveDate = orderInfo.getReserveDate(); String reserveDateString = new DateTime(reserveDate).toString(&quot;yyyy/MM/dd&quot;); String body = reserveDateString + &quot;就诊&quot;+ orderInfo.getDepname(); paramMap.put(&quot;body&quot;, body);//扫码后手机显示内容 paramMap.put(&quot;out_trade_no&quot;, orderInfo.getOutTradeNo()); //订单流水号 //paramMap.put(&quot;total_fee&quot;, order.getAmount().multiply(new BigDecimal(&quot;100&quot;)).longValue()+&quot;&quot;); paramMap.put(&quot;total_fee&quot;, &quot;1&quot;);//TODO 为了测试 支付金额 paramMap.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;); //终端ip paramMap.put(&quot;notify_url&quot;, &quot;http://xxxxxxxxx&quot;);//回调地址 paramMap.put(&quot;trade_type&quot;, &quot;NATIVE&quot;); //二维码类型 //请求微信生成二维码接口 HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;); //设置post请求相关参数 //微信支付要求传递参数xml格式 //把封装map集合变成xml，加密处理，传输 String xml = WXPayUtil.generateSignedXml(paramMap, ConstantPropertiesUtils.PARTNERKEY); client.setXmlParam(xml); //支持https协议 client.setHttps(true); //发送 client.post(); //调用微信接口，返回数据,xml格式的数据 String resultXml = client.getContent(); System.out.println(&quot;微信二维码：&quot;+resultXml); //把xml格式数据转换map Map&lt;String, String&gt; resultMap = WXPayUtil.xmlToMap(resultXml); Map map = new HashMap&lt;&gt;(); map.put(&quot;orderId&quot;, orderId); map.put(&quot;totalFee&quot;, orderInfo.getAmount()); map.put(&quot;resultCode&quot;, resultMap.get(&quot;result_code&quot;)); map.put(&quot;codeUrl&quot;, resultMap.get(&quot;code_url&quot;)); //微信二维码地址 return map; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new orderException(20001,&quot;生成二维码失败&quot;); &#125; &#125;&#125; 控制层 12345678910111213141516@RestController@RequestMapping(&quot;/api/order/weixin&quot;)public class WeixinController &#123; @Autowired private WeiXinService weixinPayService; /** * 下单 生成二维码 */ @GetMapping(&quot;/createNative/&#123;orderId&#125;&quot;) public R createNative( @ApiParam(name = &quot;orderId&quot;, value = &quot;订单id&quot;, required = true) @PathVariable(&quot;orderId&quot;) Long orderId) &#123; Map map = weixinPayService.createNative(orderId); return R.ok().data(map); &#125;&#125; 前端微信支付二维码，wx.js定义方法 123456createNative(orderId) &#123; return request(&#123; url: `/api/order/weixin/createNative/$&#123;orderId&#125;`, method: &#x27;get&#x27; &#125;)&#125; 显示二维码需要前端安装插件 安装npm install vue-qriously 订单详情页，修改order&#x2F;show.vue组件 1234567891011121314151617181920212223242526272829303132333435import weixinApi from &#x27;@/api/yygh/wx&#x27;&lt;!-- 微信支付弹出框 --&gt; &lt;el-dialog :visible.sync=&quot;dialogPayVisible&quot; style=&quot;text-align: left&quot; :append-to-body=&quot;true&quot; width=&quot;500px&quot; @close=&quot;closeDialog&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;operate-view&quot; style=&quot;height: 350px;&quot;&gt; &lt;div class=&quot;wrapper wechat&quot;&gt; &lt;div&gt; &lt;qriously :value=&quot;payObj.codeUrl&quot; :size=&quot;220&quot;/&gt; &lt;div style=&quot;text-align: center;line-height: 25px;margin-bottom: 40px;&quot;&gt; 请使用微信扫一扫&lt;br/&gt; 扫描二维码支付 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-dialog&gt; //生成二维码 pay() &#123; //弹框 this.dialogPayVisible = true //调用接口 weixinApi.createNative(this.orderId).then(response =&gt; &#123; this.payObj = response.data if(this.payObj.codeUrl == &#x27;&#x27;) &#123; this.dialogPayVisible = false this.$message.error(&quot;支付错误&quot;) &#125; else &#123; //每隔3秒查询一次支付状态 this.timer = setInterval(()=&gt;&#123; this.queryPayStatus(this.orderId) &#125;,3000) &#125; &#125;) &#125;, 查询订单支付状态，添加定时器方法，每隔3秒去查询一次支付状态，api 123456queryPayStatus(orderId) &#123; return request(&#123; url: `/api/order/weixin/queryPayStatus/$&#123;orderId&#125;`, method: &#x27;get&#x27; &#125;)&#125;, 后端，weixinservice封装信息请求微信提供的接口，判断是否支付成功，因为微信返回的是xml文件，所以需要转换 123456789101112131415161718192021222324252627282930//调用微信接口查询支付状态@Overridepublic Map queryPayStatus(Long orderId, String paymentType) &#123; //1 根据orderId查询订单信息 OrderInfo orderInfo = orderInfoService.getById(orderId); if(orderInfo == null) &#123; throw new orderException(20001,&quot;订单不存在&quot;); &#125; try &#123; //2 封装微信接口需要数据 Map paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;appid&quot;, ConstantPropertiesUtils.APPID); paramMap.put(&quot;mch_id&quot;, ConstantPropertiesUtils.PARTNER); paramMap.put(&quot;out_trade_no&quot;, orderInfo.getOutTradeNo()); paramMap.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); //3 调用微信接口，传递数据，设置参数 HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/pay/orderquery&quot;); client.setXmlParam(WXPayUtil.generateSignedXml(paramMap,ConstantPropertiesUtils.PARTNERKEY)); client.setHttps(true); client.post(); //4 获取微信接口返回数据 String xml = client.getContent(); System.out.println(&quot;支付状态返回xml: &quot;+xml); Map&lt;String, String&gt; resultMap = WXPayUtil.xmlToMap(xml); return resultMap; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new orderException(20001,&quot;查询失败&quot;); &#125;&#125; 支付成功后，更新状态 控制层，查询状态 123456789101112131415161718@ApiOperation(value = &quot;查询支付状态&quot;)@GetMapping(&quot;/queryPayStatus/&#123;orderId&#125;&quot;)public Result queryPayStatus( @ApiParam(name = &quot;orderId&quot;, value = &quot;订单id&quot;, required = true) @PathVariable(&quot;orderId&quot;) Long orderId) &#123; //调用查询接口 Map&lt;String, String&gt; resultMap = weixinPayService.queryPayStatus(orderId, PaymentTypeEnum.WEIXIN.name()); if (resultMap == null) &#123;//出错 return Result.fail().message(&quot;支付出错&quot;); &#125; if (&quot;SUCCESS&quot;.equals(resultMap.get(&quot;trade_state&quot;))) &#123;//如果成功 //更改订单状态，处理支付结果 String out_trade_no = resultMap.get(&quot;out_trade_no&quot;); paymentInfoService.paySuccess(out_trade_no, PaymentTypeEnum.WEIXIN.getStatus(), resultMap); return Result.ok().message(&quot;支付成功&quot;); &#125; return Result.ok().message(&quot;支付中&quot;);&#125; 退款退款与支付唯一不同的是需要在下载微信提供的退款证书，下载好后通过配置文件加载退款证书路径 1weixin.cert=C:\\\\apiclient_cert.p12 weixinservice中 123456789101112131415161718192021222324252627282930313233343536373839//退款@Overridepublic Boolean refund(Long orderId) &#123; //1 根据订单号查询订单支付记录信息 QueryWrapper&lt;PaymentInfo&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_id&quot;,orderId); PaymentInfo paymentInfo = paymentInfoService.getOne(wrapper); //2 TODO 添加退款信息到退款表 try &#123; //3 调用微信退款接口 //封装微信接口需要数据 Map&lt;String,String&gt; paramMap = new HashMap&lt;&gt;(8); paramMap.put(&quot;appid&quot;,ConstantPropertiesUtils.APPID); //公众账号ID paramMap.put(&quot;mch_id&quot;,ConstantPropertiesUtils.PARTNER); //商户编号 paramMap.put(&quot;nonce_str&quot;,WXPayUtil.generateNonceStr()); paramMap.put(&quot;transaction_id&quot;,paymentInfo.getTradeNo()); //微信订单号 paramMap.put(&quot;out_trade_no&quot;,paymentInfo.getOutTradeNo()); //商户订单编号 paramMap.put(&quot;out_refund_no&quot;,&quot;tk&quot;+paymentInfo.getOutTradeNo()); //商户退款单号 // paramMap.put(&quot;total_fee&quot;,paymentInfoQuery.getTotalAmount().multiply(new BigDecimal(&quot;100&quot;)).longValue()+&quot;&quot;); // paramMap.put(&quot;refund_fee&quot;,paymentInfoQuery.getTotalAmount().multiply(new BigDecimal(&quot;100&quot;)).longValue()+&quot;&quot;); paramMap.put(&quot;total_fee&quot;,&quot;1&quot;); paramMap.put(&quot;refund_fee&quot;,&quot;1&quot;); //设置接口和参数 HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/secapi/pay/refund&quot;); client.setXmlParam(WXPayUtil.generateSignedXml(paramMap,ConstantPropertiesUtils.PARTNERKEY)); client.setHttps(true); client.setCert(true);//退款证书 client.setCertPassword(ConstantPropertiesUtils.PARTNER);//证书密码 商户key //发送post请求 client.post(); //4、返回退款数据 String xml = client.getContent(); Map&lt;String, String&gt; resultMap = WXPayUtil.xmlToMap(xml); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;","tags":["SpringBoot","Vue","微信支付"],"categories":["SpringBoot","Vue","微信支付"]},{"title":"过滤器和拦截器的5个区别！","path":"/5df02e95/","content":"过滤器和拦截器的5个区别！ 过滤器（Filter）和拦截器（Interceptor）都是基于 AOP（Aspect Oriented Programming，面向切面编程）思想实现的，用来解决项目中某一类问题的两种“工具”，但二者有着明显的差距，接下来我们一起来看。 实现过滤器和拦截器首先，我们先来看一下二者在 Spring Boot 项目中的具体实现，这对后续理解二者的区别有很大的帮助。 实现过滤器过滤器可以使用 Servlet 3.0 提供的 @WebFilter 注解，配置过滤的 URL 规则，然后再实现 Filter 接口，重写接口中的 doFilter 方法，具体实现代码如下： 12345678910111213141516171819202122232425import org.springframework.stereotype.Component;import javax.servlet.;import javax.servlet.annotation.WebFilter;import java.io.IOException;@Component@WebFilter(urlPatterns = &quot;/*&quot;)public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;过滤器：执行 init 方法。&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;过滤器：开始执行 doFilter 方法。&quot;); // 请求放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;过滤器：结束执行 doFilter 方法。&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;过滤器：执行 destroy 方法。&quot;); &#125;&#125; 其中： void init(FilterConfig filterConfig)：容器启动（初始化 Filter）时会被调用，整个程序运行期只会被调用一次。用于实现 Filter 对象的初始化。 void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)：具体的过滤功能实现代码，通过此方法对请求进行过滤处理，其中 FilterChain 参数是用来调用下一个过滤器或执行下一个流程。 void destroy()：用于 Filter 销毁前完成相关资源的回收工作。 实现拦截器 拦截器的实现分为两步，第一步，创建一个普通的拦截器，实现 HandlerInterceptor 接口，并重写接口中的相关方法；第二步，将上一步创建的拦截器加入到 Spring Boot 的配置文件中。接下来，先创建一个普通拦截器，实现 HandlerInterceptor 接口并重写 preHandle&#x2F;postHandle&#x2F;afterCompletion 方法，具体实现代码如下： 123456789101112131415161718192021import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class TestInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;拦截器：执行 preHandle 方法。&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;拦截器：执行 postHandle 方法。&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;拦截器：执行 afterCompletion 方法。&quot;); &#125;&#125; 其中： boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)：在请求方法执行前被调用，也就是调用目标方法之前被调用。比如我们在操作数据之前先要验证用户的登录信息，就可以在此方法中实现，如果验证成功则返回 true，继续执行数据操作业务；否则就返回 false，后续操作数据的业务就不会被执行了。 void postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)：调用请求方法之后执行，但它会在 DispatcherServlet 进行渲染视图之前被执行。 void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)：会在整个请求结束之后再执行，也就是在 DispatcherServlet 渲染了对应的视图之后再执行。 最后，我们再将上面的拦截器注入到项目配置文件中，并设置相应拦截规则，具体实现代码如下： 12345678910111213141516import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class AppConfig implements WebMvcConfigurer &#123; // 注入拦截器 @Autowired private TestInterceptor testInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(testInterceptor) // 添加拦截器 .addPathPatterns(&quot;/*&quot;); // 拦截所有地址 &#125;&#125; 了解了二者的使用之后，接下来我们来看二者的区别。 过滤器 VS 拦截器过滤器和拦截器的区别主要体现在以下 5 点： 出身不同； 触发时机不同； 实现不同； 支持的项目类型不同； 使用的场景不同。 接下来，我们一一来看。 1.出身不同过滤器来自于 Servlet，而拦截器来自于 Spring 框架，从上面代码中我们也可以看出，过滤器在实现时导入的是 Servlet 相关的包，如下图所示：而拦截器在实现时，导入的是 Spring 相关的包，如下图所示： 2.触发时机不同请求的执行顺序是：请求进入容器 &gt; 进入过滤器 &gt; 进入 Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller），如下图所示：所以过滤器和拦截器的执行时机也是不同的，过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。 3.实现不同过滤器是基于方法回调实现的，我们在上面实现过滤器的时候就会发现，当我们要执行下一个过滤器或下一个流程时，需要调用 FilterChain 对象的 doFilter 方法进行回调执行，如下图所示：由此可以看出，过滤器的实现是基于方法回调的。而拦截器是基于动态代理（底层是反射）实现的，它的实现如下图所示：代理调用的效果如下图所示： 4.支持的项目类型不同过滤器是 Servlet 规范中定义的，所以过滤器要依赖 Servlet 容器，它只能用在 Web 项目中；而拦截器是 Spring 中的一个组件，因此拦截器既可以用在 Web 项目中，同时还可以用在 Application 或 Swing 程序中。 5.使用的场景不同因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务。而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。 本文项目源码下载https://gitee.com/mydb/springboot-examples/tree/master/spring-boot-filter 总结过滤器和拦截器都是基于 AOP 思想实现的，用来处理某个统一的功能的，但二者又有 5 点不同：出身不同、触发时机不同、实现不同、支持的项目类型不同以及使用的场景不同。过滤器通常是用来进行全局过滤的，而拦截器是用来实现某项业务拦截的。 参考 &amp; 鸣谢 blog.csdn.net&#x2F;wo541075754&#x2F;article&#x2F;details&#x2F;111661213 zhuanlan.zhihu.com&#x2F;p&#x2F;340397290","tags":["学习","SpringBoot","Java","过滤器","拦截器"],"categories":["学习","Java","SpringBoot","过滤器","拦截器"]},{"title":"如何用Java几分钟处理完30亿个数据?","path":"/a233dc51/","content":"如何用Java几分钟处理完30亿个数据? 1. 场景说明 现有一个 10G 文件的数据，里面包含了 18-70 之间的整数，分别表示 18-70 岁的人群数量统计。假设年龄范围分布均匀，分别表示系统中所有用户的年龄数，找出重复次数最多的那个数，现有一台内存为 4G、2 核 CPU 的电脑，请写一个算法实现。 123,31,42,19,60,30,36,........ 2. 模拟数据 Java 中一个整数占 4 个字节，模拟 10G 为 30 亿左右个数据， 采用追加模式写入 10G 数据到硬盘里。 每 100 万个记录写一行，大概 4M 一行，10G 大概 2500 行数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package bigdata;import java.io.*;import java.util.Random;/** * @Desc: * @Author: bingbing * @Date: 2022/5/4 0004 19:05 */public class GenerateData &#123; private static Random random = new Random(); public static int generateRandomData(int start, int end) &#123; return random.nextInt(end - start + 1) + start; &#125; /** * 产生10G的 1-1000的数据在D盘 */ public void generateData() throws IOException &#123; File file = new File(&quot;D:\\\\ User.dat&quot;); if (!file.exists()) &#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; int start = 18; int end = 70; long startTime = System.currentTimeMillis(); BufferedWriter bos = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file, true))); for (long i = 1; i &lt; Integer.MAX_VALUE * 1.7; i++) &#123; String data = generateRandomData(start, end) + &quot;,&quot;; bos.write(data); // 每100万条记录成一行，100万条数据大概4M if (i % 1000000 == 0) &#123; bos.write(&quot; &quot;); &#125; &#125; System.out.println(&quot;写入完成! 共花费时间:&quot; + (System.currentTimeMillis() - startTime) / 1000 + &quot; s&quot;); bos.close(); &#125; public static void main(String[] args) &#123; GenerateData generateData = new GenerateData(); try &#123; generateData.generateData(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上述代码调整参数执行 2 次，凑 10G 数据在 D 盘 User.dat 文件里： 准备好 10G 数据后，接着写如何处理这些数据。 3. 场景分析 10G 的数据比当前拥有的运行内存大的多，不能全量加载到内存中读取。如果采用全量加载，那么内存会直接爆掉，只能按行读取。Java 中的 bufferedReader 的 readLine() 按行读取文件里的内容。 4. 读取数据 首先，我们写一个方法单线程读完这 30 亿数据需要多少时间，每读 100 行打印一次： 12345678910111213141516private static void readData() throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(FILE_NAME), &quot;utf-8&quot;)); String line; long start = System.currentTimeMillis(); int count = 1; while ((line = br.readLine()) != null) &#123; // 按行读取 if (count % 100 == 0) &#123; System.out.println(&quot;读取100行,总耗时间: &quot; + (System.currentTimeMillis() - start) / 1000 + &quot; s&quot;); System.gc(); &#125; count++; &#125; running = false; br.close();&#125; 按行读完 10G 的数据大概 20 秒，基本每 100 行，1 亿多数据花 1 秒，速度还挺快。 5. 处理数据 5.1 思路一 通过单线程处理，初始化一个 countMap，key 为年龄，value 为出现的次数。将每行读取到的数据按照 “,” 进行分割，然后获取到的每一项进行保存到 countMap 里。如果存在，那么值 key 的 value+1。 12345678910111213for (int i = start; i &lt;= end; i++) &#123; try &#123; File subFile = new File(dir + &quot;\\\\&quot; + i + &quot;.dat&quot;); if (!file.exists()) &#123; subFile.createNewFile(); &#125; countMap.computeIfAbsent(i + &quot;&quot;, integer -&gt; new AtomicInteger(0)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 单线程读取并统计 countMap： 123456789public static void splitLine(String lineData) &#123; String[] arr = lineData.split(&quot;,&quot;); for (String str : arr) &#123; if (StringUtils.isEmpty(str)) &#123; continue; &#125; countMap.computeIfAbsent(str, s -&gt; new AtomicInteger(0)).getAndIncrement(); &#125;&#125; 通过比较找出年龄数最多的年龄并打印出来： 123456789101112131415private static void findMostAge() &#123; Integer targetValue = 0; String targetKey = null; Iterator&lt;Map.Entry&lt;String, AtomicInteger&gt;&gt; entrySetIterator = countMap.entrySet().iterator(); while (entrySetIterator.hasNext()) &#123; Map.Entry&lt;String, AtomicInteger&gt; entry = entrySetIterator.next(); Integer value = entry.getValue().get(); String key = entry.getKey(); if (value &gt; targetValue) &#123; targetValue = value; targetKey = key; &#125; &#125; System.out.println(&quot;数量最多的年龄为:&quot; + targetKey + &quot;数量为：&quot; + targetValue);&#125; 测试结果 总共花了 3 分钟读取完并统计完所有数据。 内存消耗为 2G-2.5G，CPU 利用率太低，只向上浮动了 20%-25% 之间。 要想提高 CPU 利用率，那么可以使用多线程去处理。 下面我们使用多线程去解决这个 CPU 利用率低的问题。 5.2 思路二：分治法 使用多线程去消费读取到的数据。采用生产者、消费者模式去消费数据。 因为在读取的时候是比较快的，单线程的数据处理能力比较差。因此思路一的性能阻塞在取数据的一方且又是同步操作，导致整个链路的性能会变的很差。所谓分治法就是分而治之，也就是说将海量数据分割处理。 根据 CPU 的能力初始化 n 个线程，每一个线程去消费一个队列，这样线程在消费的时候不会出现抢占队列的问题。同时为了保证线程安全和生产者消费者模式的完整，采用阻塞队列。Java 中提供了 LinkedBlockingQueue 就是一个阻塞队列。 初始化阻塞队列 使用 LinkedList 创建一个阻塞队列列表： 1private static List&lt;LinkedBlockingQueue&lt;String&gt;&gt; blockQueueLists = new LinkedList&lt;&gt;(); 在 static 块里初始化阻塞队列的数量和单个阻塞队列的容量为 256。 上面讲到了 30 亿数据大概 2500 行，按行塞到队列里。20 个队列，那么每个队列 125 个，因此可以容量可以设计为 256 即可。 1234//每个队列容量为256for (int i = 0; i &lt; threadNums; i++) &#123; blockQueueLists.add(new LinkedBlockingQueue&lt;&gt;(256));&#125; 生产者 为了实现负载的功能，首先定义一个 count 计数器，用来记录行数： 1private static AtomicLong count = new AtomicLong(0); 按照行数来计算队列的下标 long index&#x3D;count.get()%threadNums。 下面算法就实现了对队列列表中的队列进行轮询的投放： 1234567891011121314151617static class SplitData &#123; public static void splitLine(String lineData) &#123; String[] arr = lineData.split(&quot; &quot;); for (String str : arr) &#123; if (StringUtils.isEmpty(str)) &#123; continue; &#125; long index = count.get() % threadNums; try &#123; // 如果满了就阻塞 blockQueueLists.get((int) index).put(str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count.getAndIncrement(); &#125; &#125; 消费者1) 队列线程私有化 消费方在启动线程的时候根据 index 去获取到指定的队列，这样就实现了队列的线程私有化。 12345678910111213141516171819private static void startConsumer() throws FileNotFoundException, UnsupportedEncodingException &#123; //如果共用一个队列，那么线程不宜过多，容易出现抢占现象 System.out.println(&quot;开始消费...&quot;); for (int i = 0; i &lt; threadNums; i++) &#123; final int index = i; // 每一个线程负责一个 queue，这样不会出现线程抢占队列的情况。 new Thread(() -&gt; &#123; while (consumerRunning) &#123; startConsumer = true; try &#123; String str = blockQueueLists.get(index).take(); countNum(str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 2) 多子线程分割字符串由于从队列中多到的字符串非常的庞大，如果又是用单线程调用 split(“,”) 去分割，那么性能同样会阻塞在这个地方。 1234567891011121314// 按照 arr的大小，运用多线程分割字符串private static void countNum(String str) &#123; int[] arr = new int[2]; arr[1] = str.length() / 3; for (int i = 0; i &lt; 3; i++) &#123; final String innerStr = SplitData.splitStr(str, arr); new Thread(() -&gt; &#123; String[] strArray = innerStr.split(&quot;,&quot;); for (String s : strArray) &#123; countMap.computeIfAbsent(s, s1 -&gt; new AtomicInteger(0)).getAndIncrement(); &#125; &#125;).start(); &#125;&#125; 3) 分割字符串算法 分割时从 0 开始，按照等分的原则，将字符串 n 等份，每一个线程分到一份。 用一个 arr 数组的 arr[0] 记录每次的分割开始位置。arr[1] 记录每次分割的结束位置，如果遇到的开始的字符不为 “,” 那么就 startIndex-1。如果结束的位置不为 “,” 那么将 endIndex 向后移一位。 如果 endIndex 超过了字符串的最大长度，那么就把最后一个字符赋值给 arr[1]。 123456789101112131415161718192021222324252627282930313233/** * 按照 x坐标 来分割 字符串，如果切到的字符不为“，”， 那么把坐标向前或者向后移动一位。 * * @param line * @param arr 存放x1,x2坐标 * @return */public static String splitStr(String line, int[] arr) &#123; int startIndex = arr[0]; int endIndex = arr[1]; char start = line.charAt(startIndex); char end = line.charAt(endIndex); if ((startIndex == 0 || start == &#x27;,&#x27;) &amp;&amp; end == &#x27;,&#x27;) &#123; arr[0] = endIndex + 1; arr[1] = arr[0] + line.length() / 3; if (arr[1] &gt;= line.length()) &#123; arr[1] = line.length() - 1; &#125; return line.substring(startIndex, endIndex); &#125; if (startIndex != 0 &amp;&amp; start != &#x27;,&#x27;) &#123; startIndex = startIndex - 1; &#125; if (end != &#x27;,&#x27;) &#123; endIndex = endIndex + 1; &#125; arr[0] = startIndex; arr[1] = endIndex; if (arr[1] &gt;= line.length()) &#123; arr[1] = line.length() - 1; &#125; return splitStr(line, arr);&#125; 测试结果 内存和 CPU 初始占用大小： 启动后，运行时内存稳定在 11.7G，CPU 稳定利用在 90% 以上。 总耗时由 180 秒缩减到 103 秒，效率提升 75%，得到的结果也与单线程处理的一致。 6. 遇到的问题如果在运行了的时候，发现 GC 突然罢工不工作了，有可能是 JVM 的堆中存在的垃圾太多，没回收导致内存的突增。 解决方法 在读取一定数量后，可以让主线程暂停几秒，手动调用 GC。 提示: 本 demo 的线程创建都是手动创建的，实际开发中使用的是线程池。","tags":["学习","SpringBoot","Java","数据"],"categories":["学习","Java","SpringBoot","数据"]},{"title":"把剩饭做成盲盒卖，消费者和商家能双赢吗？","path":"/5de8058a/","content":"把剩饭做成盲盒卖，消费者和商家能双赢吗？ 作者：来自这篇文章的那位小姐姐：大学 - ZQ的博客 (forever520.top) var ap = new APlayer({ element: document.getElementById(\"aplayer-QTOhkIGf\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"把剩饭做成盲盒卖，消费者和商家能双赢吗？\", author: \"Wency\", url: \"https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/blog/%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD/%E4%B8%80%E4%BD%8D%E5%81%B6%E9%81%87%E7%9A%84%E5%B0%8F%E5%A7%90%E5%A7%90/1/1.wav?sign=d029c8b56221780d\", pic: \"https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/blog/%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD/%E4%B8%80%E4%BD%8D%E5%81%B6%E9%81%87%E7%9A%84%E5%B0%8F%E5%A7%90%E5%A7%90/1/avatar-95188.jpg?sign=4657a0896fae9683\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Lots of Food Gets Tossed. These Apps Let You Buy It, Cheap. Around the country, apps that connect customers to businesses with leftover food have begun to spread. The concept is simple: Restaurants and grocery stores throw away huge amounts of food every day. Rather than trash it, apps like Too Good To Go and Flashfood help businesses sell it at a reduced price. They claim that the businesses and buyers are helping the environment because the food would otherwise become food waste, a big contributor to climate change. Food production itself is a major contributor to greenhouse gas emissions, accounting for between a quarter and a third of global emissions. Each step of the process — growing, harvesting, moving, processing, packaging, storing and preparing food — releases carbon dioxide, methane and other planet-warming gases. When the food is wasted, so are all those emissions. In addition, once unused food reaches landfills, it decomposes and releases more methane. Too Good To Go has tried to gamify buying leftover food. In the United States, customers in twelve cities can browse restaurants and stores, then reserve “surprise bags” that typically cost about four to six dollars and contain food that would have been originally priced at roughly three times that amount. The bags can be picked up at a certain time window. One complication is that, according to interviews with several companies selling on Too Good To Go, at least a few items for sale there aren’t necessarily what buyers might think of as “food waste.” A beverage company owner said he used the app to sell discontinued products, but also sold new flavors there in hopes of attracting new customers.","tags":["学习","英语","剩饭","消费者","商家","小姐姐"],"categories":["学习","英语","剩饭","消费者","商家","小姐姐"]},{"title":"喜剧","path":"/5341a03c/","content":"喜剧 button{ background-color: white; border: 1px solid #008CBA; color: black; text-align: center; text-decoration: none; display: inline-block; font-size: 14px; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; cursor: pointer; } button:hover{ background-color: #008CBA; color: white; } 推荐使用火狐浏览器进行观影，效果最佳哟！ var dplayer6 = new DPlayer({\"element\":document.getElementById(\"dplayer6\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E6%8A%96%E9%9F%B3/%E5%96%9C%E5%89%A7/%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%93%E6%A3%80.mp4\"}}); 一年一度喜剧大赛-第一季-互联网体检 吐槽大会-体育专场-范志毅一年一度喜剧大赛-第二季-少爷和我 一年一度喜剧大赛-第二季-警察和我一年一度喜剧大赛-第二季-虎父无犬子 一年一度喜剧大赛-第一季-父亲的葬礼一年一度喜剧大赛-第二季-进化论 一年一度喜剧大赛-第二季-千年就一回一年一度喜剧大赛-第二季-当一个女人决定退鞋 一年一度喜剧大赛-第一季-时间都去哪儿了一年一度喜剧大赛-第一季-丛林法则 一年一度喜剧大赛-第一季-透明人一年一度喜剧大赛-第一季-三狗直播间 一年一度喜剧大赛-第一季-水煮三结义一年一度喜剧大赛-第一季-先生请出山 一年一度喜剧大赛-第一季-如果先生不出山一年一度喜剧大赛-第二季-妈妈的味道 一年一度喜剧大赛-第二季-德古拉和我一年一度喜剧大赛-第二季-好兄台 一年一度喜剧大赛-第二季-遇人不赎一年一度喜剧大赛-第二季-军师恋盟 一年一度喜剧大赛-第二季-请赐教一年一度喜剧大赛-第二季-开不了口 一年一度喜剧大赛-第二季-商战这件小事一年一度喜剧大赛-第二季-少爷和小姐 一年一度喜剧大赛-第二季-难眠的夜晚一年一度喜剧大赛-第二季-复活军团 一年一度喜剧大赛-第二季-将合租进行到底一年一度喜剧大赛-第二季-超快乐男孩 一年一度喜剧大赛-第二季-当一个龙虾人决定去一年一度喜剧大赛-第二季-大考结束那一天 一年一度喜剧大赛-第二季-我的伴娘一年一度喜剧大赛-第二季-我要当rapper 一年一度喜剧大赛-第二季-音乐课最重要一年一度喜剧大赛-第二季-再见老张 一年一度喜剧大赛-第二季-总决赛","tags":["喜剧大赛","脱口秀","吐槽大会"],"categories":["喜剧大赛","脱口秀","吐槽大会"]},{"title":"SpringBoot一个注解，实现接口防刷","path":"/4bba226b/","content":"SpringBoot一个注解，实现接口防刷 本文介绍一种极简洁、灵活通用接口防刷实现方式、通过在需要防刷的方法加上@Prevent 注解即可实现短信防刷； 使用方式大致如下： 12345@ResponseBody@GetMapping(value = &quot;/testPrevent&quot;)@Prevent //加上该注解即可实现短信防刷(默认一分钟内不允许重复调用，支持扩展、配置）public Response testPrevent(TestRequest request) &#123;\treturn Response.success(&quot;调用成功&quot;);&#125; 目录 实现防刷切面PreventAop.java 使用防刷切面 演示 1、实现防刷切面PreventAop.java 大致逻辑为：定义一切面，通过@Prevent注解作为切入点、在该切面的前置通知获取该方法的所有入参并将其Base64编码，将入参Base64编码+完整方法名作为redis的key，入参作为reids的value，@Prevent的value作为redis的expire，存入redis； 每次进来这个切面根据入参Base64编码+完整方法名判断redis值是否存在，存在则拦截防刷，不存在则允许调用； 1.1 定义注解Prevent 12345678910111213141516171819202122232425262728package com.zetting.aop;import java.lang.annotation.*;/** * 接口防刷注解 * 使用： * 在相应需要防刷的方法上加上 * 该注解，即可 */@Documented@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Prevent &#123; /** * 限制的时间值（秒） * @return */ String value() default &quot;60&quot;; /** * 提示 */ String message() default &quot;&quot;; /** * 策略 * * @return */ PreventStrategy strategy() default PreventStrategy.DEFAULT;&#125; 1.2 实现防刷切面PreventAop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.zetting.aop;import com.alibaba.fastjson.JSON;import com.zetting.common.BusinessException;import com.zetting.util.RedisUtil;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import java.lang.reflect.Method;import java.util.Base64;/** * 防刷切面实现类 * @author: zetting */@Aspect@Componentpublic class PreventAop &#123; private static Logger log = LoggerFactory.getLogger(PreventAop.class); @Autowired private RedisUtil redisUtil; /** * 切入点 */ @Pointcut(&quot;@annotation(com.zetting.aop.Prevent)&quot;) public void pointcut() &#123; &#125; /** * 处理前 * @return */ @Before(&quot;pointcut()&quot;) public void joinPoint(JoinPoint joinPoint) throws Exception &#123; String requestStr = JSON.toJSONString(joinPoint.getArgs()[0]); if (StringUtils.isEmpty(requestStr) || requestStr.equalsIgnoreCase(&quot;&#123;&#125;&quot;)) &#123; throw new BusinessException(&quot;[防刷]入参不允许为空&quot;); &#125; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method = joinPoint.getTarget().getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes()); Prevent preventAnnotation = method.getAnnotation(Prevent.class); String methodFullName = method.getDeclaringClass().getName() + method.getName(); entrance(preventAnnotation, requestStr,methodFullName); return; &#125; /** * 入口 * @param prevent * @param requestStr */ private void entrance(Prevent prevent, String requestStr,String methodFullName) throws Exception &#123; PreventStrategy strategy = prevent.strategy(); switch (strategy) &#123; case DEFAULT: defaultHandle(requestStr, prevent,methodFullName); break; default: throw new BusinessException(&quot;无效的策略&quot;); &#125; &#125; /** * 默认处理方式 * @param requestStr * @param prevent */ private void defaultHandle(String requestStr, Prevent prevent,String methodFullName) throws Exception &#123; String base64Str = toBase64String(requestStr); long expire = Long.parseLong(prevent.value()); String resp = redisUtil.get(methodFullName+base64Str); if (StringUtils.isEmpty(resp)) &#123; redisUtil.set(methodFullName+base64Str, requestStr, expire); &#125; else &#123; String message = !StringUtils.isEmpty(prevent.message()) ? prevent.message() : expire + &quot;秒内不允许重复请求&quot;; throw new BusinessException(message); &#125; &#125; /** * 对象转换为base64字符串 * @param obj 对象值 * @return base64字符串 */ private String toBase64String(String obj) throws Exception &#123; if (StringUtils.isEmpty(obj)) &#123; return null; &#125; Base64.Encoder encoder = Base64.getEncoder(); byte[] bytes = obj.getBytes(&quot;UTF-8&quot;); return encoder.encodeToString(bytes); &#125;&#125; 注：以上只展示核心代码、其他次要代码（例如redis配置、redis工具类等）可下载源码查阅 2、使用防刷切面 在MyController 使用防刷 123456789101112131415161718192021222324252627282930313233343536package com.zetting.modules.controller;import com.zetting.aop.Prevent;import com.zetting.common.Response;import com.zetting.modules.dto.TestRequest;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;/** * 切面实现入参校验 */@RestControllerpublic class MyController &#123; /** * 测试防刷 * * @param request * @return */ @ResponseBody @GetMapping(value = &quot;/testPrevent&quot;) @Prevent public Response testPrevent(TestRequest request) &#123; return Response.success(&quot;调用成功&quot;); &#125; /** * 测试防刷 * @param request * @return */ @ResponseBody @GetMapping(value = &quot;/testPreventIncludeMessage&quot;) @Prevent(message = &quot;10秒内不允许重复调多次&quot;, value = &quot;10&quot;)//value 表示10表示10秒 public Response testPreventIncludeMessage(TestRequest request) &#123; return Response.success(&quot;调用成功&quot;); &#125;&#125; 3、演示 gitee 源码：https://gitee.com/Zetting/my-gather/tree/master/springboot-aop-prevent","tags":["SpringBoot","注解","接口"],"categories":["SpringBoot","注解","接口"]},{"title":"NodeJs安装与环境配置与优化","path":"/38850fb1/","content":"NodeJs安装与环境配置与优化 NodeJS下载https://nodejs.org/zh-cn/download/ 选择长期支持版本（LTS) windows建议选择64-bit的.msi安装版本 NodeJS安装无脑下一步 接受许可 选择安装路径 （不建议安装到C盘） 建议大家在其他盘新建一个文件夹管理所有的编程环境 我这里在 F:\\environment odejs下 *一定要记得新建文件夹（nodejs） 否则会默认安装到文件夹内* 选择安装内容 我们选择默认 继续下一步 开始安装 安装结束 测试： win+R 键 输入cmd打开命令行 输入 node -v &#x2F; npm -v 提示版本信息说明安装正确 修改npm为淘宝镜像源（提升下载速度）打开命令行运行以下代码回车即可（不会有其它提示） 1npm config set registry https://registry.npm.taobao.org 自定义npm全局路径配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在nodejs下建立node_global及node_cache两个文件夹。 启动cmd 输入如下命令 12345# 按照自己node_global 路径填写npm config set prefix &quot;F:\\environment odejs ode_global&quot;# 按照自己node_cache 路径填写npm config set cache &quot;F:\\environment odejs ode_cache&quot; 测试： 命令行输入 npm install -g vue-cli 安装vue-cli -g 代表全局安装 可能出现报错： 解决方案：管理员权限运行cmd 一劳永逸的方法：修改安装目录下的权限 选择属性-安全-Authenticated Users -编辑 -勾选完全控制（允许）即可 正确安装提示： 且在安装目录&#x2F;node_gloal下有如下文件 配置node_global的环境变量目的： 解决命令行内输入已经安装的全局模块报错 打开系统对话框，“此电脑”右键“属性”-“高级系统设置”-“高级”-“环境变量”。 进入环境变量对话框，在 *系统变量* 下新建 NODE_PATH ，输入 以自己实际路径为准 1F:\\environment odejs ode_global 测试：命令行 输入 vue 提示如下 证明安装成功！","tags":["NodeJs"],"categories":["NodeJs"]},{"title":"Maven配置教程","path":"/a418e376/","content":"Maven配置教程 Maven的下载 在Maven的官网即可下载，点击访问Apache Maven。 下载后解压即可，解压后目录结构如下： Maven常用配置在配置之前请将JDK安装好。 1. 环境变量配置 添加M2_HOME:对应Maven的解压目录即可。 编辑Path环境变量： 测试，在cmd窗口输入mvn -v查看 显示如下即配置成功： 2. 修改配置文件通常我们需要修改解压目录下conf/settings.xml文件，这样可以更好的适合我们的使用。 此处注意：所有的修改一定要在注释标签外面，不然修改无效。Maven很多标签都是给的例子，都是注释掉的。 文章最后附上我的整个Settings.xml文件配置。 1. 本地仓库位置修改在&lt;**localRepository**&gt;标签内添加自己的本地位置路径 1234567 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;&lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; 2. 修改maven默认的JDK版本在&lt;**profiles**&gt;标签下添加一个&lt;**profile**&gt;标签，修改maven默认的JDK版本。 123456789101112&lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 3. 添加国内镜像源添加&lt;**mirrors**&gt;标签下&lt;**mirror**&gt;，添加国内镜像源，这样下载jar包速度很快。默认的中央仓库有时候甚至连接不通。一般使用阿里云镜像库即可。这里我就都加上了，Maven会默认从这几个开始下载，没有的话就会去中央仓库了。 1234567891011121314151617181920212223&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库1 --&gt;&lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库2 --&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 常用IDE下配置Maven目前常用的开发工具如idea，eclipse都自身集成了一个版本的Maven。但是通常我们使用自己已经配置好的Maven。 IDEA下配置Maven 1：此处修改为自己解压的Maven目录 2：勾选Override，修改为自己目录下的settings.xml目录 3：修改为自己的本地仓库地址，一般会自动识别。 此处勾选，当修改pom文件时，Maven就能帮我们自动导包了。 Eclipse下配置Maven 将eclipse使用的Maven修改为自己的。点击add后选择自己Maven的安装目录即可。添加好之后记得勾选。 将所有的settings修改为自己Maven目录下的conf&#x2F;settings.xml.点击Update Settings按钮，下面的Local Respository会自动识别出来。 附：完整的Settings.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they&#x27;re all using the same Maven | installation). It&#x27;s normally provided in | $&#123;maven.conf&#125;/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;\t&lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the &#x27;id&#x27; attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id&#x27;s for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;!-- | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;, | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | &lt;plugin&gt; | &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt; | &lt;artifactId&gt;myplugin&lt;/artifactId&gt; | | &lt;configuration&gt; | &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt; | &lt;/configuration&gt; | &lt;/plugin&gt; | ... | | NOTE: If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to | anything, you could just leave off the &lt;value/&gt; inside the activation-property. | &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt; --&gt;\t&lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt;&lt;/settings&gt;","tags":["Maven","编程"],"categories":["Maven","编程"]},{"title":"win10上将chrome浏览器安装的D盘","path":"/eae3fb25/","content":"win10上将chrome浏览器安装的D盘 百度安装Chrome到D盘，通常是将安装后的文件夹直接复制到D盘，但是这样操作会导致chrome浏览器无法正常更新！ 安装步骤 下载chrome安装包： https://www.google.com/chrome/ 确定好安装目录： D:\\Program Files\\Google, 可以自定义 创建目录： D:\\Program Files\\Google\\Chrome —————创建安装目录 创建目录： D:\\Program Files\\Google\\PersonData ———创建个人数据目录 创建目录：C:\\Program Files\\Google ——————————-chrome浏览器的默认安装目录， 目录中的文件删除掉 删除目录：C:\\Program Files (x86)\\Google ———————–chrome更新相关内容默认安装目录 管理员执行cmd命令： 千万注意空格，不要出现前后有空格的情况，例如 “ D:\\Program Files\\Google\\Chrome “ 12345mklink /d &quot;C:\\Program Files\\Google\\Chrome&quot; &quot;D:\\Program Files\\Google\\Chrome&quot;mklink /d &quot;C:\\Program Files (x86)\\Google&quot; &quot;D:\\Program Files\\Google&quot;mklink /d &quot;C:\\Users\\xxxxx\\AppData\\Local\\Google&quot; &quot;D:\\Program Files\\Google\\PersonData&quot; 点击下载的安装包进行安装 安装完毕后查看","tags":["chrome","浏览器"],"categories":["chrome","浏览器"]},{"title":"idea内存配置","path":"/528ecea1/","content":"idea内存配置 找到IDEA安装的bin目录 打开idea.exe.vmoptions 文件 如果嫌麻烦还打开了idea 那么就可以点击这个.. 关键的三个参数的说明 1、 -Xms 是最小启动内存参数 2、 -Xmx 是最大运行内存参数 3、-XX:ReservedCodeCacheSize 保留代码占用的内存容量参数 建议手动设置参数值 一、电脑运行内存为8G的建议 -server -Xms512m -Xmx1024m -XX:ReservedCodeCacheSize&#x3D;300m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB&#x3D;50 -ea -Dsun.io.useCanonCaches&#x3D;false -Djava.net.preferIPv4Stack&#x3D;true -Djdk.http.auth.tunneling.disabledSchemes&#x3D;”” -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow 二、电脑运行内存为16G的建议 -server -Xms1024m -Xmx2048m -XX:ReservedCodeCacheSize&#x3D;500m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB&#x3D;50 -ea -Dsun.io.useCanonCaches&#x3D;false -Djava.net.preferIPv4Stack&#x3D;true -Djdk.http.auth.tunneling.disabledSchemes&#x3D;”” -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow 设置内存显示： idea默认情况下，是不显示当前内存使用情况的，可以通过设置让其显示，方法如下： 打开Preferences--&gt;Appearance &amp; Behavior--&gt;Appearance，右侧勾选Window Options下面的Show memory indicator即可。","tags":["idea","编程软件","java"],"categories":["idea","编程软件","java"]},{"title":"git ssh配置、密钥创建","path":"/4c0014ec/","content":"gitssh配置、密钥创建 许多人都用过git的https直接拉取代码，今天来操作下ssh的形式拉取代码 安装了Git后，桌面右键打开Git bash 12git config --global user.name &quot;userName&quot; //你的用户名git config --global user.email &quot;emailaddress&quot; //你的邮箱地址 查看是否配置过密钥 1cd ~/.ssh 进行创建ssh 1ssh-keygen -t rsa -C &#x27;xxx@qq.com&#x27; 之后不断Enter即可 查看你生成的公钥 1cat ~/.ssh/id_rsa.pub 输入该命令回车后，复制看到的公钥，去代码托管平台配置ssh 最后验证下这个key是不是正常工作 1234// gitee的同学ssh -T gitee@gitee.com// 使用github的同学，则改为ssh -T git@github.com 之后会问你Are you sure you want to continue connecting (yes&#x2F;no)?只要回答yes，回车就会看到下面的Hi Anonymous! You’ve successfully authenticated, but GITEE.COM does not provide shell access.就表示你的设置已经成功了。 接下来就可以开始直接克隆你的代码下来复制你代码库的ssh","tags":["git","ssh"],"categories":["git","ssh"]},{"title":"觉醒年代","path":"/a3c72645/","content":"觉醒年代 简介：电视剧《觉醒年代》以1915年《青年杂志》问世到1921年《新青年》成为中国共产党机关刊物为贯穿，展现了从新文化运动、五四运动到中国共产党建立这段波澜壮阔的历史画卷，讲述了觉醒年代社会风情和百态人生。 《觉醒年代》 第40集本集主要内容： 陈独秀外出刚回到家里，吴炳湘便找上门来，提醒陈独秀不能离开北京。陈独秀和李大钊一行人见面，众人决定帮助陈独秀逃出北京。陈独秀、李大钊坐着马车奔向上海，途中俩人目睹了难民们流离失所的悲惨生活。 第40集节选全剧最喜欢的部分 var dplayer8 = new DPlayer({\"element\":document.getElementById(\"dplayer8\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E7%94%B5%E8%A7%86%E5%89%A7/%E8%A7%89%E9%86%92%E5%B9%B4%E4%BB%A3/%E8%A7%89%E9%86%92%E5%B9%B4%E4%BB%A3%E7%AC%AC40%E9%9B%86%E8%8A%82%E9%80%89.mp4\"}}); 第40集全集var dplayer9 = new DPlayer({\"element\":document.getElementById(\"dplayer9\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E7%94%B5%E8%A7%86%E5%89%A7/%E8%A7%89%E9%86%92%E5%B9%B4%E4%BB%A3/%E8%A7%89%E9%86%92%E5%B9%B4%E4%BB%A3%E7%AC%AC40%E9%9B%86.mp4\"}});","tags":["电视剧","觉醒年代"],"categories":["电视剧","觉醒年代"]},{"title":"画江湖之不良人第四第五季","path":"/8ad397dd/","content":"画江湖之不良人第四第五季 button{ background-color: white; border: 1px solid #008CBA; color: black; text-align: center; text-decoration: none; display: inline-block; font-size: 14px; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; cursor: pointer; } button:hover{ background-color: #008CBA; color: white; } 推荐使用火狐浏览器观影更佳 var dplayer7 = new DPlayer({\"element\":document.getElementById(\"dplayer7\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E5%8A%A8%E6%BC%AB/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA/%E7%AC%AC%E5%9B%9B%E5%AD%A3/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA%20%E7%AC%AC4%E5%AD%A3%20%E7%AC%AC01%E9%9B%86.mp4\"}}); 第四季第01集 第02集 第03集 第04集 第05集 第06集 第07集 第08集 第09集 第10集 第11集 第12集 第13集 第五季第01集 第02集 第03集 第04集 第05集 第06集 第07集 第08集 第09集 第10集 第11集 第12集","tags":["动漫","画江湖之不良人"],"categories":["动漫","画江湖之不良人"]},{"title":"Docker学习2","path":"/ce090c51/","content":"1.Docker镜像镜像 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。 只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 分层的镜像 UnionFS(联合文件系统)UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 Docker镜像加载原理 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 为什么Docker镜像要采用这种分层结构呢？ 镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。 比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像； 同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 重点理解Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫”镜像层“。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 Docker镜像commit操作案例123docker commit 提交容器副本使之成为一个新的镜像。docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名] 案例演示ubuntu安装vim从Hub上下载ubuntu镜像到本地并成功运行 原始的默认ubuntu镜像是不带着vim命令的 外网连通的情况下，安装vim docker容器内执行上述两条命令： apt-get update apt-get -y install vim 安装完成后，commit我们自己的新镜像 启动我们的新镜像并和原来的对比 小总结Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。 新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层 2.本地镜像发布到阿里云 阿里云开发者平台：https://promotion.aliyun.com/ntms/act/kubernetes.html 创建仓库镜像选择控制台，进入容器镜像服务 选择个人实例、命名空间、仓库名称 进入管理界面获得脚本 将镜像推送到阿里云、将镜像推送到阿里云registry、 将阿里云上的镜像下载到本地docker pull xxx 3.本地镜像发布到私有库1 官方Docker Hub地址：https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。 2 Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。 Docker Registry是官方提供的工具，可以用于构建私有镜像仓库 步骤1.下载镜像Docker Registry1docker pull registry 2.运行私有库Registry，相当于本地有个私有Docker hub12docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调 3.案例演示创建一个新镜像，ubuntu安装ifconfig命令从Hub上下载ubuntu镜像到本地并成功运行 原始的Ubuntu镜像是不带着ifconfig命令的 外网连通的情况下，安装ifconfig命令并测试通过 123docker容器内执行上述两条命令：apt-get updateapt-get install net-tools 安装完成后，commit我们自己的新镜像 1234公式：docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]命令：在容器外执行，记得docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;zzyy&quot; a69d7c825c4f zzyyubuntu:1.2 启动我们的新镜像并和原来的对比:1 官网是默认下载的Ubuntu没有ifconfig命令,2我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。 4.curl验证私服库上有什么镜像1curl -XGET http://192.168.111.162:5000/v2/_catalog 5.将新镜像zzyyubuntu:1.2修改符合私服规范的Tag1234按照公式： docker tag 镜像:Tag Host:Port/Repository:Tag自己host主机IP地址，填写同学你们自己的，不要粘贴错误，O(∩_∩)O使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000/zzyyubuntu:1.2docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2 6.修改配置文件使之支持http12345vim命令新增如下红色内容：vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;192.168.111.162:5000&quot;]&#125; 上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。&#x3D;&#x3D;&#x3D;&#x3D;&gt; 修改完后如果不生效，建议重启docker 7.push推送到私服库1docker push 192.168.111.162:5000/zzyyubuntu:1.2 8.curl验证私服库上有什么镜像21curl -XGET http://192.168.111.162:5000/v2/_catalog 9.pull到本地并运行12docker pull 192.168.111.162:5000/zzyyubuntu:1.2docker run -it 镜像ID /bin/bash 4.Docker容器数据卷坑:容器卷记得加入–privileged&#x3D;true Docker挂载主机目录访问如果出现cannot open directory .: Permission denied 解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可 如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为， 在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即 使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。 是什么：—句话:有点类似我们Redis里面的rdb和aof文件 将docker容器内的数据保存进宿主机的磁盘中 运行一个带有容器卷存储功能的容器实例 1docker run -it --privileged=true -v/宿主机绝对路径目录:/容器内目录 镜像名 能干嘛？将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的 Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。 为了能保存数据在docker中我们使用卷。 特点：1：数据卷可在容器之间共享或重用数据 2：卷中的更改可以直接实时生效，爽 3：数据卷中的更改不会包含在镜像的更新中 4：数据卷的生命周期一直持续到没有容器使用它为止 案例：宿主vs容器之间映射添加容器卷12公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bashdocker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash 查看数据卷是否挂载成功 1docker inspect 容器ID 容器和宿主机之间数据共享 1 docker修改，主机同步获得 2 主机修改，docker同步获得 3 docker容器stop，主机修改，docker容器重启看数据是否同步。 读写规则映射添加说明读写(默认): rw &#x3D; read + write docker run -it –privileged&#x3D;true -v&#x2F;宿主机绝对路径目录:&#x2F;容器内目录:rw 镜像名 只读：容器实例内部被限制，只能读取不能写 docker run -it –privileged&#x3D;true -v&#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名 &#x2F;容器目录:ro 镜像名 就能完成功能，此时容器自己只能读取不能写 ro &#x3D; read only 此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。 卷的继承和共享容器1完成和宿主机的映射 1docker run -it --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu 容器2继承容器1的卷规则 1docker run -it --privileged=true --volumes-from 父类--name u2 ubuntu 5.Docker常规安装简介、总体步骤 搜索镜像、拉取镜像、查看镜像、启动镜像（服务端口映射）、停止容器、移除容器。 安装tomcatdocker hub上面查找tomcat镜像:docker search tomcat 从docker hub上拉取tomcat镜像到本地:docker pull tomcat docker images查看是否有拉取到的tomcat 使用tomcat镜像创建容器实例(也叫运行镜像) 1234docker run -it -p 8080:8080 tomcat-p小写，主机端口:docker容器端口-P大写，随机分配端口i:交互、t:终端、d:后台 访问猫首页，问题：找不到 解决： 可能没有映射端口或者没有关闭防火墙、 把webapps.dist目录换成webapps：先成功启动tomcat、查看webapps文件夹查看为空 免修改版说明： 12docker pull billygoo/tomcat8-jdk8docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8-jdk8 安装mysqldocker hub上面查找mysql镜像 从docker hub上{阿里云加速器)拉取mysql镜像到本地标签为5.7 使用mysql5.7镜像创建容器(也叫运行镜像) 简单版使用mysqI镜像 1234docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7docker psdocker exec -it 容器ID /bin/bashmysql -uroot -p 建库建表插入数据 外部win10也来连接运行在dokcer上的mysql容器实例服务 问题：插入中文数据报错，docker上默认字符集编码隐患 docker里面的mysql容器实例查看，内容如下：SHOW VARIABLES LIKE ‘character%’ 删除容器后，里面的mysqI数据如何办？ 实战版新建mysql容器实例 123456docker run -d -p 3306:3306 --privileged=true -v /zzyyuse/mysql/log:/var/log/mysql -v /zzyyuse/mysql/data:/var/lib/mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7 新建my.cnf,通过容器卷同步给mysql容器实例 12345[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8 重新启动mysql容器实例再重新进入并查看字符编码 再新建车新建表再插入中文测试 结论： 之前的DB 无效 修改字符集操作+重启mysql容器实例 之后的DB 有效，需要新建 结论：docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据 假如将当前容器实例删除，再重新来一次，之前建的dbo1实例还有吗?还有滴。 安装redis从docker hub_上(阿里云加速器)拉取redis镜像到本地标签为6.0.8 12docker pull redis:6.0.8docker run -d -p 6379:6379 redis:6.0.8 命令提醒:容器卷记得加入–privileged&#x3D;true Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied 解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可 在CentOs宿主机下新建目录&#x2F;app&#x2F;redis mkdir -p &#x2F;app&#x2F;redis 将一个redis.conf文件模板拷贝进&#x2F;app&#x2F;redis目录下 &#x2F;app&#x2F;redis目录下修改redis.conf文件 1234567开启redis验证 可选requirepass 123允许redis外地连接 必须注释掉 # bind 127.0.0.1daemonize no将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败开启redis数据持久化 appendonly yes 可选 使用redis6.0.8镜像创建容器(也叫运行镜像) 1234docker run -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf 测试redis-cli连接上来:docker exec -it 运行着Rediis服务的容器ID redis-cli 请证明docker启动使用了我们自己指定的配置文件 修改前：我们用的配置文件，数据库默认是16个 修改后：修改成10个，宿主机的修改会同步给docker容器里面的配置。记得重启服务 测试redis-cli连接上来第2次 安装nginx","tags":["Docker","学习"],"categories":["Docker","学习"]},{"title":"SpringSecurity从入门到精通","path":"/d22a2606/","content":"SpringSecurity从入门到精通课程介绍 0. 简介​\tSpring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 ​\t一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 ​ 一般Web应用的需要进行认证和授权。 ​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 ​ 授权：经过认证后判断当前用户是否有权限进行某个操作 ​\t而认证和授权也是SpringSecurity作为安全框架的核心功能。 1. 快速入门1.1 准备工作​\t我们先要搭建一个简单的SpringBoot工程 ① 设置父工程 添加依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ② 创建启动类 1234567@SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class,args); &#125;&#125; ③ 创建Controller 123456789101112import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 1.2 引入SpringSecurity​\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ​\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。 ​\t必须登陆之后才能对接口进行访问。 2. 认证2.1 登陆校验流程 2.2 原理初探​\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。 2.2.1 SpringSecurity完整流程​\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 ​\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 FilterSecurityInterceptor：负责权限校验的过滤器。 ​ ​\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 2.2.2 认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 2.3 解决问题2.3.1 思路分析登录 ​\t①自定义登录接口 ​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt ​ 把用户信息存入redis中 ​\t②自定义UserDetailsService ​ 在这个实现类中去查询数据库 校验： ​\t①定义Jwt认证过滤器 ​ 获取token ​ 解析token获取其中的userid ​ 从redis中获取用户信息 ​ 存入SecurityContextHolder 2.3.2 准备工作①添加依赖 1234567891011121314151617&lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--jwt依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; ② 添加Redis相关配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; 123456789101112131415161718192021222324252627282930import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; ③ 响应类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.fasterxml.jackson.annotation.JsonInclude;@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123; /** * 状态码 */ private Integer code; /** * 提示信息，如果有错误时，前端可以获取该字段进行提示 */ private String msg; /** * 查询到的结果数据， */ private T data; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, T data) &#123; this.code = code; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ResponseResult(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125;&#125; ④工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; 1234567891011121314151617181920212223242526import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ⑤实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.Serializable;import java.util.Date;/** * 用户表(User)实体类 * * @author 三更 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = -40356785423868312L; /** * 主键 */ private Long id; /** * 用户名 */ private String userName; /** * 昵称 */ private String nickName; /** * 密码 */ private String password; /** * 账号状态（0正常 1停用） */ private String status; /** * 邮箱 */ private String email; /** * 手机号 */ private String phonenumber; /** * 用户性别（0男，1女，2未知） */ private String sex; /** * 头像 */ private String avatar; /** * 用户类型（0管理员，1普通用户） */ private String userType; /** * 创建人的用户id */ private Long createBy; /** * 创建时间 */ private Date createTime; /** * 更新人 */ private Long updateBy; /** * 更新时间 */ private Date updateTime; /** * 删除标志（0代表未删除，1代表已删除） */ private Integer delFlag;&#125; 2.3.3 实现2.3.3.1 数据库校验用户​\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。 准备工作​\t我们先创建一个用户表， 建表语句如下： 123456789101112131415161718CREATE TABLE `sys_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27; ​ 引入MybatisPuls和mysql驱动的依赖 123456789&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ​ 配置数据库信息 123456spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver ​ 定义Mapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; ​ 修改User实体类 1类名上加@TableName(value = &quot;sys_user&quot;) ,id字段上加 @TableId ​ 配置Mapper扫描 12345678@SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SimpleSecurityApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class); System.out.println(run); &#125;&#125; ​ 添加junit依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; ​ 测试MP是否能正常使用 123456789101112@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testUserMapper()&#123; List&lt;User&gt; users = userMapper.selectList(null); System.out.println(users); &#125;&#125; 核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息 12345678910111213141516171819202122@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询用户信息 LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); //如果查询不到数据就通过抛出异常来给出提示 if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 //封装成UserDetails对象返回 return new LoginUser(user); &#125;&#125; 因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。 12345678910111213141516171819202122232425262728293031323334353637383940414243@Data@NoArgsConstructor@AllArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如 这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。 2.3.3.2 密码加密存储​\t实际项目中我们不会把密码明文存储在数据库中。 ​\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 ​\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 12345678910@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.3.3.3 登陆接口​\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 ​\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。 ​\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 123456789101112@RestControllerpublic class LoginController &#123; @Autowired private LoginServcie loginServcie; @PostMapping(&quot;/user/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginServcie.login(user); &#125;&#125; 123456789101112131415161718192021222324252627282930@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 123456789101112131415161718192021222324252627@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125;&#125; 2.3.3.4 认证过滤器​\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。 ​\t使用userid去redis中获取对应的LoginUser对象。 ​\t然后封装Authentication对象存入SecurityContextHolder 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; //放行 filterChain.doFilter(request, response); return; &#125; //解析token String userid; try &#123; Claims claims = JwtUtil.parseJWT(token); userid = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; //从redis中获取用户信息 String redisKey = &quot;login:&quot; + userid; LoginUser loginUser = redisCache.getCacheObject(redisKey); if(Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication中 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行 filterChain.doFilter(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //把token校验过滤器添加到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 2.3.3.5 退出登陆​\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125; @Override public ResponseResult logout() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userid = loginUser.getUser().getId(); redisCache.deleteObject(&quot;login:&quot;+userid); return new ResponseResult(200,&quot;退出成功&quot;); &#125;&#125; 3. 授权3.0 权限系统的作用​\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 ​\t总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 ​\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 ​\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 3.1 授权基本流程​\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。 ​\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。 ​\t然后设置我们的资源所需要的权限即可。 3.2 授权实现3.2.1 限制访问资源所需权限​\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。 ​\t但是要使用它我们需要先开启相关配置。 1@EnableGlobalMethodSecurity(prePostEnabled = true) ​\t然后就可以使用对应的注解。@PreAuthorize 123456789@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 3.2.2 封装权限信息​\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。 ​\t我们先直接把权限信息写死封装到UserDetails中进行测试。 ​\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.sangeng.domain;import com.alibaba.fastjson.annotation.JSONField;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user,List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JSONField(serialize = false) private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; ​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。 123456789101112131415161718192021222324252627282930313233343536package com.sangeng.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;import com.sangeng.domain.LoginUser;import com.sangeng.domain.User;import com.sangeng.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Objects;@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,list); &#125;&#125; 3.2.3 从数据库查询权限信息3.2.3.1 RBAC权限模型​\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 ​ 3.2.3.2 准备工作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `sg_security`;/*Table structure for table `sys_menu` */DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;菜单表&#x27;;/*Table structure for table `sys_role` */DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;del_flag&#x27;, `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;角色表&#x27;;/*Table structure for table `sys_role_menu` */DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`,`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;/*Table structure for table `sys_user` */DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;/*Table structure for table `sys_user_role` */DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`,`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 1234567891011SELECT DISTINCT m.`perms`FROM\tsys_user_role ur\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`WHERE\tuser_id = 2\tAND r.`status` = 0\tAND m.`status` = 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.sangeng.domain;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;/** * 菜单表(Menu)实体类 * * @author makejava * @since 2021-11-24 15:30:08 */@TableName(value=&quot;sys_menu&quot;)@Data@AllArgsConstructor@NoArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class Menu implements Serializable &#123; private static final long serialVersionUID = -54979041104113736L; @TableId private Long id; /** * 菜单名 */ private String menuName; /** * 路由地址 */ private String path; /** * 组件路径 */ private String component; /** * 菜单状态（0显示 1隐藏） */ private String visible; /** * 菜单状态（0正常 1停用） */ private String status; /** * 权限标识 */ private String perms; /** * 菜单图标 */ private String icon; private Long createBy; private Date createTime; private Long updateBy; private Date updateTime; /** * 是否删除（0未删除 1已删除） */ private Integer delFlag; /** * 备注 */ private String remark;&#125; 3.2.3.3 代码实现​\t我们只需要根据用户id去查询到其所对应的权限信息即可。 ​\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。 123456import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.sangeng.domain.Menu;import java.util.List;public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; ​\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.`perms` FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id` WHERE user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; ​\t在application.yml中配置mapperXML文件的位置 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver redis: host: localhost port: 6379mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml ​\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。 1234567891011121314151617181920212223@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Autowired private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; List&lt;String&gt; permissionKeyList = menuMapper.selectPermsByUserId(user.getId());// //测试写法// List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,permissionKeyList); &#125;&#125; 4. 自定义失败处理​\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 ​\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 ​\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 ​\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 ​\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 ①自定义实现类 1234567891011@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; 12345678910@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; ②配置给SpringSecurity ​\t先注入对应的处理器 12345@Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; ​\t然后我们可以使用HttpSecurity对象的方法去配置。 1http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).accessDeniedHandler(accessDeniedHandler); 5. 跨域​\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 ​\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 ​\t所以我们就要处理一下，让前端能进行跨域请求。 ①先对SpringBoot配置，运行跨域请求 123456789101112131415161718@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; ②开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 12345678910111213141516171819202122232425@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6. 遗留小问题其它权限校验方法​\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 ​\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。 ​\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 ​\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 ​\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 1234@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 自定义权限校验方法​\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。 123456789101112@Component(&quot;ex&quot;)public class SGExpressionRoot &#123; public boolean hasAuthority(String authority)&#123; //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); List&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); &#125;&#125; ​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法 12345@RequestMapping(&quot;/hello&quot;)@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 基于配置的权限控制​\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; CSRF​\tCSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。 ​\thttps://blog.csdn.net/freeking101/article/details/86537087 ​\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 ​\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。 认证成功处理器​\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 ​\t我们也可以自己去自定义成功处理器进行成功后的相应处理。 12345678@Componentpublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;认证成功了&quot;); &#125;&#125; 1234567891011@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 认证失败处理器​\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 ​\t我们也可以自己去自定义失败处理器进行失败后的相应处理。 1234567@Componentpublic class SGFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;认证失败了&quot;); &#125;&#125; 1234567891011121314151617181920@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 登出成功处理器1234567@Componentpublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;注销成功&quot;); &#125;&#125; 123456789101112131415161718192021222324252627@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 其他认证方案畅想","tags":["学习","SpringBoot","SpringSecurity"],"categories":["学习","SpringSecurity","SpringBoot"]},{"title":"换掉FastDFS，SpringBoot整合MinIO实现分布式文件服务，真香！","path":"/9fdae502/","content":"FastDFS 陪伴我走过了很多年，当年大学的时候就是用 FastDFS 为项目搭建的分布式存储服务。 不过，随着技术的进步。FastDFS 正在慢慢被大家放弃，这玩意好用是好用，部署起来也是真的麻烦，臃肿。 今天分享一个非常不错且开源的分布式存储组件 MinIO，比 FastDFS 更简单易用，并且功能也更加强大！ 什么是 MinIO？Minio 是个基于 Golang 编写的开源对象存储套件，基于 Apache License v2.0 开源协议，虽然轻量，却拥有着不错的性能。它兼容亚马逊 S3 云存储服务接口。可以很简单的和其他应用结合使用，例如 NodeJS、Redis、MySQL 等。 1. 应用场景MinIO 的应用场景除了可以作为私有云的对象存储服务来使用，也可以作为云对象存储的网关层，无缝对接 Amazon S3 或者 MicroSoft Azure 。 2. 特点 高性能：作为一款高性能存储，在标准硬件条件下，其读写速率分别可以达到 55Gb/s 和 35Gb/s。并且 MinIO 支持一个对象文件可以是任意大小，从几 kb 到最大 5T 不等。 可扩展：不同 MinIO 集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。 云原生：容器化、基于 K8S 的编排、多租户支持。 Amazon S3 兼容：使用 Amazon S3 v2 &#x2F; v4 API。可以使用 Minio SDK，Minio Client，AWS SDK 和 AWS CLI 访问 Minio 服务器。 SDK 支持：GO SDK：https://github.com/minio/minio-go，JavaSDK：https://github.com/minio/minio-java，PythonSDK：https://github.com/minio/minio-py 图形化界面：有操作页面 支持纠删码：MinIO 使用纠删码、Checksum 来防止硬件错误和静默数据污染。在最高冗余度配置下，即使丢失 1&#x2F;2 的磁盘也能恢复数据。 功能很强大，本文只是抛砖引玉，有兴趣的朋友自己去探索吧~ 安装 MinIO安装非常简单，笔者这里使用 Docker 安装，步骤如下： 1. 获取镜像执行命令如下： 1docker pull minio/minio 2. 启动镜像执行命令如下： 1docker run -p 9000:9000 -p 9001:9001 --name minio -d --restart=always -e &quot;MINIO_ACCESS_KEY=admin&quot; -e &quot;MINIO_SECRET_KEY=admin&quot; -v /home/data:/data -v /home/config:/root/.minio minio/minio server --console-address &quot;:9000&quot; --address &quot;:9001&quot; /data 命令解释如下： -p：9000是图形界面的端口，9001是 API 的端口，在使用 SDK 连接需要用到 MINIO_ACCESS_KEY：指定图形界面的用户名 MINIO_SECRET_KEY：指定图形界面的密码 按照上述两个步骤启动成功即可。 3. 图形界面操作安装成功后直接访问地址：http:&#x2F;ip:9000&#x2F;login，如下： 输入用户名和密码登录成功后，如下： 菜单很多，这里就不再详细介绍了，笔者这里直接在Buckets菜单中创建一个桶为test，如下图： 并且设置这个桶的隐私规则为public，如下： MinIO 到此已经安装设置成功了 Spring Boot 整合 MinIO 上传文件虽然 MinIO 在图形界面提供了手动上传的操作，但是也可以通过 SDK 的方式去上传，下面介绍一下 Spring Boot 整合 MinIO 上传文件。 1. 获取 accessKey 和 secretKey这里的accessKey和secretKey并不是图形界面登录名和密码，获取很简单，直接在图形界面中操作，如下图： 2. 添加依赖添加 MinIO 的依赖，如下： 12345&lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;8.2.1&lt;/version&gt;&lt;/dependency&gt; 3. 添加配置这里笔者对 SDK 做了简单的封装，案例源码都会提供，下面只列出部分代码。 在aplication.yml配置中添加 MInIO 相关的配置，如下： 123456789101112minio: # 访问的url endpoint: http://192.168.47.148 # API的端口 port: 9001 # 秘钥 accessKey: HQGWFYLWGC6FVJ0CQFOG secretKey: pUGhAgQhZDxJaLmN3uz65YX7Bb3FyLdLglBvcCr1 secure: false bucket-name: test # 桶名 我这是给出了一个默认桶名 image-size: 10485760 # 我在这里设定了 图片文件的最大大小 file-size: 1073741824 # 此处是设定了文件的最大大小 4. 新建上传文件接口笔者这里定义了一个上传文件接口，如下： 12345678910111213141516171819/** * @author 公众号：码猿技术专栏 */@RequestMapping(&quot;/minio&quot;)@RestControllerpublic class MinioController &#123; @Autowired private MinioService minioService; @PostMapping(&quot;/upload&quot;) public String uploadFile(MultipartFile file, String bucketName) &#123; String fileType = FileTypeUtils.getFileType(file); if (fileType != null) &#123; return minioService.putObject(file, bucketName, fileType); &#125; return &quot;不支持的文件格式。请确认格式,重新上传！！！&quot;; &#125;&#125; 5. 测试上述 4 个步骤已经整合完成了，下面直接调用接口上传一张图片试一下，如下： 图片 接口返回的URL就是文件的访问地址，直接输入浏览器访问即可。 在 MInIO 中也可以看到存储的文件，如下图： 如果你需要分享给别人，也可以手动分享，有效期是 7 天，一旦过了这个有效期将会失效，如下： 源码地址：https://github.com/chenjiabing666/JavaFamily/tree/master/springboot-minio 。","tags":["SpringBoot","FastDFS","MinIO","文件"],"categories":["SpringBoot","FastDFS","MinIO","文件"]},{"title":"使用Druid轻松实现加密！","path":"/347cd178/","content":"为什么要加密？现在的开发习惯，无论是公司的项目还是个人的项目，都会选择将源码上传到 Git 服务器（GitHub、Gitee 或是自建服务器），但只要将源码提交到公网服务器就会存在源码泄漏的风险，而数据库配置信息作为源码的一部分，一旦出现源码泄漏，那么数据库中的所有数据都会公之于众，其产生的不良后果无法预期（比如某某酒店的信息）。 于是为了避免这种问题的产生，我们至少要对数据库的密码进行加密操作，这样即使得到了源码，也不会造成数据的泄露，也算保住了最后一块遮羞布。 如何加密？对于 Java 项目来说，要想快速实现数据库的加密，最简单可行的方案就是使用阿里巴巴提供的 Druid 来实现加密。 什么是Druid？Druid（中文译为“德鲁伊”）是阿里巴巴开源的一款 Java 语言中最好的数据库连接池。Druid 提供了强大的监控和扩展功能，当然也包含了数据库的加密功能。 Druid 开源地址：https://github.com/alibaba/druid/ Druid可以做什么？ Druid 可以监控数据库访问性能，Druid 内置提供了一个功能强大的 StatFilter 插件，能够详细统计 SQL 的执行性能，这对于线上分析数据库访问性能有帮助。 替换数据库连接池 DBCP 和 C3P0，Druid 提供了一个高效、功能强大、可扩展性好的数据库连接池。 数据库密码加密，直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver 和 DruidDataSource 都支持 PasswordCallback。 SQL 执行日志，Druid 提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog，你可以按需要选择相应的 LogFilter，监控你应用的数据库访问情况。 扩展 JDBC，如果你要对 JDBC 层有编程的需求，可以通过 Druid 提供的 Filter-Chain 机制，很方便编写 JDBC 层的扩展插件。 对于本文来说，我们重点来看它的第 3 个特性，也就是使用 Druid 来实现数据库密码加密。 加密执行流程在没有进行密码加密之前，项目的交互流程是这样的： 在使用了密码加密之后，项目的交互流程就变成了这样： 使用Druid实现加密本示例运行环境： Spring Boot 2.4.3 MySQL 5.7 Java 1.8 Idea 2020.1.3 1.添加Druid依赖Maven 项目： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; Gradle 项目： 1compile &#x27;com.alibaba:druid-spring-boot-starter:1.2.5&#x27; 获取 Druid 最新版本：https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter 2.生成密文Druid 添加完成之后就可以借助 Druid 中提供的 ConfigTools 类来加密密码了，实现代码如下： 12345678910import com.alibaba.druid.filter.config.ConfigTools;class MyTests &#123; public static void main(String[] args) throws Exception &#123; // 需要加密的明文命名 String password = &quot;youPassword&quot;; // 【注意：这里要改为你自己的密码】 // 调用 druid 生成私钥、公钥、密文 ConfigTools.main(new String[]&#123;password&#125;); &#125;&#125; 以上代码执行的结果如下： privateKey:MIIBUwIBADANBgkqhkiG9w0BAQEFAASCAT0wggE5AgEAAkEApOjcMWSDzJiKVGmtcBBoQPtM9tVW2H2cnS6xZK7NrbzQXYWLQD2zefIrrx9vMvqRIHEqkmAHTuUcUXHgCxu0cwIDAQABAkAlqo5ItdWo0Jqf5zdXJlg5p2yP4HCiqCYyfKzF+2s9KEmgWZJWTctZDsgQ0iYUohORR59I+J4nabhel1x5&#x2F;INpAiEA6jwSyFqMUPOh1XlrzNFek+RthOQ5n4+ALPo+vULayO0CIQC0O7JM9sIq+tg+jCGv+ypk6vbuRKY9m5W2rSRXapGm3wIgRHul3jAjIDPrF&#x2F;f1HaAFL+Y0Yws7Ebyp8&#x2F;yCRWF7iA0CIALbe20q8FMcHPeI4zPWCIsHCpkmb3hEkjAOOKhGIT8DAiAqiUuz92NqKeyjmOfons1ka65EzVwA3NDhZ6+IQcnuig&#x3D;&#x3D; publicKey:MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKTo3DFkg8yYilRprXAQaED7TPbVVth9nJ0usWSuza280F2Fi0A9s3nyK68fbzL6kSBxKpJgB07lHFFx4AsbtHMCAwEAAQ&#x3D;&#x3D; password:IMgKm27bOHok3&#x2F;+5aDL4jGBoVVZkpicbbM6pIXQppi3dI7h3jngSAqhqwqYnfuYpyVJ0k++q9xWWnHtd6sAWnQ&#x3D;&#x3D; 从上述结果可以看出，使用 ConfigTools 类会生成 3 部分的内容： privateKey：私钥，暂时不会用到，用于密码的加密； publicKey：公钥，用于密码的解密； password：加密之后的密码。 PS：要实现数据库的加密，主要使用的是 publicKey（公钥）和 password（密文），这就把明文转换成密文了。 3.添加配置完成了以上操作之后，只需要将上一步生成的公钥和密文添加到项目的配置文件 application.yml（或application.xml）中就实现了加密操作了，具体配置信息如下： 1234567891011121314spring: # MySQL 配置 datasource: driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql://127.0.0.1:3306/testdb?serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8&amp;useSSL=false username: root password: IMgKm27bOHok3/+5aDL4jGBoVVZkpicbbM6pIXQppi3dI7h3jngSAqhqwqYnfuYpyVJ0k++q9xWWnHtd6sAWnQ== # encrypt config filters: config connect-properties: config.decrypt: true config.decrypt.key: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKTo3DFkg8yYilRprXAQaED7TPbVVth9nJ0usWSuza280F2Fi0A9s3nyK68fbzL6kSBxKpJgB07lHFFx4AsbtHMCAwEAAQ== 其中 password 对应的是上一步生成的 password（密文），而 config.decrypt.key 对应的是上一步生成的 publicKey（公钥），如下图所示： 这里提供一个原始的配置文件，以便和加密后的配置文件进行比对： 4.注意事项-插着钥匙的锁经过前面 3 步的配置之后，我们的程序就可以正常运行了，但这远没有结束！ 在第 3 步配置时，我们将密文和公钥都写入配置文件，这就会造成当有人拿到密文和公钥之后，就可以使用 Druid 将加密的密码还原出来了，这就好比一把插着钥匙的锁是极不安全的。 因此我们正确的使用姿势：是将公钥找一个安全的地方保存起来，每次在项目启动时动态的将公钥设置到项目中，这样就可以有效的保证密码的安全了。 正确的配置文件接下来我们将 Spring Boot 的公钥设置为配置项，在项目运行时再替换为具体的值，最终的安全配置信息如下： 1234567891011121314spring: # MySQL 配置 datasource: driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql://127.0.0.1:3306/testdb?serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8&amp;useSSL=false username: root password: IMgKm27bOHok3/+5aDL4jGBoVVZkpicbbM6pIXQppi3dI7h3jngSAqhqwqYnfuYpyVJ0k++q9xWWnHtd6sAWnQ== # encrypt config filters: config connect-properties: config.decrypt: true config.decrypt.key: $&#123;spring.datasource.druid.publickey&#125; 可以看出公钥被修改成“${spring.datasource.druid.publickey}”了，这就相当于使用占位符先把坑给占上，等项目启动时再更换上具体的值。 PS：“spring.datasource.druid.publickey”并非是固定不可变的 key，此 key 值用户可自行定义。 开发环境替换公钥开发环境只需要在 Idea 的启动参数中配置公钥的值即可，如下图所示： 当我们输入正确的公钥值时程序可以正常运行，当输入一个错误的公钥值时就会提示解码失败，如下图所示： 生产环境替换公钥生产环境在启动 jar 包时只需要动态设置公钥的值即可，参考以下命令： java -jar xxx.jar –spring.datasource.druid.publickey&#x3D;你的公钥 Druid运行原理经过上述步骤之后，我们就完成 MySQL 密码的加密了，这样当 Spring Boot 项目启动时，Druid 的拦截器会使用密文和公钥将密码还原成真实的密码以供项目使用，当然这一切都无需人工干预（无需编写任何代码），Druid 已经帮我封装好了，我们只需要通过以上配置即可。 什么？你想知道 Druid 是如何通过密文和公钥还原出真实的密码的？ 没问题，满足你，其实 ConfigTools 类中已经提供了相应实现，代码如下： 1234567// 密文String password = &quot;VwH1mu2IUpqjfKTd+gSikiZgJTi+3Y5zFIFRfxYnH1UqHzm1K8TIHnMaV3TErBaGsVEaGV0e63pb0Ys3Wdm7Kg==&quot;;// 公钥String publicKey = &quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALWIEp19IM04sB+vQXnEOH9gFNFdL5TFGSEhORgHj4MnfTfBSNaOoSgCaM8BOpjiHmwuEb7LpvmXI1x/ymUvNzECAwEAAQ==&quot;;// 还原成真实的密码String result = ConfigTools.decrypt(publicKey, password);System.out.println(&quot;最终结果：&quot; + result); 总结本文我们使用阿里巴巴开源的 Druid 实现了 MySQL 的密码加密，Druid 的加密过程非常方便，无需编写任何代码，只需要添加 Druid 依赖，再通过 Druid 的工具类生成密文，最后将密文配置到 application.yml 文件即可。项目在运行时会通过拦截器将密文转换成真正的密码，从而实现了 MySQL 密码的加密和解码的过程。","tags":["数据库","MySQL","Druid"],"categories":["数据库","Druid","MySQL"]},{"title":"qq音乐听不了系列","path":"/9817823d/","content":"qq音乐听不了系列 高音质的歌曲(20-60M左右)注意流量消耗，其他(3-5M左右)请随意！想听的歌可以留言哟，看到之后会放上去！ var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"最伟大的作品\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.lrc\"},{\"title\":\"Letting Go\",\"author\":\"蔡健雅\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20Letting%20Go.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E5%B0%81%E9%9D%A2/Letting%20Go.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E6%AD%8C%E8%AF%8D/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20Letting%20Go.lrc\"},{\"title\":\"红色高跟鞋\",\"author\":\"蔡健雅\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20%E7%BA%A2%E8%89%B2%E9%AB%98%E8%B7%9F%E9%9E%8B.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E5%B0%81%E9%9D%A2/%E7%BA%A2%E8%89%B2%E9%AB%98%E8%B7%9F%E9%9E%8B.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E6%AD%8C%E8%AF%8D/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20%E7%BA%A2%E8%89%B2%E9%AB%98%E8%B7%9F%E9%9E%8B.lrc\"},{\"title\":\"晴天\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8F%B6%E6%83%A0%E7%BE%8E/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%99%B4%E5%A4%A9.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8F%B6%E6%83%A0%E7%BE%8E.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%99%B4%E5%A4%A9.lrc\"},{\"title\":\"告白地球\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%E7%9A%84%E5%BA%8A%E8%BE%B9%E6%95%85%E4%BA%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%91%8A%E7%99%BD%E6%B0%94%E7%90%83.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%91%A8%E6%9D%B0%E4%BC%A6%E7%9A%84%E5%BA%8A%E8%BE%B9%E6%95%85%E4%BA%8B.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%91%8A%E7%99%BD%E6%B0%94%E7%90%83.lrc\"},{\"title\":\"花海\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%8A%B1%E6%B5%B7.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%8A%B1%E6%B5%B7.lrc\"},{\"title\":\"稻香\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%A8%BB%E9%A6%99.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%A8%BB%E9%A6%99.lrc\"},{\"title\":\"七里香\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%B8%83%E9%87%8C%E9%A6%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%83%E9%87%8C%E9%A6%99.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%B8%83%E9%87%8C%E9%A6%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%83%E9%87%8C%E9%A6%99.lrc\"},{\"title\":\"好想爱这个世界啊\",\"author\":\"华晨宇\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%8D%8E%E6%99%A8%E5%AE%87/%E5%8D%8E%E6%99%A8%E5%AE%87%20-%20%E5%A5%BD%E6%83%B3%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%95%8A.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%8D%8E%E6%99%A8%E5%AE%87/%E5%B0%81%E9%9D%A2/%E5%A5%BD%E6%83%B3%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%95%8A.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%8D%8E%E6%99%A8%E5%AE%87/%E6%AD%8C%E8%AF%8D/%E5%8D%8E%E6%99%A8%E5%AE%87%20-%20%E5%A5%BD%E6%83%B3%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%95%8A.lrc\"},{\"title\":\"奔赴星空\",\"author\":\"尹昔眠、小田音乐社\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%B9%E6%98%94%E7%9C%A0%E3%80%81%E5%B0%8F%E7%94%B0%E9%9F%B3%E4%B9%90%E7%A4%BE%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%81%E9%9D%A2/%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E6%AD%8C%E8%AF%8D/%E5%B0%B9%E6%98%94%E7%9C%A0%E3%80%81%E5%B0%8F%E7%94%B0%E9%9F%B3%E4%B9%90%E7%A4%BE%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.lrc\"},{\"title\":\"满天星辰不及你\",\"author\":\"ycccc\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/ycccc%20-%20%E6%BB%A1%E5%A4%A9%E6%98%9F%E8%BE%B0%E4%B8%8D%E5%8F%8A%E4%BD%A0.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%81%E9%9D%A2/%E6%BC%AB%E5%A4%A9%E6%98%9F%E8%BE%B0%E4%B8%8D%E5%8F%8A%E4%BD%A0.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E6%AD%8C%E8%AF%8D/ycccc%20-%20%E6%BB%A1%E5%A4%A9%E6%98%9F%E8%BE%B0%E4%B8%8D%E5%8F%8A%E4%BD%A0.lrc\"},{\"title\":\"幻纱之灵\",\"author\":\"张靓颖、王者荣耀\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%BC%A0%E9%9D%93%E9%A2%96%E3%80%81%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%20-%20%E5%B9%BB%E7%BA%B1%E4%B9%8B%E7%81%B5.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%81%E9%9D%A2/%E5%B9%BB%E7%BA%B1%E4%B9%8B%E7%81%B5.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E6%AD%8C%E8%AF%8D/%E5%BC%A0%E9%9D%93%E9%A2%96%E3%80%81%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%20-%20%E5%B9%BB%E7%BA%B1%E4%B9%8B%E7%81%B5.lrc\"},{\"title\":\"我是如此相信\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%88%91%E6%98%AF%E5%A6%82%E6%AD%A4%E7%9B%B8%E4%BF%A1.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%88%91%E6%98%AF%E5%A6%82%E6%AD%A4%E7%9B%B8%E4%BF%A1.lrc\"},{\"title\":\"夜曲\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A4%9C%E6%9B%B2.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A4%9C%E6%9B%B2.lrc\"},{\"title\":\"给我一首歌的时间\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%BB%99%E6%88%91%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%BB%99%E6%88%91%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4.lrc\"},{\"title\":\"不能说的秘密\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86%20%E7%94%B5%E5%BD%B1%E5%8E%9F%E5%A3%B0%E5%B8%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86%20%E7%94%B5%E5%BD%B1%E5%8E%9F%E5%A3%B0%E5%B8%A6.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86.lrc\"},{\"title\":\"甜甜的\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%88%91%E5%BE%88%E5%BF%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%94%9C%E7%94%9C%E7%9A%84.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%BE%88%E5%BF%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%94%9C%E7%94%9C%E7%9A%84.lrc\"},{\"title\":\"蒲公英的约定\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%88%91%E5%BE%88%E5%BF%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%92%B2%E5%85%AC%E8%8B%B1%E7%9A%84%E7%BA%A6%E5%AE%9A.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%BE%88%E5%BF%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%92%B2%E5%85%AC%E8%8B%B1%E7%9A%84%E7%BA%A6%E5%AE%9A.lrc\"},{\"title\":\"青花瓷\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%88%91%E5%BE%88%E5%BF%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9D%92%E8%8A%B1%E7%93%B7.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%BE%88%E5%BF%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9D%92%E8%8A%B1%E7%93%B7.lrc\"},{\"title\":\"一路向北\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/J%20III%20MP3%20Player/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/J%20III%20MP3%20Player.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97.lrc\"},{\"title\":\"她的睫毛\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8F%B6%E6%83%A0%E7%BE%8E/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A5%B9%E7%9A%84%E7%9D%AB%E6%AF%9B.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8F%B6%E6%83%A0%E7%BE%8E.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A5%B9%E7%9A%84%E7%9D%AB%E6%AF%9B.lrc\"},{\"title\":\"反方向的钟\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/Jay/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8D%E6%96%B9%E5%90%91%E7%9A%84%E9%92%9F.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/Jay.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8D%E6%96%B9%E5%90%91%E7%9A%84%E9%92%9F.lrc\"},{\"title\":\"烟花易冷\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E8%B7%A8%E6%97%B6%E4%BB%A3/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%83%9F%E8%8A%B1%E6%98%93%E5%86%B7.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E8%B7%A8%E6%97%B6%E4%BB%A3.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%83%9F%E8%8A%B1%E6%98%93%E5%86%B7.lrc\"},{\"title\":\"听妈妈的话\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%90%AC%E5%A6%88%E5%A6%88%E7%9A%84%E8%AF%9D.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%90%AC%E5%A6%88%E5%A6%88%E7%9A%84%E8%AF%9D.lrc\"},{\"title\":\"等你下课 (with 杨瑞代)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%20(with%20%E6%9D%A8%E7%91%9E%E4%BB%A3).mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%20(with%20%E6%9D%A8%E7%91%9E%E4%BB%A3).lrc\"},{\"title\":\"错过的烟火\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%94%99%E8%BF%87%E7%9A%84%E7%83%9F%E7%81%AB.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%94%99%E8%BF%87%E7%9A%84%E7%83%9F%E7%81%AB.lrc\"},{\"title\":\"还在流浪\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%BF%98%E5%9C%A8%E6%B5%81%E6%B5%AA.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%BF%98%E5%9C%A8%E6%B5%81%E6%B5%AA.lrc\"},{\"title\":\"说好不哭 (with 五月天阿信)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD%20(with%20%E4%BA%94%E6%9C%88%E5%A4%A9%E9%98%BF%E4%BF%A1).mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD%20(with%20%E4%BA%94%E6%9C%88%E5%A4%A9%E9%98%BF%E4%BF%A1).lrc\"},{\"title\":\"粉色海洋\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%B2%89%E8%89%B2%E6%B5%B7%E6%B4%8B.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%B2%89%E8%89%B2%E6%B5%B7%E6%B4%8B.lrc\"},{\"title\":\"Mojito\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20Mojito.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20Mojito.lrc\"},{\"title\":\"霍元甲\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%9C%8D%E5%85%83%E7%94%B2/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9C%8D%E5%85%83%E7%94%B2.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%9C%8D%E5%85%83%E7%94%B2.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9C%8D%E5%85%83%E7%94%B2.lrc\"},{\"title\":\"夜的第七章\",\"author\":\"周杰伦、潘儿\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%E3%80%81%E6%BD%98%E5%84%BF%20-%20%E5%A4%9C%E7%9A%84%E7%AC%AC%E4%B8%83%E7%AB%A0.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%E3%80%81%E6%BD%98%E5%84%BF%20-%20%E5%A4%9C%E7%9A%84%E7%AC%AC%E4%B8%83%E7%AB%A0.lrc\"},{\"title\":\"本草纲目\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%AC%E8%8D%89%E7%BA%B2%E7%9B%AE.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%AC%E8%8D%89%E7%BA%B2%E7%9B%AE.lrc\"},{\"title\":\"简单爱\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AE%80%E5%8D%95%E7%88%B1.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AE%80%E5%8D%95%E7%88%B1.lrc\"},{\"title\":\"双截棍\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8C%E6%88%AA%E6%A3%8D.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8C%E6%88%AA%E6%A3%8D.lrc\"},{\"title\":\"枫\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9E%AB.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9E%AB.lrc\"},{\"title\":\"兰亭序\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%85%B0%E4%BA%AD%E5%BA%8F.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%85%B0%E4%BA%AD%E5%BA%8F.lrc\"},{\"title\":\"明明就\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8D%81%E4%BA%8C%E6%96%B0%E4%BD%9C/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%98%8E%E6%98%8E%E5%B0%B1.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8D%81%E4%BA%8C%E6%96%B0%E4%BD%9C.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%98%8E%E6%98%8E%E5%B0%B1.lrc\"},{\"title\":\"半岛铁盒\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%85%AB%E5%BA%A6%E7%A9%BA%E9%97%B4/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8D%8A%E5%B2%9B%E9%93%81%E7%9B%92.mp3\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%85%AB%E5%BA%A6%E7%A9%BA%E9%97%B4.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8D%8A%E5%B2%9B%E9%93%81%E7%9B%92.lrc\"},{\"title\":\"最伟大的作品(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.lrc\"},{\"title\":\"Letting Go(高音质)\",\"author\":\"蔡健雅\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20Letting%20Go.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E5%B0%81%E9%9D%A2/Letting%20Go.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E6%AD%8C%E8%AF%8D/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20Letting%20Go.lrc\"},{\"title\":\"红色高跟鞋(高音质)\",\"author\":\"蔡健雅\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20%E7%BA%A2%E8%89%B2%E9%AB%98%E8%B7%9F%E9%9E%8B.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E5%B0%81%E9%9D%A2/%E7%BA%A2%E8%89%B2%E9%AB%98%E8%B7%9F%E9%9E%8B.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E8%94%A1%E5%81%A5%E9%9B%85/%E6%AD%8C%E8%AF%8D/%E8%94%A1%E5%81%A5%E9%9B%85%20-%20%E7%BA%A2%E8%89%B2%E9%AB%98%E8%B7%9F%E9%9E%8B.lrc\"},{\"title\":\"晴天(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8F%B6%E6%83%A0%E7%BE%8E/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%99%B4%E5%A4%A9.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8F%B6%E6%83%A0%E7%BE%8E.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%99%B4%E5%A4%A9.lrc\"},{\"title\":\"告白地球(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%E7%9A%84%E5%BA%8A%E8%BE%B9%E6%95%85%E4%BA%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%91%8A%E7%99%BD%E6%B0%94%E7%90%83.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%91%A8%E6%9D%B0%E4%BC%A6%E7%9A%84%E5%BA%8A%E8%BE%B9%E6%95%85%E4%BA%8B.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%91%8A%E7%99%BD%E6%B0%94%E7%90%83.lrc\"},{\"title\":\"花海(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%8A%B1%E6%B5%B7.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%8A%B1%E6%B5%B7.lrc\"},{\"title\":\"稻香(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%A8%BB%E9%A6%99.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%A8%BB%E9%A6%99.lrc\"},{\"title\":\"七里香(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%B8%83%E9%87%8C%E9%A6%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%83%E9%87%8C%E9%A6%99.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%B8%83%E9%87%8C%E9%A6%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%83%E9%87%8C%E9%A6%99.lrc\"},{\"title\":\"好想爱这个世界啊(高音质)\",\"author\":\"华晨宇\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%8D%8E%E6%99%A8%E5%AE%87/%E5%8D%8E%E6%99%A8%E5%AE%87%20-%20%E5%A5%BD%E6%83%B3%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%95%8A.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%8D%8E%E6%99%A8%E5%AE%87/%E5%B0%81%E9%9D%A2/%E5%A5%BD%E6%83%B3%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%95%8A.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%8D%8E%E6%99%A8%E5%AE%87/%E6%AD%8C%E8%AF%8D/%E5%8D%8E%E6%99%A8%E5%AE%87%20-%20%E5%A5%BD%E6%83%B3%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%95%8A.lrc\"},{\"title\":\"奔赴星空(高音质)\",\"author\":\"尹昔眠、小田音乐社\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%B9%E6%98%94%E7%9C%A0%E3%80%81%E5%B0%8F%E7%94%B0%E9%9F%B3%E4%B9%90%E7%A4%BE%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%81%E9%9D%A2/%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E6%AD%8C%E8%AF%8D/%E5%B0%B9%E6%98%94%E7%9C%A0%E3%80%81%E5%B0%8F%E7%94%B0%E9%9F%B3%E4%B9%90%E7%A4%BE%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.lrc\"},{\"title\":\"满天星辰不及你(高音质)\",\"author\":\"ycccc\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/ycccc%20-%20%E6%BB%A1%E5%A4%A9%E6%98%9F%E8%BE%B0%E4%B8%8D%E5%8F%8A%E4%BD%A0.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%81%E9%9D%A2/%E6%BC%AB%E5%A4%A9%E6%98%9F%E8%BE%B0%E4%B8%8D%E5%8F%8A%E4%BD%A0.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E6%AD%8C%E8%AF%8D/ycccc%20-%20%E6%BB%A1%E5%A4%A9%E6%98%9F%E8%BE%B0%E4%B8%8D%E5%8F%8A%E4%BD%A0.lrc\"},{\"title\":\"幻纱之灵(高音质)\",\"author\":\"张靓颖、王者荣耀\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%BC%A0%E9%9D%93%E9%A2%96%E3%80%81%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%20-%20%E5%B9%BB%E7%BA%B1%E4%B9%8B%E7%81%B5.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E5%B0%81%E9%9D%A2/%E5%B9%BB%E7%BA%B1%E4%B9%8B%E7%81%B5.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%85%B6%E4%BB%96/%E6%AD%8C%E8%AF%8D/%E5%BC%A0%E9%9D%93%E9%A2%96%E3%80%81%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%20-%20%E5%B9%BB%E7%BA%B1%E4%B9%8B%E7%81%B5.lrc\"},{\"title\":\"我是如此相信(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%88%91%E6%98%AF%E5%A6%82%E6%AD%A4%E7%9B%B8%E4%BF%A1.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%88%91%E6%98%AF%E5%A6%82%E6%AD%A4%E7%9B%B8%E4%BF%A1.lrc\"},{\"title\":\"夜曲(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A4%9C%E6%9B%B2.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A4%9C%E6%9B%B2.lrc\"},{\"title\":\"给我一首歌的时间(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%BB%99%E6%88%91%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%BB%99%E6%88%91%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4.lrc\"},{\"title\":\"不能说的秘密(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86%20%E7%94%B5%E5%BD%B1%E5%8E%9F%E5%A3%B0%E5%B8%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86%20%E7%94%B5%E5%BD%B1%E5%8E%9F%E5%A3%B0%E5%B8%A6.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86.lrc\"},{\"title\":\"霍元甲(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%9C%8D%E5%85%83%E7%94%B2/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9C%8D%E5%85%83%E7%94%B2.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%9C%8D%E5%85%83%E7%94%B2.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9C%8D%E5%85%83%E7%94%B2.lrc\"},{\"title\":\"甜甜的(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%88%91%E5%BE%88%E5%BF%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%94%9C%E7%94%9C%E7%9A%84.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%BE%88%E5%BF%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%94%9C%E7%94%9C%E7%9A%84.lrc\"},{\"title\":\"蒲公英的约定(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%88%91%E5%BE%88%E5%BF%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%92%B2%E5%85%AC%E8%8B%B1%E7%9A%84%E7%BA%A6%E5%AE%9A.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%BE%88%E5%BF%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%92%B2%E5%85%AC%E8%8B%B1%E7%9A%84%E7%BA%A6%E5%AE%9A.lrc\"},{\"title\":\"青花瓷(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%88%91%E5%BE%88%E5%BF%99/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9D%92%E8%8A%B1%E7%93%B7.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%BE%88%E5%BF%99.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%9D%92%E8%8A%B1%E7%93%B7.lrc\"},{\"title\":\"一路向北(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/J%20III%20MP3%20Player/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/J%20III%20MP3%20Player.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97.lrc\"},{\"title\":\"她的睫毛(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8F%B6%E6%83%A0%E7%BE%8E/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A5%B9%E7%9A%84%E7%9D%AB%E6%AF%9B.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8F%B6%E6%83%A0%E7%BE%8E.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%A5%B9%E7%9A%84%E7%9D%AB%E6%AF%9B.lrc\"},{\"title\":\"反方向的钟(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/Jay/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8D%E6%96%B9%E5%90%91%E7%9A%84%E9%92%9F.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/Jay.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8D%E6%96%B9%E5%90%91%E7%9A%84%E9%92%9F.lrc\"},{\"title\":\"烟花易冷(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E8%B7%A8%E6%97%B6%E4%BB%A3/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%83%9F%E8%8A%B1%E6%98%93%E5%86%B7.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E8%B7%A8%E6%97%B6%E4%BB%A3.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%83%9F%E8%8A%B1%E6%98%93%E5%86%B7.lrc\"},{\"title\":\"听妈妈的话(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%90%AC%E5%A6%88%E5%A6%88%E7%9A%84%E8%AF%9D.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%90%AC%E5%A6%88%E5%A6%88%E7%9A%84%E8%AF%9D.lrc\"},{\"title\":\"等你下课 (with 杨瑞代)(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%20(with%20%E6%9D%A8%E7%91%9E%E4%BB%A3).flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%20(with%20%E6%9D%A8%E7%91%9E%E4%BB%A3).lrc\"},{\"title\":\"错过的烟火(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%94%99%E8%BF%87%E7%9A%84%E7%83%9F%E7%81%AB.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%94%99%E8%BF%87%E7%9A%84%E7%83%9F%E7%81%AB.lrc\"},{\"title\":\"还在流浪(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%BF%98%E5%9C%A8%E6%B5%81%E6%B5%AA.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%BF%98%E5%9C%A8%E6%B5%81%E6%B5%AA.lrc\"},{\"title\":\"说好不哭 (with 五月天阿信)(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD%20(with%20%E4%BA%94%E6%9C%88%E5%A4%A9%E9%98%BF%E4%BF%A1).flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD%20(with%20%E4%BA%94%E6%9C%88%E5%A4%A9%E9%98%BF%E4%BF%A1).lrc\"},{\"title\":\"粉色海洋(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%B2%89%E8%89%B2%E6%B5%B7%E6%B4%8B.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%B2%89%E8%89%B2%E6%B5%B7%E6%B4%8B.lrc\"},{\"title\":\"Mojito(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20Mojito.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BD%9C%E5%93%81.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20Mojito.lrc\"},{\"title\":\"夜的第七章(高音质)\",\"author\":\"周杰伦、潘儿\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%E3%80%81%E6%BD%98%E5%84%BF%20-%20%E5%A4%9C%E7%9A%84%E7%AC%AC%E4%B8%83%E7%AB%A0.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%E3%80%81%E6%BD%98%E5%84%BF%20-%20%E5%A4%9C%E7%9A%84%E7%AC%AC%E4%B8%83%E7%AB%A0.lrc\"},{\"title\":\"本草纲目(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%AC%E8%8D%89%E7%BA%B2%E7%9B%AE.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E4%BE%9D%E7%84%B6%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9C%AC%E8%8D%89%E7%BA%B2%E7%9B%AE.lrc\"},{\"title\":\"简单爱(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AE%80%E5%8D%95%E7%88%B1.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%AE%80%E5%8D%95%E7%88%B1.lrc\"},{\"title\":\"双截棍(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E8%8C%83%E7%89%B9%E8%A5%BF/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8C%E6%88%AA%E6%A3%8D.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E8%8C%83%E7%89%B9%E8%A5%BF.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8F%8C%E6%88%AA%E6%A3%8D.lrc\"},{\"title\":\"枫(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9E%AB.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E8%90%A7%E9%82%A6.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%9E%AB.lrc\"},{\"title\":\"兰亭序(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E9%AD%94%E6%9D%B0%E5%BA%A7/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%85%B0%E4%BA%AD%E5%BA%8F.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E9%AD%94%E6%9D%B0%E5%BA%A7.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%85%B0%E4%BA%AD%E5%BA%8F.lrc\"},{\"title\":\"明明就(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%8D%81%E4%BA%8C%E6%96%B0%E4%BD%9C/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%98%8E%E6%98%8E%E5%B0%B1.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%8D%81%E4%BA%8C%E6%96%B0%E4%BD%9C.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E6%98%8E%E6%98%8E%E5%B0%B1.lrc\"},{\"title\":\"半岛铁盒(高音质)\",\"author\":\"周杰伦\",\"url\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%85%AB%E5%BA%A6%E7%A9%BA%E9%97%B4/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8D%8A%E5%B2%9B%E9%93%81%E7%9B%92.flac\",\"pic\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E5%B0%81%E9%9D%A2/%E5%85%AB%E5%BA%A6%E7%A9%BA%E9%97%B4.jpg\",\"lrc\":\"https://www.everlasting520.top/d/tblog/%E9%9F%B3%E4%B9%90/%E6%AD%8C%E6%89%8B/%E5%91%A8%E6%9D%B0%E4%BC%A6/%E6%AD%8C%E8%AF%8D/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E5%8D%8A%E5%B2%9B%E9%93%81%E7%9B%92.lrc\"}]}; options.element = document.getElementById(\"aplayer-CcopbOJS\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":["音乐","qq音乐"],"categories":["音乐","qq音乐"]},{"title":"名侦探柯南剧场版","path":"/2e3fc7b6/","content":"名侦探柯南剧场版 名侦探柯南剧场版推荐使用火狐浏览器观影最佳 贝克街的亡灵2002var dplayer1 = new DPlayer({\"element\":document.getElementById(\"dplayer1\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E5%8A%A8%E6%BC%AB/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/%E5%89%A7%E5%9C%BA%E7%89%88/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97%E5%89%A7%E5%9C%BA%E7%89%88%E8%B4%9D%E5%85%8B%E8%A1%97%E7%9A%84%E4%BA%A1%E7%81%B5.mp4\"}});","tags":["名侦探柯南","名侦探柯南剧场版","动漫"],"categories":["名侦探柯南","名侦探柯南剧场版","动漫"]},{"title":"SpringBoot读取配置文件的5种方法！","path":"/bfeab9fd/","content":"Spring Boot 中读取配置文件有以下 5 种方法： 使用 @Value 读取配置文件。 使用 @ConfigurationProperties 读取配置文件。 使用 Environment 读取配置文件。 使用 @PropertySource 读取配置文件。 使用原生方式读取配置文件。 它们的具体使用方法如下，为了方便测试，我们在 Spring Boot 配置文件 application.properties 添加以下内容： 12profile.name=Spring Boot Profileprofile.desc=Spring Boot Profile Desc. 1.使用 @Value 读取配置文件使用 @Value 可以读取单个配置项，如下代码所示： 123456789101112@SpringBootApplicationpublic class DemoApplication implements InitializingBean &#123; @Value(&quot;$&#123;profile.name&#125;&quot;) private String name; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;My Profile Name：&quot; + name); &#125;&#125; 2.使用 @ConfigurationProperties 读取配置文件@ConfigurationProperties 和 @Value 的使用略微不同，@Value 是读取单个配置项的，而 @ConfigurationProperties 是读取一组配置项的，我们可以使用 @ConfigurationProperties 加实体类读取一组配置项，如下代码所示： 12345678910import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;profile&quot;)@Datapublic class Profile &#123; private String name; private String desc;&#125; 其中 prefix 表示读取一组配置项的根 name，相当于 Java 中的类名，最后再把此配置类，注入到某一个类中就可以使用了，如下代码所示： 12345678910111213@SpringBootApplicationpublic class DemoApplication implements InitializingBean &#123; @Autowired private Profile profile; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;Profile Object:&quot; + profile); &#125;&#125; 3.使用 Environment 读取配置文件Environment 是 Spring Core 中的一个用于读取配置文件的类，将此类使用 @Autowired 注入到类中就可以使用它的 getProperty 方法来获取某个配置项的值了，如下代码所示： 1234567891011121314151617import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.core.env.Environment;@SpringBootApplicationpublic class DemoApplication implements InitializingBean @Autowired private Environment environment; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;Profile Name：&quot; + environment.getProperty(&quot;profile.name&quot;)); &#125;&#125; 4.使用 @PropertySource 读取配置文件使用 @PropertySource 注解可以用来指定读取某个配置文件，比如指定读取 application.properties 配置文件的配置内容，具体实现代码如下： 12345678910111213@SpringBootApplication@PropertySource(&quot;classpath:application.properties&quot;)public class DemoApplication implements InitializingBean &#123; @Value(&quot;$&#123;profile.name&#125;&quot;) private String name; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;Name：&quot; + name); &#125;&#125; 中文乱码如果配置文件中出现中文乱码的情况，可通过指定编码格式的方式来解决中文乱码的问题，具体实现如下： 1@PropertySource(value = &quot;dev.properties&quot;, encoding = &quot;utf-8&quot;) 注意事项@PropertySource 注解默认是只支持 properties 格式配置文件的读取的。 5.使用原生方式读取配置文件我们还可以使用最原始的方式 Properties 对象来读取配置文件，如下代码所示： 1234567891011121314151617181920212223242526import org.springframework.beans.factory.InitializingBean;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import java.io.IOException;import java.io.InputStreamReader;import java.nio.charset.StandardCharsets;import java.util.Properties;@SpringBootApplicationpublic class DemoApplication implements InitializingBean &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void afterPropertiesSet() throws Exception &#123; Properties props = new Properties(); try &#123; InputStreamReader inputStreamReader = new InputStreamReader( this.getClass().getClassLoader().getResourceAsStream(&quot;application.properties&quot;), StandardCharsets.UTF_8); props.load(inputStreamReader); &#125; catch (IOException e1) &#123; System.out.println(e1); &#125; System.out.println(&quot;Properties Name：&quot; + props.getProperty(&quot;profile.name&quot;)); &#125;&#125; 总结在 Spring Boot 中读取配置文件有以下 5 种方法： 使用 @Value 读取配置文件。 使用 @ConfigurationProperties 读取配置文件。 使用 @PropertySource 读取配置文件。 使用 Environment 读取配置文件。 使用原生方式读取配置文件。 其中最常用的是前 3 种，如果读取某一个配置项可使用 @Value，如果读取一组配置项可使用 @ConfigurationProperties，如果要指定读取某一个具体的配置文件可使用 @PropertySource 来指定。","tags":["SpringBoot","配置文件"],"categories":["SpringBoot","配置文件"]},{"title":"什么是语法糖？Java中有哪些语法糖？","path":"/c05be2cf/","content":"什么是语法糖？Java中有哪些语法糖？语法糖是大厂 Java 面试常问的一个知识点。 本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理 语法糖语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。 有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。 我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。 很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。 解语法糖前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。 说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。 如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。 Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。 糖块一、 switch 支持 String 与枚举前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中switch开始支持String。 在开始coding之前先科普下，Java中的swith自身原本就支持基本类型。比如int、char等。 对于int类型，直接进行数值的比较。对于char类型则是比较其ascii码。 所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte。short，char(ackii码是整型)以及int。 那么接下来看下switch对String得支持，有以下代码： 123456789101112131415public class switchDemoString &#123; public static void main(String[] args) &#123; String str = &quot;world&quot;; switch (str) &#123; case &quot;hello&quot;: System.out.println(&quot;hello&quot;); break; case &quot;world&quot;: System.out.println(&quot;world&quot;); break; default: break; &#125; &#125;&#125; 反编译后内容如下： 123456789101112131415161718192021222324public class switchDemoString&#123; public switchDemoString() &#123; &#125; public static void main(String args[]) &#123; String str = &quot;world&quot;; String s; switch((s = str).hashCode()) &#123; default: break; case 99162322: if(s.equals(&quot;hello&quot;)) System.out.println(&quot;hello&quot;); break; case 113318802: if(s.equals(&quot;world&quot;)) System.out.println(&quot;world&quot;); break; &#125; &#125;&#125; 看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。还好hashCode()方法返回的是int，而不是long。 仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。 糖块二、 泛型我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的。 通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。 C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。 Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。 也就是说，对于Java虚拟机来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。 以下代码： 1234Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;name&quot;, &quot;hollis&quot;); map.put(&quot;wechat&quot;, &quot;Hollis&quot;); map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;); 解语法糖之后会变成： 1234Map map = new HashMap(); map.put(&quot;name&quot;, &quot;hollis&quot;); map.put(&quot;wechat&quot;, &quot;Hollis&quot;); map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;); 以下代码： 12345678910public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) &#123; Iterator&lt;A&gt; xi = xs.iterator(); A w = xi.next(); while (xi.hasNext()) &#123; A x = xi.next(); if (w.compareTo(x) &lt; 0) w = x; &#125; return w;&#125; 类型擦除后会变成： 1234567891011 public static Comparable max(Collection xs)&#123; Iterator xi = xs.iterator(); Comparable w = (Comparable)xi.next(); while(xi.hasNext()) &#123; Comparable x = (Comparable)xi.next(); if(w.compareTo(x) &lt; 0) w = x; &#125; return w;&#125; 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List.class或是List.class，而只有List.class。 糖块三、 自动装箱与拆箱自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。 因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。 原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。 先来看个自动装箱的代码： 1234 public static void main(String[] args) &#123; int i = 10; Integer n = i;&#125; 反编译后代码如下: 12345public static void main(String args[])&#123; int i = 10; Integer n = Integer.valueOf(i);&#125; 再来看个自动拆箱的代码： 12345public static void main(String[] args) &#123; Integer i = 10; int n = i;&#125; 反编译后代码如下： 12345public static void main(String args[])&#123; Integer i = Integer.valueOf(10); int n = i.intValue();&#125; 从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 所以，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。 糖块四 、 方法变长参数可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。 看下以下可变参数代码，其中print方法接收可变参数： 123456789101112public static void main(String[] args) &#123; print(&quot;Holis&quot;, &quot;公众号:Hollis&quot;, &quot;博客：www.hollischuang.com&quot;, &quot;QQ：907607222&quot;); &#125;public static void print(String... strs)&#123; for (int i = 0; i &lt; strs.length; i++) &#123; System.out.println(strs[i]); &#125;&#125; 反编译后代码： 1234567891011121314 public static void main(String args[])&#123; print(new String[] &#123; &quot;Holis&quot;, &quot;\\u516C\\u4F17\\u53F7:Hollis&quot;, &quot;\\u535A\\u5BA2\\uFF1Awww.hollischuang.com&quot;, &quot;QQ\\uFF1A907607222&quot; &#125;);&#125;// transient 不能修饰方法，这里应该是反编译错误了？public static transient void print(String strs[])&#123; for(int i = 0; i &lt; strs.length; i++) System.out.println(strs[i]);&#125; 从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。 糖块五 、 枚举Java SE5提供了一种新的类型-Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。 要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？ 答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类。 那么枚举是由什么类维护的呢，我们简单的写一个枚举： 123public enum t &#123; SPRING,SUMMER;&#125; 然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下： 123456789101112131415161718192021222324252627282930public final class T extends Enum&#123; private T(String s, int i) &#123; super(s, i); &#125; public static T[] values() &#123; T at[]; int i; T at1[]; System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i); return at1; &#125; public static T valueOf(String s) &#123; return (T)Enum.valueOf(demo/T, s); &#125; public static final T SPRING; public static final T SUMMER; private static final T ENUM$VALUES[]; static &#123; SPRING = new T(&quot;SPRING&quot;, 0); SUMMER = new T(&quot;SUMMER&quot;, 1); ENUM$VALUES = (new T[] &#123; SPRING, SUMMER &#125;); &#125;&#125; 通过反编译后代码我们可以看到，public final class T extends Enum，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。 当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。 糖块六 、 内部类内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。 内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。 outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，分别是outer.class和outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。 123456789101112131415161718192021222324252627public class OutterClass &#123; private String userName; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public static void main(String[] args) &#123; &#125; class InnerClass&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 以上代码编译后会生成两个class文件：OutterClass$InnerClass.class 、OutterClass.class 。 当我们尝试使用jad对OutterClass.class文件进行反编译的时候，命令行会打印以下内容： 123Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class...Generating OutterClass.jad 他会把两个文件全部进行反编译，然后一起生成一个OutterClass.jad文件。文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637public class OutterClass&#123; class InnerClass &#123; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private String name; final OutterClass this$0; InnerClass() &#123; this.this$0 = OutterClass.this; super(); &#125; &#125; public OutterClass() &#123; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName)&#123; this.userName = userName; &#125; public static void main(String args1[]) &#123; &#125; private String userName;&#125; 糖块七 、条件编译—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。 如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码： 1234567891011121314public class ConditionalCompilation &#123; public static void main(String[] args) &#123; final boolean DEBUG = true; if(DEBUG) &#123; System.out.println(&quot;Hello, DEBUG!&quot;); &#125; final boolean ONLINE = false; if(ONLINE)&#123; System.out.println(&quot;Hello, ONLINE!&quot;); &#125; &#125;&#125; 反编译后代码如下： 1234567891011121314public class ConditionalCompilation&#123; public ConditionalCompilation() &#123; &#125; public static void main(String args[]) &#123; boolean DEBUG = true; System.out.println(&quot;Hello, DEBUG!&quot;); boolean ONLINE = false; &#125;&#125; 首先，我们发现，在反编译后的代码中没有System.out.println(“Hello, ONLINE!”);，这其实就是条件编译。 当if(ONLINE)为false的时候，编译器就没有对其内的代码进行编译。 所以，Java语法的条件编译，是通过判断条件为常量的if语句实现的。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。 这与C&#x2F;C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。 糖块八 、 断言在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。 如果要开启断言检查，则需要用开关-enableassertions或-ea来开启。 看一段包含断言的代码： 12345678910public class AssertTest &#123; public static void main(String args[]) &#123; int a = 1; int b = 1; assert a == b; System.out.println(&quot;公众号：Hollis&quot;); assert a != b : &quot;Hollis&quot;; System.out.println(&quot;博客：www.hollischuang.com&quot;); &#125;&#125; 反编译后代码如下： 12345678910111213141516171819202122232425public class AssertTest &#123; public AssertTest() &#123; &#125; public static void main(String args[])&#123; int a = 1; int b = 1; if(!$assertionsDisabled &amp;&amp; a != b) throw new AssertionError(); System.out.println(&quot;\\u516C\\u4F17\\u53F7\\uFF1AHollis&quot;); if(!$assertionsDisabled &amp;&amp; a == b) &#123; throw new AssertionError(&quot;Hollis&quot;); &#125; else &#123; System.out.println(&quot;\\u535A\\u5BA2\\uFF1Awww.hollischuang.com&quot;); return; &#125;&#125;static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();&#125; 很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。 其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。 -enableassertions会设置$assertionsDisabled字段的值。 糖块九 、 数值字面量在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。 比如： 123456public class Test &#123; public static void main(String... args) &#123; int i = 10_000; System.out.println(i); &#125;&#125; 反编译后： 12345678public class Test&#123; public static void main(String[] args) &#123; int i = 10000; System.out.println(i); &#125;&#125; 反编译后就是把_删除了。也就是说编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。 糖块十 、 for-each增强for循环（for-each）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？ 12345678910public static void main(String... args) &#123; String[] strs = &#123;&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;&#125;; for (String s : strs) &#123; System.out.println(s); &#125; List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;); for (String s : strList) &#123; System.out.println(s); &#125;&#125; 反编译后代码如下： 12345678910111213141516171819public static transient void main(String args[])&#123; String strs[] = &#123; &quot;Hollis&quot;, &quot;\\u516C\\u4F17\\u53F7\\uFF1AHollis&quot;, &quot;\\u535A\\u5BA2\\uFF1Awww.hollischuang.com&quot; &#125;; String args1[] = strs; int i = args1.length; for(int j = 0; j &lt; i; j++) &#123; String s = args1[j]; System.out.println(s); &#125; List strList = ImmutableList.of(&quot;Hollis&quot;, &quot;\\u516C\\u4F17\\u53F7\\uFF1AHollis&quot;, &quot;\\u535A\\u5BA2\\uFF1Awww.hollischuang.com&quot;); String s; for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s)) s = (String)iterator.next();&#125; 代码很简单，for-each的实现原理其实就是使用了普通的for循环和迭代器。 糖块十一 、 try-with-resourceJava里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。 关闭资源的常用方式就是在finally块里是释放，即调用close方法。比如，我们经常会写这样的代码： 1234567891011121314151617181920public static void main(String[] args) &#123; BufferedReader br = null; try &#123; String line; br = new BufferedReader(new FileReader(&quot;d:\\\\hollischuang.xml&quot;)); while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // handle exception &#125; finally &#123; try &#123; if (br != null) &#123; br.close(); &#125; &#125; catch (IOException ex) &#123; // handle exception &#125; &#125;&#125; 从Java 7开始，jdk提供了一种更好的方式关闭资源，使用try-with-resources语句，改写一下上面的代码，效果如下： 12345678910public static void main(String... args) &#123; try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\\\ hollischuang.xml&quot;))) &#123; String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // handle exception &#125;&#125; 看，这简直是一大福音啊，虽然我之前一般使用IOUtils去关闭流，并不会使用在finally中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。 反编译以上代码，看下他的背后原理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static transient void main(String args[]) &#123; BufferedReader br; Throwable throwable; br = new BufferedReader(new FileReader(&quot;d:\\\\ hollischuang.xml&quot;)); throwable = null; String line; try &#123; while((line = br.readLine()) != null) System.out.println(line); &#125; catch(Throwable throwable2) &#123; throwable = throwable2; throw throwable2; &#125; if(br != null) if(throwable != null) try &#123; br.close(); &#125; catch(Throwable throwable1) &#123; throwable.addSuppressed(throwable1); &#125; else br.close(); break MISSING_BLOCK_LABEL_113; Exception exception; exception; if(br != null) if(throwable != null) try &#123; br.close(); &#125; catch(Throwable throwable3) &#123; throwable.addSuppressed(throwable3); &#125; else br.close(); throw exception; IOException ioexception; ioexception; &#125;&#125; 其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。 所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。 糖块十二、Lambda表达式关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。 Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。 先来看一个简单的lambda表达式。遍历一个list： 12345public static void main(String... args) &#123; List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;); strList.forEach( s -&gt; &#123; System.out.println(s); &#125; );&#125; 为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。 反编译后代码如下: 12345678public static /* varargs */ void main(String ... args) &#123; ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\\u516c\\u4f17\\u53f7\\uff1aHollis&quot;, (Object)&quot;\\u535a\\u5ba2\\uff1awww.hollischuang.com&quot;); strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());&#125;private static /* synthetic */ void lambda$main$0(String s) &#123; System.out.println(s);&#125; 可以看到，在forEach方法中，其实是调用了java.lang.invoke.LambdaMetafactory#metafactory方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个lambda$main$0方法进行了输出。 再来看一个稍微复杂一点的，先对List进行过滤，然后再输出： 1234567public static void main(String... args) &#123; List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;); List HollisList = strList.stream().filter(string -&gt; string.contains(&quot;Hollis&quot;)).collect(Collectors.toList()); HollisList.forEach( s -&gt; &#123; System.out.println(s); &#125; );&#125; 反编译后代码如下： 12345678910111213public static /* varargs */ void main(String ... args) &#123; ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\\u516c\\u4f17\\u53f7\\uff1aHollis&quot;, (Object)&quot;\\u535a\\u5ba2\\uff1awww.hollischuang.com&quot;); List&lt;Object&gt; HollisList = strList.stream().filter((Predicate&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList()); HollisList.forEach((Consumer&lt;Object&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());&#125;private static /* synthetic */ void lambda$main$1(Object s) &#123; System.out.println(s);&#125;private static /* synthetic */ boolean lambda$main$0(String string) &#123; return string.contains(&quot;Hollis&quot;);&#125; 两个lambda表达式分别调用了lambda$main$1和lambda$main$0两个方法。 所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。 可能遇到的坑泛型——当泛型遇到重载12345678public class GenericTypes &#123; public static void method(List&lt;String&gt; list) &#123; System.out.println(&quot;invoke method(List&lt;String&gt; list)&quot;); &#125; public static void method(List&lt;Integer&gt; list) &#123; System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;); &#125; &#125; 上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List，但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。 泛型—— 当泛型遇到catch泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException和MyException的 泛型—-当泛型内包含静态变量12345678910111213public class StaticTest&#123; public static void main(String[] args)&#123; GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;(); gti.var=1; GT&lt;String&gt; gts = new GT&lt;String&gt;(); gts.var=2; System.out.println(gti.var); &#125;&#125;class GT&lt;T&gt;&#123; public static int var=0; public void nothing(T x)&#123;&#125;&#125; 以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。 自动装箱与拆箱——对象相等比较12345678public static void main(String[] args) &#123; Integer a = 1000; Integer b = 1000; Integer c = 100; Integer d = 100; System.out.println(&quot;a == b is &quot; + (a == b)); System.out.println((&quot;c == d is &quot; + (c == d)));&#125; 输出结果： 12a == b is falsec == d is true 在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。 适用于整数值区间-128 至 +127。 只适用于自动装箱。使用构造函数创建对象不适用。 增强for循环1234for (Student stu : students) &#123; if (stu.getId() == 2) students.remove(stu); &#125; 会抛出ConcurrentModificationException异常。 Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。 所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。 总结前面介绍了12种Java中常用的语法糖。由于篇幅问题，其他还有一些常见的语法糖比如字符串拼接其实基于 StringBuilder，Java10 里面的 var 关键字声明局部变量采用的是智能类型推断这里就不提了。 所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。 当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。 有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。","tags":["Java","语法糖"],"categories":["Java","语法糖"]},{"title":"Docker学习1","path":"/57005deb/","content":"Docker学习11.Docker的基本组成镜像（image）、容器（container）、仓库（repository） 镜像Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。 容器1 从面向对象角度 Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台 2 从镜像容器角度 ***可以把容器看做是一个简易版的 Linux 环境***（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 仓库仓库（Repository）是集中存放镜像文件的场所。 类似于 Maven仓库，存放各种jar包的地方； github仓库，存放各种git项目的地方； Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub(https://hub.docker.com/)， 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等 小总结需要正确的理解仓库&#x2F;镜像&#x2F;容器这几个概念: Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 镜像文件 * image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 容器实例 * 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器 仓库 * 就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。 2.Docker平台架构图解(入门版) Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。可以对比mysql演示对比讲解。 3.Docker平台架构图解(架构版)Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 Docker运行的基本流程为: 用户是使用Docker Client与 Docker Daemon建立通信，并发送请求给后者。 Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client的请求。 Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。 Job 的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。 当需要为Docker创建网络环境时，通过网络管理驱动Network driver创建并配置Docker容器网络环境。 当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。 4.CentOS7安装Docker官网:https://docs.docker.com/engine/install/centos/ 1.确定你是centOS7及以上版本 1cat /etc/redhat-release 2.卸载旧版本 3.yum安装gcc相关 Centos7能上外网 yum -y install gcc vum -y install gcc-c++ 4.安装需要的软件包,执行命令 1yum install -y yum-utils 5.设置stable镜像仓库 1234567大坑:yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo报错:1 [Errno 14] curl#35 - TCP connection reset by peer2 [Errno 12] curl#35 - Timeout推荐:yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6.更新yum软件包索引 1yum makecache fast 7.安装DOCKER CE 1yum -y ins tall docker-ce docker-ce-cli containerd.io 8.启动docker 1systemctl start docker 9.测试 12docker versiondocker run hello-world 10.卸载 1234systemctl stop dockeryum remove docker-ce docker-ce-cli containerd.iorm -rf /var/lib/dockerrm -rf /var/lib/containerd 5.阿里云镜像加速https://promotion.aliyun.com/ntms/act/kubernetes.html 注册一个属于自己的阿里云账户(可复用淘宝账号) 获得加速器地址连接 登陆阿里云开发者平台 点击控制台 选择容器镜像服务 获取加速器地址 粘贴脚本直接执行 mkdir -p /etc/docker tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; &#123; &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;] &#125; EOF 12345678910- 或者分步骤都行- ```bash mkdir -p /etc/docker vim /etc/docker/daemon.json #阿里云 &#123; &quot;registry-mirrors&quot;: [&quot;https://｛自已的编码｝.mirror.aliyuncs.com&quot;] &#125; 重启服务器 sys temctl daemon-reload sys temctl restart docker 123456789101112131415161718192021222324252627282930313233343536## 6.永远的HelloWorlddocker run hello-world，run了什么![](https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/blog/%E5%AD%A6%E4%B9%A0/Docker/6.png)## 7.底层原理为什么Docker会比VM虚拟机快(1)docker有着比虚拟机更少的抽象层由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。![](https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/blog/%E5%AD%A6%E4%B9%A0/Docker/7.png)![](https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/blog/%E5%AD%A6%E4%B9%A0/Docker/8.png)## 8.Docker常用命令### 帮助启动类命令```bash启动docker: systemctl start docker停止docker: systemctl stop docker重启docker: systemctl restart docker查看docker状态: systemctl status docker开机启动: systemctl enable docker查看docker概要信息: docker info查看docker总体帮助文档: docker --help查看docker命令帮助文档: docker 具体命令 --help 镜像命令123456789101112docker images //列出本地主机上的镜像OPTIONS说明:-a :列出本地所有的镜像（含历史映像层)-q :只显示镜像ID。各个选项说明:REPOSITORY：表示镜像的仓库源TAG：镜像的标签版本号IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像 1234docker search [OPTIONS] 镜像名字OPTIONS说明:--limit :只列出N个镜像，默认25个docker search --limit 5 redis 123docker pull 某个XXx镜像名字 //下载镜像docker pull 镜像名字[:TAG]docker pull ubuntu 1docker system df //查看镜像/容器/数据卷所占的空间 1234docker rmi 某个镜像名字ID //删除镜像删除单个: docker rmi -f 镜像ID删除多个: docker rmi -f 镜像名1:TAG 镜像名2:TAG删除全部: docker rmi -f $(docker images -qa) 面试题:谈谈docker虚悬镜像是什么? 仓库名、标签都是的镜像，俗称虚悬镜像dangling image 思考：结合我们Git的学习心得，大家猜猜是否会有docker commit &#x2F;docker push? 容器命令有镜像才能创建容器，这是根本前提(下载一个CentOS或者ubuntu镜像演示) docker pull centos,docker pull ubuntu 本次演示用ubuntu演示 新建+启动容器1234567891011121314151617181920docker run [OPTIONS] IMAGE[COMMAND][ARG...]OPTIONS说明（常用）：有些是一个减号，有些是两个减号--name=&quot;容器新名字&quot; 为容器指定一个名称；-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；-i：以交互模式运行容器，通常与 -t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；也即启动交互式容器(前台有伪终端，等待交互)；-P: 随机端口映射，大写P-p: 指定端口映射，小写p启动交互式容器(前台命令行)#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。docker run -it centos /bin/bash参数说明：-i: 交互式操作。-t: 终端。centos : centos 镜像。/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。要退出终端，直接输入 exit:重新进入docker exec -it &lt;name/ID&gt; /bin/bash 列出当前所有正在运行的容器123456docker ps [OPTIONS]OPTIONS说明（常用）：-a :列出当前所有正在运行的容器+历史上运行过的-l :显示最近创建的容器。-n：显示最近n个创建的容器。-q :静默模式，只显示容器编号。 退出容器12exit:run进去容器，exit退出，容器停止ctrl+p+q:run进去容器，ctrl+p+q退出，容器不停止 启动已停止运行的容器1docker start 容器ID或者容器名 重启容器1docker restart 容器ID或者容器名 停止容器1docker stop 容器ID或者容器名 强制停止容器1docker kil 容器ID或容器名 删除已停止的容器1docker rm 容器ID 一次性删除多个容器实例12docker rm -f $(docker ps -a -q)docker ps -a -q|xargs docker rm 重要有镜像才能创建容器，这是根本前提(下载一个Redis6.0.8镜像演示) 启动守护式容器(后台服务器)在大部分的场景下，我们希望docker 的服务是在后台运行的,我们可以过-d指定容器的后台运行模式。 123456789101112docker run -d 容器名#使用镜像centos:latest以后台模式启动一个容器docker run -d centos问题：然后docker ps -a 进行查看, 会发现容器已经退出很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~ redis前后台后动小case12前台交互式启动:docker run -it redis:6.0.8后台守护式启动:docker run -d redis:6.0.8 查看容器日志1docker logs 容器ID 查看容器内运行的进程1docker top 容器ID 查看容器内部细节1docker inspect 容器ID 进入正在运行的容器并以命令行交互12docker exec -it 容器ID bashShell重新进入docker attach容器ID 上述两个的区别 attach直接进入容器启动命令的终端，不会启动新的进程用exit退出，会导致容器的停止。 exec是在容器中打开新的终端,并且可以启动新的进程用exit退出，不会导致容器的停止。 推荐大家使用docker exec命令，因为退出容器终端，不会导致容器的停止。 进入redis服务123docker exec -it 容器ID /bin/bashdocker exec -it 容器ID redis-cli—般用-d后台启动的程序，再用exec进入对应容器实例 9.从容器内拷贝文件到主机上容器→主机 1docker cp 容器ID:容器内路径 目的主机路径 10.导入和导出容器export导出容器的内容留作为一个tar归档文件[对应import命令] import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export] 12docker export容器ID &gt; 文件名.tarcat文件名.tar | docker import-镜像用户/镜像名:镜像版本号 11.小总结常用命令 12345678910111213141516171819202122232425262728293031323334353637attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同 run，但不启动容器diff Inspect changes on a container&#x27;s filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history Show the history of an image # 展示一个镜像形成历史images List images # 列出系统当前镜像import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information # 显示系统相关信息inspect Return low-level information on a container # 查看容器详细信息kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器logout Log out from a Docker registry server # 从当前 Docker registry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值","tags":["Docker","学习"],"categories":["Docker","学习"]},{"title":"常见web攻击","path":"/284985fb/","content":"搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。本篇主要简单介绍在Web领域几种常见的攻击手段及Java Web中的预防方式。 XSS什么是XSSXSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。 XSS通常可以分为两大类： 存储型XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。这个流程简单可以描述为：恶意用户的Html输入Web程序-&gt;进入数据库-&gt;Web程序-&gt;用户浏览器。 反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。 比如说我写了一个网站，然后攻击者在上面发布了一个文章，内容是这样的 &lt;script&gt;alert(document.cookie)&lt;/script&gt;,如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，就会将cookie展现出来，这就是典型的存储型XSS。 如图： 如何预防XSS答案很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。 目前防御XSS主要有如下几种方式： 过滤特殊字符 避免XSS的方法之一主要是将用户所提供的内容进行过滤(如上面的script标签)。 使用HTTP头指定类型 w.Header().Set(&quot;Content-Type&quot;,&quot;text/javascript&quot;) 这样就可以让浏览器解析javascript代码，而不会是html输出。 SQL注入什么是SQL注入攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。 举例：&#39; OR &#39;1&#39;=&#39;1 这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如&#39; OR &#39;1&#39;=1=&#39;1的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39;,经过参数拼接后，会执行 SQL语句 SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39; OR &#39;1&#39;=&#39;1&#39;，这个时候1&#x3D;1是成立，自然就跳过验证了。如下图所示： 但是如果再严重一点，密码输如的是&#39;;DROP TABLE user;--，那么 SQL命令为SELECT * FROM user WHERE username=&#39;admin&#39; and password=&#39;&#39;;drop table user;--&#39; 这个时候我们就直接把这个表给删除了。 如何预防SQL注入 在Java中，我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用 SQL语句伪造成参数，到了服务端的时候，这个伪造 SQL语句的参数也只是简单的字符，并不能起到攻击的作用。 对进入数据库的特殊字符（&#39;&quot;\\尖括号&amp;*;等）进行转义处理，或编码转换。 在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。 避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。 在上图展示中，使用了Java JDBC中的PreparedStatement预编译预防SQL注入，可以看到将所有输入都作为了字符串，避免执行恶意SQL。 DDOS什么是DDOSDDOS：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。 在技术角度上，DDoS攻击可以针对网络通讯协议的各层，手段大致有：TCP类的SYN Flood、ACK Flood，UDP类的Fraggle、Trinoo，DNS Query Flood，ICMP Flood，Slowloris类等等。一般会根据攻击目标的情况，针对性的把技术手法混合，以达到最低的成本最难防御的目的，并且可以进行合理的节奏控制，以及隐藏保护攻击资源。 下面介绍一下TCP协议中的SYN攻击。 SYN攻击在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态. SYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。 如何预防DDOS阿里巴巴的安全团队在实战中发现，DDoS 防御产品的核心是检测技术和清洗技术。检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。而检测技术的核心在于对业务深刻的理解，才能快速精确判断出是否真的发生了 DDoS 攻击。清洗技术对检测来讲，不同的业务场景下要求的粒度不一样。 CSRF什么是CSRFCSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack&#x2F;session riding，缩写为：CSRF&#x2F;XSRF。 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF的原理下图简单阐述了CSRF攻击的思 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录&#x2F;结束会话了……） 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 下面讲一讲java解决CSRF攻击的方式。 模拟CSRF攻击登录A网站用户名和密码都是admin。 http://localhost:8081/login.html: 你有权限删除1号帖子http://localhost:8081/deletePost.html: 登录有CSRF攻击A网站的B网站http://localhost:8082/deletePost.html: 明显看到B网站是8082端口，A网站是8081端口，但是B网站的删除2号帖子功能依然实现。 如何预防CSRF攻击简单来说，CSRF 就是网站 A 对用户建立信任关系后，在网站 B 上利用这种信任关系，跨站点向网站 A 发起一些伪造的用户操作请求，以达到攻击的目的。 而之所以可以完成攻击是因为B向A发起攻击的时候会把A网站的cookie带给A网站，也就是说cookie已经不安全了。 通过Synchronizer TokensSynchronizer Tokens： 在表单里隐藏一个随机变化的 csrf_token csrf_token 提交到后台进行验证，如果验证通过则可以继续执行操作。这种情况有效的主要原因是网站 B 拿不到网站 A 表单里的 csrf_token 这种方式的使用条件是PHP和JSP等。因为cookie已经不安全了，因此把csrf_token值存储在session中，然后每次表单提交时都从session取出来放到form表单的隐藏域中，这样B网站不可以得到这个存储到session中的值。 下面是JSP的： 1&lt;input type=&quot;hidden&quot; name=&quot;random_form&quot; value=&lt;%=random%&gt;&gt;&lt;/input&gt; 但是我现在的情况是html，不是JSP，并不能动态的从session中取出csrf_token值。只能采用加密的方式了。 Hash加密cookie中csrf_token值这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。 我采用的hash加密方法是JS实现Java的HashCode方法，得到hash值，这个比较简单。也可以采用其他的hash算法。 前端向后台传递hash之后的csrf_token值和cookie中的csrf_token值，后台拿到cookie中的csrf_token值后得到hashCode值然后与前端传过来的值进行比较，一样则通过。 你有权限删除3号帖子1http://localhost:8081/deletePost.html B网站的他已经没有权限了我们通过UserFilter.java给攻击者返回的是403错误，表示服务器理解用户客户端的请求但拒绝处理。 http://localhost:8082/deletePost.html: 攻击者不能删除4号帖子。 前端代码： deletePost.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;deletePost&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function deletePost() &#123; var url = &#x27;/post/&#x27; + document.getElementById(&quot;postId&quot;).value; var csrf_token = document.cookie.replace(/(?:(?:^|.*;\\s*)csrf_token\\s*\\=\\s*([^;]*).*$)|^.*$/, &quot;$1&quot;); console.log(&#x27;csrf_token=&#x27; + csrf_token); $.ajax(&#123; type: &quot;post&quot;,//请求方式 url: url, //发送请求地址 timeout: 30000,//超时时间：30秒 data: &#123; &quot;_method&quot;: &quot;delete&quot;, &quot;csrf_token&quot;: hash(csrf_token) // 对csrf_token进行hash加密 &#125;, dataType: &quot;json&quot;,//设置返回数据的格式 success: function (result) &#123; if (result.message == &quot;success&quot;) &#123; $(&quot;#result&quot;).text(&quot;删除成功&quot;); &#125; else &#123; $(&quot;#result&quot;).text(&quot;删除失败&quot;); &#125; &#125;, error: function () &#123; //请求出错的处理 $(&quot;#result&quot;).text(&quot;请求出错&quot;); &#125; &#125;); &#125; // javascript的String到int(32位)的hash算法 function hash(str) &#123; var hash = 0; if (str.length == 0) return hash; for (i = 0; i &lt; str.length; i++) &#123; char = str.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; hash = hash &amp; hash; // Convert to 32bit integer &#125; return hash; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;删除帖子&lt;/h3&gt;帖子编号 ： &lt;input type=&quot;text&quot; id=&quot;postId&quot;/&gt;&lt;button onclick=&quot;deletePost();&quot;&gt;deletePost&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;div&gt; &lt;p id=&quot;result&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后台代码： UserInterceptor.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.morethink.interceptor;import cn.morethink.util.JsonUtil;import cn.morethink.util.Result;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;/** * @author 李文浩 * @date 2018/1/4 */public class UserInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String method = request.getMethod(); System.out.println(method); if (method.equalsIgnoreCase(&quot;POST&quot;) || method.equalsIgnoreCase(&quot;DELETE&quot;) || method.equalsIgnoreCase(&quot;PUT&quot;)) &#123; String csrf_token = request.getParameter(&quot;csrf_token&quot;); Cookie[] cookies = request.getCookies(); if (cookies != null &amp;&amp; cookies.length &gt; 0 &amp;&amp; csrf_token != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(&quot;csrf_token&quot;)) &#123; if (Integer.valueOf(csrf_token) == cookie.getValue().hashCode()) &#123; return true; &#125; &#125; &#125; &#125; &#125; Result result = new Result(&quot;403&quot;, &quot;你还想攻击我??????????&quot;, &quot;&quot;); PrintWriter out = response.getWriter(); out.write(JsonUtil.toJson(result)); out.close(); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注意： cookie必须要设置PATH才可以生效，否则在下一次请求的时候无法带给服务器。 Spring Boot 出现启动找不到主类的问题时可以mvn clean一下。 Filter设置response.sendError(403)在Spring Boot没有效果。 总结上面一共提到了4种攻击方式，分别是XSS攻击（关键是脚本，利用恶意脚本发起攻击），SQL注入（关键是通过用SQL语句伪造参数发出攻击），DDOS攻击（关键是发出大量请求，最后令服务器崩溃），CSRF攻击（关键是借助本地cookie进行认证，伪造发送请求）。","tags":["web攻击","安全"],"categories":["web攻击","安全"]},{"title":"十种常见的web攻击","path":"/c147cc06/","content":"软件开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。本篇主要简单介绍在web领域十种常见的攻击手段及防御方式。 1. Dos拒绝服务攻击介绍：Dos拒绝服务攻击（Denial of Service attack）是一种能够让服务器呈现静止状态的攻击方式。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以会照单全收。海量的请求造成服务器进入停止工作或拒绝服务的状态。 DDOS分布式拒绝服务攻击（Distributed Denial of Service）就是在DOS攻击基础上借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标发送大量请求使使服务器瘫痪。DDoS攻击可以针对网络通讯协议的各层，大致有：TCP类的SYN Flood、ACK Flood，UDP类的Fraggle、Trinoo，DNS Query Flood，ICMP Flood，Slowloris类。CC攻击也是DDOS攻击的一种形式。 防御：DDoS 防御的技术核心是检测技术和清洗技术。检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。而检测技术的核心在于对业务深刻的理解，才能快速精确判断出是否真的发生了 DDoS 攻击。清洗技术对检测来讲，不同的业务场景下要求的粒度不一样。 2. CSRF跨站点请求伪造介绍：CSRF跨站点请求伪造（Cross-Site Request Forgeries）是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息状态更新，属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了其他请求。JSON 劫持（JSON Hijacking）是用于获取敏感数据的一种攻击方式，也属于 CSRF 攻击的范畴。 防御：1）将cookie设置为HttpOnly。CSRF攻击很大程度是利用了浏览器的cookie，为了防止站内XSS漏洞，cookie设置HttpOnly属性，JS脚本就无法读取到cookie中的信息，避免攻击者伪造cookie的情况出现。 2）增加token。CSRF攻击之所以成功，主要是攻击中伪造了用户请求，而用户请求的验证信息都在cookie中，攻击者就可以利用cookie伪造请求通过安全验证。因此抵御CSRF攻击的关键就是，在请求中放入攻击者不能伪造的信息，并且信息不在cookie中。鉴于此，开发人员可以在http请求中以参数的形式加一个token，此token在服务端生成，也在服务端校验，服务端的每次会话都可以用同一个token。如果验证token不一致，则认为是CSRF攻击，拒绝请求。 3）通过Referer识别。Http头中有一个字段Referer，它记录了Http请求来源地址。但是注意不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。 3. SOL注入攻击介绍：SOL注入攻击是攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。 举例：’ OR ‘1’&#x3D;’1，这是最常见的 SQL注入攻击。当我们输入用户名 admin ，然后密码输入’ OR ‘1’&#x3D;1&#x3D;’1的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是SELECT * FROM user WHERE username&#x3D;’’ and password&#x3D;’’,经过参数拼接后，会执行 SQL语句 SELECT * FROM user WHERE username&#x3D;’’ and password&#x3D;’’ OR ‘1’&#x3D;’1’，这个时候1&#x3D;1是成立，自然就跳过验证。 防御：对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。在应用发布之前建议使用专业的SQL注入检测工具（如sqlmap、SQLninja）进行检测，以及时修补被发现的SQL注入漏洞。避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，容易把代码里的SQL语句暴露出来。 4. XSS跨站脚本攻击介绍：XSS跨站脚本攻击（Cross-Site scripting）是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。XSS攻击分类包含反射型，存储型，DOM型，FLASH。 防御：坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。主要有两种方式：过滤特殊字符和使用HTTP头指定类型。 **5.**文件上传漏洞介绍：倘若web网站没有对文件类型进行严格的校验，导致可执行文件上传到了服务器，恶意程序就会执行。 防御：客户端检测 ：程序员一般使用 JavaScript 来拒绝非法文件上传。 服务器端检测： 1）白名单与黑名单验证：定义不允许或允许上传的文件扩展名； 2）MIME验证：php 中通过 $_FILE[‘file’][‘type’] 来检验； 3）目录验证：在文件上传时，程序通常允许用户将文件放到指定的目录中，如果指定的目录存在，就将文件写入目录中。 6. DNS查询攻击介绍：DNS查询攻击（DNS Query Flood）是向被攻击的服务器发送海量的随机生成的域名解析请求，大部分根本就不存在，并且通过伪造端口和客户端IP，防止查询请求被ACL过滤。 被攻击的DNS服务器在接收到域名解析请求后，首先会在服务器上查找是否有对应的缓存，当没有缓存并且该域名无法直接由该DNS服务器进行解析的时候，DNS服务器会向其上层DNS服务器递归查询域名信息，直到全球互联网的13台根DNS服务器。 大量不存在的域名解析请求，给服务器带来了很大的负载，当解析请求超过一定量的时候，就会造成DNS服务器解析域名超时，这样攻击者便达成了攻击目的。 防御：根据域名 IP 自学习结果主动回应，减轻服务器负载（使用 DNS Cache）；对突然发起大量频度较低的域名解析请求的源 IP 地址进行带宽限制；在攻击发生时降低很少发起域名解析请求的源 IP 地址的优先级；限制每个源 IP 地址每秒的域名解析请求次数。 **7.**暴力破解介绍：这个一般针对密码而言，弱密码（Weak Password）很容易被别人猜到或被破解工具暴力破解。 防御：防御方法主要有两种，其一密码复杂度要足够大也要足够隐蔽，其二限制尝试次数。 **8.**信息泄露介绍：由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。 防御：敏感信息加密传输；应用程序报错时，不对外产生调试信息；过滤用户提交的数据与特殊字符；保证源代码、服务器配置的安全。 **9.**业务漏洞介绍：业务漏洞是跟具体的应用程序相关，比如参数篡改（连续编号 ID &#x2F; 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）等。 防御：系统设计阶段就需要考虑业务漏洞的问题，尽量避免连续编号、越权操作等。 **10.**后门程序介绍：后门程序一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。但是如果这些后门被其他人知道，或是在发布软件之前没有删除后门程序，那么它就成了安全风险，容易被黑客当成漏洞进行攻击。 防御：使用非对称后门接口进行软件更新，避免对称后门接口， 给后端程序加壳，更新去除后门的补丁程序。","tags":["web攻击","安全"],"categories":["web攻击","安全"]},{"title":"Truncate用法详解","path":"/a69da845/","content":"前言： 当我们想要清空某张表时，往往会使用truncate语句。大多时候我们只关心能否满足需求，而不去想这类语句的使用场景及注意事项。本篇文章主要介绍truncate语句的使用方法及注意事项。 1.truncate使用语法truncate的作用是清空表或者说是截断表，只能作用于表。truncate的语法很简单，后面直接跟表名即可，例如： truncate table tbl_name 或者 truncate tbl_name 。 执行truncate语句需要拥有表的drop权限，从逻辑上讲，truncate table类似于delete删除所有行的语句或drop table然后再create table语句的组合。为了实现高性能，它绕过了删除数据的DML方法，因此，它不能回滚。尽管truncate table与delete相似，但它被分类为DDL语句而不是DML语句。 2.truncate与drop,delete的对比上面说过truncate与delete，drop很相似，其实这三者还是与很大的不同的，下面简单对比下三者的异同。 truncate与drop是DDL语句，执行后无法回滚；delete是DML语句，可回滚。 truncate只能作用于表；delete，drop可作用于表、视图等。 truncate会清空表中的所有行，但表结构及其约束、索引等保持不变；drop会删除表的结构及其所依赖的约束、索引等。 truncate会重置表的自增值；delete不会。 truncate不会激活与表有关的删除触发器；delete可以。 truncate后会使表和索引所占用的空间会恢复到初始大小；delete操作不会减少表或索引所占用的空间，drop语句将表所占用的空间全释放掉。 3.truncate使用场景及注意事项通过前面介绍，我们很容易得出truncate语句的使用场景，即该表数据完全不需要时可以用truncate。如果想删除部分数据用delete，注意带上where子句；如果想删除表，当然用drop；如果想保留表而将所有数据删除且和事务无关，用truncate即可；如果和事务有关，或者想触发trigger，还是用delete；如果是整理表内部的碎片，可以用truncate然后再重新插入数据。 无论怎样，truncate表都是高危操作，特别是在生产环境要更加小心，下面列出几点注意事项，希望大家使用时可以做下参考。 truncate无法通过binlog回滚。 truncate会清空所有数据且执行速度很快。 truncate不能对有外键约束引用的表使用。 执行truncate需要drop权限，不建议给账号drop权限。 执行truncate前一定要再三检查确认，最好提前备份下表数据。","tags":["数据库","MySQL","Truncate"],"categories":["MySQL","数据库","Truncate"]},{"title":"CentOS7常用命令大全","path":"/4d21ae5d/","content":"CentOS7常用命令大全常用命令文件与目录操作 命令 解析 cd &#x2F;home 进入 ‘&#x2F;home’ 目录 cd .. 返回上一级目录 cd ..&#x2F;.. 返回上两级目录 cd - 返回上次所在目录 cp file1 file2 将file1复制为file2 cp -a dir1 dir2 复制一个目录 cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录（.代表当前目录） ls 查看目录中的文件 ls -a 显示隐藏文件 ls -l 显示详细信息 ls -lrt 按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序） pwd 显示工作路径 mkdir dir1 创建 ‘dir1’ 目录 mkdir dir1 dir2 同时创建两个目录 mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树 mv dir1 dir2 移动&#x2F;重命名一个目录 rm -f file1 删除 ‘file1’ rm -rf dir1 删除 ‘dir1’ 目录及其子目录内容 查看文件内容 命令 解析 cat file1 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 more file1 查看一个长文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 tail -3 file1 查看一个文件的最后三行 vi file 打开并浏览文件 文本内容处理 命令 解析 grep str &#x2F;tmp&#x2F;test 在文件 ‘&#x2F;tmp&#x2F;test’ 中查找 “str” grep ^str &#x2F;tmp&#x2F;test 在文件 ‘&#x2F;tmp&#x2F;test’ 中查找以 “str” 开始的行 grep [0-9] &#x2F;tmp&#x2F;test 查找 ‘&#x2F;tmp&#x2F;test’ 文件中所有包含数字的行 grep str -r &#x2F;tmp&#x2F;* 在目录 ‘&#x2F;tmp’ 及其子目录中查找 “str” diff file1 file2 找出两个文件的不同处 sdiff file1 file2 以对比的方式显示两个文件的不同 vi file 操作解析i进入编辑文本模式Esc退出编辑文本模式:w保存当前修改:q不保存退出vi:wq保存当前修改并退出vi 查询操作 命令 解析 find &#x2F; -name file1 从 ‘&#x2F;’ 开始进入根文件系统查找文件和目录 find &#x2F; -user user1 查找属于用户 ‘user1’ 的文件和目录 find &#x2F;home&#x2F;user1 -name *.bin 在目录 ‘&#x2F; home&#x2F;user1’ 中查找以 ‘.bin’ 结尾的文件 find &#x2F;usr&#x2F;bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 find &#x2F;usr&#x2F;bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 find -name ‘*.[ch]’ | xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ find -type f -print0 | xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ find -maxdepth 1 -type f | xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 压缩、解压 命令 解析 bzip2 file1 压缩 file1 bunzip2 file1.bz2 解压 file1.bz2 gzip file1 压缩 file1 gzip -9 file1 最大程度压缩 file1 gunzip file1.gz 解压 file1.gz tar -cvf archive.tar file1 把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数） tar -cvf archive.tar file1 dir1 把 file1，dir1 打包成 archive.tar tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C &#x2F;tmp 把压缩包释放到 &#x2F;tmp目录下 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 dir1 把文件和目录压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式的压缩包到当前目录 unzip test.zip -d &#x2F;tmp&#x2F; 解压一个zip格式的压缩包到 &#x2F;tmp 目录 yum安装器 命令 解析 yum -y install [package] 下载并安装一个rpm包 yum localinstall [package.rpm] 安装一个rpm包，使用你自己的软件仓库解决所有依赖关系 yum -y update 更新当前系统中安装的所有rpm包 yum update [package] 更新一个rpm包 yum remove [package] 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search [package] 在rpm仓库中搜寻软件包 yum clean [package] 清除缓存目录（&#x2F;var&#x2F;cache&#x2F;yum）下的软件包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 网络相关 命令 解析 ifconfig eth0 显示一个以太网卡的配置 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置网卡的IP地址 ifdown eth0 禁用 ‘eth0’ 网络设备 ifup eth0 启用 ‘eth0’ 网络设备 iwconfig eth1 显示一个无线网卡的配置 iwlist scan 显示无线网络 ip addr show 显示网卡的IP地址 系统相关 命令 解析 su - 切换到root权限（与su有区别） shutdown -h now 关机 shutdown -r now 重启 top 罗列使用CPU资源最多的linux任务 （输入q退出） pstree 以树状图显示程序 man ping 查看参考手册（例如ping 命令） passwd 修改密码 df -h 显示磁盘的使用情况 cal -3 显示前一个月，当前月以及下一个月的月历 cal 10 1988 显示指定月，年的月历 date –date ‘1970-01-01 UTC 1427888888 seconds’ 把一相对于1970-01-01 00:00的秒数转换成时间 XSheel 5相关操作窗体快捷键 命令 解析 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + a 光标移动到行首（ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（end of line） Ctrl + f 光标向前（forward）移动一个字符位置 Ctrl + b 光标往回（backward）移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + r 显示:号提示，根据用户输入查找相关历史命令（reverse-i-search） Ctrl + w 删除从光标位置前到当前所处单词（word）的开头 Ctrl + t 交换光标位置前的两个字符 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + Alt + d 显示桌面 Alt + b 光标往回（backward）移动到前一个单词 Alt + d 删除从光标位置到当前所处单词的末尾 Alt + F2 运行 Alt + F4 关闭当前窗口 Alt + F9 最小化当前窗口 Alt + F10 最大化当前窗口 Alt + Tab 切换窗口 Alt + 左键 移动窗口（或在最下面的任务栏滚动鼠标滑轮） 操作小技巧​ 鼠标中间键：粘贴突出显示的文本。(使用鼠标左键来选择文本。把光标指向想粘贴文本的地方。点击鼠标中间键来粘贴。) ​ Tab：命令行自动补全。使用 shell 提示时可使用这一方式。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配键入字符的所有命令。 ​ 在滚动条的空白处点击鼠标中键：屏幕即滚动到那个地方。 ​ 在桌面或文件管理器中直接按 &#x2F; 就可以输入位置，打开文件管理器。 ​ 在 vi 或 Firefox 中直接按 &#x2F; 即可进入快速搜索状态。 ​ 网站链接和图片可直接拖放到桌面或者目录，可以马上下载。 ​ 直接将文件管理器中的文件拖到终端中就可以在终端中得到完整的路径名。","tags":["Linux","CentOS7","命令"],"categories":["CentOS7","Linux","命令"]},{"title":"JsonFormat和DateTimeFormat注解的使用","path":"/28e3cf11/","content":"一、总结：注解@JsonFormat：主要解决后端向前端传参时的时间格式转换的问题； 注解@DateTimeFormat：主要解决前端向后端传参时的时间格式转换的问题。 二、实体类：1234567891011121314151617181920212223242526272829303132333435363738@Datapublic class ProductMessage &#123; @ExcelField(&quot;编号&quot;) private int id; /** * 客户姓名 */ @ExcelField(&quot;客户姓名&quot;) private String customerName; /** * 客户电话 */ @ExcelField(&quot;客户电话&quot;) private String customerPhone; /** * 客户邮箱 */ @ExcelField(&quot;客户邮箱&quot;) private String customerEmail; /** * 产品意向 */ @ExcelField(&quot;产品意向&quot;) private String productWant; /** * 创建时间 */ @ExcelField(value = &quot;创建时间&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private Date createTime; /** * 客户状态：0,未联系, 1,已联系 */ @ExcelField(&quot;客户状态：0,未联系, 1,已联系&quot;) private String customerStatus;&#125; 三、解释说明：1、 @JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”, timezone &#x3D; “GMT+8”) pattern：是需要转换的时间日期的格式； timezone：是将时间设置为东八区（中国大陆用的是东八区的时间），避免时间在转换中有误差（如果不填写，会有八个小时的误差）。 JsonFormat 默认的时区是 Greenwich Time， 默认的是格林威治时间，而我们是在东八区上，所以需要在默认时区的基础上加上8个时区。 2、@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”) pattern:是需要转换的时间日期的格式。 这里我两个注解都同时使用了，因为我既需要取数据到前台，也需要前台数据传到后台，都需要进行时间格式的转换，可以同时使用的。","tags":["JsonFormat","DateTimeFormat","注解"],"categories":["JsonFormat","DateTimeFormat","注解"]},{"title":"BigDecimal加减乘除","path":"/8715942a/","content":"1、对于不需要任何准确计算精度的数字可以直接使用float或double，但是如果需要精确计算的结果，则必须使用BigDecimal类2、运算速度比一般的+、-、*、&#x2F;要快3、基本方 法描述 add(BigDecimal)BigDecimal对象中的值相加，然后返回这个对象。 subtract(BigDecimal)BigDecimal对象中的值相减，然后返回这个对象。 multiply(BigDecimal)BigDecimal对象中的值相乘，然后返回这个对象。 divide(BigDecimal)BigDecimal对象中的值相除，然后返回这个对象。 toString()将BigDecimal对象的数值转换成字符串。 doubleValue()将BigDecimal对象中的值以双精度数返回。 floatValue()将BigDecimal对象中的值以单精度数返回。 longValue()将BigDecimal对象中的值以长整数返回。 intValue()将BigDecimal对象中的值以整数返回。 money.divide(new BigDecimal(100), 2, BigDecimal.ROUND_HALF_DOWN);除100，保留2位小数，四舍五入 4、BigDecimal.setScale()方法用于格式化小数点 setScale(1)表示保留一位小数，默认用四舍五入方式setScale(1,BigDecimal.ROUND_DOWN)直接删除多余的小数位，如2.35会变成2.3setScale(1,BigDecimal.ROUND_UP)进位处理，2.35变成2.4setScale(1,BigDecimal.ROUND_HALF_UP)四舍五入，2.35变成2.4setScaler(1,BigDecimal.ROUND_HALF_DOWN)四舍五入，2.35变成2.3，如果是5则向下舍 注释：scale指的是你小数点后的位数。比如123.456则score就是3.score()就是BigDecimal类中的方法啊。比如:BigDecimal b &#x3D; new BigDecimal(“123.456”);b.scale(),返回的就是3. roundingMode是小数的保留模式。它们都是BigDecimal中的常量字段,有很多种。比如：BigDecimal.ROUND_HALF_UP表示的就是4舍5入。 pubilc BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)的意思是说：我用一个BigDecimal对象除以divisor后的结果，并且要求这个结果保留有scale个小数位，roundingMode表示的就是保留模式是什么，是四舍五入啊还是其它的，你可以自己选！ 4：对于一般add、subtract、multiply方法的小数位格式化如下：BigDecimal mData &#x3D; new BigDecimal(“9.655”).setScale(2, BigDecimal.ROUND_HALF_UP); 5、与0比较标准做法 BigDecimal big_decimal &#x3D; new BigDecimal(“3”);int r&#x3D;big_decimal.compareTo(BigDecimal.Zero); &#x2F;&#x2F;和0，Zero比较if(r=&#x3D;0) &#x2F;&#x2F;等于if(r=&#x3D;1) &#x2F;&#x2F;大于if(r&#x3D;&#x3D;-1) &#x2F;&#x2F;小于或者if(big_decimal.equals(BigDecimal.Zero)) &#x2F;&#x2F;是否等于0","tags":["BigDecimal运算"],"categories":["BigDecimal运算"]},{"title":"Idea常用快捷键列表","path":"/5c4469f6/","content":"自动代码常用的有fori&#x2F;sout&#x2F;psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。例如要输入for(User user : users)只需输入user.for+Tab ； 再比如，要输入Date birthday &#x3D; user.getBirthday()只需输入user.getBirthday().var+Tab即可。 代码标签输入完成后，按Tab，生成代码。 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） fori&#x2F;sout&#x2F;psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+&#x2F; 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 查询快捷键 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 CTRL+ALT+ left&#x2F;right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 CTRL+SHIFT+O 弹出显示查找内容 Ctrl+W 选中代码，连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up&#x2F;Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left&#x2F;right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+&#x2F; 或 Ctrl+Shift+&#x2F; 注释（&#x2F;&#x2F; 或者&#x2F;…&#x2F; ） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left&#x2F;right 切换代码视图 ALT+ ↑&#x2F;↓ 在方法间快速移动定位 CTRL+ALT+ left&#x2F;right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 Alt+6 查找TODO 其他快捷键 SHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） svn快捷键 ctrl+k 提交代码到SVN ctrl+t 更新代码 调试快捷键其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。 alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点 F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 重构 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 十大Intellij IDEA快捷键Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 1 智能提示:Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。 用F2&#x2F; Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if&#x2F;for时也可以自动补上{}花括号。最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 2 重构:Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 3 代码生成：这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori&#x2F;sout&#x2F;psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter&#x2F;setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter&#x2F;setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday &#x3D; user.getBirthday();只需输入user.getBirthday().var+Tab即可。 4 编辑：编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left&#x2F;Right移动光标到前&#x2F;后单词，Ctrl+[&#x2F;]移动到前&#x2F;后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left&#x2F;Right&#x2F;[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward&#x2F;Backward移动到前&#x2F;后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前&#x2F;下一编辑位置Ctrl+Left&#x2F;Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 5 查找打开：类似Eclipse，Intellij的Ctrl+N&#x2F;Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B&#x2F;Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F&#x2F;Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3&#x2F;Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 6 其他辅助：以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。Ø 新建：Alt+Insert可以新建类、方法等任何东西。Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4&#x2F;5-运行调试。Ctrl+Tab切换标签页，Ctrl+E&#x2F;Ctrl+Shift+E打开最近打开过的或编辑过的文件。Ø 单元测试：Ctrl+Alt+T创建单元测试用例。Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。Ø 调试：F7&#x2F;F8&#x2F;F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template&#x2F;Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T CTRL+ALT+ left&#x2F;right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方","tags":["Idea","快捷键"],"categories":["Idea","快捷键"]},{"title":"linux防火墙和开放端口常用命令","path":"/c4c96365/","content":"linux防火墙和开放端口常用命令防火墙:1.firewalld的基本使用启动： 1systemctl start firewalld 查状态： 1systemctl status firewalld 停止： 1systemctl disable firewalld 禁用： 1systemctl stop firewalld 2.查询端口是否开放: 1firewall-cmd --query-port=80/tcp 开放80端口: 1firewall-cmd --permanent --add-port=80/tcp 移除端口： 1firewall-cmd --permanent --remove-port=8080/tcp 查看开放了那些端口: 1firewall-cmd --list-ports 重启防火墙(修改配置后要重启防火墙): 1firewall-cmd --reload CentOS7 默认使用的是firewalld作为防火墙。以下内容为 CentOS7 防火墙常用命令总结 开机启动防火墙服务1[root@localhost ~]# systemctl enable firewalld 开机关闭防火墙服务1[root@localhost ~]# systemctl disable firewalld 查看防火墙状态12345678[root@localhost ~]# systemctl status firewalld● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; `disabled`; vendor preset: enabled) Active: inactive (`dead`) Docs: man:firewalld(1)# `disabled` 表示开机默认不启动防火墙服务 对应 `enable` 表示开机启动防火墙服务# `dead` 表示防火前当前处于关闭状态 对应 `running` 表示启动状态 手动启动防火墙服务1[root@localhost ~]# systemctl start firewalld 手动关闭防火墙服务1[root@localhost ~]# systemctl stop firewalld 重新启动防火墙服务1[root@localhost ~]# systemctl restart firewalld 添加开放 TCP 或者 UDP 端口 --permanent 永久生效，没有此参数重启后失效】 123[root@localhost ~]# firewall-cmd --permanent --add-port=3306/tcp[root@localhost ~]# firewall-cmd --permanent --add-port=8080-8081/tcp[root@localhost ~]# firewall-cmd --permanent --add-port=53/udp 删除开放的 TCP 或者 UDP 端口123[root@localhost ~]# firewall-cmd --permanent --remove-port=3306/tcp[root@localhost ~]# firewall-cmd --permanent --remove-port=8080-8081/tcp[root@localhost ~]# firewall-cmd --permanent --remove-port=53/udp 更新防火墙规则 【切记每次更改firewall规则后需重新加载】1[root@localhost ~]# firewall-cmd --reload 查看指定端口是否开放1[root@localhost ~]# firewall-cmd --query-port=80/tcp 查看所有打开的端口1[root@localhost ~]# firewall-cmd --list-ports 查看所有打开的服务 其实一个服务对应一个端口，每个服务对应 /usr/lib/firewalld/services 下面一个 xml 文件。 1[root@localhost ~]# firewall-cmd --list-services 查看防火墙规则1[root@localhost ~]# firewall-cmd --list-all 添加服务 系统提供了部分默认服务配置，在 /usr/lib/firewalld/services 目录下 xml 配置文件中配置了默认端口；如果您希望在非标准端口上使用服务，则必须打开特定端口，参考 firewall-cmd --permanent --add-port=8080/tcp 所示。 1[root@localhost ~]# firewall-cmd --permanent --add-service=http 删除服务1[root@localhost ~]# firewall-cmd --permanent --remove-service=http 添加IP白名单123[root@localhost ~]# firewall-cmd --permanent --add-source=192.168.1.5# 或者指定网络段CIDR格式[root@localhost ~]# firewall-cmd --permanent --add-source=192.168.1.0/24 删除IP白名单123[root@localhost ~]# firewall-cmd --permanent --remove-source=192.168.1.5# 或者指定网络段CIDR格式[root@localhost ~]# firewall-cmd --permanent --remove-source=192.168.1.0/24 添加IP黑名单123[root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.5&#x27; reject&quot;# 或者指定网络段CIDR格式[root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.0/24&#x27; reject&quot; 删除IP黑名单123[root@localhost ~]# firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.5&#x27; reject&quot;# 或者指定网络段CIDR格式[root@localhost ~]# firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.0/24&#x27; reject&quot; 添加复杂规则 只允许 指定IP 访问 指定端口【重点】 source address 可以设置为单个IP地址或者 CIDR符号 192.168.1.0/24 一系列IP地址port 可以为单个端口或端口范围，例如 8080-8088 1[root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.5&#x27; port protocol=&#x27;tcp&#x27; port=&#x27;22&#x27; accept&quot; 删除复杂规则 要删除复杂规则，请使用选项 --remove-rich-rule 必须完全指定要删除哪个规则，因此最好复制并粘贴完整规则，而不是尝试自己去输入规则。 1[root@localhost ~]# firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.5&#x27; port protocol=&#x27;tcp&#x27; port=&#x27;22&#x27; accept&quot; 案例一：使用firewall-cmd限制ssh只能从指定IP访问 直接将堡垒机IP放行，其他IP无法访问 ssh 端口，可以有效的拦击扫描主机。减少服务器漏洞报告！演示环境将 192.168.1.5 模拟堡垒机ip，以及模拟服务器 ssh 22 端口，让服务器只有堡垒机能够ssh链接，直接拦截漏洞扫描主机，不用经常升级 ssh 漏洞 123456# 1. 删除默认开启的没有访问限制的ssh服务[root@localhost ~]# firewall-cmd --permanent --remove-service=ssh# 2. 通过添加复杂规则，增加指定允许访问ssh端口的IP[root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;192.168.1.5&#x27; port protocol=&#x27;tcp&#x27; port=&#x27;22&#x27; accept&quot;# 3. 更新防火墙规则[root@localhost ~]# firewall-cmd --reload","tags":["Linux","防火墙"],"categories":["Linux","防火墙"]},{"title":"万萌姐文章","path":"/1af8d071/","content":"万萌姐文章 作者：万萌姐 来源：微信朋友圈 时间：2010年12月28日 一杯热咖啡，一本瑞丽，一条毛毯，一个暖手袋，一些新歌。用来形容我现在的新生活再合适不过了。 我不知道我想记录什么，只是感觉此刻很美好，没有忙碌的奔跑在钢筋水泥的城市里，没有呼喝的各种声音，也没有人打扰这个宁静的上午。 生活总在得失之间游离，前两天跑到阿波罗买了一双鞋子，两件外套，两个月的工资就这样没了，感觉不到心疼，也感觉不到快乐。 我时常想，如果曾经很多事情没有发生，是不是，现在的我便不是这样的我。会和从前一样的剪着男生头、穿着宽松的T，休闲裤，板鞋。看上去，完全就是个男生。 发生的都幻灭了，记忆被封存。时间不被任何事情驱使。永远在我们看不见的地方前进，活着，到底是为了什么。遇到相爱的人？实现自己的理想？还是白活一场！ 我们活在浩瀚的宇宙里，漫天漂浮的宇宙尘埃和星河光尘，我们是比这些还要渺小的存在。你并不知道生活在什么时候就突然改变方向，陷入墨水一般浓稠的黑暗里去。你被失望拖进深渊，你被疾病拉进坟墓，你被挫折践踏的体无完肤，你被嘲笑、被讽刺、被讨厌、被怨恨、被放弃。但是我们却总是在内心里保留着希望，保留着不甘心放弃的跳动的心。我们依然在大大的绝望里小小地努力着。这种不想放弃地心情，它们变成无边黑暗里地小小星辰。我们都是小小地星辰。 最近又想出去旅行，还会是一个人，只是这次会带着不同地心情，我总觉得人活着就要走很多路，欣赏很多风景，看很多人才更有意义。生命地意义，我一直在寻找。纵有千种不顺，我也要活的潇洒。人不是要走别人走过的路，而是要走在自己的路上才明白活着的含义。 我怀念从前的我，单纯、善良、美好。 而不是现在的隐藏、市侩、心狠的我。 以前路上看到可怜的人，即使身上只有一块的零花钱也会掏出来给他们，以前会单纯的相信人都是好的，以前会相信我的未来会很美，很好。 现在走在路上，我是麻木的，看到可怜的人，头也不抬的走过，总觉得人们都是充满心机的算计，对于未来很迷茫，不再相信那些美好的事物会属于我了。 活着很累，总是迷失，寻找，跌跌撞撞！ 唯一没有失去的是信心和坚强。 其实也不是从一开始就这样坚强，只是在经历过那些黑暗的日子后，我才能把自己完全的包裹了起来，我在很多的日记里说过一些黑暗的日子，那段时光，黑暗到我有活不下去的想法，我把这称之为成长的痛，没有任何人帮助我，他们没有能力帮的了，我只能靠我自己来走出，我不断变换着心态，想法，和记忆。那段时间我全部的动力便是去努力忘掉一些悲痛的事情，我很庆幸，上天怜爱了我，在经历了那段时光后，我还能走出来，我的努力没有白费。并且以一种前所未有的姿态开始了新的生活。 我不再回想很多事情，我刻意忘掉了很多事实，居然真的不会再想起了，前些天清理了很多东西，把那些回忆清理得更彻底了。 很多事情都很顺利得进行着，在厦门时遇到过一个算命先生，他说我是有福气的人，有福气的人出门便会遇到贵人，呵呵，我不知道他是不是真能算到，比如刚来这个公司，便有很多人帮助我，顺利的度过了那段毫无头绪的日子。 如今的生活过的井井有条，偶尔和同事下班后搓搓麻将，回去再和房东聊聊天，看看电视，上班也很轻松，日子一天一天的过，很平淡，却不会乏味，心态也在慢慢变化。 很多时候，我们走过同一条街，看了同一片海，到过同一个地方，可是时间的浩海使我们隔离了，遗憾么？呵呵，算不上，只是觉得还有这么多的事情要一起去经历。一起逛街，一起旅行，一起生活。。。原来生活并没有给人绝望。还有很多期许。 错过算什么，失去算什么，悲伤算什么。没有什么比活好现在更重要。将来的生活要自己掌握，未来的路自己选择，跪着也要走下去。那些毫无意义的过往，只是演了一场戏，给自己看。 在一个闲散的冬日里，盖一条毛毯，端一杯咖啡，看一看书，听听音乐，一天的时光就是这样流逝。。。 呜~真美好。好时光都该被珍惜！ 最近在微博里看到一段话真喜欢~！ “你说你懂得生之微末，我便做了这波澜壮阔与你看；你说再热闹也终需离散，我便做了这一辈子与你看；你说应愁高处不胜寒，我便拱手河山，讨你欢。”你们是否也喜欢呢？ 舍不得结束。感情太容易宣泄，人就容易被感情所困。其实生活本身就是一次次的聚散离合么。舍不得还是要说再见。 “再见旧时光，再也不见！” 原图原图1原图2","tags":["日记","生活","万萌姐"],"categories":["日记","生活","万萌姐"]},{"title":"Java与数据库类型映射","path":"/aa3b953/","content":"Java与数据库类型映射 Java数据类型与MySql数据类型对照表 类型名称 显示长度 数据库类型 JAVA类型 JDBC类型索引(int) VARCHAR L+N VARCHAR java.lang.String 12 CHAR N CHAR java.lang.String 1 BLOB L+N BLOB java.lang.byte[] -4 TEXT 65535 VARCHAR java.lang.String -1 INTEGER 4 INTEGER UNSIGNED java.lang.Long 4 TINYINT 3 TINYINT UNSIGNED java.lang.Integer -6 SMALLINT 5 SMALLINT UNSIGNED java.lang.Integer 5 MEDIUMINT 8 MEDIUMINT UNSIGNED java.lang.Integer 4 BIT 1 BIT java.lang.Boolean -7 BIGINT 20 BIGINT UNSIGNED java.math.BigInteger -5 FLOAT 4+8 FLOAT java.lang.Float 7 DOUBLE 22 DOUBLE java.lang.Double 8 DECIMAL 11 DECIMAL java.math.BigDecimal 3 BOOLEAN 1 同TINYINT ID 11 PK (INTEGER UNSIGNED) java.lang.Long 4 DATE 10 DATE java.sql.Date 91 TIME 8 TIME java.sql.Time 92 DATETIME 19 DATETIME java.sql.Timestamp 93 TIMESTAMP 19 TIMESTAMP java.sql.Timestamp 93 YEAR 4 YEAR java.sql.Date 91 sqlserver数据库对应java中的数据类型 SQL Server 类型 JDBC 类型 (java.sql.Types) Java 语言类型 bigint BIGINT long timestampbinary BINARY byte[] bit BIT boolean char CHAR String decimalmoneysmallmoney DECIMAL java.math.BigDecimal float DOUBLE double int INTEGER int imagevarbinary(max) LONGVARBINARY byte[] varchar(max)text LONGVARCHAR String nchar CHARNCHAR (Java SE 6.0) String nvarchar VARCHARNVARCHAR (Java SE 6.0) String nvarchar(max)ntext LONGVARCHARLONGNVARCHAR (Java SE 6.0) String numeric NUMERIC java.math.BigDecimal real REAL float smallint SMALLINT short datetimesmalldatetime TIMESTAMP java.sql.Timestamp varbinaryudt VARBINARY byte[] varchar VARCHAR String tinyint TINYINT short uniqueidentifier CHAR String xml LONGVARCHARSQLXML (Java SE 6.0) StringSQLXML time TIME (1) java.sql.Time (1) date DATE java.sql.Date datetime2 TIMESTAMP java.sql.Timestamp datetimeoffset (2) microsoft.sql.Types.DATETIMEOFFSET microsoft.sql.DateTimeOffset sqlserver和Oracle数据类型对应关系 SqlServer 2k转换为Oracle 10g 列名 SqlServer数据类型 SqlServer长度 Oracle数据类型 column1 bigint 8 NUMBER（19） column2 binary 50 RAW（50） column3 bit 1 NUMBER（2） column4 char 10 CHAR（10） column5 datetime 8 DATE column6 decimal 9 NUMBER（18） column7 float 8 BINARY_DOUBLE column8 image 16 BLOB column9 int 4 NUMBER（10） column10 money 8 NUMBER（19，4） column11 nchar 10 NCHAR（10） column12 ntext 16 NCLOB column13 numeric 9 NUMBER（18） column14 nvarchar 50 NVARCHAR2（50） column15 real 4 BINARY_FLOAT column16 smalldatetime 4 DATE column17 smallint 2 NUMBER（5） column18 smallmoney 4 NUMBER（10，4） column19 sql_variant BLOB column20 text 16 CLOB column21 timestamp 8 RAW（8） column22 tinyint 1 NUMBER（3） column23 uniqueidentifier 16 BLOB column24 varbinary 50 RAW（50） column25 varchar 50 VARCHAR2（50） Oracle 10g 转换为SqlServer 2k Oracle列名 Oracle数据类型 SqlServer列名 SqlServer数据类型 SqlServer数据长度 COLUMN1 BINARY_DOUBLE COLUMN1 float 8 COLUMN2 BINARY_FLOAT COLUMN2 real 4 COLUMN3 BLOB COLUMN3 image 16 COLUMN4 CLOB COLUMN4 ntext 16 COLUMN5 CHAR（10） COLUMN5 nchar 10 COLUMN6 DATE COLUMN6 datetime 8 COLUMN12 NUMBER COLUMN12 numeric 13 COLUMN13 NVARCHAR2（10） COLUMN13 nvarchar 10 COLUMN14 RAW（10） COLUMN14 varbinary 10 COLUMN15 TIMESP（6） COLUMN15 datetime 8 COLUMN16 TIMESP（6） WITH LOCAL TIME ZONE COLUMN16 datetime 8 COLUMN17 TIMESP（6） WITH TIME ZONE COLUMN17 datetime 8 COLUMN18 VARCHAR2（10） COLUMN18 nvarchar 10 COLUMN7 INTERVAL DAY（2） TO SECOND（6） COLUMN7 nvarchar 30 COLUMN8 INTERVAL YEAR（2） TO MONTH COLUMN8 nvarchar 14 COLUMN9 LONG COLUMN9 ntext 16 COLUMN10 LONG RAW COLUMN10 image 16 COLUMN11 NCLOB COLUMN11 ntext 16","tags":["学习","Java","数据库"],"categories":["学习","Java","数据库"]},{"title":"SpringBoot集成文件","path":"/5f3d3706/","content":"SpringBoot集成文件 SpringBoot集成文件 除了处理word, excel等文件外，最为常见的就是PDF的导出了。在java技术栈中，PDF创建和操作最为常用的itext了，但是使用itext一定要了解其版本历史和License问题，在早前版本使用的是MPL和LGPL双许可协议，在5.x以上版本中使用的是AGPLv3(这个协议意味着，只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的)。本文主要介绍通过SpringBoot集成itextpdf实现PDF导出功能。 知识准备 需要了解itext，以及itext历史版本变迁，以及license的问题。 什么是itext 来源于百度百科：iText是著名的开放源码的站点sourceforge一个项目(由Bruno Lowagie编写)，是一个用Java和.NET语言写的库，用来创建和修改PDF文件。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。iText的安装非常方便，下载iText.jar文件后，只需要在系统的CLASSPATH中加入iText.jar的路径，在程序中就可以使用iText类库了。 iText提供除了基本的创建、修改PDF文件外的其他高级的PDF特性，例如基于PKI的签名，40位和128位加密，颜色校正，带标签的PDF，PDF表单(AcroForms)，PDF&#x2F;X,通过ICC配置文件和条形码进行颜色管理。这些特性被一些产品和服务中使用，包括Eclipse BIRT，Jasper Reports，JBoss Seam，Windward Reports和pdftk。 一般情况下，iText使用在有以下一个要求的项目中： 内容无法提前利用：取决于用户的输入或实时的数据库信息。 由于内容，页面过多，PDF文档不能手动生成。 文档需在无人参与，批处理模式下自动创建。 内容被定制或个性化；例如，终端客户的名字需要标记在大量的页面上。 itext的历史版本和License问题 使用itext一定要了解其版本历史，和License问题，在早前版本使用的是MPL和LGPL双许可协议，在5.x以上版本中使用的是AGPLv3(这个协议意味着，只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的) iText 0.x-2.x&#x2F;iTextSharp 3.x-4.x 更新时间是2000-2009 使用的是MPL和LGPL双许可协议 最近的更新是2009年，版本号是iText 2.1.7&#x2F;iTextSharp 4.1.6.0 此时引入包的GAV版本如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.lowagie&lt;/groupId&gt; &lt;artifactId&gt;itext&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt;&lt;/dependency&gt; **iText 5.x和iTextSharp 5.x** - - **只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的** - 更新时间是2009-2016, 公司化运作，并标准化和提高性能 - 开始使用**AGPLv3协议** - iTextSharp被设计成iText库的.NET版本，并且与iText版本号同步，iText 5.0.0和iTextSharp5.0.0同时发布 - 新功能不在这里面增加，但是官方会修复重要的bug - 此时引入包的GAV版本如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.3&lt;/version&gt;&lt;/dependency&gt; **iText 7.x** - - 更新时间是2016到现在 - AGPLv3协议 - 完全重写，重点关注可扩展性和模块化 - 不适用iTextSharp这个名称，都统称为iText,有Java和.Net版本 - JDK 1.7+ - 此时引入包的GAV版本如下： 123456&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext7-core&lt;/artifactId&gt; &lt;version&gt;7.2.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 注：iText变化后，GitHub上有团队基于4.x版本（MPL和LGPL双许可协议）fork了一个分支成为OpenPDF，并继续维护该项目。 标准的itextpdf导出的步骤 itextpdf导出pdf主要包含如下几步： 123456789101112131415161718@Overridepublic Document generateItextPdfDocument(OutputStream os) throws Exception &#123; // 1. 创建文档 Document document = new Document(PageSize.A4); // 2. 绑定输出流（通过pdfwriter) PdfWriter.getInstance(document, os); // 3. 打开文档 document.open(); // 4. 往文档中添加内容 document.add(xxx); // 5. 关闭文档 document.close(); return document;&#125; document中添加的Element有哪些呢？ 需要说明下如下概念之前的差别： Chunk：文档的文本的最小块单位 Phrase：一系列以特定间距（两行之间的距离）作为参数的块 Paragraph：段落是一系列块和（或）短句。同短句一样，段落有确定的间距。用户还可以指定缩排；在边和（或）右边保留一定空白，段落可以左对齐、右对齐和居中对齐。添加到文档中的每一个段落将自动另起一行。 （其它从字面上就可以看出，所以这里具体就不做解释了） 实现案例 这里展示SpringBoot集成itext5导出PDF的例子。 Pom依赖引入poi的依赖包 12345678910&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 导出PDFUserController中导出的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243package tech.pdai.springboot.file.word.poi.controller;import java.io.OutputStream;import javax.servlet.http.HttpServletResponse;import io.swagger.annotations.ApiOperation;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import tech.pdai.springboot.file.word.poi.service.IUserService;/** * @author pdai */@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private IUserService userService; @ApiOperation(&quot;Download Word&quot;) @GetMapping(&quot;/word/download&quot;) public void download(HttpServletResponse response) &#123; try &#123; XWPFDocument document = userService.generateWordXWPFDocument(); response.reset(); response.setContentType(&quot;application/vnd.ms-excel&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=user_world_&quot; + System.currentTimeMillis() + &quot;.docx&quot;); OutputStream os = response.getOutputStream(); document.write(os); os.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; UserServiceImple中导出PDF方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Overridepublic Document generateItextPdfDocument(OutputStream os) throws Exception &#123; // document Document document = new Document(PageSize.A4); PdfWriter.getInstance(document, os); // open document.open(); // add content - pdf meta information document.addAuthor(&quot;pdai&quot;); document.addCreationDate(); document.addTitle(&quot;pdai-pdf-itextpdf&quot;); document.addKeywords(&quot;pdf-pdai-keyword&quot;); document.addCreator(&quot;pdai&quot;); // add content - page content // Title document.add(createTitle(&quot;Java 全栈知识体系&quot;)); // Chapter 1 document.add(createChapterH1(&quot;1. 知识准备&quot;)); document.add(createChapterH2(&quot;1.1 什么是POI&quot;)); document.add(createParagraph(&quot;Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。用它可以使用Java读取和创建,修改MS Excel文件.而且,还可以使用Java读取和创建MS Word和MSPowerPoint文件。更多请参考[官方文档](https://poi.apache.org/index.html)&quot;)); document.add(createChapterH2(&quot;1.2 POI中基础概念&quot;)); document.add(createParagraph(&quot;生成xls和xlsx有什么区别？POI对Excel中的对象的封装对应关系？&quot;)); // Chapter 2 document.add(createChapterH1(&quot;2. 实现案例&quot;)); document.add(createChapterH2(&quot;2.1 用户列表示例&quot;)); document.add(createParagraph(&quot;以导出用户列表为例&quot;)); // 表格 List&lt;User&gt; userList = getUserList(); PdfPTable table = new PdfPTable(new float[]&#123;20, 40, 50, 40, 40&#125;); table.setTotalWidth(500); table.setLockedWidth(true); table.setHorizontalAlignment(Element.ALIGN_CENTER); table.getDefaultCell().setBorder(1); for (int i = 0; i &lt; userList.size(); i++) &#123; table.addCell(createCell(userList.get(i).getId() + &quot;&quot;)); table.addCell(createCell(userList.get(i).getUserName())); table.addCell(createCell(userList.get(i).getEmail())); table.addCell(createCell(userList.get(i).getPhoneNumber() + &quot;&quot;)); table.addCell(createCell(userList.get(i).getDescription())); &#125; document.add(table); document.add(createChapterH2(&quot;2.2 图片导出示例&quot;)); document.add(createParagraph(&quot;以导出图片为例&quot;)); // 图片 Resource resource = new ClassPathResource(&quot;pdai-guli.png&quot;); Image image = Image.getInstance(resource.getURL()); // Image image = Image.getInstance(&quot;/Users/pdai/pdai/www/tech-pdai-spring-demos/481-springboot-demo-file-pdf-itextpdf/src/main/resources/pdai-guli.png&quot;); image.setAlignment(Element.ALIGN_CENTER); image.scalePercent(60); // 缩放 document.add(image); // close document.close(); return document;&#125;private List&lt;User&gt; getUserList() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; userList.add(User.builder() .id(Long.parseLong(i + &quot;&quot;)).userName(&quot;pdai&quot; + i).email(&quot;pdai@pdai.tech&quot; + i).phoneNumber(121231231231L) .description(&quot;hello world&quot; + i) .build()); &#125; return userList;&#125; 在实现时可以将如下创建文档内容的方法封装到Util工具类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Paragraph createTitle(String content) throws IOException, DocumentException &#123; Font font = new Font(getBaseFont(), 24, Font.BOLD); Paragraph paragraph = new Paragraph(content, font); paragraph.setAlignment(Element.ALIGN_CENTER); return paragraph;&#125;private Paragraph createChapterH1(String content) throws IOException, DocumentException &#123; Font font = new Font(getBaseFont(), 22, Font.BOLD); Paragraph paragraph = new Paragraph(content, font); paragraph.setAlignment(Element.ALIGN_LEFT); return paragraph;&#125;private Paragraph createChapterH2(String content) throws IOException, DocumentException &#123; Font font = new Font(getBaseFont(), 18, Font.BOLD); Paragraph paragraph = new Paragraph(content, font); paragraph.setAlignment(Element.ALIGN_LEFT); return paragraph;&#125;private Paragraph createParagraph(String content) throws IOException, DocumentException &#123; Font font = new Font(getBaseFont(), 12, Font.NORMAL); Paragraph paragraph = new Paragraph(content, font); paragraph.setAlignment(Element.ALIGN_LEFT); paragraph.setIndentationLeft(12); //设置左缩进 paragraph.setIndentationRight(12); //设置右缩进 paragraph.setFirstLineIndent(24); //设置首行缩进 paragraph.setLeading(20f); //行间距 paragraph.setSpacingBefore(5f); //设置段落上空白 paragraph.setSpacingAfter(10f); //设置段落下空白 return paragraph;&#125;public PdfPCell createCell(String content) throws IOException, DocumentException &#123; PdfPCell cell = new PdfPCell(); cell.setVerticalAlignment(Element.ALIGN_MIDDLE); cell.setHorizontalAlignment(Element.ALIGN_CENTER); Font font = new Font(getBaseFont(), 12, Font.NORMAL); cell.setPhrase(new Phrase(content, font)); return cell;&#125;private BaseFont getBaseFont() throws IOException, DocumentException &#123; return BaseFont.createFont(&quot;STSong-Light&quot;, &quot;UniGB-UCS2-H&quot;, BaseFont.NOT_EMBEDDED);&#125; 导出后的PDF 添加页眉页脚和水印 在itextpdf 5.x 中可以利用PdfPageEvent来完成页眉页脚和水印。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package tech.pdai.springboot.file.pdf.itextpdf.pdf;import com.itextpdf.text.BaseColor;import com.itextpdf.text.Document;import com.itextpdf.text.Element;import com.itextpdf.text.Phrase;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.ColumnText;import com.itextpdf.text.pdf.PdfContentByte;import com.itextpdf.text.pdf.PdfGState;import com.itextpdf.text.pdf.PdfPageEventHelper;import com.itextpdf.text.pdf.PdfTemplate;import com.itextpdf.text.pdf.PdfWriter;/** * @author pdai */public class MyHeaderFooterPageEventHelper extends PdfPageEventHelper &#123; private String headLeftTitle; private String headRightTitle; private String footerLeft; private String waterMark; private PdfTemplate total; public MyHeaderFooterPageEventHelper(String headLeftTitle, String headRightTitle, String footerLeft, String waterMark) &#123; this.headLeftTitle = headLeftTitle; this.headRightTitle = headRightTitle; this.footerLeft = footerLeft; this.waterMark = waterMark; &#125; @Override public void onOpenDocument(PdfWriter writer, Document document) &#123; total = writer.getDirectContent().createTemplate(30, 16); &#125; @Override public void onEndPage(PdfWriter writer, Document document) &#123; BaseFont bf = null; try &#123; bf = BaseFont.createFont(&quot;STSong-Light&quot;, &quot;UniGB-UCS2-H&quot;, BaseFont.NOT_EMBEDDED); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // page header and footer addPageHeaderAndFooter(writer, document, bf); // watermark if (waterMark!=null) &#123; addWaterMark(writer, document, bf); &#125; &#125; private void addPageHeaderAndFooter(PdfWriter writer, Document document, BaseFont bf) &#123; PdfContentByte cb = writer.getDirectContent(); cb.saveState(); cb.beginText(); cb.setColorFill(BaseColor.GRAY); cb.setFontAndSize(bf, 10); // header float x = document.top(-10); cb.showTextAligned(PdfContentByte.ALIGN_LEFT, headLeftTitle, document.left(), x, 0); cb.showTextAligned(PdfContentByte.ALIGN_RIGHT, headRightTitle, document.right(), x, 0); // footer float y = document.bottom(-10); cb.showTextAligned(PdfContentByte.ALIGN_LEFT, footerLeft, document.left(), y, 0); cb.showTextAligned(PdfContentByte.ALIGN_CENTER, String.format(&quot;- %d -&quot;, writer.getPageNumber()), (document.right() + document.left()) / 2, y, 0); cb.endText(); cb.restoreState(); &#125; private void addWaterMark(PdfWriter writer, Document document, BaseFont bf) &#123; for (int i = 1; i &lt; 7; i++) &#123; for (int j = 1; j &lt; 10; j++) &#123; PdfContentByte cb = writer.getDirectContent(); cb.saveState(); cb.beginText(); cb.setColorFill(BaseColor.GRAY); PdfGState gs = new PdfGState(); gs.setFillOpacity(0.1f); cb.setGState(gs); cb.setFontAndSize(bf, 12); cb.showTextAligned(Element.ALIGN_MIDDLE, waterMark, 75 * i, 80 * j, 30); cb.endText(); cb.restoreState(); &#125; &#125; &#125; @Override public void onCloseDocument(PdfWriter writer, Document document) &#123; ColumnText.showTextAligned(total, Element.ALIGN_LEFT, new Phrase(String.valueOf(writer.getPageNumber() - 1)), 2, 2, 0); &#125;&#125; 添加水印后导出后的PDF 进一步理解 通过如下几个问题进一步理解itextpdf。 遇到license问题怎么办如前文所述，使用itext一定要了解其版本历史和License问题，在早前版本使用的是MPL和LGPL双许可协议，在5.x以上版本中使用的是AGPLv3。有两种选择： 使用2.1.7版本 12345&lt;dependency&gt; &lt;groupId&gt;com.lowagie&lt;/groupId&gt; &lt;artifactId&gt;itext&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt;&lt;/dependency&gt; 使用OpenPDF GitHub上有团队基于itext 4.x版本（MPL和LGPL双许可协议）fork了一个分支成为OpenPDF，并继续维护该项目。 为何添加页眉页脚和水印是通过PdfPageEvent来完成 为何添加页眉页脚和水印是通过PdfPageEvent来完成？ 举个例子，如果我们在上述例子中需要在页脚中显示 “Page 1 of 3”, 即总页数怎么办呢？而itext是流模式的写入内容，只有写到最后，才能知道有多少页，那么显示总页数必须在内容写完之后（或者关闭之前）确定；这就是为什么在onEndPage方法时才会写每页的页眉页脚。 iText仅在调用释放模板方法后才将PdfTemplate写入到OutputStream中，否则对象将一直保存在内存中，直到关闭文档。所以我们可以在最后关闭文档前，使用PdfTemplate写入总页码。可以理解成先写个占位符，然后统一替换。 示例源码https://github.com/realpdai/tech-pdai-spring-demos 参考文章https://itextpdf.com https://blog.csdn.net/u012397189/article/details/80196974","tags":["学习","SpringBoot","文件导出"],"categories":["学习","SpringBoot","文件导出"]},{"title":"SpringBoot实现跨域的5种方式","path":"/4ee1cd7b/","content":"SpringBoot实现跨域的5种方式 Spring Boot 实现跨域的 5 种方式一、为什么会出现跨域问题出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port） 二、什么是跨域当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 当前页面 被请求页面 是否跨域 原因 http://www.test.com/ http://www.test.com/index.html 否 同源（协议、域名、端口号相同） http://www.test.com/ https://www.test.com/index.html 跨域 协议不同（http&#x2F;https） http://www.test.com/ http://www.baidu.com/ 跨域 主域名不同（test&#x2F;baidu） http://www.test.com/ http://blog.test.com/ 跨域 子域名不同（www&#x2F;blog） http://www.test.com:8080/ http://www.test.com:7001/ 跨域 端口号不同（8080&#x2F;7001） 三、非同源限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 无法向非同源地址发送 AJAX 请求 四、java 后端 实现 CORS 跨域请求的方式对于 CORS的跨域请求，主要有以下几种方式可供选择： 返回新的CorsFilter 重写 WebMvcConfigurer 使用注解 @CrossOrigin 手动设置响应头 (HttpServletResponse) 自定web filter 实现跨域 注意: CorFilter &#x2F; WebMvConfigurer &#x2F; @CrossOrigin 需要 SpringMVC 4.2以上版本才支持，对应springBoot 1.3版本以上 上面前两种方式属于全局 CORS 配置，后两种属于局部 CORS配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过 @CrossOrigin 注解来进行细粒度更高的跨域资源控制。 其实无论哪种方案，最终目的都是修改响应头，向响应头中添加浏览器所要求的数据，进而实现跨域。 1.返回新的 CorsFilter(全局跨域)在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。 1234567891011121314151617181920212223@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1. 添加 CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域 config.addAllowedOrigin(&quot;*&quot;); //是否发送 Cookie config.setAllowCredentials(true); //放行哪些请求方式 config.addAllowedMethod(&quot;*&quot;); //放行哪些原始请求头部信息 config.addAllowedHeader(&quot;*&quot;); //暴露哪些头部信息 config.addExposedHeader(&quot;*&quot;); //2. 添加映射路径 UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource(); corsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;,config); //3. 返回新的CorsFilter return new CorsFilter(corsConfigurationSource); &#125;&#125; 2. 重写 WebMvcConfigurer(全局跨域)1234567891011121314@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) //是否发送Cookie .allowCredentials(true) //放行哪些原始域 .allowedOrigins(&quot;*&quot;) .allowedMethods(new String[]&#123;&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;&#125;) .allowedHeaders(&quot;*&quot;) .exposedHeaders(&quot;*&quot;); &#125;&#125; 3. 使用注解 (局部跨域)在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。 12345678@RestController@CrossOrigin(origins = &quot;*&quot;)public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello world&quot;; &#125;&#125; 在方法上使用注解 @CrossOrigin: 1234567@RequestMapping(&quot;/hello&quot;)@CrossOrigin(origins = &quot;*&quot;) //@CrossOrigin(value = &quot;http://localhost:8081&quot;) //指定具体ip允许跨域public String hello() &#123; return &quot;hello world&quot;;&#125; 4. 手动设置响应头(局部跨域)使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。 12345@RequestMapping(&quot;/index&quot;)public String index(HttpServletResponse response) &#123; response.addHeader(&quot;Access-Allow-Control-Origin&quot;,&quot;*&quot;); return &quot;index&quot;;&#125; 5. 使用自定义filter实现跨域首先编写一个过滤器，可以起名字为MyCorsFilter.java。 1234567891011121314151617181920212223package com.mesnac.aop;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Component;@Componentpublic class MyCorsFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,content-type&quot;); chain.doFilter(req, res); &#125; public void init(FilterConfig filterConfig) &#123;&#125; public void destroy() &#123;&#125;&#125; 在web.xml中配置这个过滤器，使其生效。 12345678910&lt;!-- 跨域访问 START--&gt;&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mesnac.aop.MyCorsFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 跨域访问 END --&gt;","tags":["学习","springboot","跨域"],"categories":["学习","springboot","跨域"]},{"title":"springboot日志","path":"/1a179d85/","content":"springboot日志 springboot logback日志按日期年月日写入需求： 调用Slf4j时写入日志文件 文件目录按年月日（yyyy-MM-dd）录入 1.添加配置文件logback-spring.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;&lt;!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --&gt;&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;contextName&gt;logback-spring&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;log&quot;&gt;&lt;/property&gt; &lt;timestamp key=&quot;datetime&quot; datePattern=&quot;yyyy-MM-dd&quot;/&gt; &lt;!--0. 日志格式和颜色渲染 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt; &lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt; &lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt; &lt;!--1. 输出到控制台--&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;!--&lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;--&gt; &lt;!--&lt;level&gt;INFO&lt;/level&gt;--&gt; &lt;!--&lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--2. 输出到文档--&gt; &lt;!-- 2.1 level为 DEBUG 日志，时间滚动输出 --&gt; &lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/$&#123;datetime&#125;/debug.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 日志归档 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/debug/web-debug-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录debug级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;debug&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.2 level为 INFO 日志，时间滚动输出 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/$&#123;datetime&#125;/info.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/web-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;info&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.3 level为 WARN 日志，时间滚动输出 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/$&#123;datetime&#125;/warn.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/web-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.4 level为 ERROR 日志，时间滚动输出 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文档的路径及文档名 --&gt; &lt;file&gt;$&#123;log.path&#125;/$&#123;datetime&#125;/error.log&lt;/file&gt; &lt;!--日志文档输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/web-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文档保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文档只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、 以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前logger将会继承上级的级别。 addtivity:是否向上级logger传递打印信息。默认是true。 &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;/&gt; &lt;logger name=&quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&quot; level=&quot;INFO&quot;/&gt; --&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;info&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别： 【logging.level.org.mybatis=debug logging.level.dao=debug】 --&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 不能设置为INHERITED或者同义词NULL。默认是DEBUG 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 --&gt; &lt;!-- 4. 最终的策略 --&gt; &lt;!-- 4.1 开发环境:打印控制台--&gt; &lt;!-- &lt;springProfile name=&quot;dev&quot;&gt;--&gt; &lt;logger name=&quot;net.ourway&quot; level=&quot;debug&quot;/&gt;&lt;!-- 修改此处扫描包名 --&gt; &lt;!-- &lt;/springProfile&gt;--&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;/root&gt; &lt;!-- 4.2 生产环境:输出到文档--&gt; &lt;springProfile name=&quot;pro&quot;&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 2.修改application.properties或application.yml添加配置 1logging.config= classpath:logback-spring.xml 3.测试写入","tags":["学习","springboot","日志"],"categories":["学习","springboot","日志"]},{"title":"apfree的使用","path":"/6b0322e9/","content":"eff7bc64190e429525d784d60a5cc7fd6c1e13af71acdcfb1f9ef0a23667545050dcc7765e9d4afda90e98f96cd18d8690b5f1342c34cfa098f9dd7207a3e3b2d32094fcab54419960da83896cd0225aa6c99cf2cf096cabbd6ef28505a17a1736b515a49c247ded3ef0817b60c997203c0b15bbd1541d0445e7b18d2dbc22b1956bba48c35b36c947e6f8da0e666a2633fc9e58b5c585ed72e303a703996748c1bd1725fba64e3dddefa4dcac8a61de10b51ca94f7a6fb7d8aed16ec8d1fbd40206d11b3637a6368cb06286dee6837d0732abca2c9cabc18b6206c5901910ed58b4670c3ef017aee3d725b67212b25e8e7c1ff946d5b5710d40f931678e4a2d3ddca2744fd9cbf6ef5d910ffaf293860d00a92eab6c90254addcd676b1fc70e407c14187430ad836be18a84e03629e4f7b638c78a16d7be5610c6a8f2f5b56f85be28f21fd8a6293f57afbab5885be352c7233c191dea7afe16d0b2384cd9ef7fd57efd250a34d0f6e46d3f1aa96973e7e89942c370d15266f6d9a70fde3f379808bc311ffc8fad8b332e6b57cd6c93e987ee2f1c58bacd4ff4e5d464cc722d366312d70175edc7a664574ff80d45aec82e37a71e703c0bc987f9d66e6821d467d69e8af9c0569af0e7ab91672cf1d0421f91dd7ca6f3c1d62b987ded7e34864c774754f842a760edb53c7089b9637f37fe7fff532b3cf18ccf1c48870ac818540f2f09ba864c826a30da2224f845ada6adff737e0c631a50d7bc7e24b84d2822425dbc5af7d9bb8a47e0fb09c16e8da2ca469c29fd9d91d7dda01b9ae4ed16b7ee826150b23c82ad201c37f6ea87dc00f5334b7fc23c6326e2487af7afd784d013667e97e95870f67f9ed2d1eabd299c4fbe1dee279a017f7630540c8c0e68cb9370a0507bbd7f26eedce11109a98a1dfa22df45c1a1503cc2b6fccd0dd3a597cf5a3b2ae8331a9ac6ca6c6ae1450a579bb048bffd8d5c96a0c877a30cc63c01b9a0e2c62f0d3ce63c42e90bb57075a8d8945766738478ae758064ac92fa6393f26351bf70d985a228b697cc857d5d2e06c66c872965c97dfe8061af49b1226dc3540497e35f1056b4a6e9c1f7bf0bbd410c10d1fa56d98c816f059a89e1e5ee3cd813414c23bc9df319ee75ed06f3e16729141965772b6a55d3e09eb72cfa6b20aad47b80417806c241abad872b01ef23f2b2310dd2ea48ce1e0f274d166c8c100389606a99f41a4c65ea7d8d665dfe363ef201e1f82e854acd05ed93b9e9eec0e4f1154e36b063dd5f546f956c4fbca1e8b70325a4d3aacc25ec5ed729ac2e1cd79087246b553f2ba753fa279a345aacd6c9768566b4a4419674e89273a63e3e4e42d1cca0d731452e8edbca5b100625772c07f5be5a1603b7415397f16fc6053c169ef5a6a5f7df3933972d2c9fba2c9243465c650af8f1930165412ece4eacbed08300f5e2d4a11e3a9865eb4b41641b0df140f17897d95957798f67b7ee3cdee80a28b797937d9aa0638ef050ef1677a32242cc4cf4006a2b939fc36a53bc7eee5e35f5c1393b559bde2e378fd893976155020ed60423af86f88faa40094793905a4b0e0c3ef3768f5cc86ccb9347ac29662cf839234d7b6f9cc05168d8d4cd1d76a473a846851e847d98fbdcd34357a9bbbffa977ca0807146f72160e3a39608112fe35f4338b60638d854949141688cc1c80b23a6dea6afb1bf3c1583c81a23c7c2a49522fb4280c30597da7b76357e5a87c8110bb353a7ec9e6ec4593baa8ea6652962b291019e3064fcfea2152ec69604f91ba92c6ae534ed7ce4c733f2798340f11132ed80c1409493eec3944e638d5fae50495d6b4d4cd7e8ebc64224a560926847c752595b05c4f70381b3f79418a5fdacb07bcceed58adbb6c0619a4899e8c485ad0dafcf1b89addac1b92cd9304bc87c7d5baf6c19e66ea053e5ee59a19c5959c2bfaa4dbdab3e3be8487b1c00e709199cd1e62c25186329f67edbe5f13daa3b76f92ba946ee32ef1c72da09f0b132dcc8ab398d21e0675a7ab85e766da3ec267b92d0bdf52ffea704a3bbe2340f543659e169800eff5f661773b120da7db0cc2e0cfc24f7e88c7cecdf666ca9d4d8756305e077fa6dba3d7db856fcee265b82b1eac302e4998e9106944e5b5ae1118ea99ea3d960859fff6ff422f1355fa7445f908383451ed23c508f13f5f3e4fc79f547987b5af6269851ed015bbbf87cd79561b5b8b08b74f8b8216d91f58e263693adc445c6737a830eec72e5083c04372dcd5cc46161caea1558debd1795b80d1f3e0b526ec3add1519255020b6a69509ba1ea66988a24585cb3b04b4ad6a97878ad6e17839b916f4269e59087da1421573880504124f5172c47516543fc9c6a6aa6a9a67a35f68625242a6fa45f6d06ac0ff8b62a6395d897a6c3baa46000199ebdba35cef2d4ba85b8c5a35db69b849da586cca29cff06fe4e1788c167563e9096e2d9b76d4ba77e159d6070171ecbefed6473dd9bb6ef2fe39aa87cd4964484fe3ae43aac34d6378706b667fadd3b77d7872d1d145b889c8e13aa4e7017c1a6c80726beb84be87d91846b1ec15c9ec0ef3a684f764750cc4b16a06e6253fa673062d421b9e9203baca993c66fe131f1094a113e8fcec5862fdfb2d158e6ed636b680034f06094627365b850ca060b02f0c39a22db169eea86c7558450b4cd7795778fac1a7b976ae73a8d4c70921335957461d76d6d72c1b3783e2aad550dd18c65d185ff827333c1f3aba10e2c33fb98ed51bb3b9e3d5813c99f71689eb41132f8ae61946fe02b6ec8b5e90a198d12104688e6017fdcc7089b53f5bac3a1ad7fb634a0db8b1e3872c977af823b6ae63b214f2ccc3099301aa0158cbff20913835fd43cef599d3be299c94ca7016e6f2aba05939cb88806cd5f60996ab805dab210ff8366b5ad455918fc64ac861764f297cb20716c67b6daf67ff59cbd0533f6127991e049334d73db008a8cd2cd6f9188d4f5d21e3bd950fdc11af5ec2b4bc6b4fe299b2af689c68e0b0559ffebb367e45ec7f5df91d060601312639a699e7c5a44209e6bd7704edd1088fd43cbb6c4cf08d0b8b2248ca36ddab4519db02a396ea52e72c27d6c721ca2eacd19a6dbcdcd61e4f7dfe3ca73aea9852057d27907935dbaf92223d2c219e9bcb4d9c8d5de02e51b13a526799d35a85de9822a0631ee7eff4c639e09842c426627e3fcf55e95fe66adc5067187a8baf9cce4cf59f741cb460c9cb7e12c836dd79e26bf6e1c1699748b3860beae48a71a54a2499119fbaf399f52d6c8e3b470b18817dff2a8ba64e4d6f70d4bf2ab2caba58f1d1857d6c5ce835c18e82027e2cae21d3fd7579937aedfc63512504b4a4fbcdf75154ecd81191742631572541ab808eb139f713a29ea8c3317f8acab323ede1a8f34b3267baef5502a10ddc7d596397b0996b543810d5ebeb8b741e7c8a02bcbf325faa5b66edef0f6a3a5665c6964804064936d4287955b5377e59136dcd0dbd7518b92c03dd283f48885dd1adac794bff9c02d74ee49d861e27c79acf3b8ff3ae5fa39b34f4bdb8fc29cbfdebd435275de07ee007994f06ef1162e74cf5afc24affecf016d6193a393f141a96bc5724a0f11e8a3ad1c6ccad52098bdd6317c373b6abfa1e9416b639fe0772dcd2ffc938b51f55e7fe4dba494a98f37235f5f89d1eb2254ce87cefd94329f4ab8eee1eefa081d34b1d0eb9885eb6b0c58fa4eb2c36d5ace7361a53b32ad2ad1114a0552c15796e623a299b19348706e55cfc41d2a4aea57777acedf895c740bec4e234caf5efc5e0fe30e0006595143c0cda5e1e9139b0ee89c932e02646660d9322e24738f92ed38b9e21047c63e03d14c1bec7d4415e90c596776acea8846a3203c6001773b240d10245df1a2d3ca53fe2e6159a28498c1845a2b1ab4025d59235ce0678bf656c4b9cbfe4f35b15472190318855abececb987c481f4731d8ca3d17bf6136765a459648c0990fd13a23b5e7d47f22ea9b3e5d35ff481830bc6f280148d7b63638f0465b3276aaf3977f1ce36017e7e107f73dfcb0333d4ae044dc4197be6a6164eb1199d6d5315d8940264262fa67fe12beb3e0bf2c210e31c3b6d50295144ba80aefa845dc89c5e83d1bb2fd75cac378df3c2e5c56b3ada1c238d32061be3267feea18180f0336567fe683a0c2ba3b7747ff0fa7eb9f25f5d4bbeb25a68f52209b2f97347e118b5549c3dd3b11efe0220e0f0863fdb7f130571c3208ba122d918cbeec718aee547b03fc912d9434394f723e97be05f01b677b9cb6d1eb9fe8254bfab678eb1d01aec32fc24000f1ea4bbb4af70b2a17846b8ddea948dc58e02aedcc91799fd50dc07c1f23373985d771bce07b537be0843052a68eeb1cea28de59326c17740de5016a808dce1aa290ac3d754db5c0e867d401cb5a261ed6ec336c1bb5761ff6dfa564dff544985dd8a5bd0040eedfbe8afd36fe1f525437951246bcefc090aacba5a0b0c6662b93022fb960fcebc62fedf67edac0207cb37e8ee189b1438681ca3a490337e736ae728a866d32b3f89b7b1485873df040049053a821fb7eb6c88904caf387fff0e65ac3256b1e20f2e98ce9520b7afd6630f56f00ff230d77a241c48fa7ccb4b94b033adb937d24b216aa55f2e57c915dedefdc38a765313e9ce6c578b8879eb112449347d62b5903fab0495ef325804eca7c6bc5cb0d80f60d49a42eaa47de5f1bfea24b9f1d990f623e384ceb9a83049fd00ec3f466946da6aacb154a7fc08e37065aed78eb492a31435171f938380b4f1b329b9cf2669605a7028dd27abea0a0821959631be4fb672f38d5d5a2bfd7d91fbeebc2b5de637404679e29f30a1f59ca4304a9d0fd76f979a72569a092d8ed9a58a153233d4f12f3b3a0b062eea2a7e5e8d467fd283ec93ec18b1b5902905531b7efe54886fed2144cfcb3203e7bfe5ed3bec16b051ca47ae2472d4bc702b66ab732f89e2b1a1681d909c67aa1354691e1fa9530d036eba21106d454e0f26c4b745dc1815a5dd32443b9f74627b98b4cd322239c0b713c26b77222bb686222b13afd3e7d8e142c45730eddbb89bbe2165be35677eec29735ed094733bc278e7620253f0b18c6a11e6cdbaf6736e55129718e7107f9c47f6250cf7b1c3e0e6fc383a202f57843f14ce3340137bd662ebb5f314e7339a6adaf25a6993f825b29c62cfe74570e39844eaf4ad5bfd81461775cce454f200b12526aa1500cb5d0dceb32f1cad0e87e3dda816909b8005f667c5ae42275802106cede225fcb8c8675c9c77fd41a790dc167f4e1c426c41cf3c06b3c05a3a2674d01c34ec42f0206e08db6769e15641d87e9f9d1218e303b6f5a7923155aa5e76b49e5dadc758e1c7a3a7616101719b45bb5963588ffb5d2520fef639be2891cd5717c2a94a0fc5b30746520eb4d1cb214bcc4046430ddc55910b4432c904751ef39be1f9e5bb8d9fc6f08a05a29138189f875f9780949b83cc64ed01d3412014b72400af3e63a8ff76889580201652abf41b6ed30cd73e2539dfab2bc273951007fcf21b8bbd76315336739391fa3c26554d1091494221002315b7c64c3e9aea27082e42ccb5fd29a6915255d14b1ee298255c1c7c4bef8727b2f35ec7e51cbda07c5a7823606e92aefc884635c7b3440bbfe2d3e1be86912520bdb553229558c473f2e64a8b503197177feea081086e3ff5646b6c5e245847dd965bce5b7f39dc2ac74dee3a8b0e79abe61acd7399b752a564a538dbe19368ab68b1508b8c81b243acd53f4fdaf676ab9126ed4614752062b7102926cf9ff61bd977d4ae1020482f221a01d934bac90a04f9cbec5ed61311e343da469846a7358463d91fb5772cc74c03eabbbbb2eb87e05812d7e766d0cf6ef254ba085fbbda4fc8d9b210a9e8a2f2a5a0dd72fb8b64bbe2514c607237c692d747bf291bd2a787d11516fdea78dcfadb93ad1cfade0ba559f7e3082978b60ae26df5b870717cc77096c5e0dd543c26bed8ee94f0364de50274bd1f4f4816f57fcbc7c8a419dd44b499b7f640a0419aef89bd6cf7578b41a6cc7eeac7919c190ad9ab5c0ffb9aea9178992b7dadf71d3324413fa7f806c25f4cd76f956813b365d04eb0d31fab059b56534c741f1a15be78c9ca5b2c198f6406a037f61c23c62163138939534a07580f447c110c5b455b0161fb611a7dd56600065a505eb6d75cfc598c2b7b31d20bb0e2be1731a6a48cbbce2c495bfece13be21593d1c50df4673f1d7ee79661937e9896cf4ebfb7f5a41768afa908e77542d44273bade72c075bedf42b7ec1e048fc3956b0128d917c7c1e19694b78b5713cf2c07251664c254f4d9ec5f6ad26f712b1f9677ee09bfc58a57e680cc69046abcd3625241979d80c36696d5ed6d512adf5a849364af69ae2ee8a2c6c85591302d5d31f91739163230cde2dcff908f8793083910071f11dba750bbcd226bef909fbc99860da95f44f7cf6ed51eabfbd992e7ffe17a9b506bded3e168d1372c6657bb1910be00661fb3c0625b162eba2a9bc4abdce50471739c4eaa23600759bbfb87bae275560cde02f79dd666db009675ab47f630d3633cd509aaac04fd9e455688d006620d234230be7baf508081dc1b21e7d32fc90ebb59c65c6f5c2041b01f2ec6c2f2d65bc46cc88f5a77f81b1d886bff7dc08d242bfbf9af89897d752018d1ebd0d8acb3bc209c1fc98e851e9c683137a936352730cea0f2e629963f096ec35ca0dd07c49ab067f30e3976b6abc2d7f26d25029ea6f82d534e5ed4abd1bac559ddcda4fcca6c2f87d1bdbb7e48f229181cb91426995f6b855a2608bca4711a You must enter the password to read.","tags":["学习","apfree"],"categories":["学习","apfree"]},{"title":"apfree的安装","path":"/8cdb001f/","content":"76a3653a703cce5f56dc4a468f12d5d43a610f843d1618181c7dac1ec4cacd947262209829fe915c3762db838f07149d3f482a95bf1011f0c1b0958f9ed5213d3a43ba6fa2b01ab85838ebdc17378fa9f3e5e609781d370646f92f982cc8a2b0ba721569ccab51188e982d0012d8d9dd73ba801ba7cbbef63a15abcc32b6914df47e0ad527461397aa2d43ecda5854283e762fdaff980694b639ad7753cdb957b88ceba37f3f9bb9786ab77461dfc15cb83ad067389a8513e106e6e8c65273454520f063927d1d139738c877420f6c40236714b84f3d82fc4bad787e17127b312ba132f03148b41cbe6e517e310337c01b543761b7ffda6dba312d5d0f97ebf889784622013059385b923a9623ee82f2752dc3444aa015922c4f91a1c1b75f93db13a7beed6994fdb1f994353b3aafbe4d2f4d42a1cbfeb3088f8a671b77136d23d521592194b9ef45435364a759931a24836104553ed55e81d892ddf98175bfedea7dfebc91c57b29f5dec1323ff50841e79eb34561117bfdc6cad189ca8b28d46359dedabf8509ca27490fb18e2164a5314c1b2e3e32dad768a1f22c7f23967e1eb1b0af2defe8c19fc392d7d35b7b73145102c42babe5ab10129fc2b4d7986b943e20727980cdca66e93217d179b296c5837d1e7c44311125b556d935eb4869d61aad760ea61c189e157d3967c31e3bf4ccd3f54f9f9632290cd757b299f0d3118a2ea77c5fd367e383d97dd8df512b9a6bb39427a82a1deed55b592804233070f4e07ec6add68993aa38e048ca599d94b3a716c393b10f05b795a0ee9df014c7309172d223db66bbd3f077372555b76910039602dab9cad745a163c2155063584292b7acd2046994d7bfb117407c1f22741cb5585585764955e8ffc692d217723a691ebfa7c46435d217d180470b3317a602ae24b29e2038047a48b0c460bd891bc8771c319f69ee10d4b7031f4de40e859810d65bc97e53de85c8bca1cf75b145c6a691dbf675586f48b63495343acdcda963cdff9e4d9ed1a1a6fbe7bae12f3b99d3a44dde30f45e7af974fca240a5133033b359e11bd136f73d075c253f8d0c8a81b7ef9bf960cc09aca1980e7f19df79414c4bae57d21709892c5a7a2e49db156e0f9792106ead2d9c4d39d75be369c99648aee4c868c1f866738343bf15ab1c77d388e6d07ad6a6ce7ae3adb0c45c6fe1a3ce6a81de60c595a139eadcf9f30f48ec7b3e7c019e8506638d02a700a4e6dca16527e75f30122e6c910b03f8088225971998105f366e9d15dc11967ecc6a54efcba0d0f2525a24055c2684bc9a7ccd9c6c6d8f016732e6cb63a6d8e00b03cef61b67d7459393483677a67f6d1434e29f2e91e6163c6535ec5b53c9631467b9516c644111f22ee9710e8783d12032b2ad56229dce92840b7859bf67b8979d3afb11547b5a50c8385d7876d00bb1f4286152bf4e6e1be414deaf969350dd0dcb6c5785c5d43d2d1279514012fbbb95c422d54cc1d5140d931c934992783dee4229f76ca011ed267e9f291a29e4f45c1e32447a7158723fcc5ae39fd1f8a68e26b5172798baf7b7b503900962fdb31348ca8713ca4d9587b1c0850b49a0d138d5c92f6a92d9281f903a9d33fe476bfb86af8afdb820803c4bb690cacd436212c1af8c0ef2af5810469c3f65d402b785b73611334c71680536e48454647b25d9e355f442e03b6c4a8ceda95c6d55d188513d50209c2f8427b95f34d31f3db84433a90eb44a00c646a9026b55a0b57174b5a2a56c3f877ce172e98c29bc2e0a14c9bf7b1ca8cb94f166315d9be7dff86e4143e211ebab5f8ef56a744379c63b2da958323bef381ebda156629d8ff86195076c59cfcee825ccce68b8f90970cde1a8ddd3d7c7ce2411c97824e7c18746dee5e8fb5ac665d0362af273cb1966558b1332be124ad55c192bbba220e21801b6061ad146caccc9613e56169b32da60d9c4818afd06f1a942f9d5e0016d1d17dd100cf8586b449651a74740cbb1e65435ac2e172a63a88310eb1078e2f99c32207e292863ba820a38de950386c1d098adfe927892696374e085292cb315f8fd38c414a8ef2a54b833be5fd10814a35da964121d2472a37c24ba69d5a639cd2479702bcba6125120427e116bb8a97ab97746574deb66e2ef7f22fa42d6357a5222cd1ae2c6a4501d73d465a314e2b11ab22c112c14eb07dfbe31a12e930cf3be610477174a08322c496c0cf50377ea77aae082dd58877be8ec2232190ec294540da146fbed533025d565659992833335a8306367d891294a736ea2b426ac3a461a03dccc0fa095427b934c4b2f58e67adf74ea357d6e09329ad0e0b2de138ab9afe42889d6b736bf3de28eeee55e1b61df24bfeddeec19bc011185838f843e1d6ac15ce7aff60bba6b8d29a2b576ac741a61222a1920b34f93e338807e062da2c448e0e16a4360cdd9a6835a5b88a1b4be626f10ea4b99ce5686b211a97eecb0eb120613918f8e1c68272b4df67d09b4893c74020cdbe96d6324b430eb2680dae816c6f6aff146c55f9da847e2424bf7721792846861c43fc7671e9e316efed8454ea94d52f5e99057cf604942b03040590b2a4ce0e4332266ae57707535aeede96dcbf22a0231fe5fb64e87d2fe04ad7b2a8af9c40a1c6e85fa6b9bcdc4c8e3bdd4e31f097a10e0d65c83ab9878c378fc14c24c7b79f9825903e9540c301782563254e7d82dc0132f7a3067ab2990685cd3fbef0122cbbff7689b1c04e7817677d739044740a9b36bab47a75836337e054b63686c7bcb717a455b758501bd3a78c077300b2c07691c2e04cb420373535871cfc2d9482d0d54db88cf5df7f7a68286eced4cc58921b93c3b9b82ae3617d8907a39add516dc7541f98fbff66ccaa2936470ee7843df51382b855ca2d62c20caf6fe7821f872790185cd246791d416b4d6cf9fdd3e0a36d8f88d1a9a53fbc041817fa0eca4ab7b5519bb54474628072bb01da420e20f5b065de5c2556c37e4ad62845d53ca4a5de4af7ad6bf05ea0dab0d74fe8743181a8af2ebb87c32ab2164a40438b2419efdac67a1046695da5d3fcbca06c4adf0335139edd982d4bbc9d95cf0d970ac560e02d50745c17b57507cb77e6e64c5c9dad739f267de48535175ae24051b4f9f6339f1a876f915d5a4b5a6b2fc15dd91ee96de875e91b1b0dc3977967d75f16c21d3e8897dc5ace62c38f06a12efe4093b46deb846fe35e31cf1acbbb67631791a21a8a64657331ebdcfa36e7492d51230c85dafde29f544c5233e891bc7ad2bc873e24d3a60d883659b80f54104b17c77792226075ae30b814a4bebb9e093466804bf597b073becbf4d7ced2ea5e7365fc0b3c72401c39ae658be9c597b26a810c2e90a30213b946e0416914dbcc0ce29b7abd8319104af94d1c5a5b99041dee12663a6e91fd8d82436419b05fb032996f4cf401ee5df282fc75b15276da666bb68ff2159193814ffff16f04292f98cfbb9e50f901d27f645234bc89c01fc43ce169f7c8d6c2163b647b6797788abeea8a81dc7d52284f1b1c617a35b87c829a2006bca8b000d142631f01f50a65a309b7b27f55808c309b77770e4560d504fc0a12cfcde8738d8880af842607623d1b3a748513cc60bdd15226c6c18190daf3bcb878b70d26f901b5ac434948bc96b69d5e86794cfb306b6a7cbea3fb34d2bc483e1fdb193bc9343cabe86c2211344b477ae0291be293b6eaf959b7002f704264db5828643c0a131d1ab210203e1d90c2321ac0d179cbcf53892f27514f8bc8bab8dec4a230e2a74f5bb4d06c35b34e80234d5300b226a4224c533f591c02d2849c7388bc7fdf2f543b6f98f012bc051c0f03b2719ec86ac01f03a6e3cf18316c2742b92ca7f98b364c3f00e295c921a8e382cba66ac3c05a5d53c0411b65b4f45b1cb7343d238d0079e0e599d8f5131f67b0a4aa82ed2d1ff9119758a478b3036126452dc0ad957a7f0361161593aba59c2207b41b3e0dcf24959740b5ede9db7f79324f9b7f9a2e25c0560e2494a41628735caebe3f317f676b3da8a16c9e12f30c87efe0144a2789e1a36a88e057b86ab5323705ac01104fd0a38687b1483e6a52fb92d19eaa4b7c9706b53cc09fa063931c78fea87706f8fd3c63675e057d4793083e2f83de1e8402b4fa152e56accc44b78f6bcafa78e4c0dbcae662bb865920ad483a3e99175b94b8c6ea2e077f755ac320184199ac5af1cc2b9974f3311ef77d437c525bfcd4d7eb6fc9f41e6a73ffc9a407cc8ae96504e3d9c3dc78825d32fc625c6dd899ca61a884171c651961c8076b6c8c6967c62f2b1230f45fc17fb3374f93589d02430d941ff6ffaa6e0504e55b9483c87305f4711eb7bdde05e950c940d51219ed3f7e45ab01d2fd764ef277b1fd3aae9cc2e22155a42213ed119c7a8d17132de0ad176a600dba90629c37ba4c5d0f24a2a6824d42c5371821164e1dad9632fda87f9ec3621a545185495645a99c2a9f2cc53794f16d3f1fb4a53b65ffffe61e670c33ae9d528fae80de92464bafe990167f6f172ad08f8b27c891ee28259bc60fee24ba66aa58855e946093a7dd2b36d170aa1153204ff5e06e0d10764600c0aa9e72c76abed40d286b2944a47f99318c8cf92b1d22bd360a39792364465f5834760e0188a6eff5b11e4ad2ec99639d4d3c08f0b98758a83a47d728885317f23046b99017e7e70e632b184c4523eabcdcd9f23d758ea321b33ebb85b5799b5f51ad27c756ecc8aa549859296fa375c9f885897e03d1be82bedd76655831cebc798361f4e51c7ac6010a66a59da0a06181a9362fa1bc1784ada11328281cca13851fa78a583a6fa1c044a77179b15e3c2383585b47920a5e31e36840417d290807182fc3cb80112f0fa8e5d636f887697305579967140329fa7a9a89a8cfac8103f2e799c35a9cdd32ff6658afe44c3df5948548475ad559e997b35852c77ae39c9b58248c52468e9e59243855ababf66d3d077913a96b43499d5f8d6d167b99e3b91676aec64401baa7d3a921f5e076ab2edad905a567bd8f3c5954ff2dc0663643b07432d4524d034752a953f9edbffbae1396b520a29ae2eec2db7e6dee561fc7117d4daa35419d38f818271ad98fc270a3bbed32395b8cd4839821f792abb46b41439b618786c845c39c77c87521aa408a8728ab3b40b64e6db7187df8f8599b5e9636d3b0a8d8ea4cd9477a0d03ce1e7743a150bb04899169667c2c571193c51deec69ae754facf73da4be9097de13d75c995b600463713b482be221c3c59b140eab17ede6088d11b7688b5d88671606fd93d0428c6a26e23fae77f18ab855737ac45a1b4b9ccb1c2cff400b173c9030dd3599a17c53eb1604f35f812a7429c3710d0b89470f25e7bdeeff985bafd4d638bfb3bae5563ef5e3f4cded9a8042a60f5413702e39ec11b9daf66de51d2038a938483fe63f64e804e0bd2f783c236ab1b1fc0f14ba6bb6df97b24adf6f68ecee91068e667e7f976b91be1eb140f5b4999cb9d0544fb4d38e7546d5b3a20c81f0dfcb95c89db28ce5a112d29e6973f16087154836208a1125e9e8a48df88e7b315862b700ef578393035c121407b17583e1e527e294d6173d97a16f8609b912c18f405ecccc3279976f6e087b6a89671de11a46fd5477cc7214b4937e858434b55e2af204b73faa7c10ea949257254ee79f9884bda470ac1a80e632f7d47048ef6ea3212942f52eecf85742b6cf444f0b9007d2ff88afbe4de231c356f4eeef5ce0aec34ef24313434791bbc38026263990d7f94c6a7aab984d9a81f85e67dc74892d90a7dc109840efafda8f6fa69b28dae4f4d398dedb84228d4e78df3c04c595761f7b22fe646cda8b8d2d11e67df0d817e7b28feaa292439adeab5b0ca9e8d71ee642f95adba50cd631cdd02927ec41f36dcd750f55029055f3ac7d39c4af0e349ac0fd04a842ea73dc23099f5b2bbb6dc09f54b5631ad3d87968708769fb3771df72f5f86d325b9ca97c53db2940822219c8a17a1bf6a2b10c6df80f8100d15bc4e39cd42dabacba09164ce992c16bdf9d30185f235d3b03700a81027f2b7de75c47f11470a4a8b4354a6e622d45aaeeb33f66d7f672226331bf929c6c160a0a58c342ad1fe95250e84c17326f7f390a921ca9e8f4e817f39cb6f1b7615c82024f092acd81c0dd00a0e816a6f131dab0e6f0208cb0008242067f8f9f0ed2e53eb4e344fece51cc76b3a05bb46f7f7bc8c9004a8636e46ff156b7969b7e7450acb57c70d85a464fa8d04934c34bb5a8ebd1d74da36e7bc0b37df8fe3d6f46dfef9c6e870449d6bb25ce2e3f643cce5bc8c6a809ca6c6b93155c0d63b2030f05ae9e6075d7a4ed6028830bd05d462225ddbc12e01b6c1734c628d70f45e206e79833422820787f71d4a4c8c0b82856322a8a427f6b8bd3a4479294db99afa9fbb73a790238aa96187321c729399cf17b3735f82dec19e4154e4ccbdc3e1d413c0e5bf460ec50ead0cd04a8b512041f162e6958fb30417b13f591947c05c049a8e09aa621786c91f3030e256c2094a96ec179466ee6938a8a58d5f7f51a33a80203bf436a2e00cda2860a6c7bee117b5d11b4726dedf940a9e4edf7ab19d41eaf603b5fdf73e5bec8debb52d7a1a68eeb979cf2f596f4854150e3a990b4b0dbf7699c0575e2e108d7d231e59b9294974354e65273a3d611f117d566af9225dfbc94874d633434fa57f9845b28335394c769ea53a654ea4650b67bc6564ebe18f007a6586fc401b69aa45821f45944eb90c735890a1c082a1150cb129371e5631dabd9183ea67b4767af98c67477f34296fcc6ef0c4ec5d0a8886b2bf92c49b114eca1479bc2f1e9fc0da50d8e4918c1812ad01d54ac525a26e7f59f336aae71f3ff6009d825e311a66c42f9157c6426b28d2abed58c87e805dd29c112a3ea19c96982365e7a53b3953d75eb83bbf00961c16297bfbb7d2dcc5c0a188a2eb074125ad1838fab6933ded5ba5b04863fcdabe2107cc8a4d41ee897f9b02d703bf8cc1e4ff8e9ccf8712955864d261177762284918b53a47bb60b50ab1a829d5dc295b73de24bf5a609b78a597f70af68b9c9432df8eb8e86b3612d30a3aba39e364bf490b180333b216ff91809c2543ff6669aa5c2c7f626a44e9a22a14d2603f25599a9869f91848b9adc7e84ffa38c9222dc83b578c655b642b445c2c997b9b569efc9c5143966dc16eb8c58904e08f98534ca9efc6442aed3745e5204a1b16a590e9813a615720bd454c401a4cd7cd6e1e9e7cb78e61ec527aafa7f4b464ead425cbdc7ccacec80937442f0d5f7f8eb44540968f7397b9d052f8ffa90f5f7bda4dcc9239f78b4b2e8e80f0b480c4769e33e64f2abe16bbb8a18e3e58d82c0c4e1017664f3122ee361d0f0aa7e3e47b1dd29c2d3e87fa2dec502a77862eb18d761268ea1044753c0323000210d23ce83bf9d184ee6d083a831752380a0cf9796e2be81c03ce66b90b8552acf1c927c430b85a26463605eb6a6fff401d2969363c263ee83df67287b1751e5d09f43f1daf761da592c59f36a67c4dff57b5422f424d584e5c9a8e2cd3ae3bed5535098ca2eb9aa2e867fd1049fa3e3666d3eba8191edcf60a20110adc61dd23c80cd76ee4fb5431d486bc290cb74da12a7d6840d7b0eecf6e4c484aebe4fcd81c40b63db46e031732af76e5ca9d76a191858bb63264e600797a0d5a15302b5c44f94127b2866104d0a37999931321ef1458c97000845df05b4ccdbca64e3932cc312a1630ea932c9f46e6ed004a791a6620de55b1f0a523aff6c2a4bc7359290120f0c89c72cd8692bcae7c2ae74cc72452a6089cd0863a789c06308f0ad26da8a091082a4028a658070b7faa0c258990c90a04545f6dab53ead7ee582add41345bfa89eb9fec3b61a2481a0823e90536916621fdcf53e8c0fe3aedf731050b80f836c027fe616d8f38d5f48fbe563dd6409ae0423f675a449028e60587cc4cff0b25c799efc10b26beb667c8578049c3b3dd455597ffc62859673b01e3307a5939c6f873377777921e54b7d0638215afbedd095ea872ba76be9e449c90ee0eb80d317b6929239989322ed2e3299820a5bd3e04f3088decfa2fcb1a453571b7e6d3db9816aa956a3d14ca052e56156b395c369a0e8886b5ab0002cff97e5b57ceb4fdef9becceca59a65dcc5331d6266c4d361fe97a7dc84b00b4aab497845753857c71d804eb24c7b1ef7f1b880458312b42a2da0af56fc3e2441f83609bfb3dfef255e7ff3dcf51e9afddf0a0e82c152e5a3edc1ee409a3897a221178166a94970b4ca46a6ec1e9f47914e960bbe3ec2963d8661cc42fdaa63e555fd322919e8f767e388bc638a38bdec10a78203ea7a564dc6ca8ca1b920d4264534befce5e99b0fbf7066634cc2be67ded477eaceff8ead3d50a39ade9111fbadb8f559dbc40ae36eeea7cd892c24a9114d4fb3e6f60fe2a7cd0d52542793f22806f045cf440d60cae837f34e9ea17b18a3b81d6fe7723015abcf71a37d986338b0c8e548f150b0c247f02047f42bedf5145918dd582a23cbdc64017173f80bdc1d3aa89380496c5fed961800aa7c542e0bd2c4e81f8bc0a2fd6b8504b6cab72d26c3426a2fc15d08529f718aa1945955ef87bcdf42e2f14ce8a2625b893a194329142990987de88640a498b58df983a8b864d26f5ccd874bc824353879df22405e52264bdcfc1b3187b8e1295a009fecf71fd57dda126b623bc50a4175bb2a9d5b0207ec8c3a30547ee75e63ec12c26eb964a4f7166d113a745ca84036108a66e49e9fa376f82640ef033921d5a06fdcae3db2925dbaf3e5afbaddae5c52c4c3be508f11e8bd12ffa4eacad0272ee5dc9c25d671eca37c23a5cc2cc4f09a893caa146a2c9f59a01a75568ce704ee386d577ed93ea08d4fd75a92c6ba51643519f318ee7240c54a8e37ec6594799182d581ce5aa3be23e5ccd9c0c53238b475a33093bea865f7eb96fd875377c72bb1f734cb4acbcde06b7d19e5304d77711de22c6ebc2e90d50fec98d44daaacd33a33f67f3bad6031ba0c6c1e89994ef4db5742519e662245f110745f57f4162f840ad3940d71999b1f119411fa503af332933d9aa06b597099b184bc338a3a1e7e8485c79b6544298e4aec6fa946ee22f482f2c12f198eb9e1d5524b76c48b0df8952b2db59240a27e8a7d214e615eb3d81cfa210f43bcd6e487a9c519614fd67419feb113c79707b75e05c9bbfbef633e9f11a76685f08dfa4cfe66fbd9f1eb0b0d705ce0c76f0dab555c1e0e491f24355b4fc1cc77e3d28adca994787c582e33c2943f89f57fdaa5f3891c69f1b07d24cbfd6d7634ccc86368e87005ebcc4df6cf4a0a5a9369ce89c97cb19fcbd98ad3a869e058e87636878ac8812fe8a1fb8bd44914be8b548f943ec791f5869c024e32bd08ca13b4473cf14f59efac770972b8fc720d36e0d6d6a79ba2978a2ef380775d12fa5b09b219e7814ea682d3012f1dfb7a8d9095c4925d609f42a19a694d45c9dbe9f95005d8a2af06453f75eb9c0a34c6e5506dc0c33efd6201adc34972246e506b6472a88908430826d44880a2de55e27e237a7136912a998bf2179a32582bc9fb41316a71bb94f69993a88741d0486d1d3ae0bde43406d6b8247dea2f64779405ac5eacfbe30d6d06ce1fc0dcde02a6abe60733c51c4b8a367f1ea1a3323777dccba655fadac5a6c72fa61d7efc071fc7a49b4ca1bc55702747b936187ce4233867d1778175297ff0c6ee4b5e7a2cceb3bff65773f54f9802e643c379eab10fff91e764715ecef54aeb9e91b923f9fc41118f95cf99e935d6bc1ebcac4616a420af87b148cb48a94a33ca20abd0b048e3c616b82a77f9743d880fa371d5b9908063a51ec4a646abc1b5149e2f72be0bbce95e04beedd029dadb7e0646f7e83c7aae492c9dcdbc18f8ffe5c433030996f7ab97fe22e70720814f2386042c2a73f24df689786afeaf9803eded0cd4d81b975cd1e6df89e4a5fe1669a6cd05f00d33f4e8ae32857a8206923835b11b6255885269c4d27200d7d67abe619ef5a6122922520f8b05f41634e0d1f2257ea910c7b8e34d77017e6f0d077e6f469c2181acff60af794b9e9e25d7c835cc9512c18a400d66b63e7be4188315d2e06be39e1fd195f3d10c1d53258fce087cca03bee8230e74b11ff16e4d3c6af49565453bd0b44b3120673450ea712ae06992b5b76e12a7ec8506c87b22410e193766a62effa6b27386a585bdf5321229f108082e10a450d5c11dd197393e63e2b78889f47bf97ed27fd82947c43402a829a78e18f66bc663e47a4fd5c497550c238d78257e14aa447ab7e8c35635232a89cdd218d3709c536a0483fb86f37e9fdbab609ed40b56bf17800891eb0a09226a72eb0bf1337356a771253b421b317e910300393f1abb04f1a0d914d280f8924d3c9693fc7bd573c34bf0eb0308e4abcfb6e8fe5b011aa6023e2f6ca68d4a25aee37d3a1e65fded77d58882b18ccda226c6d2be06b47e775aec2c441f197da0f59c3a70a89601b79a3b4655e6d2f5d901a3049273330ddaace69ed5e61edabbb7d1e9b3febb49069acfa44c5c5e996273b8edef7ebe4f06d72bb2404e96598c7e813d0575e4a2d82c0a031e265067bb92fe4fe7bdc22b1c09eb506252649754d8fff437ce6fcb4b596aabc7e4cf240f78a6444902beb0c85c76c41f91a95c6322a5fd0ba02db0d9ae10990c7a5745e8096a0e89e787c6930b4ed3dbe7597b93ccb6d79029a0f6010663f86af1599aa1a2e6dc882d73d8012da7f0de5eb7be8d7bba73f6e56f40dd5d44e6f87b5e73ec74e8086dd910dfee8aecc9aadc9234b170e594a5dc685ddcf501e223790fcf857bde0781335a2efe7c70440b09a77857f51e3ecd232ef7a6739074a7c57f6f795f69743f0cf530bfa3bd10dc48941982436949c39fc5802574e8ff6c02c75ed19bb02f47c030e5758591f7110cd4f5ae6e8a37752efca35c3d50c36307992aaca8bc5580a0b7bfe790cc8fb33edcabe2a79b0e6a03bd8886fcadc9b4b3989490658af43b077a3a14fce3d79764ef8eee97d3237b64cc1a2292c34c27dddc0bbe18012d2343cdd3a7bcc60d16f90e46a89af6f55bdb16bae454ec12d1daad896dcda5f51cc5e2f50394b661eb428460f5d420b1016ab74f169381946cdb312e58fd9f7f8444413982b0c670d6e4fbaeb7d877ae8e9870605c08d16119407806caebc98dd5bb716445ac8e7a44916ef61a154a8b5f1aab8d29ccf61d7fecb919a96fbbc8170da1476d1587aaebcde78c7739f91139bbc36724724c0371f899cc4079757a6cfa173c1c71d3aea2ce3d496a8df12bd11640641c36a2dad777f6f12a108620423b00a7afc2f368a20adf9fc23350e8f2af4e1e6f884b28474f149348420f2d3f1dc81b4234460ab0e35ab67a46e2be4788b3cc5e4953cb641ff7f45f69fa312038425d3e48f166db3984cea461a4fd81ed945c0fdeb1002d620562f04ed581 You must enter the password to read.","tags":["学习","apfree"],"categories":["学习","apfree"]},{"title":"公司培训","path":"/bda667ca/","content":"培训 入厂安全教育","tags":["笔记","随记","公司"],"categories":["随记","公司","笔记"]},{"title":"JWT","path":"/1bb08f7a/","content":"学习笔记 JWT的结构是什么 使用JWT引入依赖 常见异常信息 令牌的获取 令牌的验证 JWT工具类的封装生成Token 验证Token 整合SpringBoot依赖与环境配置 数据库 实体类与DAO层，Mapper 服务层 Controller层 问题 JavaWeb中可以使用拦截器去做，SpringCloud中在网关中去做 使用拦截器","tags":["学习","JWT","SpringBoot"],"categories":["学习","JWT","SpringBoot"]},{"title":"大学","path":"/2965e54a/","content":"大学：大学四年，眨眼即逝。依稀记得入学时父母陪我去到离家221公里的大学，时刻为我的衣食起居而担忧，走在悠长的校道上，往事如泉水般涌出，历历在目，父母为我操劳了大半辈子，我无以为报，离别时的不舍让我的心隐隐作痛。我的家庭非常的幸福，无疑我是非常幸运的，我爱我家，我爱我的祖国。 大一的时候我就遇到了我们的学业导师李老师，李老师美丽大方、和蔼可亲、爱护同学，在非常繁忙的工作之余也是时刻关注我们学生的许多问题，解决我们的烦恼。同时也要感谢我的辅导员张老师、高老师和蔏老师；以及各个科目的授课老师对我们的辛勤付出，为我们的考试以及学业操碎了心。非常荣幸能够遇到一群这么优秀的同学，一同学习，共同进步。特别是我的三位室友，分别是罗室友、涂涂、老毛。 大二上学期，一场突如其来的新冠肺炎疫情打破了我们的生活，全国上下直至整个世界都在播报着这03年非典以来的又一次全球疫情，武汉封城，钟南山院士奔赴武汉一线、陈薇院士团队迅速展开对疫苗的研发工作，还有许许多多的“最美逆行者，志愿者”与家人分离，纷纷支援，奔赴一线。武汉加油、中国加油！ 大三的时候已是疫情常态化了，我非常自豪的说现在全世界最安全的地方就是中国。我们也迎来了史上最严格的一次事件-全国各个高校的封校。都说大学四年，疫情就占了三年一点也没错，封校生活也不都是乏味的，大家在操场上，有打篮球的、足球的、羽毛球的、跑步的、唱歌跳舞的同学，有在图书馆中尽情翱翔于知识海洋的同学。在这期间最主要就是完成学年论文的相关任务，把任务书与开题报告完善好，之后进行开题答辩，很幸运的老师指出了我的许多问题，我得以在毕业论文之前换了一个方向，重新开始。 大四这一年没有课，上学期出去实习，下学期回学校写论文。最终完成论文答辩。2018年09月-2022年06月，我们终于毕业啦！ 2022年06月18日，穿上学士服，满怀期待的去到体育馆参加隆重的毕业典礼。完成拨穗与学士学位证的授予仪式，拍摄毕业照。第二天拿到毕业证，大学四年的短暂生活就此结束啦。 2022年06月23日，我回家了，本以为可以在家好好调养几天，结果收到通知27号就要去公司提前报道了，因公司总部离家较远，需要提前一天出发，买了26号晚上21:45的票，后到常德站改签到20:35，说是10:33到达长沙站，结果晚点到50分，差点儿没有赶上地铁2号线去长沙南站，明早6:52的高铁。到达南站后，一堆人问你住宿啊、去哪儿啊。还好我有我的宝藏室友-老毛，他的人生阅历超级丰富，我很敬佩他。有了他的指引，我轻松多了，以前他说在长沙南站的厕所过过夜，我心里一激灵-好想法，后面他说在这附近有24小时营业的麦当劳，可以去那里趴着休息一晚。今时不同往日，现在的麦当劳，差不多凌点半就开始赶人了，正好当时店里还有两位小伙伴，我们三不约而同的走在了一起。 这是一段奇妙的旅程，“这世间唯有读书与旅行让人增长见识”。我们三能够在南站相遇，不可谓不是一种缘分。我们在南站二楼的地上，度过了这漫长的一夜。一位是康老弟，一位是杨小姐。怎么说是一种缘分呢，杨小姐同我是一辆高铁，去往同一个地方。一晚上没睡正好在车上睡会儿。 到站后，又是同一辆公交车，她先下车了，我到达宿舍后，是双人间，我迎来了我的室友-刘兄。老天爷呀，我做错了什么，大学宿舍四人就老毛抽烟，中间还戒烟过一个月，后面可想而知。这双人间，咋还是会遇到抽烟的室友（吐槽）。吸烟有害健康已经深入人心，但这又有什么用呢，无法想象像尼古丁这样的有毒物质在我们的肺中无限积累，我这十几年抽的二手烟简直不敢想象。刘兄人非常的热情，学的财务相关的专业，正在备战8月1日的初会考试。与我一样提前来公司的有十几人，后面就正式开始上班班啦。 大学室友简介：罗同学：一起吃饭上课的好兄弟，网恋过不知道多少个对象，到头来一无所有，这告诉我们网恋需谨慎。 涂涂：技术大牛，我们宿舍唯一一个有女朋友的，感情非常的稳固，是我们学习的好榜样。 老毛：除了吸烟其他都好，也不知道换过多少女朋友了，情感大师，乘着年轻就是干。","tags":["日记","生活"],"categories":["生活","日记"]},{"title":"杨宗纬音乐合集","path":"/ab0acde9/","content":"杨宗纬音乐合集 杨宗纬音乐合集 var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"空白格 (Live)\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E7%A9%BA%E7%99%BD%E6%A0%BC%20(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.mp3\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E7%A9%BA%E7%99%BD%E6%A0%BC%20(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E7%A9%BA%E7%99%BD%E6%A0%BC%20(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"流浪记(Live)\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%B5%81%E6%B5%AA%E8%AE%B0_(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.mp3\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E6%B5%81%E6%B5%AA%E8%AE%B0%20(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E6%B5%81%E6%B5%AA%E8%AE%B0_(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"那个男人\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E9%82%A3%E4%B8%AA%E7%94%B7%E4%BA%BA-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E9%82%A3%E4%B8%AA%E7%94%B7%E4%BA%BA-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E9%82%A3%E4%B8%AA%E7%94%B7%E4%BA%BA-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"其实都没有\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%85%B6%E5%AE%9E%E9%83%BD%E6%B2%A1%E6%9C%89-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E5%85%B6%E5%AE%9E%E9%83%BD%E6%B2%A1%E6%9C%89-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E5%85%B6%E5%AE%9E%E9%83%BD%E6%B2%A1%E6%9C%89-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"我变了我没变\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%88%91%E5%8F%98%E4%BA%86%E6%88%91%E6%B2%A1%E5%8F%98-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E6%88%91%E5%8F%98%E4%BA%86%E6%88%91%E6%B2%A1%E5%8F%98-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E6%88%91%E5%8F%98%E4%BA%86%E6%88%91%E6%B2%A1%E5%8F%98-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"我们好像在哪见过\",\"author\":\"杨宗纬,叶蓓\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%88%91%E4%BB%AC%E5%A5%BD%E5%83%8F%E5%9C%A8%E5%93%AA%E8%A7%81%E8%BF%87-%E6%9D%A8%E5%AE%97%E7%BA%AC,%E5%8F%B6%E8%93%93.mp3\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E6%88%91%E4%BB%AC%E5%A5%BD%E5%83%8F%E5%9C%A8%E5%93%AA%E8%A7%81%E8%BF%87-%E6%9D%A8%E5%AE%97%E7%BA%AC,%E5%8F%B6%E8%93%93.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E6%88%91%E4%BB%AC%E5%A5%BD%E5%83%8F%E5%9C%A8%E5%93%AA%E8%A7%81%E8%BF%87-%E6%9D%A8%E5%AE%97%E7%BA%AC,%E5%8F%B6%E8%93%93.lrc\"},{\"title\":\"洋葱\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%B4%8B%E8%91%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E6%B4%8B%E8%91%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E6%B4%8B%E8%91%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"越过山丘\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E8%B6%8A%E8%BF%87%E5%B1%B1%E4%B8%98-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E8%B6%8A%E8%BF%87%E5%B1%B1%E4%B8%98-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E8%B6%8A%E8%BF%87%E5%B1%B1%E4%B8%98-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"这一路走来\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E8%BF%99%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E8%BF%99%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E8%BF%99%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"最爱\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%9C%80%E7%88%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.mp3\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E6%9C%80%E7%88%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E6%9C%80%E7%88%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"初爱\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%88%9D%E7%88%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E5%88%9D%E7%88%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E5%88%9D%E7%88%B1-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"给未来的自己(Live)\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"国王与乞丐\",\"author\":\"华晨宇,杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1(Live)-%E6%9D%A8%E5%AE%97%E7%BA%AC.flac\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E5%9B%BD%E7%8E%8B%E4%B8%8E%E4%B9%9E%E4%B8%90-%E5%8D%8E%E6%99%A8%E5%AE%87,%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E5%9B%BD%E7%8E%8B%E4%B8%8E%E4%B9%9E%E4%B8%90-%E5%8D%8E%E6%99%A8%E5%AE%87,%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"},{\"title\":\"空白格(《一生一世》电影片尾曲)\",\"author\":\"杨宗纬\",\"url\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E7%A9%BA%E7%99%BD%E6%A0%BC_(%E3%80%8A%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E3%80%8B%E7%94%B5%E5%BD%B1%E7%89%87%E5%B0%BE%E6%9B%B2)-%E6%9D%A8%E5%AE%97%E7%BA%AC.mp3\",\"pic\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E5%B0%81%E9%9D%A2/%E7%A9%BA%E7%99%BD%E6%A0%BC%20(%E3%80%8A%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E3%80%8B%E7%94%B5%E5%BD%B1%E7%89%87%E5%B0%BE%E6%9B%B2)-%E6%9D%A8%E5%AE%97%E7%BA%AC.jpg\",\"lrc\":\"https://www.forever520.top/d/123/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9F%B3%E4%B9%90/%E6%9D%A8%E5%AE%97%E7%BA%AC/%E6%AD%8C%E8%AF%8D/%E7%A9%BA%E7%99%BD%E6%A0%BC_(%E3%80%8A%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E3%80%8B%E7%94%B5%E5%BD%B1%E7%89%87%E5%B0%BE%E6%9B%B2)-%E6%9D%A8%E5%AE%97%E7%BA%AC.lrc\"}]}; options.element = document.getElementById(\"aplayer-cTbvyQbN\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":["音乐","杨宗纬"],"categories":["音乐","杨宗纬"]},{"title":"画江湖之不良人","path":"/e0ab66cc/","content":"画江湖之不良人 建议使用火狐浏览器观影更佳 欢迎观看：第四、第五季全集欢迎观看：第六季全集《画江湖之不良人 第6季》定档2023年3月2日2022年12月29日 var dplayer2 = new DPlayer({\"element\":document.getElementById(\"dplayer2\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E5%8A%A8%E6%BC%AB/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA/%E7%AC%AC%E5%85%AD%E5%AD%A3/%E3%80%8A%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA%20%E7%AC%AC6%E5%AD%A3%E3%80%8B%E5%AE%9A%E6%A1%A32023%E5%B9%B43%E6%9C%882%E6%97%A5.mp4\"}}); 抖音var dplayer3 = new DPlayer({\"element\":document.getElementById(\"dplayer3\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E5%8A%A8%E6%BC%AB/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA/%E7%AC%AC%E5%85%AD%E5%AD%A3/%E8%B6%85%E7%87%83%E8%B6%85%E5%B8%A6%E6%84%9F%E8%B6%85%E8%B5%9E%E6%89%93%E6%96%97%E9%9B%86%E9%94%A6%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA.mp4\"}}); 第六季 先导PVvar dplayer4 = new DPlayer({\"element\":document.getElementById(\"dplayer4\"),\"video\":{\"url\":\"https://www.everlasting520.top/d/main/%E6%88%91%E7%9A%84%E6%96%87%E4%BB%B6/%E8%A7%86%E9%A2%91/%E5%8A%A8%E6%BC%AB/%E7%94%BB%E6%B1%9F%E6%B9%96%E4%B9%8B%E4%B8%8D%E8%89%AF%E4%BA%BA/%E7%AC%AC%E5%85%AD%E5%AD%A3/%E5%85%88%E5%AF%BCpv.mp4\"}});","tags":["动漫","画江湖之不良人"],"categories":["动漫","画江湖之不良人"]},{"title":"qq音乐","path":"/49fe70ce/","content":"欢迎收听我的音乐你的心！ 欢迎收听我的音乐你的心！ 听不了的歌曲或想听的歌曲可以留言哟，之后可在【qq音乐听不了系列】听歌哟！谢谢！","tags":["日常","音乐","qq音乐"],"categories":["音乐","qq音乐"]},{"title":"常用网站","path":"/dc34c405/","content":"常用网站 常用网站①网盘&#x2F;磁链搜索网站 ①网盘&#x2F;磁链搜索网站 复制链接到浏览器打开使用 虫部落 简介： 可以提问的资源搜索网站 网址： https://chongbuluo.com UP云搜 简介： 搜索阿里云盘资源的网站 网址： https://upyunso.com 我的小站 简介： 阿里云盘资源共享网站 网址： https://pan666.cn 天翼小站 简介： 天翼云盘资源网站 网址： https://yun.hei521.cn 优聚搜 简介： 搜索百度网盘、蓝奏云盘等资源 网址： https://jujuso.com 磁力猫 简介： 一个可以搜索磁链资源的网站 网址： https://clm9.me 盘搜搜 简介： 一个可以搜索网盘资源的网站 网址： https://pansoso.com ②在线处理PDF网站 ②在线处理PDF网站 复制链接到浏览器打开使用 PDF24 简介： 免费的PDF处理网站 网址： https://tools.pdf24.org/zh/ all to all 简介： 免费的PDF格式转换网站 网址： https://www.alltoall.net ilovePDF 简介： 免费的PDF在线处理工具 网址： https://ilovepdf.com/zh-cn cleverPDF 简介： 免费的PDF在线处理工具 网址： https://cleverpdf.com/cn pdf派 简介： 免费的PDF在线处理工具 网址： https://www.pdfpai.com HiPDF 简介： 免费的PDF在线处理工具 网址： https://www.hipdf.cn 轻闪PDF 简介： 免费的PDF在线编辑器 网址： https://lightpdf.cn ③在线处理图片网站 ③在线处理图片网站 复制链接到浏览器打开使用 PHOTOKIT 简介： 在线一键抠图、改图、修图、美图 网址： https://photokit.com/?lang=zh remove抠图 简介： 免费图片去除背景 网址： https://remove.bg/zh docsmall 简介： 免费图片动图压缩网站 网址： https://docsmall.com 白描OCR 简介： 免费图片文字提取网站 网址： https://web.baimiaoapp.com img图像压缩 简介： 免费图片压缩网站 网址： https://img.top 图像大小调整 简介： 免费图像大小调整网站 网址： https://imageresizer.com iloveimg 简介： 免费在线图片编辑器 网址： https://iloveimg.com/zh-cn 稿定在线PS 简介： 在线PS 网址： https://ps.gaoding.com 泼辣修图 简介： 在线修图网站 网址： https://editor.polaxiong.com ④在线处理音&#x2F;视频网站 ④在线处理音&#x2F;视频网站 复制链接到浏览器打开使用 音伴分离提取 简介： 从音频中提取人声、伴奏 网址： https://www.lalal.ai 在线视频压缩 简介： 免费在线视频压缩网站 网址： https://apowersoft.cn/compress-video-online 在线录屏 简介： 免费在线录屏网站 网址： https://recordscreen.io 网易见外 简介： 视频翻译转写、字幕翻译、语音翻译等 网址： https://jianwai.youdao.com 在线音频处理 简介： 声音和音乐分离网站 网址： https://vocalremover.org/ch 123apps 简介： 音视频编辑处理网站 网址： https://123apps.com/cn convertio 简介： 在线视频格式转换 网址： https://convertio.co/zh/video-converter ⑤免费图片资源网站 ⑤免费图片资源网站 复制链接到浏览器打开使用 iconfont 简介： 免费下载图标、插画等资源 网址： https://www.iconfont.cn pixabay 简介： 免费高清图片资源网站 网址： https://pixabay.com/zh/ 图鱼 简介： 纹理背景素材资源网站 网址： https://www.hituyu.com unsplash 简介： 免费图片资源网站 网址： https://unsplash.com piqsels 简介： 免费可商用图片资源网站 网址： https://www.piqsels.com/zh 西田图像 简介： 高质量免版权图片素材网站 网址： https://www.sitapix.com pexels 简介： 免费高清图片资源网站 网址： https://www.pexels.com/zh-cn BURST 简介： 免费高清图片资源网站 网址： https://burst.shopify.com hippopx 简介： 免版权图库 网址： https://www.hippopx.com/zh stocksnap 简介： 免费图片资源网站 网址： https://stocksnap.io ⑥免费音&#x2F;视频资源网站 ⑥免费音&#x2F;视频资源网站 复制链接到浏览器打开使用 pexels 简介： 免费视频资源网站 网址： https://pexels.com/zh-cn/videos videvo 简介： 免费视频资源、模板资源网站 网址： https://www.videvo.net mixkit 简介： 免费视频资源网站 网址： https://mixkit.co freesound 简介： 免费可商用音乐资源网站 网址： https://www.freesound.cn 淘声网 简介： 免费声音资源网站 网址： https://www.tosound.com 耳聆网 简介： 免费声音资源网站 网址： https://www.ear0.com pixabay 简介： 免费高清视频素材资源网站 网址： https://pixabay.com/zh/videos 爱给网 简介： 音视频、模板资源网站 网址： https://www.aigei.com mugle 简介： 共享歌曲搜索引擎 网址： https://mugle.io ⑦工具箱类网站 ⑦工具箱类网站 复制链接到浏览器打开使用 工具达人 简介： 工具应用导航类型的网站 网址： https://dartools.com 孟坤工具箱 简介： 工具箱网站 网址： http://tool.mkblog.cn 果汁导航 简介： 高质量应用导航网站 网址： http://guozhivip.com 爱资料工具 简介： 工具箱网站 网址： https://www.toolnb.com toolfk 简介： 工具箱网站 网址： https://www.toolfk.com 即时工具 简介： 工具箱网站 网址： https://www.67tool.com ⑧在线办公辅助类网站 ⑧在线办公辅助类网站 复制链接到浏览器打开使用 谷歌翻译 简介： 在线翻译网站 网址： https://translate.google.cn 在线文本排版 简介： 在线文本处理网站 网址： http://txttool.com 草料二维码 简介： 二维码生成网站 网址： https://cli.im 腾讯问卷调查 简介： 腾讯问卷调查 网址： https://wj.qq.com 腾讯文档 简介： 在线文档多人办公协作 网址： https://docs.qq.com 金山文档 简介： 在线文档多人办公协作 网址： https://www.kdocs.cn 有道云笔记 简介： 在线文档多人办公协作 网址： https://note.youdao.com 语雀 简介： 在线文档多人办公协作 网址： https://www.yuque.com 石墨文档 简介： 在线文档多人办公协作 网址： https://shimo.im 飞书文档 简介： 在线文档多人办公协作 网址： https://docs.feishu.cn 百度翻译 简介： 在线翻译工具 网址： https://fanyi.baidu.com 有道云词典 简介： 在线查词、翻译工具 网址： https://dict.youdao.com 百度脑图 简介： 在线思维导图工具 网址： https://naotu.baidu.com GitMind 简介： 多端思维导图工具 网址： https://gitmind.cn 知犀思维导图 简介： 多端思维导图工具 网址： https://www.zhixi.com ⑨简历&#x2F;PPT模板网站 ⑨简历&#x2F;PPT模板网站 复制链接到浏览器打开使用 officeplus 简介： office官方模板网站 网址： https://www.officeplus.cn hippter 简介： PPT模板站导航网站 网址： http://www.hippter.com ppter 简介： PPT模板网站 网址： https://www.ppter8.com 优品PPT 简介： PPT模板素材网站 网址： https://www.ypppt.com slidesgo 简介： PPT模板网站 网址： https://slidesgo.com 第一PPT 简介： PPT模板素材背景网站 网址： https://www.1ppt.com 极简简历 简介： 在线简历制作网站 网址： https://polebrief.com ⑩设计&#x2F;剪辑模板网站 ⑩设计&#x2F;剪辑模板网站 复制链接到浏览器打开使用 newcger(AE) 简介： AE模板素材网站 网址： https://www.newcger.com 捡屁笑 简介： PR&#x2F;AE模板、插件资源网站 网址： https://jpsmile.com lookae 简介： PR&#x2F;AE模板、插件资源网站 网址： https://www.lookae.com 365PSD 简介： 免费PSD模板资源网站 网址： https://cn.365psd.com/free-psd Oursketch 简介： sketch素材模板插件网站 网址： https://oursketch.com 可画 简介： 模板丰富的在线设计平台 网址： https://www.canva.cn 开源icon 简介： 开源的UI图标 网址： https://css.gg 爱给网 简介： 平面&#x2F;视频模板插件素材网站 网址： https://aigei.com/design 码力全开 简介： 产品&#x2F;设计师&#x2F;独立开发者的资源库 网址： https://design.maliquankai.com ⑪在线学习类网站 ⑪在线学习类网站 复制链接到浏览器打开使用 doyoudo 简介： 以设计、剪辑为主的课程网站 网址： https://doyoudo.com 大学资源网 简介： 覆盖类目广的免费课程网站 网址： http://www.dxzy163.com 中国大学MOOC 简介： 免费学习知名高校课程的网站 网址： https://www.icourse163.org 学堂在线 简介： 拥有多个知名高校的优质课程 网址： https://www.xuetangx.com Word联盟 简介： 办公类软件学习教程 网址： http://www.wordlm.com 优优网 简介： 以设计课程为主的学习网站 网址： https://uiiiuiii.com 手工客 简介： 学习手工的网站 网址： https://kiinii.com MOOC中国 简介： 分享优质慕课的网站 网址： https://www.cmooc.com 华文慕课 简介： 中文为主的慕课平台 网址： http://chinesemooc.org ⑫文库文献资源网站 ⑫文库文献资源网站 复制链接到浏览器打开使用 百度学术 简介： 论文查重、学术分析、文献搜索等 网址： https://xueshu.baidu.com 库问搜索 简介： 免费下载文献资源 网址： http://www.koovin.com OALib 简介： 免费下载学术文章 网址： https://www.oalib.com 谷粉学术 简介： 文献搜索、下载的网站 网址： https://gfsoso.99lb.net wikihow 简介： 科普类网站 网址： https://zh.wikihow.com 谷歌学术 简介： 谷歌学术搜索引擎 网址： https://ac.scmor.com 科塔学术 简介： 学术资源很全面的导航平台 网址： https://site.sciping.com 考试酷 简介： 免费的在线考试系统 网址： https://www.examcoo.com iData 简介： 知识搜索网站 网址： https://www.cn-ki.net ⑬网盘工具类网站 ⑬网盘工具类网站 复制链接到浏览器打开使用 百度网盘 网址： https://pan.baidu.com 阿里云盘 网址： https://www.aliyundrive.com 文叔叔 简介： 不限速极速快传文件 网址： https://www.wenshushu.cn 123云盘 简介： 分享后可免登录一键下载 网址： https://www.123pan.com 奶牛快传 简介： 大文件传输工具 网址： https://cowtransfer.com 蓝奏云 简介： 下载无限制无验证的小文件传输网站 网址： https://www.lanzou.com airportal 简介： 文件快传网站 网址： https://airportal.cn ⑭电子书籍&#x2F;漫画网站 ⑭电子书籍&#x2F;漫画网站 复制链接到浏览器打开使用 书享家 简介： 电子书导航网站 网址： http://shuxiangjia.cn 阅读链 简介： 电子书下载网站 网址： https://www.yuedu.pro 笔趣阁 简介： 电子书阅读、下载网站 网址： https://www.znlzd.com 听书宝 简介： 有声小说网站 网址： http://m.tingshubao.com 书栈网 简介： 开源书籍和文档分享网站 网址： https://www.bookstack.cn ZLibrary 简介： 搜索、下载书籍、文章 网址： https://zh.book4you.org 搜漫 简介： 漫画搜索网站 网址： https://www.soman.com mangabz 简介： 漫画类网站 网址： http://www.mangabz.com 漫画台 简介： 漫画类网站 网址： https://www.manhuatai.com ⑮免费观影类网站 ⑮免费观影类网站 复制链接到浏览器打开使用 无名小站 简介： 曾经的“片 库” 网址： https://www.btnull.org 7080网 简介： 影视搜索网站 网址： https://7080.wang 茶杯狐 简介： 影视聚合搜索类网站 网址： https://cupfox.app 4K鸭 简介： 画质高清的影视网站 网址： https://yanetflix.com 韩饭网 简介： 看韩剧的网站 网址： https://www.hanfan.cc 人人影视 简介： 分享人人资源的网站 网址： https://yyets.dmesg.app 抓饭体育 简介： 看球赛的网站 网址： https://www.zhuafan.tech 央视片库 简介： 央视电视剧动画片纪录片 网址： https://tv.cctv.com/yxg/index.shtml 纪录片天地 简介： 看纪录片的网站 网址： http://www.jlpcn.net ⑯音乐下载类网站 ⑯音乐下载类网站 复制链接到浏览器打开使用 MyFree MP3 简介： 免费下载无损音乐的网站 网址： http://tools.liumingye.cn/music ⑰动漫类网站 ⑰动漫类网站 复制链接到浏览器打开使用 嗯哩嗯哩 简介： 免费追番的网站 网址： https://enlienli.com zzzfun 简介： 免费追番的网站 网址： http://www.zzzfun.com AGE 简介： 在线看、可下载的动漫网站 网址： https://www.agemys.com 动漫星球 简介： 免费追番的网站 网址： https://www.dmxq.me ⑱游戏类网站 ⑱游戏类网站 复制链接到浏览器打开使用 游民星空 简介： 游戏资讯、游戏下载的网站 网址： https://www.gamersky.com 3DM游戏 简介： 以单机游戏为主的网站 网址： https://www.3dmgame.com taptap 简介： 高品质手游分享网站 网址： https://www.taptap.com wegame 简介： 单机、网游游戏平台 网址： https://www.wegame.com.cn FC&#x2F;街机 简介： FC、街机等游戏网站 网址： https://www.yikm.net epic 简介： epic游戏商城 网址： https://epicgames.com FC游戏 简介： FC游戏在线玩网站 网址： http://lab.mkblog.cn/FCGames ⑲壁纸类网站 ⑲壁纸类网站 复制链接到浏览器打开使用 微软壁纸 简介： 微软官方壁纸库 网址： https://wallpapers.microsoft.design wallhaven 简介： 免费高质量的壁纸网站 网址： https://wallhaven.cc wallpaperup 简介： 免费的壁纸网站 网址： https://www.wallpaperup.com 故宫壁纸 简介： 几百张故宫壁纸免费下载 网址： https://digital.dpm.org.cn/lights/royal.html wallroom 简介： 最高8K壁纸的免费壁纸网站 网址： https://wallroom.io 3G壁纸 简介： 免费的壁纸网站 网址： https://www.3gbizhi.com 极简壁纸 简介： 免费的壁纸网站 网址： https://bz.zzzmh.cn ⑳字体类网站 ⑳字体类网站 复制链接到浏览器打开使用 100font 简介： 免费可商业字体网站 网址： https://www.100font.com 字体天下 简介： 字体下载网站 网址： https://www.fonts.net.cn 英文字体 简介： 以英文字体为主的网站 网址： https://fontsup.com 字体版权查询 简介： 360字体版权查询网站 网址： https://fonts.safe.360.cn 苹果字体下载 简介： 下载Apple平台的字体 网址： https://developer.apple.com/fonts fonts2u 简介： 多种字体下载网站 网址： https://zh.fonts2u.com","tags":["网站","网址"],"categories":["网站"]},{"title":"生活常识","path":"/1319ee66/","content":"6bb6fc88079796a31c62046e79558a2ac68ac66b9d5387a9f74c034869d9cfc8d0e336a5a7339ad443721aa747bd5aeb18beb386fe12b246797acdddf5457860d5a280a3ba7b70b4e300981ea12673d882d83be764ed47c5c14f481f78f9d45a87abce826975df626c7aa72342c8f7529a389b2879064daf2398c6583cced10ca2394c6bb3b5ebdaebf7bd667460208ff38facc3adf34e19142a2757fa3bfb6daab545691bfb32653982c58b258812236519f94eef3d35ba2784e187aef403887a9bd380698ed70dd43298a365162d4c5d192d157063ee7b687bdb431a41443b16b691418bae767657753a49a7f6a60705a7cea85258ad875a583a761fb221e798d01c89f60be408fab7b24fd7d85c7d8b3d9af34bdd9e316e2bd2c3f5cc3e18e735e0dce0f2f2da3900c14ee5be1c41c02ba04200d59dd8c46589f1d746c750ca0779f622c21bc67f8a10208ea6e9dd2d3ebdf57452a46f3f3d6f12780d84fe6080e12f23d916ca129e06f8664bf2c68c1854fec8c044ebe32c8a16a2a1cfe29fff139c07754e56933ab3c08ba86349dc4b246ce6cfb74994e4d88d54c3d1ab6c2addfd64686f6b781fb7d94b900397d3478c81c83e4d102470f4668623e3548a9619ce9ca214129122cc7059a56947f9ee20913c0465dc12371071ca9884f55cf97786c99baadfdbe99b3eee72c01e90447d996079a0d09da2f20260110517376937e38efc83378bd8257e825c00393cbb1c086bfcb9c51927644a087f4f794aa6c295190da9753f1ef06e3f121e1f55d0692f7012d38b3ac13c7f847d811b55053b991520304ce1b21a7761c8b67145591eca904af4aa53105352ceeaa6f8b22976d3b3feb2513be52f830a2c707853a6e408f531e4a7db3ce7bcee8f4902eeb2044a3822f1354b411c6679b6be9cbbf51c07c8b553adb032091349d38bfcecfb1042c4e2e23aa06acd22b6613e6f87354ade0b1b80228afa833d5d642acb7206fd4cf4b3a8570e5aa6387dec6459e31407cd1cb17d6b95fc59371515373d9218d6edfe995bde7de2dec2648d74c7c96258799239fe128c29f090d8bba766da9a2e02b1d64f06023da7805af5647cdabd9015bba471dbc73a39ed29d78c09b21d1a8b0cd48409670785c1f5dc450b17de650334e403838cfd2d2b05edcdaa86bb35ec7ac1ffb0a99bb8ac7d8b59c1bec3816b83c97760b00f40984fa0ebb8901329cceb67537f41ea094440c31869af1af9fad26c3a92b96e63cfdac29d2cbe4e3bf918116d85b2927aa0dfd862c543fe269cb0654759090e31a34b0439bcb82fae6050dc40ab01b07117c21f803045c4b02c456c93cf6ae3c44488902d03a3d147eabca9fe4379b101e7be68aa9e161824e11315218c7ff8be2c2550fc3e36178e2b2972c4f9e463d8844cb5682001bff79dbea6644de99295c8d0df3804f57dca4ce52a7bed21a4150fdf9e14f62ff31d06fe5f19ca58a40488754b700c6b48ada1822cdf2c0701508c3e8f2919590a1dcfb4a1b987ebbf16aa224ac5ff55f518a815eb4574463a54bcd939085ae8f41044e780c020e7866800fda14d75c9708ecd49130e19ec77e8ebd2beb82accb8a1353a8f6743facfab9b68b8fd31ec1d5e16d7499fe06adb3184de2fbaf7e4a3bef0a63c152a1c751d68ca63f0dd0d598ad9a15288c356b13b25df45252d4030f8388baadfa918f298f121654e4b400e5dcdfbe6f6c275a39d50be7d6c071a05a92ffc44916063d4729fd9dee2a32f519522d9e5261ab00da5eace61303e179b263ba6025b9595cc2ec22a237bd15ba11f9aa4d08ab06a99841c8b23553b58779cf52312d6b4d884d12fba539d33af51327ea6e3866620986875d064b6aee5b9e80aab00cf43d3a890cb4762d25800c8aabd4482c368775e634d34e820b8b3b3a671b930d9efefbf2567aacf6a45fc6308e4e1d2c42629ea3721728178db8ce2aac62145a7067fd361c2d9f28f10d4e8285ff5ec0109dcf298771803f66f71a3838f16012e27e4ca56605c6d01a5c35844ba5b452861d1636066c4fbd9411646d04775b785d40b7648d0e8c854fd2685536f029b1d9b9706482bf254e9ef5d015f77e0fc8c0a6c0fa1b09171173c87f2ef5755779d4d3bc40746023c4f1d9b7076722846b5a6b266f082967c0185f397c736e3fd627dea26867123c640c36cf0d36558925e77a166bb01449efdaa2b3ca966f10f8d65b28e3acb4b715e9b90ec6c873e78a127f1a62741e611cc60a3f2affaf090ef80a890cf4553f6afcebccfb93d7c16421ccf231117ef39fd4afce3f3cbc1a0bdfbce0b7281e859ec439e6ae773e4402557190677c5f224702eef46a3ccb27e70749633f6222874320b12d6bd058109f7d3a7a0028caed5ed82ab1955ff055c9dd48ddc362ec0175c01daf4c57af9548e0b3dbf5d76b260723e223133487d4082011a4f9b698beccaec20ddd419d7fb6b80f536066c4d045c0da35eb400f0947665cfb9ef1319c669d385860974a14dabd8baca669790ff1c9512bd7758517c1538bb9006b8a1380162ec941709d8c55f76428ccb090c06d56015d7bfa403573d027f201c8aa4e5be98eb64e095e89656e11ab4db6ab9f66c7137e6e746643a121091bc8471e2c63332f8900d98c78844419b3e497227a9c5450671110a709da444e1888568ce5be97159d296442436b2bd01908242e2caab47d690302577a3f631ac0b2100aaf19395e495079d4817dfe439ec654ed70dcbb6f714d8c7f6e1c259a4786bd33c07246d099f935cc5b6beb7bb58021aa59969da3fb711fecd7fb2d76b5459f6f815df3ef32ec1c25d10f6ed2720da4445e8de9c83bf4bb2b195490b0aa3f35b9171b62491036233d55a332a0dea1a4baaead7ffbee29796628f27ff2f4f2f5aad62f3c91f2c1c4fca782bf8c9a9ee6927e407bd503993938b233ddc817f764466f6d19c4dead050b92f1e5a0210185e44a5adcfed765a7640dca902245aa451dced9854c7bc4884677bde2c2859aa1c1c302a54a8ce09b0901062c5020ce05118834928dbb2db905dc0bdbed6392a4a0d254ab4fe8c2e39ff9901cf23bd442cf544cfac360808e973251b78a981cb7728b084d009a0ed28b81a9ce89cf654c210cd8296c2327eaa2526df73eab380a5e362f3d6ff960fb360dafff0c37a1ebf304b9da4268863d19a52a7a509e15fce95a4b99124f197d2f4ea11c41353f7b94ad08b819a3c357867c24c653f04d1b8dde5b2be426ebda91d53b70e01cb380288251788a77fb5cfae447f25173c5ee198671cfb6822891802ba8d649fbb7f9f1d3a585368afc1abd6a552d6ace45237453966c293041575c8ed1bca5f31d3f2bab3e5705d1738e4880c3bf128e39477be7e9a1662b113851e7a3e88c36ba676aa682218a2d642d29275ce192d1647edb7b4fb4e46103573e4e6414d203db27002f175849d3b769316483d1975542016decce4a2afad6ddf563147f5621e6a8d1f8ee2c602401f89f1ceec1fdf93dfd4433d643d316ddd0958ba1dfd64f70caadf78a20b43df77d07018035a987ffa8952b7d0645489275ad7de624169ffa86aeaa6693cf15fefb47fc10c067b57ce1a1554367693d84f2e191066882250c3c497a8692296c84ea8e8f1572a99d97fb52a1ad9221821ea1f03ca33cf9792827aae0cad4ab3bda7346ea43a70f9bde0e0959f885e6fa9748d85fbe3d2e6a9d0221c1d1b5cdb5dce2a46c8eaf8db321254cd4a079cf7ee49750e451747dd840bbfc74ca850520eac81770922ca076d8a2199acd576b3095eabbfd99d63ee0b41ebfe142ef779c28cc1e162c46296d8c47fa44cc418fe0846e7f3fb818e665ebb2edf1b22d4c1bae044f52764c94973a2ee9daef7b05fa45a6104891b3c181eb1d961985abacbd124987b73d2ac131829b8e2cc9fd095346fda427c4b890463e32dc765166faadd77fa01df9759962aa21c37067c8ed2f6c146c6008bce2d15c068c832bc6693af3cbcf1e61d8b695486e8ce574b312d5a24e4da74dbf2e332a13d48a0dd59ca27244a06d336ab267c97d8d148c86ded4fa552fd74c1d700ac3eec116e8b8510dff1a0e2a7d643bd29997007e7db61d76c271c07b04245067edfff41f0daa77281764ca6c7b29f4da2a59578229cfc92cf85e0b00e899c2962616868c57940275e7aecda56b45adcc6107bfbea3cd633a04cd2591bbb3def51743f976e57089b1f88e1273436fb689ed2e52b76d787a2774b1078210f4f166d18ec9df1af57deed53bdc05c4ed401ad78d75d45dd8c0cfcdc5b47831024d79ff498104803f6b6eb42445192e0ffbf7c355e851ccd5919da7411de93f0772670334d6cf96add544f3e76a7ca7ede4b0dbc726d40d62542b68854571c68e278255290b989a82afa9d7cc4ededf8a61d85e75abccd95c577a163513cd887fa0732453b5db3cd4bcbd4cf6296c4bd9f5f2172feafc82cc8d391999c7227dabc1f77a9c270c84882d67f7968c90bf9d564ec41d1459d2cf4f82afd61390d775ce0d37b342b08f64e7667f278c02c1252e9ed1696a135a0fad667baf0a5149b8bed44229cb89b60bab7f41838111e72c78fa2c798a7c43b411404049564cf3d77ad54ae2065e673582156edc3f80157ed2e1cac35cf1f3732f9bf76a73d220c48e9d8aa60b36d6b4512ad02467dada64df4937901f5657c4d8678009f7d18619f6feea9e942cf5d7e0893a8bfe394727959160aebdbdd314015418892396f4f703a521e45cf6062f7116db17b19717172fa9082c38fb26524101d0f5becc678694acb143de47fdd897c01c72d949434f25e155ba0cdd76c91550468c777000a819a2e226808ca410cf0c4709ff35c8d6da141cb63772e31765c3a8c5c55c54b53747d68187aad1f9d13e406af01e47b37947e55eb0552e9a8069b0f5d31f967814fab8092c35111b66d25f704445cdf29afcb56a84c7c47e47d353133c4672d2befa42de24afad34f999fd218b69d599b84bb3a282fd58f4e56e3914cbdf2da8bff2b1122df1e5337cee827ce87575df8846184136c15098b77a4cae3afc5eb1126a41f3e3d72a230a1a61f9e48f777d739bddf96528065a40a0698c2a700a46fa5a2430d80f1c7fb04920c008f9ca9ae40a99f2022793b8eed4dde61f977fbd80d7b37f9ebeb39dd5c378aa8b1f0abdf1197a0a756e40eb4965a9ef3faea56cf3947e77e744eaeb427fc00a349cbff9319f7a42e75d51752b41e7ba50fdd860ac778f0bd40c5bceaf6c39df075c3232d4e18795e4b15b63dc463229acd6e83755766b1c7f7e2a494d33f35fc713010d0ea132ba29cc07de93d5c9cda3100145ab9bc7cba1e79e2ef7efb8af39dc737120a6e71c9ba27ef6a38f6b38bd7f4a0a4e934dbcfaa5c0c4884cea753bb84c588bdeb58a3c3f559d636fae86937beecc170eb864f8016900481885cc4d6a7ae3bb58cb97ae99dd723e0ad2c56a40b30c26384b23d1cf7d732986dd859f0c89e21d196cda643a58e8e5687e4282c32650dfc4396da84b1ffdba9347a2d32d87f482fa6e04c0f32f50be8c00c9ade4f2759e08b6c315ef170d65261b0cba61c7cfd72158d00c3026c4a39050c815ee35b9399e41b7078d13d12f7ad4382a81ce9824dd8e73dbe71b5b6f814265b88d1e6f9a11ace08fa3f1e278a7581f265017f201fdc5d82d48383ebb1df60529cb3b212e4c8ddbbd1e79563f2edbdcc32aeb06e24b5107b953a8733b8d972cd315c4f283759a930e3f35b103f24e2e797c2326baef0a7040bbfb90192d0e3c0840da30abd188461df576be2c1b363126d4510bd69efcc834f2605cc51a03c8a7c97c3fc44fc04915746ac6427d4bd75bda0cdf187721d4ac92cdca803266520de606e0a8069346556011d0305246b2f42db5dd3f05e4cc2adfc90358ff44f84abd8e880815902d6c8b9143601a982ce66fe96cdbb353ad3d3c52a78fbe11ac0085927de50d0439a3c19d2ee7c7b51908f59154308562e86aabae6d7e52a5e68e528432223007d57379396858f9cd048d108a81d0ab8ad9949476b2e3e9f7143c55a9a896141e28b051af113b1f9c67c3454c94652485ab086afb62113730df1aa127f99edcef79142b55c4e6b271a47f1c5ce9bce6ce1689d34f085d3d6b42aa2ba23ae44efb999833d27ac30da3b531b7d3f1bb342986ae4228bee2c4c49ebe22178e173cdaf3adaac668f6178ede0a51db66ae91afffe347a5e22f3222a9cb6726258c0559328195c52515f48dbf0f42be8a7c4948020281fc71c7ff925a19a8c5775165a9bf28b789b8a21af39473c07ca4a83b814fb5bb59201acee0fe1f62050c34f8042af2462948c346f956deb92c7ddc68cb9e900c876af8af9fcea4278eb5fb75a9f4b30c528c59463e3ad1cc0576755b91864cb4e755eeb5a5fa7d5d7325bd0100f07dadb3bafa587535185785d88099ecd7d2bb8dfab4eb21d0aa4c21ef8a74d69f913af6870139ad59728e617831f4ce2ccf0ac65efa4c162fd0dc112e48ebb64d1febd9d203c33a29a0e5fd9455b8fc179af27d23d7c0bfe3d8f814e3a30bb660f77dbaf3dd5840af653a1b068fe477879f65ae946cc0c0ddff0f39f0e09ca3d693962cf630b23037f0007b041e2227acb0b518116616509b3c1b84d5860cd5d47706c3e4c66e032c802fd670dad3cfe4c02036bbce167421fa832e8daaaaf6a983f6f9ff6b4b0fe46890d2755412ad9c5fc778fe2449a9864fda7046f74e3acdcfa9bd1c3379f5e2a3d110556ccc97e2dcace3142d781fc44973828496bda5fd3dfa7cb5509bfa6a0b7a770230007efa7f0ed6481b8859ed236ce11419385230251fb72af3e56634400d59eae76b0f82041280d02f75b06ea0b37a07cfd78227db0841b04daacb2f433f8ec259eab23e101c4cc7f6f4b22a772c90a7e45acbd06f33458402fe358b38ad4b4faa02215385d139ddd22661fc994d8610c1fdb6bd831fcaa24ad486170c3807ee5c84689373712b797f5b638535fce8acd9da0b31bd324e8916b705e23b8a78b545d8a6bf53b0e3c7f160f0d1b56f6d13bab7a811ca1ee5393a9b6885c210fff83b52077a7c87226271e206c0af519fe5bfb214a8d2c7a98dc11aecff3037d6405af3c43b194b216ef717d85cfc36b447daa2c743f859aeafe697d7013d7a62dca41e191b51a7d4ae4d6670a1f6bf1e0d43a630dd866ec9a63d8f0d2350cad1f823a996fbc4c737f4048d36ab0bad6f01dd9eef588d0c8295685a7155097d97951567b42df9e6539b871267d5649bf23d9d449d28f11d8f8688fc6fa238ca429e91b7e082e1da1a0412c7beaff572aedb178b20b21ea7020b901fc4ea839fded35f7fb62032cb0d5212a97a9900a63e0a3168260bdfdc86cf30196019e3b39deae976a22895b7ec016dec9df1b02071678231f49f4b0dd0107d48f2ebd27e284567a1c390491ab6011319a57c54acc7e0bd30f0d85d6a624907b187be0e6e4868929df6756c0098fb07506cb8844888d6124bfd3bd68fa930e07633c1a56cb90ff1c07f50c5711e735858b3586a5bc6bf994fe2d18e85643cc8a18127e430ceb1bab0550a515d4198e72d247345e98ce1e9cfec39b208c7b8500ec9363419f0e752bad97da709d60cba4bb3b7d02d530c9fbc8c3ee80bfa355e4e113a88db79c58fafb8d609e25016dc215e10e720f2d50569aad7b439d8d212f49eb13d0503409d4e10aada270480eaebb3dace289bfd992a0632bb6dbd45788fec5139d717091e39299d0e2df107d4bda28f35f9e25dca953eca9c6a089a57d1d3b37ee7322a204ccebe2714867463243151eaf0940c5fdbd1a062488c0acde879f8c4c6b566cc5690bfc207f752cbacf68d8d3728c3b5d2601232778567fd37aa08c5e4ab1384f603763c600a9876a2831267437bfc2b225f1d58b5c96a48eadb92e7896987561917c0f7309c50495d06c4ada1943eaf1d52f98eb3a6faec71766ac9218f5c0b9925182858d4df572a8f7f55a337d1d062220d3366d3affff8782723e24c8edbe8e4e7297983e0a5b46c31e1bb4424182d90c98d255fa7f6be3ff40f5e5c07706b5ff53d609d03f5ef096a6072432d85d75087117b7b9f9ce84194e3f10aa0c8f8730de65dbbb698dc2bc2ff46a718fdeb9854c2c116c71a1f51b7535e4ca9a5e7b6c728468507a0e0ef66890dbd52b9200a6a837624f986d8dfd26bedd61f4ef9b0515d1762acb2d8914c59b85aba3a9db00ae19119491be0b45caae02c5e4e2454da4d6768108ab79254f159e5b422a47925e13925049e7c5484e397f46f75364ebebb41a2f6ffb0f55e819f2b5d339d752f94182406a6f4cec561c405c0d4b934453989f14336a47f1947d8bda295acb8f121912b91e5b4da12bccb3202d580a7c282d3758536811bfeda956ebd1d14b88f676e285ea47a748be0dcb326c10fb4690d6ce7635a4af8896e4e98fa187a3c84ce19baad7fa4a64d44acac8d3151e503ec7bcaa35ed860210b1866d979b20f47ad585f6f01293d76ae1ac39704536048ddeede341280ca30f1cefe2bc90281071070eccbfd82e2e4dc9d44477e12ac51d519280063ed94d76c170c2c75394959d80020ce7db0652ff86d547bb91704cc5ccb621e05b2d8fe7b824970909ee64ac3c906b942d723818ad2a7d72d5ba537ae93a26443d7a31b8a44b80b15a799f8ce976a3a601dcffd20757a9f3e0b67722cc9b6698d3d9e63295ab89c38572e8dda08b70a08100e1c1cb5f57c1bb5f0f012773a4caa244e3861f32ace3e380c43e3e16787f65e68cfcec77b8048f22b8b4c4f1e4c9b713c918a21cdd7ba36b12436f9e5aef8a165a9dd7eccd19f36791630d8dfe97db0089e9dcb6e3f1e07f12ef61a75707f21f7ea27556ddfd5b3966591c138233401e4bf582af8439ccd6dca2a7017f24a36eff20f481a4c496ac8acd1f9314a5e92cb2827f8121809ea3a00cae48478505341fb7c93341b425da53261b503e6de3f4ce660f110e139c0c04b80e31cf5e12f4bc95f28f589fcef7dddac91f818f62ea5beb8077011aad040844711317eec6ac7b371aa4dc0c06197f98d52f7754de4ee35a3c6d325583e911af0effdf16ff992f8ea8f3f44d0d3553383218f9fe11596249401a6b095ad1c7ddecc0cccd2569976334d93b4d6ee613b999950196cd0ba91558910cfe71046aeff138e91b89ebd4b6f9f494487eaa7cccede39d3ce17c267a7a34689f95c6b8d40093e1d06d1513350c7d2a83db586a252894acdc925ad6c347b1355903a8b794994e97c5502e1ada937cef3702fac0a130c1dac344a1f8048e10ab5b25df8c4a3c1adf569857f1ba41c87b81236a995eec00a5b21ed9ee7fa1337e5ac2c43228c06c614650b2d7dcb2ef8bda6eb811ad701fb22f105d675569b4940091a16e1195b609ad1e166a4789a27d60ed01922d8e1cc056842f28ccd1d5e58fba08c89fbe3c27e3b3c11d48e90558a23c3c617d4498d2d88978525f6b8d277d58ed6a683603687bcdfd5e6b8003e744c1683839dd73f7f43bc822f1785aa19caa6244181c1114ac1dc9156662059240753c9e559cf5110fb9c5344495dc5482243a5e0fbcf6ddd081d95941af11537e0cd450bbf71973dcf8ce98f30c129889f8b925ec32dbdf4071e01ac11a8f669f7cdd59502cd856a52997e86c2081e6c93d6fa8c4982e37b5f0065ede69e88c73640ce088ca7e81bd586a94b2235306f3506c40844b3dc5da12c140b76951557e53ef94e4162cb8579ce993ae2f60e955fb8eefea8ae12528db340c2fa95059b594cf74102a1ef926030ec662ae8ebec5d204b4a1b2eff76a69d32ffe64a287dd377397d7d4613140c0048358ab992b5e911aea0a2f044f95de356706a7244498d2ccde3a98604619aa6856b7fa693049ea7722e5a878c6f12e6240a722fb1e501ae0838151b916492bcf211c0e1a9ced3dd1eae8d362c0dd37755a8c57eb90b98424144174dcfd134679815321d7db1db26c551026d4fc7dfe75131744a109c6c9f2620cc55126042dff663ed1e9a914a48fa138e36cf273fdb1b181ba254407261a4793a0c0421faf7eb07a052d36dae4a5235cdd1b7f4239bb8439d8189b32c3963311db296ee89b4cc2c27390b46c18a504f3219fb21645e33bb2c568daaafa11edab026ff0f8a80bc8961a1091ec298bed3f25a475d6027e2681a42f7fb0449ebd49787ec5a066d12455c2806c211c9569aa67b85821e553ffa382f5902ef1a0662e7ddf09c2bc2fabcda18d82aa066b42f9d79117f52da523c0b5a7a4b00c89718083ae9ff8f2220a69050182e2b3b21b36370ea93500c8340b83c4af67ca299c30a9b6fe4946280930b87d5155cebbe7f3e2e9bd531931b57412e27fea76012b1b80802087b062c899a9741e4e4bf4ea2b5dc6dd341a968d3db06b24d5df8f59458a36e00cfb28e97916e15b0414cb51dbd47bf6582182d43b51c8085934ca65ffb75d878f86f1388cb47389e6b51a6f48bc9e4b9bf9a9bd1082917510e716c768dda52e9e605f5b3821529df4f4a18ce9a4469d2c75062d26e60cecdda11f103fc169eccfc7df5114f092a6e5dbd492428d59aa005d3c63b3a4b76bf90a917b68d4b116e36d43a03e04a8664a6b9a2b4697be7f497fb7be53e4361dde76fcc1a4db992948952294dd4824ac0707609cc392335a07e200ac69766587235710a17531f46dc3a62c0a204c114542adae11873470309f2d383b325ecc925554f2bcc328b4a10df7b72965b19229099fa398980923191e83a897ae515b296dc3d056b9ea5a57d319db5393500977f3414a8a71961b5e1c7441f4d9ec1c69928d537bbe0586ad5854f081515f691484d5a93cd5181265a5f671caa35614c35ff71ac26f1b899724670a0e2f7fbf5ec607e24848b823f7cd01b7b44480b80c5ea4fdd63a5d04c1ed97ae90caf7b411c9da72bcf047bba0b99d88bec42a8b40eeaf40bb5da8691f58ada8fadf54faf4b1b97c268cad29308b69794018d18592c4d91b736c3c18dbfda88b12c760dfc6ae087be3924ceffc441d84ef041acc13176e9da2bcc46bed50eada52b8f97b46e37d06897985725fbc4f00bbc6d0577093e67ed955d407e1b4ef36b87962b4178e46714f7231e5d4bb7aa219c41a4d2983f9fab81ef478c9ac9b59be4130cd106cb614e4c5fe804490a52732ffca839bbe8c927fb7e505392f1c18ce4e257e3c1256c1edbdb4295ed22b6ae1f3f1d1dcf460f039cb660bd7cfe76abfbe4be21e38a486dcaf2c146635c09cded8c8c4fa259fec8925318803265597896dc4d3562bc99dfc0dc0ba05aaef3626c92b962e1569a846414bc6779ab3e9b7a23a67561b0dd38836dac931f6397cc6e83d1ff9e9498f09b14955be247f65ec05a913ed1b39d09aa8addab407da657a9a0bf067e057e266cefe4a554b037b34721d89134af8fc66706fa18e4ea8daa186d7cfde08bf20cd0f93c041fa561a89daadf7db27f766fd416f15d938975ad0a0be7737606a72d79a22fcc532488428abe1084d29d984dadf4f70fe0000f2e71a75b0d063f08d00ee963a25902e7c0a237c8edf0d8d4d943ee2eb647aa5205c5418ca0431cc849df9d1a3f3f7ee87e2f835a9f41f57c8c510e102ed712cdc08e49d91d816a38bb4cf229d526342797f842f95d033df94d5f8cf9e598ff5b396e42c5cddb0369dc7d83788b4aa957de6d7222a589b2e5f1efd82a7ec838444e66a954f2ce8d19d57ecabff5e17f0328b3d81dd5b1a6354d4ce62ce0f53acabdf934266fe27ffa77743b9523ca1248d32845eef2761d4afa7b4c50993f59b0f5d92b92b3a222d506025b90674ee5cd12a437a650eb9fe2d2cf0547dec7834122e1f4f47a407bb46b694087a35afacb7b049789bc8f5c5cbe70e00cebed0a39ee04b4769d4040c44dc7bd32bb2203e59466e54d041bbbbfaa6f44b346351cc94edd3eab119c19a1d33f359db6d661f8dc428e5ab4152149d74deec22d70c711a7eace91b5ff26bc23d5c8e6e4625bd1700e2d861869ecf8f3717fe6a27eb1afb4227438faf77771c049fd575c2bab0b0ddb50ff6e913410e29d919a329b5ac1cad208e390e691a60eacb675767d2ea9002efacea5696ecd08eb85cad0ea8c2b93a1d42fe1c53944794469c1b3a03d2838bc93ba0fc7c95e1a977563b408188b8fece2fa3cc779e29d7ab890d8e4664677102a04886be62d54c0ae263ed99c984ade8e15f98f0ce9ad2febb099252c3aaecd00459412a303270e118037ccd09f2ae1f3137cb52ecdef1306bc0067e99f6a191c96bd11afdf83477e91e39e859bb6aa2556599e8b68bd505522bacaded273d57f32b33ca6a9c0d1ae3d62518588e4fd2e30e24c6205cda97aaab48b6d7218083d5a13fa7dfa32b76c10919faa4e5f78e81a31fe5c5b2a80bc4360d5a4fce4e73aa3a89ca9a979a5a47c7cb4971c7b9ef9e0598c70b508bff61e8bc304ebd4caecac53603b7e313833113a3cded680880499ef90ae6ff0845d3aa907905e172ff7ea7a9e1ead23987f515f754ddc0fa0b90307365fd385bd745605bc894dc96a56b9bdf210da1390d95c080d1718a0187cf7fdd1c1a3a70f40a92d69d5f34ee679519f33123132174dbc87692841bf95d45d89958226d980d33a107e4c46b2eebf1d2a5ce7c73c4d8a45a1d0e9944e02e9cafa532cd4ba9e602ab43f31dcac432d7cefb4fe933d76b693d974ab1d5de21256104a8b7eb34582fb8f25be71afe604922567e3ab17f4160211fba48f974b7e5a3247b66552de1375426466cbb071aed9ff4382f5ef040b960bb745f46d4bb502d7e8c26b2f638b345fa809ab077bd596877cc52be3240e1196c77c121acd344d747d049d8ebee695d2f664a5bbc5da9848b133ecc749d4b34eb1b0a1b78ab9ae818915b1b99983d83e7e7865ed7976be11dc099174b8b482909ef476eb5c21b616bacd7f9ffe698a8018c78ca13edf122f4e4301de051ede6a9c06feabddd610191e80644617009f5bec7cad4627b64548284dc34c8e06f66d035805842f4432e1d584d50c909e5a102432cc5d60462d8c8a540fbd97f3a4e6fb109bf7bd0fe92d266bed883fe9b0194461501f1620b9b58b11de6db61ad58352ea516e709f23b8b3796683d3d578ae8f41601f7da9fafbbda82743537adb41ff2c66bc992622183c599c25ac5eb5970d937c893ede8fb1360169a1900673b42af0ddebab549758f9970493c877370dfb4d506663b57ed40de5969d9faba5266107180fab250757b42fcd5df3708d0a89f747e4a9913e1933c76ab4f7c484738ba608e2ca2bd6280d82fd36f21277261429de1c8be6c999f9c3d77fe07fe188b78b12fa21cf0689b14ea60de0c47e1e79171abdc37c008c0e00f852d0f00103f1d80408e72542f69745659b401dc1f533576addd9e8af5581d8d2ac2c598838278270f48f9985072bf2bbb048a8d79bef41211062ed0cb912a2e980098a801a71721475c1e0a20012d931064fa18b4cf1589fe40a54619251d4935b3e2ace442cb84967e8f252c988eb2f19649ec01dc3fc727ff1fbe6ee32649aa913e56833d358c7cae637b1b408e2edf3d142866884ac6b676caf872ebec223c251c8d97570c1997df4092da9f92b773ce97a685fd427fa50392c63dda356fa6daddb95a9c94b93e21ab54bef3ada992c8aa89716c08aa23753bb64f8bfeb3f66c1eabca1e4511f8edc2cd7775336d3cddd3ec09ca2fc51a63a60c3d38c4d5926ed17c52164f0220bd9b79eba8a633f955b39fbfe698a4195af742a0e2e4937584e799cdf9e8d62586895e235b30fb30e1788050ff0bab648ec65cc38984e54f4f66aedaacdd4051473bf516e6385c4fd369b2c64d3abd0025b5490845684febf6ea0293c04d2ba73322a0a58547cda19a63cea8fe616fabb4c762c757e6d86190663b5751e09db6b2daf371b09a08859a9106db40d19e6f9c4d5ef460ea35c5ceea54afc1e2da6d22526fe128a10cc0ef180eb466932c1e82ab8a56c3a047fac1219886f9f16454f6a0b8ac7b1e7be96702703d8c88a96e87134940da42eafe455a5c1ef06a1434dc700e38b3609de3aa7a1b433992db5d77b3e1b9027386bcc752fae03a97d815fa3cfd62f4bb73a0866ecb74ab19cc255a30e7fa5156cd94d94ec7ad97033c77540aefbed13b12467988306e457ea6adb3f56af10553346dfea9367f5449451980de5b3e5715cd4bb768c46ca7d8acb67651cef7c49936759a3a3958c52efbd1584c1c9f14a70e3cdd071b50e5f11a9bdeb84faf3e7fb1259d76135237f8e64070e2acfaf23ca9251ecbda1d9e6ef5ce6c0cff98355fb5d403c0c42033e56230faddce01c716d532b3e057e21e190f84796eecad5da5f1c4a8f8f0d2cb9c9fd709a570bb8a38bc8f2cc21ac0d0e8ef0deedad809f2905eca514d03efca7f49402e4d57c75cf8777da979440af1481e95a81a2eb447f41654f242bff66457876a85eb161f93a22edba4a2ce77fde6d0b880706d064e80f4419b65283086a0ef94772a9d3af052a4710f7376596b3eaed2bfd74a648a920997516d4bdda2783994deaa0cfcb8956634ea584602ad35a9b98b0d8283ca102acc7dcc1c368d36d9aaad4dd77265b2c7dc9bdb751c0b1ab6904feacf03b82b7bf9653941bbb91ecffe6cda2478fe9b7bd32bcca1817b815e9f3dd5b3d833819cd1f382283a06123848e6179466d607064304e60797a0453f5d68f7ab80d45eb7e2fda42b26c435d076ddefb0424bafada3f62ef545af223d635b413bfaab0c2a0d7b2023a679cf42694cd981ec89d3ca5aeb5cf0f7a775fb8ddc23d0ad765f3f8f6efa7dbf9f798b02b852fd6bc360fae17de5e179bedee779dcd463c387235a331bfce8a2c19f52b95281b111c57498fc5550aae2c5ce3339f69027f8b0678932f509687b35948a324fe375b4feb8706570224677e0e4a6f34d9cc9e0529039fcd797f06277f2820484e0776a464d6a84c88d163029c1ec0f992b644383c55ecc86f838a657c15d4d1d13cd772634e86fd58dabe11b5d17e0210344cd94343c0c1c88f6508e10e4853cc211fa450cff5873a3de2cdcc668865de7e1f9b788d81247572a5796c8d30b8044e09a1fa3cec9a2a351850c2173cfded2681c74e2e4ccf1cc87565cbba60097690e9679392b04c65147ede8678f92d255ede368ca0010e55032ba68052d949fb320e5dbcdba67d598c9a3a93805cf01d7f23549fa17adbab2c9f6ba5ecafb3472d49ae4561394227415c69370b1906b24cdd96f9d8447f6fc3d62f815479d93a2583f4e55f008eb03842dcf8930cbceb28cd3fbfac538e513d40d6ac528cc61006c65fe7b96af20e9df10450260a951d8204e7a54f2f5d447e05bdee4d1c330f414ad94a91583ba66309df78aa4beaf40205a956d9a31aaf2fe84dd038a5a8aa86568802082d8ac34d23fdda67fd0842a56bdd0f435e9ef4c2a8f3b3d8e8a73de2f9937ec8682cf95aedaa5f20e78f26c0be50534d6f7629f82e3e7fa69a2c24d20ff3d824b071cf8a88190719074d510e83029f403dd649671161bb382daea0f04f5252c1e3030ee233667ae1e057e868db2a447676b238483872a71188251dc7a10fbe534e9a773576957181c0f055d0da1aa910ec1ed18a1e4bca360fb598b908e08d8dde1ac1f1c8b674d228909bdfe9cecf5150821b9ce0c4776e70b3fc0a13d01bb695dc57d4c5db739c2289408e015a840f74f63614b1e93d26791e6329075db7867e87400e61e538462d2105d858abc23bd8e886d77cc2c1b527d948a05cfb11555c180fdb115605cce0f0f78b26b1faf19b72ba274132ccdc74bfb3e07db474111e0345f6bc1d083cf8d9d65f979030704abd76e11f71d2da7c9604155b28e7b7c286885ed08bf4f8bb4d3bf0492fd248af246d2b02f7abdf0426f665fd801ebb88622ad7ed1318f2f074f765f4db08bbce9276aa0339e87766f4748ad98b3e92b610e3f4d50947dca0ee32a75ce28e0eacc206464a17302bda61c0a3d2a82c1fecc564bef984a88847fa82f2098380277251836776e3468b1889dfb3cf8dc4683e4092dd2cfd60ef0def0924b2dde5c7cf302f6c3cec2f934d3d4e99bb0952ca5e8835f80e4d517206b492847f1538fe43bad23031c2724f19139c4e0648c9368cdc3f3bd19c9b791328e06fa48aad6a27966d67646114f7d2421ed12ebf3c751ce9183aa32be4a1727962bb63d65f00a538910360887d16d3868e21ac82a75a4bf91debdaa918003be60baf7f567a2c60df49a277b0eb44b3d5460ce2c64a369287b010777f7b57d0eb7ba2371c1bb4872e95ff31d02e0833779b3a3011ba634f6eedcf0c7bb2a21c7da6f5189901134cbef0fb2ffd032e19cc4c709490fc9cd854dcff4576339148f3bb6d9535810a7fb248531ec50078b0f2d7e6049d477ab12aadca4dcea8f3ff0dc833d6b2d761d75450f43ecd2c90e0d2e887e5c086b7cdf0264d1e93276c0aa82ec5b771d59df97037e99258111880acda15a22e8a3539a9c3495e6627bd82fd18fd341184e219003d71cac6daa85e94ca5c1a01c403f4df54b2474bf748698d038641c49790be819db12b5977e33d998bc6a9b5bc743c4b8d64144f00fe64637ade2d3929f46590ccfef51a38d2ca4bb7a26369c155fc1086ff36611eb775288ecf81eb71306d29e007414547c217c81b88fd3fb30d7d73ead1339d545a52d31e3b9685fc1ac9c0647cf59dcc7d861eeb004de9fc1134343ce3745493e5916f03ed4d26d396f400ea2efbbcd8f59c2f6bad118a2dcb2d59471e389a181b2fc1bc744e279e41b8920b922c8ff418b624ce94e2c5855c006240231486d1d551f72747d73ef7700de7bf182fb5ef97930113c1a0aa4e594db37cbb7c79902ff1107612fd385f11741fe19a1636cd528dc9b1bc4b8f162e1ffc2a5ee679fd3b4b7b3fdb6d9420e5def8471e50c543b228345a5f3a8252955b18b66367e530dcf8264e955060893cf0fa595984539f1edf27957cc8256ba8f869bf75b1fc9a62bf59ed19b790b2a9e25f28c47acfcf81f5ad8cda10ce0de6c4eb821b6a9bce6589e43a1cc3fe934504c01f051b100eb5aa5733134a3c49b118ec2ace5eb8dee1799aa3cbfc8840075208f0f3cd621fca513317ba4c66065b69c1f9dd8a2d6fb96ea2009195496f01a49052b41531318841e80c0bc1141ff8351909e5c2aa67b45e93dd088495ffd1b6c8a6a687ca3165dfea62b1cbc5f481cf79d5d298f13fa9514b75242c1ca6efc3646ce408feb5da5b26727b2ad7eec90216e63ab52cd6692d181e0e36a08416086c4be8fbdaa94b49f5c36da5db990cd9cd6277cbdf410a5b62457861fbcf77855dc6adee1d26d671042350483f3035db9c805c001a7ed6f6cdb7c76c19fe097e154475f4dbd10fb9ce5d68fdeebad49c29d04eb6ccea489bfb6e3843c9a45710b8a2a29bc97ddd3d5f6373761eca0b3333151664f8e08729fabaa02da4b60bac4cee8f4b4b98ed3be3455420ad19188df18f490b5ea53b2d9511d28eefb655cc6386d917b3a1097e0146f2d377271451259e665034f5fc6b8b109dc1ab9356e9e096dc6328a15e7270def97ca34f8a4c6b6b394b9836b521df90402e3526dc2300525088ef4e03416d87f4b2625288ab2f19ce2063f129a667d15af42fb9c5496abcf4acdcc9e1e8052bc24db6d3b5a480cc5dae07710d8f0817d8fec27789a4bc3645e1f5a689a04bdc018a2b8b89a3287260c2822b977f02220ece2e2a5a542132a645604cbc27b1ebb86d58055a0ecd66297933e9906b223e9026e071f13786d62747efd8001ddc3166ca4b418151286d7df4dc9f683f52a714077571af4d195c11751b58c535c7b40a2388ec76a715ef9a6505edeb1e44469500ffc10e8b6541953f51a8868dee403841f13b3d563433f3b2cd8e879cfa9b2c57819dfd23b963b41f48613f5331369e6756be79d9e5c4b9ff2eb00342f058e6b99cea86209332b0d426b3886a84012bb7cad6880ec6cddbb70b06b1d965f587591d5fae1d09b99a79b8683a2abb6e77fb77da00487329905f5dda00ad510d3926c131d0d808718e532205380deabfdaa5836cfa7f8711c52f664064991be5fe77325a3231118e34f591f434f878ea35f5d72ab37fc52191d64c71fb14b9e32b163df6353fdc4d3c833731471a5b8779f3de23b2e18c52bf21b3869b16c15084b615d8c0c2790203e5f804aae218e05fa0126d0fbe0aeebc7830862c6734d61c1c1a81faf05645c2ad905bbe18d34e23244a6a5f4e253e8fbf2ad111044f2e5244dc8d7f8416cf893191e208f471ddf9dd01daf6c94e9da2ad662e6ba78c047dc4f27d83db935512694ae2d616776629502031dd5417953f99a30bf0c73a423b4d2e67760e661626dbcdac20dfb028f1fb9b2c843fb88c00f77899f4836809484c90055aafe4c43abceda13d0b56b8e3a8caeeb138347127ead7cb5ed1480f86fd0326c704573600a3490c33abac1c483387a46d3d4ad809126ef743e39ab79ac923dd2e3e380ba9a7f215cf6d661afb612dde5eb0d5e3b32febd1b16654e123b61291a7568fc05aac6aa97ae789f7994762dd0a0b6c1b262a8e9028ced32180745d849ecc5be34d26327064c0c2716ab4688f286bdaec05c601a77f35b3d4e281f52291eaa17f86f8a32157c13e339449795a8a43e543defa4a708e5e9db5b3bcb98feb682403656e598c42c504b96abb90f62caf46474973dc9f8405eb782982769034f56539793ccaa7b7bd85222335354e512b0b4d9306d0b06 You must enter the password to read.","tags":["生活","常识"],"categories":["生活","常识"]},{"title":"思路","path":"/c50fd7c9/","content":"69f579da7df170188cc4a8d7c35a1740747dcf6366f497d9e1c8a26e734f962540a42ba66f2fb82eb373e66a66aa1dffed3b4d9e296f5cf18686a921763b0045d25285f9be68f735e2797c40c3103ec0def213bf949aaddfc27434ab262a43b61d8a95bccef954bb24da2613d619507d6d9f7275fe735c78a4ea5e941f77518d2b8b04bca1e092b6b20b5dcd0a681128778c908c383e0ddafe73ac14296c46f16491f998b0ebfe932e340e2f0c184e6dce9e280e5aec8320ab24fdddfec03b206c10d3359450a2c9bcb958c11f2db9d8c91cc80e1e165cd7b9b2d1a3968e9de1b2188e7ee82fa0402557b3e19fbf84b66b8b3eeafba3b53168c09b434412e74ae7e7841d91d5608db64105654770c08c16e6cf45d5c5cfea10fb76db3378b30f45200fe1ad028b0b602a44315304ee4dadf3c036193513a55eae90bb2d552abaac7853b6a110ff588f1f82f8072b89566bf61c278bc30bd06fe97a1dbd7196700ee4387d778f6536bcb133013c187c524207478c8af46484b08656f55a6ee4d920728a9537b2f2223e9e835235c6f968dc49f80cebb4f74bee73f9834f8af809ce9425104241221b0a23ca16457704dc62e4c7d2b9683777b24a2e0532b80e1e3b07a73b13846adf4dab71be3cb6761c422c8a3a44dbf3d9e28d164fea7a2c4e4a050eddac4bdf2973b384fb5516b50c8e68b275749edc597a8c01b33f21e921dd796d6363c002f6e0faed2a24e3124a252534a6fc4778f80e239e05cd6c41ab301fec8af9f9a64886c60cd9d47b7f443f0b1d9c8eca640af6728483071086851aa5b42b0e911841f1cf3041f1a49722d42f5ca99e7a2cb610749299737b1e312b77823e7b24c588f57f826b53e571022803e42a1aaa4d75f2d8d39fb169f452c660b1a3b5832be7eac3d88ed4917eba09d7effe4da21f0d496a3aa986b679073b2d5fea7e08e66bfb3cb38a47586a8baf6b1f8fa62c02b06567d2b53d9eef8f552e271605aa66d28b7698c9dfc5237b23815a273898567d1a80b455c4e4055307dbe23ea55723879c85b3512821a8617cbdb177686ef96e6dc6631549bddbd6d4fc6fc8d32dc186fdd9e59a3837121c75c94944e080445a9bc56617f99f4f704be1f43fd571c2e60138ba6538da083709ff35cbc46fe722103fdad2067234d9113876c069cb3f4721187ebaea2a98cf68753d6352572fa85e14e60f340a6200aa89a0f4a1f0c2d8a223a23204ad79c7f63796a52e361646a72b4d94b29be2fc7e8e5c43c4aa4467dd50ec8fe9e36b92a8a3e0a7e1137ff50ba2576b39289a57a8a0f79879043b710ef7116be416889b1ae19c5ca5a34fbefb8550c2146da2c8fbe24c52c0c6e122486011ee96b0f6fff416fd5d820c94d47fd2867fc095c64ed8d5e18140edb6bc7a393f892bd5c32622bc70091093fb9c2e39fed296bde4348151088996ba4115e131146194f65f11d57adb140100b52dbc2af0bed0544f69aad8c988fefd8dd5331a7f046e1777be12e464a6da70534dccb791d6f65ddd27923c231afeca3793cb582afe6768b9b758b42221639d89cb23f669dd7bb789acdca8c2c8aa7103d13cf8ecc0a2e69eea21869945aee40938fc6c3c92b09081c988810b751b92cc16ae8ce57b9e74dfc42e0aa21321ed8b8ac313f83c166af59fe84009776bb1bc446bd52762bc3664faac650cd9141d357eef6e29f21157a18f2c0ca452a74ab30a641ac8221f748c4551c689c8bbeb56ce96f932fd97e35ed8d522926b09d2a5f2a16fa4c5812bdf21bd880328ee812dbb6fc4f36bf2990eee9d0ce1e692adca0536434be1650f8835170de882a90afc43c4ed6a1e2dc83e16b1ba08ae9a91b83ba75fcf80316e38daca043e4676cc3fac936d4ad930960428a1dda911fd332be1e2054a19a2fb42245d92ef9a55a6a7558fc848e1ffef8ac3 You must enter the password to read.","tags":["笔记","视频"],"categories":["笔记"]},{"title":"给你的hexo插入音乐视频","path":"/353df0b0/","content":"起因在hexo上插入音乐一般使用插件hexo-tag-aplayer，插入视频通常使用hexo-tag-dplayer或者直接使用bilibili分享的iframe嵌在文章内即可。但hexo-tag-aplayer和hexo-generator-feed存在冲突，将导致网站的rss摘要出现问题。 我在很早之前就关注了寻我（一个博客聚合的网站），站长给了我非常多的首页推荐，我的网站在那里被很多人看到，很感谢那位不知姓名的站长。 但是最近发现，寻我上我文章的摘要没有了，所有排查了一下rss，发现摘要变成了下面这样： 1&lt;summary type=&quot;html&quot;&gt;&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;&lt;/summary&gt; 分析了几个小时，发现这种现象的原因是hexo-tag-aplayer和hexo-generator-feed这两个插件存在冲突，具体原理我不太清楚，但不使用hexo-tag-aplayer插件或者修改博客根目录下的_config.yml文件均能解决： 12aplayer: asset_inject: false 虽然rss就恢复正常了，但要么不使用aplayer无法给文章插入音乐；或者修改_config.yml，文章中aplayer的引用无效。都不是完美的解决方法。 hexo-tag-mmediahexo-tag-mmedia是一个聚合的媒体插入插件，安装这一个插件，相当于安装了以下的插件： Aplayer：一个用的很多的音乐播放插件 Meting：一个网易云音乐、百度、腾讯、搜狗、虾米的音乐播放插件 Dplayer：一个视频播放插件 Bilibili：一个插入bilibili视频的插件 YouTube（开发中） ArtPlayer（开发中） 安装 删除已安装的几个插件，以防冲突。 123npm uninstall hexo-tag-aplayernpm uninstall hexo-tag-dplayernpm uninstall hexo-tag-bilibili 安装hexo-tag-mmedia 1npm install hexo-tag-mmedia --save 配置如果不需要自定义设置，不需要修改 _config.yml ，直接使用即可： 123456789101112131415161718mmedia: aplayer: cdn: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js style_cdn: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css default: meting: cdn: https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js api: default: dplayer: cdn: https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js style_cdn: https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css hls_cdn: https://cdn.jsdelivr.net/npm/hls.j/dist/hls.min.js dash_cdn: https://cdn.jsdelivr.net/npm/dashjs/dist/dash.all.min.js shaka_dash_cdn: https://cdn.jsdelivr.net/npm/shaka-player/dist/shaka-player.compiled.js flv_cdn: https://cdn.jsdelivr.net/npm/flv.js/dist/flv.min.js webtorrent_cdn: https://cdn.jsdelivr.net/npm/webtorrent/webtorrent.min.js default: default可以设置默认参数： 12345meting: cdn: https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js api: default: order: random 使用注意复制代码的时候，不要把代码块的格式复制进去了，我之前使用typora，复制下面的代码，结果死活不渲染，郁闷了挺久。 Aplayer这是一个播放音乐的插件，个人感觉不是特别好用，因为歌曲模式会自动循环播放，歌单模式，hexo-tag-mmedia支持暂时不完善。 格式1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125; 示例1&#123;% aplayer &quot;大调&quot; &quot;官大为&quot; &quot;https://music.gaficat.com/%E5%A4%A7%E8%B0%83.mp3&quot; %&#125; 字段说明 配置项 默认 说明 title 必须 曲目标题，第一个参数 author 必须 曲目作者，第二个参数 url 必须 音乐文件地址 picture_url none 音乐对应的图片地址 narrow false 袖珍风格，带有此参数表示 true ，不带表示 false autoplay false 自动播放，带有此参数表示 true ，不带表示 false width:xxx 100% 播放器宽度 lrc none 歌词地址 效果 var ap = new APlayer({ element: document.getElementById(\"aplayer-WSWiWJjY\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"大调\", author: \"官大为\", url: \"https://music.gaficat.com/%E5%A4%A7%E8%B0%83.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 其他AplayerList似乎有bug，我暂时没有使用。 MetingJS这是一个插入各家音乐平台音乐的插件，个人觉得非常好用，特别是qq音乐的独家竟然也可以放，太顶了。 格式（下面两个都可以）123&#123;% meting &quot;001Mf4Ic1aNYYK&quot; &quot;tencent&quot; &quot;album&quot; &quot;order:random&quot; &quot;listmaxheight:180px&quot; %&#125;&#123;% meting &quot;auto:https://y.qq.com/n/yqq/song/001Mf4Ic1aNYYK.html&quot; %&#125; 字段说明 字段 默认 描述 id 必须 音乐 id，第一个参数 server 必须 音乐平台，第二个参数，可选： netease , tencent , kugou , xiami , baidu type 必须 音乐类型，第三个参数，可选： song , playlist , album``search , artist auto 无 有 auto 选项时前三个参数不需要填写，否则为必填，如格式中的第二个。 autoplay false 自动播放，带有此参数表示 true ，不带表示 false fixed false 吸底模式，带有此参数表示 true ，不带表示 false mini false 迷你模式，带有此参数表示 true ，不带表示 false listfolded false 默认折叠列表，带有此参数表示 true ，不带表示 false mutex true 互斥，如不需互斥 &quot;mutex:false&quot; theme #2980b9 主题颜色 loop all 循环模式 ，可选值 all , one , none order list 播放顺序，可选值 list , random preload auto 预加载模式 ，可选 none , metadata , auto volume 0.7 默认音量，可选 0-1 lrctype 0 歌词类型 listmaxheight 340px 播放器最大高度 storagename metingjs 示例1&#123;% meting &quot;002nf0kI0YUPR9&quot; &quot;tencent&quot; &quot;song&quot; &quot;loop:none&quot; %&#125; 这里qq音乐举例，最顶的是qq音乐独家的也能播放，id是后面链接中.html前面的一串字符：https://y.qq.com/n/yqq/song/002nf0kI0YUPR9.html 效果 Dplayer这是一个播放视频的插件。 格式12&#123;% dplayer &quot;url:KeyCastOW.mp4&quot; &quot;id:DDEC4F882C0B66FAD&quot; &quot;addition:addition0&quot; &quot;addition:addition1&quot; %&#125;Copy 字段说明 配置项 默认 描述 url 必填 视频地址 pic 封面 thumbnails 缩略图 type auto 视频格式，可选 auto hls dash shakaDash flv webtorrent id 弹幕 id，建议使用视频的 CRC 或 MD5，再或使用 UUID api 弹幕 api token maximum 10000 最大弹幕数 user DIYgod 弹幕发送用户名 bottom 15% 弹幕底端距离 unlimited true addition 额外弹幕，可重叠加多个 suburl 字幕地址 subtype webvtt 字幕类型，可选 webvtt ass subbottom 40px 字幕底端距离 subfontSize 20px 字幕字体大小 subcolor #fff 字幕字体颜色 autoplay false 自动播放，带有此参数表示 true，不带表示 false loop false 循环，带有此参数表示 true，不带表示 false screenshot false 截屏按钮，带有此参数表示 true，不带表示 false，此参数会造成跨域 hotkey true 热键控制 mutex true 互斥 theme #b7daff 主题颜色 lang 语言，不指定会根据浏览器环境自动识别 preload auto 预加载，可选 none metadata auto logo logo 地址 volume 0.7 默认音量 0-1 contextmenu 右键菜单，可叠加 highlight 高光点，可叠加多个，例如 &quot;highlight:&#123;time: 20, text: &#39;这是第 20 秒&#39;&#125;&quot; code 额外代码，不懂不要填，需要写的请参考源码 示例（不知道就不要乱加，直接丢链接进去最好使）1&#123;% dplayer &quot;url:https://pic.gaficat.com/default/UpTown%20Spot.mp4&quot; %&#125; 效果（来一段大狗吧）var dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"video\":{\"url\":\"https://pic.gaficat.com/default/UpTown%20Spot.mp4\"}}); Bilibili可以直接通过bilibili的iframe插入bilibili视频，当然也可以通过这种方式插入bilibili视频。 格式1&#123;% bilibili &quot;aid:43218022&quot; &quot;quality:high&quot; &quot;danmaku:false&quot; &quot;allowfullscreen&quot; %&#125; 字段说明 配置项 默认 描述 bvid none 视频 bv 号，bvid、aid 和 av 必填一项，推荐使用 bvid aid none 视频 av 号 av none 视频链接地址，不要带分 P 信息，与 aid 同时填写会被覆盖，不推荐使用 page 1 分 P，填写 av 时才会生效 quality low 视频质量，可选 high low danmaku false 开启弹幕，带有此参数表示 true，不带表示 false allowfullscreen true 是否允许全屏 width 100% 宽度 max_width 800px 最大宽度 margin auto 位置，css 属性，例： &quot;margin:auto&quot; &quot;margin:0 0 0 auto&quot; 示例（来一段自己弹得）1&#123;% bilibili &quot;bvid:BV11b411S7qB&quot; &quot;quality:high&quot; &quot;danmaku:false&quot; &quot;allowfullscreen&quot; %&#125; 尾巴还在为插入音频、视频烦恼吗？hexo-tag-mmedia真的可以了解一下。 经过我实际测试，hexo-tag-mmedia和hexo-generator-feed并不冲突，当然啦，也许可以通过自行设置feed模板来解决hexo-tag-aplayer和hexo-generator-feed冲突的问题，但，既然有这么好的聚合插件，我为啥还要用别的呢，所有插件装一遍，太麻烦了。 就这样，晚安！ 作者： 加菲猫的创客工坊 来源： 给你的hexo插入音乐视频 - 加菲猫的创客工坊 (gaficat.com) 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。","tags":["视频","hexo","技术","音乐"],"categories":["hexo"]},{"title":"生物常识","path":"/eaeb316e/","content":"6bb6fc88079796a31c62046e79558a2ac68ac66b9d5387a9f74c034869d9cfc8d0e336a5a7339ad443721aa747bd5aeb18beb386fe12b246797acdddf5457860d5a280a3ba7b70b4e300981ea12673d882d83be764ed47c5c14f481f78f9d45a87abce826975df626c7aa72342c8f7529a389b2879064daf2398c6583cced10ca2394c6bb3b5ebdaebf7bd667460208ff38facc3adf34e19142a2757fa3bfb6daab545691bfb32653982c58b258812236519f94eef3d35ba2784e187aef403887a9bd380698ed70dd43298a365162d4c5d192d157063ee7b687bdb431a41443b16b691418bae767657753a49a7f6a60705a7cea85258ad875a583a761fb221e798d01c89f60be408fab7b24fd7d85c7d8b3d9af34bdd9e316e2bd2c3f5cc3e18e735e0dce0f2f2da3900c14ee5be1c41c02ba04200d59dd8c46589f1d746c750ca0779f622c21bc67f8a10208ea6e9dd2d3ebdf57452a46f3f3d6f12780d84fe6080e12f23d916ca129e06f8664bf2c6f925b0b8ff334afce0ecce2a704ea2104207fdd6189f31cbdbdfd5e4cebaaaeb0c8e220d8e2ea4b3a3a299f70e97f2ae75561e26e88c4714da07b2a04e0adf90e6b4c2cf7d57fc753438a139f54238276a19c4459167b00dea58b90f0f64653e3a2ec8434e161f618532643423889643063a3e8209d46c56c066ec7ae9c4ffbe17c6cdebff78edf1090812105c5fc8526eb7e2c9a865ce24e093384067d1c36f5037b6784a776abe5216709542cc5575cb156475368e8a9e0486c4a133c762e6434ffbcf58160d83eda0f49eb863976e54d79cd5d715ba7b67532507e00992a09d04f0141b4f8e034c0c167fb5dbdf8f92f6d28c9e94988267eba29f48c99196a9c1c72d363eb138bc0e00a51afb04703506b00577a808f074a4821d18d0a560b46ea5790f48475b51b4a92f4bc0ee2b4712feffa6a08e6ade1a6c3421100d0cd310a28effe555cf14e73107c2556850521730d1b009b8d9e968f9c64d2b6917485a6856fad71e2c7478aa496c3e29c6905d70670e66ae46791ffe765db7e606235be9f6cd4d2167512843603b678286995258708834c81840ae2e5e5be2d17113da0875b613e5b00c9694cb65bf49687b68454e1369b4bbeebc5943eed591cbd90f5bdb3abffb8343ec08b1ad1cce9cbcaf7fa5cbe7b5b9e35c3f59911a15736c9d6f2dc900085732ba26229312be3baa62cf05f7c8891bcc2d958780a8bf29a5d4b4d7423b9d252c7e8743f153fcedf1be3950421c79efc9a167efe812fefdc9c262f83f76e029231591df6222962c36b0efe82b2bfa7ae774cf3e95c080f8c957bcac6b58d5f7719f23c07f54fd3af6b80118b346d2fb332e5a5067388ca51b2443de66fccf4f128bd40343f27b27b75ba5872e33e223ba16817e387efbf017e126afa5ccddfd89b6a522b58ec97c3a71dcc65047e4564b2579038c330ad8d92106ff3164b273f83b0b3c12cc735efb1c04b2712903f71674bccb64a60058823e8ddb4fcc9c1ddd5b174a95345eaeac6899d309e2a2ea2bb9b4cbd79ea9a1694c00c868be5b411f14e1b62199b77cd679f2d5ffd11e267b581f9ae749062fdbadfc0370592275256a99bdf50af0fc21eab2ab76a7150102ec02f427de1d5e72e26a52eb0a5c3f80d2ac147c0aabed4daf2894f619a40608fa434f393978740ac2b62b8990d98e03c5af987467a8baccca00bf98620ee12428f9df015458cfe659a6a8e91747b89cb8e75ea0ad123811fdc6c119783a42bf7c3c2d75c0c8e531f7fcce236a79070d9950444c781ed70bc786fd8c7ca846fd49dbfbb2fb4a7d57bd0a718390a6caf83fa7abe68dff9583e4bf854afee8dbe63568db0298f88a431fd4e04f03fad29dec0734ee0613613d0aef21d3ab17076fad30d61d8bc3896101af682ad1c76a9a623271836791644dfed2543161da0d1db732dddb6fdde64252d28ad8ff60e6986e92206b41d75b5b5144eabcf33dda4a3d019830254c85138f9e785b155ae3ee07f9c8408c8edce0ecee940eac0615c2f4de69f6123fda712e70b1e80435024efcfa00bdd4fb101a543641f130fe9adbdd04f11322d62c73161cf998a933ea5ccfaa374629dd6a9a5c5225202b63fb95e39c27462b7685ff14b2cf2c3147260bf08e4db83e49cf960411e05fe680dacbde8ac40890c442ed920c2939a1dd97e1bb634595656e0a624d116aa0787c46c7c7071f3d595d0c61a418e3af5b288142505554aa142d55ecab7079f0a291985b95fa97f52c2d090ef2ac08566dad52b16d2a06c8afc9aae1d4868bb927d9a98902d5194c4ae4acd6d1cc298b404c1a55cc4b5ea5b20081d8ad9b8a12f1e44b462e2238a98f86f981ea19acfee7d98287a56884cd439e1352c608392b9f7484c91af7bb27174ccca1198a0b704ceb693565e39f993d8b83015a35f7e71cadbdeba2938d2d876f83478fa878167e86f84fbd6f5736a5555e7fb3508762f013252349a96a5e3d349b88ebba30deba6034b0daa6457baa0d0815bdec07cc0dc7478ea69c270e4d567bef0c36daa6327221db5bc53dec4b2f16e09a6d668ff0fd83f17341ee618c4927820057be099dacdf91bae2d472ae45fd9dbe40e3d125e3fab501ac96b6186529df7626884b55ad12f0d16f574c24860ec25519c941055b95561381ae761fc023925ef9545e1baacf37e52442624d44bd53db347420f59ef159c40146afff363480bc55c48b9b03a27a8a31fd7e965f6a7c5f74635028ea430f5ef364568a5c0644e096fb0d7504058783e932e19f8ea1d837079e57ad39bda2a482508704d4ab80459677dba5a4a0bcbe8d8b896734f6bbb5748e7aa4d4b67fd922778fae872d3b763c7c8bbbf59c0602a728680185fee2c6259a52445ee50f72df17b355372678c022770a8dbf1235a4d9f930a7e8ed7d1986df7228fb90448e00e590a05d85d0de68b21ce23bdc5b2ce24085510e3e3e4085aa20ad67b329ea73ce77b461c97fe95706a831500cb726e98923f6cd5568e1337b1351e3132e287864874c1784edee90099f204f36f74c67d7341a5b37a8d18b1b561295bf451a5f87ba5c9f51a674f670f43972b771e239da31afed9ea6dceed46868622ac54c7004969a3d6dd7f95121c3c6589dd30b9963bc60843f838545ab0ffea7f925381059d73c5389da45086d8e431eb05ef16d9cace820092cae07d1bf7ac0e53a821ca6ffccd8825ccff7a1aa9c68fa7a5bfdb4c82a95e3ece5ac0ceca0c0ba41376c0cf7c8ad79b3eef88ae167ec0a940c31ff692281789fc2fb16e26d10775a14bb71b03c66ad5a66f087175973c60604b928fe26f4d2b1bb5ff268649f5bf5771c66f6d5339adf5586c19700a9f9475ec1a03346ec0c03580f4e1e693ff9c9df2b7ce643233fd5cf1983b3f143b3a8c31ad2622b2445aeb48e4ab797589a216986b809a98912521e1e7316ad1758bb10c1dc04d9f4b51da018a1486df4362a6cfc3cf033d2134a144755ab139e4fab23406b106a24cc8d7fd726580a242bf7cd0e7539409fa925a16cfc1d636342e1539ff725182ab59bdded34d349fdcee0ef84799b9831a215c6b61e160cf3eaad93eafa8a244f7a38a6d87e53fbce06e91435acc89b111ef5b79798af9177f197301a2796972e72d46b542632b4a582c1eb73e12533d88befa730766f6dc5ed59f82a4aefaec1e7732b9e29eb9e9d50a41a1d16904353caec6f8d22e7a45913e514e5d4c355944439f9fed545d48c7792a1d6eaaee8d74f3a7e09b3d1b3cd176bec28494e69fc1e5e8dca03f90e31e7381b106461ad31630dfc1b49b9a090b3e989d202549a4477fc90f74330d3eeba6674ef34c4e6b61179c12f3f2ed4ff60534032a02293ae85db34c8aecd38a37274d9e4403d888a63aebe4ed8e1958e9d3e1bc059348656fcdf4e2be8f3fa957ccd1ff2e9c8cd7a6ac73c0804b487e37dbf28b4465817374153e993f563b6bd48b92a5af98196b91e222098ee0a156df064826f9cdfcdd618bd89543ece8ebdb326dba2b7a1f10a648d10d9e508339c2ca3d0584f24ec0201848cfa2729cca5bfc71e4124af32a75d247b1043aaf4ee4100670710140551503251dc0a3c7eb241a936ef9ed853c817c7bacb578363b226dfa556cc67274fb55861b91d00fd2e9481d73caf840ea8b005f8f36ea720c6e56cb56c1c98be8d4c748a0bfd015228cebc726953c78a3a615d18252009221d452faab469d47f0a05f90a090ff6aa4ae062afe702da87f40d1c0e4fbc40083500c64cc4854235f9da25050eeb93e03ae07fceb95133267148673296c0f5653acf56aa22f619ccd8b3ec6a89bd03561934068fc90c5e259eb93df336bbd7344c40ec681ffff02b79bc615f094f7b3381716ee1184991b95f07d8e20d4ffbdeb6be087185aaf57c304d046f72d1d77a7216cb4d8f24f8a679e42f330107a023b98583ec3c6f8319d6ff26a7e116a29c97609e500595b300506d7daad750346c1a4b0aa7275cafff1b1917279f4d652ee882918023ddaf718ddae200573825f50fac3bdddc596e0e1e27ebe2ca8cd4715155465878b17d1ba87d5443e598f087c1f1b26b3e6c56796051087f7d6efd7a944e96cb49f4dce67b10d26d385eb61da4568116b254ee7cc7595d967b0e6b7436db34f74859a1da3ddc7d568fb1a292f20d9ac222496fc73802747beb063bf186b433a4abfa365337797cb6f2650c27dae79f6bf2b5ec5279657f41b2c4356ecec8aefdbade8c9c27c107728ba8b664831b6cfcc7ae25a7b3fde54a9faf1d62782703ea8937bb3bd13f3ff368c802201ec8f96c36e497984e537daf2e9fde8837aeea84e8adf54ce1c779fc0cea2be0bfd44cb727ac6df0fb7a2eebfc5fdbd7612b5c3db0bd311c4525ed5141cbab02162c846877f897ff79f8747a8eb3bfdd33fc454d6f2b1d0499abb594460f3985a9909817ec1b0a16f784dc82f08b9d879a13b0bd27166055fab43b1e451e4f967cff989ee409ffd37a07c17cea9568ec4b181ec50eb1d78fca97d12cc3e4fa4954a92c38d1176cff32364b56673e403120cd6e9035c2debb4be38a79ff2d8be61336fde36e811f509646e30feba7944bd182ca21f11821933e75a24531cf6988988b9e90a4657b07d3b8e5d268d68575a52c349dbad0ae4c3ff996ab567e19c58120f03b2e204ebcf3a9f6e3104a9ab188df51e4bdbff623f971975b16b7753229599cd2c4c080ffb9ffff4d5f300f2230847299bab9258e465ddc26c3ec923e176f4200f6f4a06695bf55599e1740f232b0b4fdb45eea8e728c4b7670d9af7047ed7d2397a11c56945bdcd97ac284ff571cf7340d47c3feb2f7d918b4ef1f9c0e8253abd76fc4e025d9bcd530fa02af0e16d1307f4648b58d02d1d535d0f309544cb9749ae1c1fbb73a743b16de0b469ccea393c1b209c999be5af9c7b8a3a781f58c3cc610a685ab86193689aed493dd89d30f295b1b12d8352ebd5c355f604b3745f8c3e518d3d0aae3e555fa29edddf20ef32511168ed2324ce5edf10f5d55762b221b19584299c9a8700d5c71610f4d46d5321c8f90ca0ca1f5c51308e01ee3b8d0a0d6b42f08dc5a3116b122aea2f023bceba335377827b83cc87437ed45f4c8698e7f51a4c5a9cd990f84ebf9e187796cc7867be06703d678f5ec3cb814df260a96dbd182ec36fba438cfe3e06de925f9e27ff5123d994ec6ed82d33d3a67f2cdef06d350d8bb6469c756834c951f5fb5cf82aeaa5c3109e2b769b1d3c9fcf2cb0240af819d38b45346d4809908bcf4f53a94c8ab7b87f21faf12609f56847e856c4593ffb6e4cc2289c5fa5a182f33ea5d7cf1eaad7644e64abdbd910754505d354589e3be1e8449bdb44c1aa3dbbb88473f0f932706ba6a4527d493e97e64f7fe7b62b2fe650abc9f954a0c39ec6582742ba240de9724dfe661b67bafa3a352c6cd4b7775ea01d44b14852db7db5cd1b3d317f9f04a634a7bd59d22957f006723af571274a4c71ee95205336510e120088e3de0f55fd5a8161bd89ec806e6f58fa4b1dc2554aa9e547f9eb6c70264e2ca5ee884c0aab848a344244de0f015c386598c6d48bd4dd5ccaffb538de05d6b933258a6c74a571a284c7b3c52bd9a1fefd31c0515f05c1c5f28634655a5d3aa35637dac58756c591129824920fa34cc4041f1a9354123132e99e07df1617fb270d89ab0cd00cb67d9cf4e4c73616642a44bfc4198c17b336bc135690653d1132ab3e8db03152adbf5d668d7fbf4a273a322a105df64e15296221bdd617398f75986539ba8ffe0e9e659273c73c00e81e7cadcde015118b60e2234218d5036e23dd8912321bd73029585aa60304c89d95446bbbd91edb3f9255174f6bbc242cde083d088427747f7f44e7c0a8a35d631738702cc88a60cbd9510f99e4ba61e61b02bf942c8ed428a160fc157d0815a3e84e07ba9d1e4a866c2179e5f4e8070242ac441779d34e66a273abec2c6b8950cf2fb9549356fb1240c4247c0488a56d9573c7a44ee1c36df7c27b93d0625e7bbeba8867832b77d4fbef1a3d38f1171b738ce1fb9f49b09b6e83778e8d409b09b37d807adf56c778b477d71cb216c40e6fa4a266b0ef13153db923c94f12583ae6dec3db9f92e7561b66c5097f92daed847caba15980ced3cbb407df2d3f25160ce105af6025439c900f861fe31d5bca616073848188aef45149d7848adb15fbf03e880be4c894a1264e64d57a53080ccf6d6ac0d461e5d9ca1c5d9ac32e5fc50727bfb888313f84192417e85c3dbe572b45c66016885499a6a81ae6ea011755d9568e166f799f6641438a1007258103a17861ae5d77ae169c0fcec41f73236da7239b9d57f01aa894b74e069ee9c5d22eb31e19629081e29ce659fb8da4d089cec240cbca77c60d9d2c6b5d4236c773fa90d7c7d5f7f34a213e8581b01def3490145730db170beed086df04929721fdc35225e5737b3c936cd50709767f243227925d5ff0049199058f180e755209f4d63528ea0b304d5a2cf7a7a9d1f2c1ca9e1696c7912e128af83da987be8c04add54ec207b7338f94c3ce4b0ad3d31c3e71f6cec2440453ae909d46f1b413d8eb9aaae5012f388ebdd2a348496fef86d330ecd71ded68d897012d3ba55f142a0766c399e64516ba14fbc61573e12c9a43bcc4e8436dc2416250ec90cd4a376284bbec4ee56487420dd0cd0f9bab095a181da3707c4ff66ab2a05977ee3b163eec251d22a77e812a14c3c6263ae50b11eaaeed2cff7a8724d3caa3889a071abba07521e807edc0e1ecc391630ef805a66a60da46cfd84fff37a4617232b274f261d26df6eebbbdfb58b747e02672867f07ba80816318b9c4c4d973ebe8f7cf49ef75c6fbba5a5dd36a9b30ba7855b5a958e95110e28be79e3bf065c11668c3ab0c0fec232edd0e2f29b1a4b02c8757aad617095eaa7520d40dd5f43cfa53d18acd19c25f575b8bee9eda99dd0d442b71662c5401c44566e6c409e5cc674a2369b82c9f4b2dd5b5adb9512efd1b3760caec6f27124cd9e3dd2441307d9bf3634500d5e1f070e6a399e99dde5cf796fdd574f9c1a645f1a2e25bc3ba89828fb82e9a5c2a45175389a7c06585c3e82930398860772d6cf95948357424f96fa87d55c10d75c2820564d8b5df866ddad4758566d2ee5350aa4c94ebe2cbdcd1d420d5e4bc359a0a454ebffccc366256618cff12c330de5607ceb65045c768d4a1d6ffc20acd20dab9fe8e831244318c0a4b6a3037ac3b58424946978619f5dbb63742479ecf757b6d867271a9d5892abda1d5426cadcff6b15483d313eeaa532f5803008d42ce83c3704db081589cb033922ac39c47f8a5c82ed25d881e330004dacc2ef1eefc437b6db62b0615ed31d245700bc528cf4ec95c734086e7d35ca95f5ba106211f4318e02ea8d1c41c7e085f8ab3dbaeea4be837392a9a1d05f0a1eb98ead9183641e7b50140715e105bfc929ae15056ec94eb2aba297ed9220201cbef47d23df79716bb7e67dee6df965c80144cbe17f23293ffaa8c06f275841210f527fcd4c8a633f9f12c380d831cbf3e9d31649c7548ad1c2b400cbffdac36434bd1352c81554c18e20557de086fe9784637228ea75c2e1b9e53f3c0ccd1555af0bf40ca6a39ce66e411513515cfdd2366b178f4fe6f3a8daf7fde577034aeaaaa044fdc5090e6244ba4511fb81821158e303440406723497a614c2c65686f7a3fbdaee770d71037922b49dbe356f21313ab0446972fc2bc1313809472d5845d902fd435404333c788a3e4fd76eed83c0de51a26bb25b876c60219dae90c0bf013ddd5652bf7dfe9669087d3d6472c4ab2690c415b74de6699b2306280a159b3e6e37ef316187b798192793f6ab638575b4be3c9c4d2fd2a4bf13521827d46c1d51a6f6ee2bbb6a71c822c6b11ef1e55f6f3adfa57f4a350fa9393d5644023bdbcef3117718a280b1ae838e4f20b82fdf20f1214ac34a82f01fe78731e4aa4afa3109c4f4c2649a582f019ba5603964f5857b54b69a015c7c5c7cc4eefb1fb62823a7672d22a69251c52c1944921a44cea1d55e0f4e7dc55142ab5abf13f123376a4d1d2e437574202c08877dfb12b4e4c9761863d30a4b6083de6dc53f7275c6fc9a496c45454e5b17d15c34be3b00cb440f0d60d959c40e2d8df39c79da72531ca3e0846866c480e4ec1fecda8304d702c918dcb2414ec776fedf5d38bdf097b93919f4246e9042105b556aa8a066fdaf579e27313f13cce3a2608e26b9e6501fbd9f3cd8c397a8a82e1b2be8aa70d3c5bb22fb857f22efc721252c2d62e9ef4de65a36d1a4e5d6e12b938119e3052765a9f6d6f62b7b8901b1b86a06fb32b5dab09c4160f5453f561ef0b5a66574cbe808a1f91673ab70361ed3e827ff0d5e4309ddbe5f0e0e3c86d23fbd8af3495bc6d2b8ae79fee58e552bd1004421efe47390a161ddd72d549d26e895736802c58b0a3f46ce9f23d5b58ce7e90ae226214854aed1be6ccc89c656c506ff73531a8b67cf621049a1a39e5cf8e28995fd6d55de66bf7cfdc688ac44018f00e844154aa3b794f21de3f4b31579b5d414d0aba5aca11b5d705d89d0e3270d8d59cd2e994ce964fbb6fc7ece7b000f1f20a7c885fa87e623884a0ec21617dd11649c1dbd760d8737d76591d454eb904c9a2ef11ae301b67476b398671dea9b97721bc26e3286de7d46b88404ddd63165ad6c88650c053119a6fbcaec172f7e8c40e86f883fda795d59c6df8dad22653105b5f0c334b072303705841817de2a2b455c33a1878681047ec0bda1090d6c3f7b0feeba11cc8e13ef4af90a6e1e5ef4846b079652d3912837488e0a8e31a2a7dd624444641326c1ef1561c4d6f5f7f0f98d380b1d3962ea49e58f7308d355a9d979ceb484a1ff32baa3ebd71b77a87035d1734c0dcece2cb36fdd272ae9df232fac5286aebcb94b00ff6f5b1b292454cf0c3688d02c6d4e091fae6fe3c39c8bbe3766ab8d05901cd9667ac95eb0ab4c93952e4db9c63ab5a9288bcc41620e3d58c4c3e0874f7df12ca0396efb7d6b7b61ca5058d07792d2d40ea6cd737f535419e923d881c6c015471affd772c7bedd505137aa0aeacf379eba57b2b655c8e17185851afd12485a6de14cc5293e82e0e7a9d93983daa106f02026fc16b0cfaebecf77cfd4d6d20442cf4f2cc64b876815745741df8ad5d3c2211709f920ff942a4f5357108dc795a3131ab897636eae833e16e7403b708a624f6d4f5c0a2fc9fb6df0813879d31728425c2b58e229c50615c9840fc7b50d39d7e219e8145840303fb6360e8d76e5400814747e5b2cdbd52060ce0480cbaaee0c70df03abd52c18df4822ff257a30a33a4a3d573bdcb0aed92574e13d154dc5133017cd0adc66b62062a90aea4b88068f811cb8f882fa272c528b79b07161f0ff460f0d0e9bbae2df12eaba17b64715e4cedd6c440dfcaa946ab31f6307e8fea2fdc321932e73edb29d8c6faa22a091a8029167addf0b677b15b44284ccb9b311a4d2579acc45bbc97cfc1c9e95829a85a350a224db22d30eb25752a95982553f97875ebb56518b080211bc9e3b1efd4de4bd7c82f151bbc08d15205b248589148c398986a9b336c3068f796ed89d604e55fd524308a00859bee6fb64024da75fe77a608f95df245bbe52865877585c3038cc11b01489f49b0c1fe13170e198fff742b3488aacb57c6852b9eaf10a7796c90fbdedbd694b977f9a9dfee35242d1a5d9cf074a14ca92544f850e0d7a0e58cf6e03ebbc76a4d049417272163d4826296944534a722cbd38b649afe3371b8df641b8c597ac23d80ef671f4612a842171874bfa903160adbcaaf98b1c8c312065ea71c49b855351bc57665c742da4317cf70ebaece80fbe69a938c0ed24c8c78ad0fb6b97c2aea2102de3be50ca857ab964d15f0c15e19234d3965926792f0d5dcd682bc497aa1596867e98824f56e0b4e1f2fd38a2159f9a6e98d75b4c510dbf15ef82c2a8b66b38f15ae8c96ab5bf6889891e6d5cb9e36113750e619fc14919f1e7ce217f8fc148bd625492ab553a2bbb07a60244444a9e76b0583f10ab73c7fdb474eed480fa1eab548279f496f3c1621956648f64d9a94e39b11cc7659bf03c7eee51110b0acc5f47f362fcea771d5265b2f68300c2382d76ed99c500ae91c1bc059e1e742aced1bdf84992b18bf44eedd449d74fe150f8ce7b2a344af5a503afc66e91fed65f80b8454b75178ccd8ec73b8dfb4ba40e708d3c736c8e127e7b4ce4286578cb32d6255b33e2a3d07db7bc64cb066d019b5629cb3e0b696c3ec90d07744172aeeda7205ae363a684e40f57871b53a6c38986bd274affeea7a40fae99e3e697d14c73656dd5d9362ae8c84e50c6933f02fe8cd2227bf7e865bb06e7d4a02f3158b0e1c29f924ac459bf99a22ac39b5412d6ad17ba4f381b886e229bd2f92d36238a09a7953871a51cc25faf2238170c7cb3f384368e836be16d5d20bfd5687fa60ed0ef1e221717c1ab808a9a3dc141e1ccd6566f42804c0ee69b7f076ea7d13ec07220b0e4ca68adb2505d85dcd00812179e87c30d398c70c75d1d36aaffb75e51e3b259d8b38c348d14eab7a27615c765f3adf3ccf08cf287c956637108cd2d2ec7da3757d70ff8de7ed52daeaef68284426d7397c88b05457ec429d13f7bebbeed6a11cc17ecc716ccbf3f29e841636150150a2c3871734cf3a61c67774eb33b68056b58dce8564ded87f38e5660edda79c40d9eaca06849b4cc07b318da99a5867cff34209818975037f9325f3aa5d09556b0d2b199dcdc142924c1f0c64a9ef9c74fdda26c879de550af49bd6266bb10b3fc09bf22424ac3b454d17109a7621dd87c7e59ba2817de377638c47ba47cd6a4753e3ec141931d472ef0d324ad1a671a1583622dd1cf282368855f4e45dd927f85e811f603467b22ba954c268f6d5a9947aa869ce74a563b44a8305b093e3ddb3078d50989073b0ee06a600c90f414a0f4024bbe383b724dd9208477f6c94646d1783e6435b0f7440ee2ff224d87191158b6aab40c044f126a7687dea92d21475f05a7f04feadbe0e112ea44e3ec1520b1718cfe8300673da12a8c842cbe94fda43241453a593ef76cfb3fe94278f970a7fcb7799814c5f892bcc453e2f8096cf481d496b0b60132ebeab07740f4b1d3167b8b046d174b94b7a7902847daf4554f4da12216340554a7897b33dd6a452abab1e193e78519304a3c27c513dd128810e89cb4a3f171d91433e25169eccdb29c4e4a326c50ead13a8664df1c71186eb2c4abd31b6c3e8436bed6d718c21e2c1870baa82422e4ea666820b6fa7902866452ed6aadde5227c6d7da3160c33fcd810a2578c7071daa9d6e69218f8b0668b2609bb167f9ea4da54a8ab80239cf4958e30259516f1bc07c72dc4bab1a937f9198dad8ee6f6a5fa1a2d928722c8a7785c332281e2b8cdbedc90f7dbdf2ad7a99a11693b99b66477c7667f3faacb048c9a257a7b7213e317f34d5f025a10863b3e1a00a8282cfff963cf5c42e3bf27230207c8a63b3ff5f53bc45e347cdc56901b8d2c50f8035fe710178ebd8eeaabdb33f27ffce06101733fd5e88dfc6ad9ca1d7d8329058ae9f9f86209e5e5acd563899926feb08fef5bae971c6510c57a9a57b9447d968422f67cd98b6f1e87b2f6e846d1bb2e76b976ba64644ec1561304c8b8c018e4845b5a8031a8895fdd4f1ac4fa8348bffc850e347343c58ab9d26fa25cc6971a63ea0bea0b5e361505565f56298c1642637e9039c7507d93379b7aef14caa3971298ed53689ed6d64a68a524d4a0f921c404549fdb380d0534c3969201acc8e15064864bf3a5fd905708276f1a595de44238aa6f8cacd2dfef7ee41eab75a46629bd3724812435b64b495638d9e2df1b25fe2bd5cb1b7097f58d8b778eac9fbe1d4edf054f88a2779a4fdaa09ac1e286488543191bdca6a58d5a004e8f1dc6dd06b52fb53271389c522f428f046d58fcf5681309cc8fb301411ae0e4f49b9b0af6f983b7455b56fbcd7e6e5bef5dd40f758bd876c2bb4f961f36dc3ada0a35d1f7841de1bab370382149360c191f1170594a59f75723a5f18f05af94b285a555bb3c193eca7ec2e88f46e2d23dc253866de3cb7c99522becf9fc07962b4556ffc0d1beff6e80c45892c0730cf34a0faa7058ffe1f882da2f7d8872181addefce1106db498ced7151815b13c02185e6b7ce5d191d7947ff20a8f7f2bbf872b1bb5a2e7b1ea0cb5ddbb7feb18d257cf666551d362bb9a8b58d228546459bef6c08473b69865591bf28a0c49b86a92563f2cd6c7d81116edb809f891cd437913724c2fc987d5db91dfd5d1698737052b55f74145d8ea916771b2f79affb983f6d8e1104785f89d1f09a26fee355813a4f2b0ed005d6cb503864ed00b5f6be3a2d17caf50f2bf57e2a51dada8a89cb0a606db294a9f822cf6aac856c30bd09816e682515d3085e6593e8d1008bc56464b9e56bbbcefade8d0fd09e4782326c9732f67030968b832477c8d86ca6038ee5c36aebc3cd4738048c1a85d6b0f205277173f7f185911cf3247e237067335433342cb103258086b4bfdf5f050257696ad6e53ae20959658d523a1c0575d5a99e2fb1164acda0f210c13a8b1fff5b1d764cfa8395d267c4ce5ef1cc4d166e18c01e334448e1b85ba6f31f8de82ad9e899d13564cff002fe5f797d950cf8e092f5738ed653838a01dba1d4062e27f3b23f81071489c887c976a665eadf249eb1a67a1a1cfae1a6184a3a4c0a565926df54a151e9ce0fef4f9df19d07d560288ca5086d97149f32275b5334dea6205e8b63501c3c1533f819974720f0ee5d1ea6dc27c19f568a63e735e6c666f0c502eaff7ff541893fd24d9c70604be4bcbb470a7d3bd0de38bf2dc05e2b22eb8b07dfba2eda00c7ed705475ddc148278d15d69896e2210a59fb914b919569cb6c84507f791397ad6539dfa1ec7b8d466c247e14ef015f75cc762c14eb7c97289c37c894bdcf3a38b7e9679f2a572125dd8ab6e4da32ae855b65d848222a10a3a21ce3325188ebdbe5202d30421d8fa7e4b9294140abdd6ec819f5675cf37ff8c1f1eb47e1a729b32c9d9e91a84d67665645c1d64073c585944cc763f549ebed53045e08e882200df90b16f2c1f47c8ba49d4639cf250613854a2c439b1edde97f5acff8ee55e8be8ab010143c5fb360422119d446d323b193baad7e854a811028b2ef7ce3ff299e97c07169987fce91b5c4d69c45a01dcf334f43fc8c012e895d8db32f8f2e5e29793fed1b71838bc34463141f3f1f765a1f5e23eebc9a9d89cb474c12527e8c2f9ea6cc92d203f8040ff5fadad196ede3b4146fae716979b40c3b329b777c674d10a6e8430138af323cf33dd0fc8ee5fdf2f78d1fcbe5e6b301de047fc03327849f1e192a4712a2c0602ebde7e5988414825748322e4a354deea72ee56569f21582db88b8188dabaa7895297dfbd2619a1fc93cb0b40ddafefd67ba1099fa49c2b7b1af0bd428ba95c99e7231a6ca909ecb0d8087704557d3840870945a60d97d857e0666d388605fc6bb8e7e10e96c418e85dab3a8822e470bd13ee00831370e2df6ec37e9a1d2d75a5019fed8c282fb38750ec2eb26c50481f1275d5226618aee1863d27918f1b5cc02064043e229c949b100c2a691230966058a4fba23aee129a67485afc0cbd5bb9433b4fee65dcee9aceebd14d1d62021b780b66b0c8ef54aa315e2170c14778b28b7d754bcad0b370dad393782cd8c0b339eae8537869edb1b043d79a549527f91f8f5db387ce77115104d6e460c32d1583b92e1d494864ab304d88e4d82f5acd7c4c61b5342fdf95665e8807a51c15959f4aeeb135397e88c4430f394ce7850d9126545537c6d5ab51d05be4fb6926270be51ef053cd79eb5cf7b94086b9b554b7a385be250d7ca6c84af9dfeb4616b233d38c38e1c433e0e36d5379a8f7f7daad6fe4c12148160c3752271a0a426b0144d3ebcf4675a7b99adcf4975237b9ded8247fce911b9fb94a0f26811647c2e32bcf9d6f1e6fb242999bc54e6e458b741b01f25afbd691b6d07221769b66c01903c956f3b5af00ee8fffe7af62cb5e88bba689351e8a19e3fd4c4d771875c9b43a28a1ed4f0bcbd41d1bee4700ba46a43a476ff0a942aae1ab0dd5c4aab730916115d2169796567baba4f3b396e5e24db79d992c2276d0f6ef61683b3b5fbd4bea392a1e485033e0217955d8f9876fd1c8c013f26b26a21669e4b4760697a52335947a13b48117a53efbfd86a00d3402293e40b89b984261ffc76cafb0b35eb4b13afeffce621b345fd180350bdbc88ee186a5e0ffdd51c4be44d08f1719987e66c8183fcdab641d76760ce4d4476d6443a83c75ee34046138f8835953f689c3961ea8a89e39c8710251a17e92e5f3c4eab24e220f33b3f7332357ba701c4b0f2d857e195097458833ee81cc0710e884940e21cb0c62e2fc4718cc63708b5df3eb33db51816f354e662c87c6767fc81f38e82461c762f86064bde2e59efc6a0639e52e4c2ce396672ff394dba9c7a77fa500275e2a7d31acbcb7e1c0574657602d667f89d14cf1618c7fb0388c22bf87b846eb22c78bb68543a62f37a4137c2520d629a9892c32e919b24ddd3dba1da558555ea445139d8ca0480fe77712db4ce3d9719a9e69a620287f154f0b77727a71a933943ba944c4d0834611d3d5d2b60fae429705c1c5445d656865617f6e5e5aed2ed8a1c6e9363e5ef655e91d8f4ea31b47dcf82f425f4362dbca7a6c09271456b53d72809c91cb8ee592ad19b995e2a6d25a0269907cdc2adea5754bceb717d9142c2384e7c1ad3f9b68393593ca456ec8564139cb8295a1ea38bd462af4c8d9ccfe124b1a236029036779b7efd0387e15b545641e979a85b12f43c81ee2a63278dbf1b1602e8ac358ab183aba24913d935b9a420deee1a3e5ae1cae7943f77477aeaf32b41109aec4656f9539014c52b3b3986110988e2600bf89be35d0b53575c6cfa6fe95d801e1ded8891759db1f531f1110ba743b3998d38806d8e0fe98b24ace0f3a36129f1e8a137c3f5016cb6642be6e70e8aa04ac39743dfafd2e9dddf7d0aeb1b974d9e30b35bd10aa550c3feb5bd73205250acc19fd1f8ba6c7387f76417448701d48c79f77fb8ea43fff4217e7c55edd2bdf2a25cf57ee3b61af93a123d5cefaa5f3ffd6d515ac49c2f83949d881cfdafc9d6548e6d311db44d658216a353641090709df7fec7c0df29c4e1dffd9d0555dd7632480a2a2ee827e026e09115d08e37a7cb3e6fe61865e611257629827335c1eb14143f72a83eb42eaee3387fe0cbb8cb04627a30c44bd9004dfb4726a1f3c09b742deb2836a99a0b37698d9730218b2382705bc7fa57d5cc0d93e63aceb5045ee5b59b6bbc40ce2f754162243fd2f1f161d91a4080899daf240c089cac8b32e36a47d726857407721c43a67e8963fbd33408e77a614e4ef59f3ab1d42d90803740c7136d825fef741e238a6b9fdadd53bd84b8bbdfb9d717da75a37e4d06eb240aa990cd9a7279d2e36ff370335b708215cd6b1a182a129487250363acefa4b5d42e6bd866da2e6704ae55483df375f5c0590a2d2c7f17e005853a4ab20f0a34e2f1e89525e6901ef605901089bc5a1d82db04f55c8e45adbfcdec21c021a43e9f9cf4cf90792c3257feef0fb715d8c37d97f2dce178a1c18a3efd1694eb35a805653b6d7ce55a3c34e19c2b458a04bd9f5c707de4e314ba620cd9cc73a30c186586376992cec0e014c81454d5983452e7a7529d3e66fa2bf18343799e8fa3a692e445a2a142af11b40beea1fa27166a7af359dc90e6ae8463d0fe6fcf9311fc8201cc6f3bdd707be07510df84a626626dfb6b2f51d6a1e17c5da45e2ca86a4625fd2ea6a79b33d20d063691f03fd4257fdc449c9fe35657a08f67289e3faef3d63ca7a5fd0f461eae7a9aa7922bea1548b058f7a7db48c68aeef8427b40e089c7401e11f934d733f669f9259cc1a26725691b57dadc8949caaa777eb13b41a7d09674c11ea63c76d4bbc0603719388a8ee36c9a1aac7673ca6e846483aaf6fd0dc6ec07ebb77f35feb6fde3cb1b9008ebd3dc39acbe1e6b582bdaaeda07dcf042ab4ed37f2988e691359a0a0a7d85cee0329730d4586e869f744ac7b3f77da9687acc4833dfa4e7eecc0158f73d8db14dafa9208355fbf99bfd2cb8a2724f73ee544dc399e6d2ae4cb1ae06f4f94cb5f7f64a952d8921f2434b2793fbd8323e6d1479c94af7165b649c4d5784acabbbe663d02cf702cbb40a06629b03aab59f056e73d02433036bafe911acbb9b46a4aafdb076df25134c42e8438f5fab384b93865872ed2a87a6c2898f7c65d6f49d996a83b3a8f5091ffa2643d0c9a2c6479da8f195e357b2def1481ebf45ace84154887021006646127f99b5f63b3a51a6bcd1a4b6cdec76991c6eb0a85d31b7b0fe10d8dd16f3fb15cf7b1004758b1782f048579cfb75e80c95a9ff54bd10367bd9b9d3f7b981ff8e4cf444c7aeac4864312f3411c4f37b0e822054c7ceb062101f8ce0ff4f06cb2d67aa464965947cb044d090e70a65562eaebeb1239940a77aba535f166adeac3e9de85312ba973d33ff376be28d2b648e230362437a712311cb6a9fb4dfa08f936b741c70a20b8d7fc3d2d6cccd1b0ecc54fe6f027c0eadb7d26370d4b13d82caa1d8e8fb8e2393456bdc4e92211b2b658ac08c8e1ffa030c5e1da2df9aa0d148c781b337fb517387392bd46b1c113bbd3296e5f01ad00df3eff0db1ebc53172ce707186f7242afe6e91d6c85fd97186b993034ab4fd7227daee387b6c03738c9e7177ced2ce3479ff803017f2d407d49dad3d653a486aca1d8d7e0b4703d08c3be6dcfb2a95225eaa5b241f061862b7e86e7af8671acdb1824bfeebd574cafa8fc9964c31f83ba34d674115970981c019a4f04d846284269af01d23dd28bfb454cdcd20c2a18b4cf7e834116eba8003ad4985479582004d4e82b0ec3618ffd373ccdcc95db54622f1f933092fc8d7886d0f88a9d2b9e60a6b1c5ff24fdd2f63dfcf5d5e69870fb45d71a6c09257dac9e0240aea558501236e454f4480a83547150ac10d6fc065ccefe44ff292449f8e1ed677a19281c2481d807f6fd5e0a941edb2afe23f1e7a4369b7ed23d626cf1ffc53ed51f6978ed0f5c6576f5eeb7cd810020a7d3f0f9e843ccdc061f01ad0f54825cfcd896e45a6cd5411814ee2eef06b6a802712947ea2346eef7bdb731575b54338ee9983b52b39b24a00f47a228e29d1318b7c5d8d778acd85a47623aa3a63b8328210450ddb5b4b7370e18ab7a333b176c157d82cbfa0d3ac32835bb94b79e82e77ac038ce7daf3e41e17f513b170421eb1e7e0aaece43c0d7373940260e5eec6c9c06d87e68e1db3753db0b59b70ec1c25a63b996ee95e1d7d41cc74d40075bbfa642de02cd05eccc1839f2c571cf52f0b3f5022a317db7874ebe276255e56963c6e2bcabe793e10f41c6508dce5f2753726ef06177fc4453fcd60b1b840006246eda056ed0e71f5989f7aeaa6b498ed13f53cfe62e60533ba1e4213e4af2bb173a10280cd08b2167beaaeb1c4169966981cdf43493fa90c030fb4bf9f9b2396a53397df25e5581d9a38bbc54ed2098f9ac64d9fe56a8a43dacf97ff21d8507a3f5dae4aece720835b48b132c62aa101e736c0da03dc3a4df7b5066cacb39c282b7a90da16021964dc1863b6967720c0d7d49e1b2efca10beeff56c0c397fa3a250a13cb58f07b554d67cec604b430d3c26b6253fd13392188d0ef44f0ccd9e49a91556ed75b1e03a1b4bc5b7188df4c2c6eaedf5fb713f358cf6930970a5dc9855a8a4594d36091d3fd4ff16cdc0ed433dcf2b20e551e24df1eeefa949030dacb9d3e44943dc08f57d0fd04d8440d312763cbbfa5c1ac191cd8b29ba8279d6041b33d3d496984af21a731edbf2630b861b5392c46a2e93c915f3b9ac0c07c0dfdaf2f927b2e6eb498e9296fc15dd9b4ce15f31f53177a2ef7c3d98f4d16773d552a60a77add9b1d72ed774d04159de240b36959adab7800214fc6f90ce79403dcc9fdc2d9fc316ffe8c1194f3cbaaa112bd879a46849ac8bb496d04b763c3a4c2633d99215540ce9f0410792fd0557a9bcb60aa621e1b3ddec32f610ca8bed792e7dcd4c913ef4cb84e2760a7f7a0e2cf6e795a073ba2e3ccc46ec4baa1ad6002bb3bbf04715399f1b8bc855858ad39da8bb60005d0a8f960da721184069c2f9e183596ca568ef63812f532106e00236a4ba6b15ffb6235662137ec2895e6f523fa966ac1c55d8aa8814569e8e98eb09bbce7bf47381b801f1eaebf38eecdcb4d01f1ed21fa10ee05dbf2eb31fa6dd9c978553c04abc1bed3bf711244bb8057492bac2af11a02cd6c44b79c14a2775ac6f83dd42c0f648463db403c6d8ef71072424099c3091eea243c9285fd75d7f271a58c019ae476eb2c30d580ddee9b4d32d59ddb9c79be1f7c783cc5b3518d1115e417fb952a69e1d218a965230620ba6454642f73a0215727bc95fa18a61121e7933a8027f70c37fa358c8e97a0727ad280905109f19552543061f808017c9f17f25bbfd3a0f6b3dd852fbef74700b30914c56063396cf135f63b4100f9f15726a45a97d327d58562098924d927f89af82b690428ce5bef7dc25deb8ab573f0683cee744629e99d1111426224862d31bc9ce9f99eb28a555875ddb028d4d457e7c383f48a54420e77346f122343e60603d8179cf1eeef5f9d6b9984656b8501 You must enter the password to read.","tags":["常识","生物"],"categories":["生物","常识"]},{"title":"货币的相关知识","path":"/6f37942d/","content":"31818a8bfc0d016bee15073f2ba2dcd5ce073ecb049f01e2e9384a6d1c6ffa4fdfa9cf4a73389c9fefb55bf0027b4fc627ee74c16d0d46a4f34ccd1a8aaba7dc859fe9214c057af2bd71c12da1a09dd1a38d5b537916c8ccd3e2d400b81aa7f5bcf3dadcadffa3c1c3da86d22e92bf2e0545139145b2780e0df20e3e1f3c667a47e3c3fbe93629d47329ebe4dcde96f38f97bbbb2c3bbb717e837cefd885f619375d08fae6e5990683930bb05a079c923864cf1575b269745f499db95a9bc2025da0eb074e6847a458228922ade3145818daedf09ac4b3705a9e7cd296cc91d7c5ae8c39f7d91f6ce4bbcf79e4e13eed3e3606b62fc8dddca9552acc54b3833ce039f9c903db368db76a1ba6cc86344b949f958829139a076cc702ec82c7f35861080aaf69b6ce60fa2817978642ad2638a10d7bff298e799a13beb0a8d8cb6368bcbc64de6a4a169098ed5c25f870ec637bf29d037497954c472b00f0afeffe170b82a8fd68c26a0d4152b1cd882b6e7ac0ddddacaf6c9b019003c63e9f0e95e285f37ae70531558f0608484b072d97add6b57ba3fe76b1be2689d511a9b8b31a6f57753f5af14bb5ceb7a9040bfd1f13c2a654de00067a8a3ce20bd6728524354af8a792c7ac54a55558f15354a6f5acd72d0af4f0215d1e295c072bf2b074f7ea4da5c85a9364be3cef146804c55daf71661863e11b5e06103303f07c4c51b63d8abf08129a808f73f003568a527ff8c4bf6545d303dba681dff98141cc4505270c7fcfc34cc00cbd4e0bd6efbfbd81547082663a23070d20fbb9801b8171365d5ea4db619cfbeba9be14cf9759a40f95ec716cf2bb7fa9622515239516ec05d1e05e096e255fb6cfbb244da042802a47a14314ae6334124c1d11c17f707abdf87590b7c2cfe020fb8bfdd0120e0569eb02562908d43b11a8536c26b42986fcd98321a0d8b9935c231ecaf0f09da50c5aef22fa566829c282d636fda850919a8a6521da846ac74bd3111d918fb00c262428558ee7712d74010b4ed3ded374f396d693b88462563c30d77002de47b8bbe928a066a9408d30595dda51bb03504f7bfb8517cfccac23fefb0e8420729b489d9352ad8fa5f3a62721ebfae833d9d33725d1ddec1d9a4196b86e4e5d992ddc852f1c0d2f71298442ff73f713058b6518ce26d82f5e7f6fa8a77bb20bae563b72866b53575916ef99466a50e23b96c035fde73d95287cbfe79c8fb8a17a46c4e00e516092298bd3151509a0f294b1ec6e5e31d8cca9309add2e48ca759e4e7e99e9e176ec41eda6d7b4873edaf0f2ee5d78bc557c60104c934676ac9304496703aadb1147114afdb2722f5278b66bd6ca37f0d5119f42b0393bc5a05749624c7aae5640481fd04561daa5d01b7e5cbababded1c514eee3ef2290b820819501b080a69e338fbd96602cfc69f436005414e67084bf718fb2b291bf7a1b9de379f1112033a8378d396a6b90814b94fe1e8c7d57b075b42c5fdcb41af9b69737b38c832965a9440d039e0da4e1f917388a6b8a6d0ddf7372f8f29c0fe86970fd5ae114bde0d32c80ff5847acc4955ecf3d3b3bfa1861f205144558d32a9049e2aac2e297fb2ab0636fe62820bf584a2f04bae4bd532090fb51d28feced2a2166a3fdef01234472d8f1d5c2c16be7fc3aef80a5f7f18b41b173f39ab6a333d5400c25a48f531bd1edec7615c11f7ff9396cd34d94f1e99301e6f29f658815d71f95416498f268ab84c0527ff2740804947829ecb27fb6239203943cd01cb2793d22b39d741efdb83103883bd9e420a84e8a37752cd40a7b3f2a331508821a12e5dd4d568664b8e78d289c5e20d0fa961742629ff4439112c9d31a6e6bb1595e107bf5e2c6f886433a957973d856d3d933231e4a411ffd7e87987c7f2956c78aad3a6e825774804b6084422b6012d8e8fb6687ae68f9bf90774ef0b6818fc78bf78514246309b3510cefc01919c64ea859cb782db3b1a58a53063629308930d298046197079f1fbed1f54da4f367046becf20c53ba0630249e2f4b34b2a2f4abe42319c031163e6846b1fdcb1a246dc0057ecb4fa15773925442dd76c438047e5c54ef4f8589a81c03c074cd5ebef076720991c9f2a3716f9095eedbe6a30113f3f35dfb2e3e0850a7da80fa2a4be5feff7cae4942eb8c967b566b406fd1ebb3a2b8684b9da34ccad5f3118d8bfe0d4f9b8ef2d8c74b90a67c989cf2ffa40bfd758a3b5a4b5c0d7c5df8825443e16910a0a447d8b8bf00f2d8d4fa55747c631cb3eda8c6aa224d60d9b80939bce8f2b8a1b48f90b73920e31b4db6fbde2cf0051c6e4bcf4db6711de59171513a2edaf86995d5729d33b334b9abaff0eb1b19d7690ca732503277ce14c9ae817e751b57ba7c7dc3ee5d5c19c00b90b20f3f6298d76be44c3ab9480e7bffc2446b94f1726c62ff6a0402bf8046617bf2e1f766765c928c314a59a79d963509795b916c78569235a628826a783ec77ac5ab3606839d95bdfc3c30166fa1e50d8f9b26b841c3175939e871e84c446c69fb7116e43f9ef0c5afbe1d37a21dacc35e59c4f9f586f9bb235de81b45ab2df8958e9f7a1f763b4e67fea4da2278317f2093731de75253765cce7215bf1f83b1a989b381cbd4d1fa3e207f975da19c3484f24fc77b570ae5f70756499a72ea67ca1c85305b065d2f9d39cc98c6b8d1db53053302c66614f86e9ce643d7d151d4381d745b9ebad8ff6462c7f5790594c44a7f7f56a7cfa346e5e17680e611b9e902a80fec51a08ed12a572b173d4f2b00d56cbc88ee90189a9808e34f0b0e228c706848c147ed90c403df147668d5a7fb5edc606acc61f66a712f77a5193f9e50495d00a04191fe1a824485608e025a9724810deec36535d15acb4ef21a43572eb08f1c88eb92f6d3f3f36aa1ee5c739a27475e4e2a83c25e1ddf688cf2683e265e2ea9f3a03f4e93d725fd36d33f6351749aba46be08e24f22f327746774f1f307d954a894172c7e61504733287b20573d6ec0e49694b58e1c4da768ca237409a7d1d3ea21801963df981b437d7d664fe6ff7e6ca7edae6a0b5a70be277b9f7f8648662af5e1eae81450519a952c515171f2cd7922755e08c60eee7cca21d4938f49d7f83c1a46c86e874b570a24920adeda714a17de276a94872efc7b46b0d7f6a7a3f52e0f1b5da70da92efda046e7123a495d0e9e05d855214054d35651e1e24d17c6226285cef9bb5ad75847321476bdedb90487b98849b8b922b3d84b63bf2076411f930d62881aba9dba9bd7b916f818cb07e854d5e18a5e2cea1310c85e5449ba512f1be983aa09f4add82fe324b03ead5e3a18545a27965eaeb8bc324e38532588755233eca8e9568855d382ecc9aeb51e0b4f80865fa3855559aae1fbe7600ef0105fc177cbb9b359029e9d2993cd8c761b1f54b4bee96c434f7ac452dc4a4bb1c6b96c7ca3adf6f1c9724c013d60f865f77ee20984a7acc873b79e276acddd840d18f9e1f9d0b39c0ac533b383277f639f8630dd4c181cb407dad3f251085e7827728479c06fab3d95569fd509c0232655dcfccd6a5ab9763e7f8b7e4b5fa30e75da023acc5f4f01b085c52b7748bbdae1807ce46c24ab95bfcedcc74c2bb54235424ead030ad24f6ac864a5fcfd1105c1dd93a29ff2d81048be0432df4d91084e5bb9d6471b084f96eec3220a7e371c8a76b210ecb16440c73dc5ed2226b7d4700a370dca0523e1329d05e0076f75811edd45e8572aceac2bf9dc9d92bef6bb4b920c52ba4935e6788dcb8d675a02ef52aaf2fafe4dca6711b5a0e480d1ce951f6a6768104c442806e6121e59eed41a3c4e5ca89123d3f8e4b34bb2277794c2470efaeb77d96a9f72c211b2a86b0c7126b92ac5eb7d866744b55221e75080181fea9e6d42410406617f230af7001bce830976c96555d39807f5c2de05d1253f392b81331b9a30575a279bdb2112eb421cb65739965d273722186f1445021cfb6eedfc83745c5032a2857131a0f29ca983b69d46041e4e41f4a8c387eff1ce6a9a4ac05bc686a7a179e81e91b9d491d7629da84369b50c85fe5b83b1cbe0cd83710dd0343511560c06e5390611237ce04229174b11c921ee7743cd601cdbba4d480c4d530d0dda070f14b0caa5d46b7ef68f98fde40c2fe885d168bb7c5f50a5b7bff5a010a01f2dea40d835ed83f67830ee8a5fcd2817368091c5e5fa9298b9d890addf5cb9256194313f4dff631560db0d306775c15ce82e634d129275ed53d8765a79af2f96fcd7ed5a44a640b9dbe71b22f690a98a71dc6f755ac91f179dd9688b8964670d5a4d2283278a3de737b90f44c6835968076fde84cf91105cf6c22c3cddf3cbaf1d1217728361ca2b49c658aa5956e29b1f336b6e4af71c105c59d84d27dbbaa19949861a875419554006729394b00a1bbaf938efbe921144bca5d729cfc63bd798dc4d3fdd0ca00b83e4eb3fab2f57fd0068539dcd84f4b9f914632b3e335aba2542e60797c40493c5e6439bf66792a6754fed5843bf42b245d2d601dac907401a3add66154f1b9937168cd9cc0749b4445622ca2335a5c77ea81270f61edbe6d9014947fe4252611c793fe6834f7ca9c050679e9d995ad19cf96188c94ad62b4d95a473dca56767f195fa2b48e1bdc1a379b4f11919823f0d7feceb4fd76032eae05b7f7f775bbf4d0f077fb70de3b813c5c15774689691175228de7d90f062ac51925c29fe775c67c7968f0dcb9043f8fba94183724088de33bfb5a4288c09b58f264aa00c1be120738de2b6722fc87c03dff37c315a932ae456764f9575aea3aed898d6558b9febce4fd94eb187a3543ee0a4d8bca7439fff87147bf6d2415bce7e3dadd2157866df18695d956f6892c3da1b030242cd20e6f657a4a01f4af980442e410f1ae6b356069957829b69c5dbbcd1b2230bb06e33d46ee9f940c27e92e79667b61783e3d6c86fbfccbb876bf9e19e4054e294a8609715c6b848f3fac05c549d1e1cdab22ca182a79bde155cabe5da02f79213366fde2c1ce18c5755fa98f058d129759f073c1a02227ec321f65b8869e56700935def5789fb2a05ea4926983f9f3606b6878161174854c0d79052471284113501986cfdeb520db90ee651c2949717e69c3d68c1d7b33146df52330c731aa5dfcaed4205d8fe14a473116dd209d2aea82b78c06ada327ad7b7b979446a5419efbd62ec01047c274340d21503376fd3830b98d96e16c2cc3920b440579e538ac3d33718f858a6017a4bd0f3d6a97d710bb3b5b7c43cb6e2ad3c29ffb52c40c67e6217b39b2e92f347229c4d91942653724e915608f6adb9e5391844b0b50a63c70ccaf258faadadbd1c786d1a0932d742acfc30a2c630d5c55fe7a4cacb7b2048648062e121f100988bb6eb7636f65c3c35410697e7b8ae18e1ae3a40962ded9a8bc88fbffccdf5696a689a3acd5f8428cbb601957957915db58f33d14364d43cbe820a16f8e45fe676a78a8a74ca000705fefe902c62679a894bca98ebb431bf3bda32f677e0a0afdeaa5c8be9e580bbab373f142758f5600ba134e8a9447c69e93fc3afcfe56d87f2e9036db10d1c630df3d4aeda20f52c15c9f6bdd2ba3ae2ccb6cb2d472cb85e813180812f886908005dbfb985ccacb513f11f1f81e6145d0cc528bd54a9ac86095327154282fa7e78e862602867bc1e925ca4ff06f715c58e8c0aac45d81901fe9425f370195835462c032a3500d6d3939b1c15d1959e531dbed8f4efaf60c3fc68fc9306bef12df625134d007f821d360f06c9cc39ef97087a237cf146398c61bf29150ee43b1dabd520bb4630bd82fb345027598bcc390522f69fb7492a00da9a07f441f0884baeb697803ed27e71b89912577bc2f323552472df78dfb94f6bf218fc352ef155542dca9905910784471d5b3ad717a1b09ce86967ce7f324a4e23ea8698fa1b53df6313a3ffab10b65e33b168baec9487b5a3eefde84772af593c30ae1238d3ecd120a4ccc421be9bc190e4f87b9bc990484bb9c2292d01e8657b4d8e7e83e8ac808fdd570f48347a74cbdf5e5e9b5eef92ad1fe4c04a870239b73d6263d9f836fd8df2d6ae8e964e58568ff12b130ea3b36df82a52c8c33b7d540bc041f6eb01084c8b211f5a736e067e01f93377eca3c77384bdcf7f99b7b4bfe77707d2cc6968293801a7129fdc74db8ab613d6d48d3fb93e652ad6402b47f602a168cfb862f3c32755c1c9a1602ef86d220ec7c03f14c1137738c843d08eb06d5b0ec0fb730315895426cca49e3527a47a570cd81a5558fe844f84a29d9e3f5ca41ee7489591d2296f09582d35aad5cc954cb734c22f57f3d4a56ec87d8ea3ece53b7846edd8b4c764198a834dee041958ce9a03c087f3258a398fdc14b6fc314aedd7ba3ba111ccf4dff2e322ea515b79b2e05d1c4fa50b8f4c795a55514eb4742c38c0b6bab4e151cee8c3beb5ad22f0a885d81217016e928eb301e053486bd9017e34890980f04e5686100cceb7e1ff025ece17fa710323a080af8370debcc7e69853ad6261b52bc3cc237e54f16764ee6e0632127012dbea205d3233821d43a7187f027fad947b9ff7f179caf2164aa92e051af5741943029f3850d5d5be49da4e1f1490cf2196518493303562fb5524b6541e61292c5ecc2b20108ec47b2c890f241b8cfb2d532a8c9a944e3e9ab3716d51d9b9e4d43639f84a0ae8e6bf186e688e305295b4b91e355fb12a21353432c7e41e0dfb10acec3f770f97f562c47bd8d0176ec72f33c6bb96940b9b614d0ba044b3bfe4990a263fa3258dc68a5114c61fd050bd47156a72bdad6eb9d25786c82dc606f9b3266c46fe564b5a99396c7d0a593248de30d074b4f0b89caac13f3389d18a673d8d79de46390660806a6223c4c6e2808f26c98306566adfbcdd6325a1f0afdb9faa33c55a2685d823b984813bb4bcbd34a2de09a9467024a7489a581e830abf81da6b7252382bbb3c355bd8e4c0310db0bf4df6f7a2eae49c06bcac75e7e01515ecdfeac3c98434e6104bf82e878d1fea64a081916592a8cb0f457ff6d454dd1f45459a1ad219a17d30dbb379ec84f847edf2b62a409ff792573622b519bb100fa2bec3cb0554844919a64e6295eec6dde784575ef7a2198d50821e9a4ad9d3bb2f2b919b8a217eb5ae6dfd1a195e70ca2659a0d1f97996ac705ccbf044fc49df61cc9d3e537bfafe7d28307acb82e932b4849eee62c76f724831bf648c9c72afc2a455bd05fcad52258443c6b35c0bd05e19d60f3ffd0fe767a9f68c18d9f05d5f33000fafce3b16a85949c498397af66f1034734adb438470c986e3435dd8956facf5bff808f3987526b4e6421707d6d6119ffa11c747988e60275f958abade5ea0e5f520e7d0634dea63521d9033460ff3b7c040a7a6d8d8f0dcaf409e62de4c0dc0bc2569f5106452499e457443c59546e9b4b1ab2a73375c7b4de19c85ffb4c81a13c59256971d3ae125e4a204fa4568910fb9351a912f31c942ad9d733fdb21a395a504a1528693069df1bb10b306bcf53f38cbef0d52b42b54d15739f8bdec1257c8748002bbf64dbd4ea44e3d320fdc6e102d3e75cf8eda30daf8da683011f00f0bf8b1935b69ed60b56d565b21cc755a06f41581b83dc9a626ee066d39a8f1eff43efde2180e70e4823142ebb6b3ff2bf657f98a516b1cb3d5d45dd9177e1cd2d4b9e49f9b1831032ce08ecc157a6ecf9986167c9404820acaa493ab15ea7bcc019062988e2e7cf1f8c115e2ced812de1a4d8b525af756667f0297e9a780f743053f3c11c39733e870703a4652959900981583830cee167dc17e4775cbb0e5b663fe113ad7cdbbae4577e32742973a8b14427d19bb4dc68f37f724bc8b95fc4612395d5e8178c16701476e30df702c72424b6e730d20fd3aed6ef6b9eef2b3d2eb9c406f44f2f1b6d4237304ab67b25af4be62d25957f3db9a8369fbda35900ef7e140ca9a64090e042857347ad5134af62e858eba4e9cd64709213c425125948691577b1557e38c22f4c808cb5eb22614cc956561822fbeb9ee3edd3799578261a0e819b50ef7d53e89a8f7d8aed07f15a81edf9f9942b134aac72ea80f354aa2bfadbee59fd3c282360f1efbbeccf94850e6ffa72a4203fe7a4259a2cfff3b10a832a927b81a954ab35af8fa9aed1dd048523bf1738981d41e15fd53d03a9db720c1a323e5a73d87e9fc149e666f000120b3d95a1b47a6db3451ad2262cd9d46ab9b9f3941e3530ae9ee8e44f8133bd4477066bdd47b26de9713560d00a634217247d60ac4dd82258a1853718add0aef4690b9c26d3bb2e496f9867d0603fdf8185a8ed558a22b3ce1e9b7ccf5eb892c6ac5f9ec2e35bde25420bf203463249b4f9e1e36b1953c3606ffcc238aa0a23cb8b1efb8068c2e1ff153db6914eda480c32b49208bd7fcfd4994beadfd59a172f753aafd112b658a6269fb4017aa6ff483d23413d3ce090b5357f3d2a060231031568fa5b1643d229b6b63fd7b809b35499f4be281cb0da843ab64a5e53158be98216abfeefa8f281a81c4dadc756f7d1ebc65fc0627b783da3a50de5e0888aa14729eafc9029501ce637505f4d6d96a6a75c98e5efd310dde6ead761a41d6a7ce204a84d15a87e4aaff41063e95d50e84111cf99b7c60e108b73be5b505ad09f197f07678719f0278cde18dbf065aa94d0ae994f7d96b167fcb5c52197deca9c45c603a3dc60a813061fa25bbadeb3a901ca2f397304098def91b6a299932070cd66908ee31e301261e8237ecb1efeb48fbab6bd974010f2fc6b1fb60bf03171a0208941a24c6fe74e3bef0116b8646fdb8dadc3d2a8cdba496b20c7e24c401a6eceaf6f81bf58943da5ff31ff4170c666484ac93504a3b84ff0a6a283f00369b55ac60197d15ce8be676db1127d0e6ca7b5a12dda3facecacefe651978830db937af14886aa487130fc0b630f0676463f99437a0dabe88befaa3aae64d0d0faaee31b02357a7dabe44b67ac8d75ff93d5c31e3ffe730f6e42f141f54b06c726f226214f48f7755377a1b9d91bc8d9970fe58badd49d94fade164098a0070ad5160c8c33a13538375091cae37fd03b86acccbebaeb1da43dcbc4a182aab9ba07e02a28b59b02422b0486273e5c39314470064dc4ee29a1f3f1e436f36d009e5f9d2a00cbc8b973175de0d85859ad01d282d72ec1886d526937126df8c1461b3e289d9f495063aa612d98e816b407e7455e68d4e753d43691c80ed9b1344499c63bd794b610ab0179af0b4ac86b88236da7e7d1ce346cb463f70a7c58335c060f99a18c125ff4220c041db3c4e2c96b3f9d6280543dd18fe5c7736d0967712a0be4164132929a5a8ceb5a4811c11744b9ad712d229532ead08cde6018ab83c9fa5794abfdc05756f4fb9e4179d73219a6045904a903d0f31758a34a30ef06609ea3be4984921953e0f25b4ff0696e9a874afaf24a51453d0273e0f26b96a74d1c6853779f3ec050049d88b852185a9316f4ef36c9d055e71e877ef4a308793b9863d5d891e7c8afa077ff94ed3ad063365246bf697b4cc361c357565c11bcce5926fc99113ca3fce2b50bdc8331ead9d1720ee41b4ef290ad87138ade96dc54852cd65eeba54618664d2611c7ecc5b012e38d423dd11a90b831c9abf7bc3b3cdc4ed91395668032f5fb27941a32c8213f0159b85bacb10b5dd154e83ab754136dfb645cc2f216a0365f99bc0f1abfbf1420406fcb9d10a04efd7c94c5f257c2f80a415959d137a7f876d133d5891cb55b7fe7546d9da822cb3920d001cc299bb707a4e90a8cb40a132e99e5f64f0b485b044e234a701b118d1ffe0d26af405c6793e4b3e30fa3477caf4f9c7107aa0410c7342471c593e9c32186efe646add8f8915aaec5feb406e27c9c29225c7253572a21a5df3f196268960b00fce1f0beb26a9bb51fceda8acce1d81bbdbd0b182956368f82360434e19de744f290f6795989ee1bb63c9747de36eeb944e387b1acda934f1b88c2844fdeea00d2753b0448c9a82d05be01259dfe88d81d5988d2d8e699c83b8758be9a494dcd512d557051286535ffa3fa3a58af2d414dd8a60b6eb398e32eace8e21df5000f0c54559af5207067fe706940a2aea3f7234833bf09460f090fef2cf3a91246293daecbcab875970c8b2d2c34496a6fad8779982cd5b7c278eb43c3873db565eb50baac851e51705c3656f52db1f0258d04db608682b1273b89b2fb86023d92dbf8671816ceb788844114e80547202746353a47b4b553b7bccdc2461308477e92147c8c1a74aeba31309c01b83b6989d529ecf3c2b36c1673cf44c1f6380b6a81b68214c3a668b085611d0125a99751ca40d77c9539cd435d5a915ee2ec0ba4d6c2b6833ea680a0f358157dbb345d17750bb923909de6faf68ed24613d3b2dd15b8c82ba2e51961ef48010bffa2bae5138ca0b13f6a091f53e41bc2cc4590449a2acd80677271fb34dba9d4ec43054a21b690acc560ba995416e13a21d31d390ebe8ce7d6ad99a910379186d13119fff3edba4fd51e95585e8e61c49ab904c90bd321c4418159454067e005319c92a276a4abfef018637f3e832ba9a45eb18705a44821c84fdc77b76a82564444ea95608c5e2115d7131cb8af404ae5087937b239ebe79f6e5e78c0a4f86917f46c71233c9c90eb7d7015ac889c0977957a577f1f45217516c8171d8887e9fd36066ddcefe25fdf1cfd64543819d1a24d451446926bf664dcc68f80526ec3c512f588096fd3162166c516bb0c4ea6fa37926973cc2e3ed5daaff064cbeb9b46ae713dddac585cefd80125a8f75e04434f27b4ca359392267840dae0f24282dc1576e9583240f045ccdbb7fbf651c8f5eaacaa37a4375af80bc0f4322ce4a9de4bd61ad70b414deb7be7cb9267c03f87cdf061d549d06b7f8ce96c6a99a046f889aee174060b643e41d42aff0c23a6d7c20d67dcaba97e1cbb6ab756f64b4b7d0456712e10c9a7414da810437423e4f05eb797f460d27d9eb665d8ab4c8528798c4e773b5bf87d1776a03e6a4b9ff0eb006bf5af07313b8ac9857c8dce0e04f093747de22101fc46ef73860e7c5723f3286afba0d3f61566aa2a04ec4fd0bf92c00564d559a8dc2efcfa794a55fc462f61fa987d04255e97ab666a12245737ede49a0c8e0ac540b9c85c87a76b73d7c965c889d1cf40f5d14d5dafad848aad1d92a468a26102bb96848fc53c90d43a4c4b616d370708c4c14343bbdb8db4398c3cb9ead822dd29dce2d6092bae87434a4553c0c3ba8a8e4e8b6c006c87dd0ec3b607e28155d33f710e737dfe1b27aa3eaf0f4f6b055fe25e41df22513b4dcaf049e2898bf558aa0a82d93a22beab362c0a4cea76eea7f46b88319da85e9bc69dbd0a154eeac64912a522151632a5e9767eb0c031c2a892e7b7aa7db2f2be03eb05200b04f6a843bd65543a6ee6311be0fe9e101491aacbbaca4b851b5d37d04d353fbbfebef2cffcaa2d92b3a34ca6de06c943be7dc9395fbe36d6b447fe66e1e1379b52e5e51af5c3fd7b4cebb43620ccf896900c6bf7e1f9539d2a762a1dfb670bffac0db12e86e9ce82bad908b97c81cb94f2fe1684cd481a9990730d5b9c5bd534fc80b0b3028df0b98f1b928cf51832f7ff94ebedf584e5b89c537a37a15eec65b9e6b95197b274a7c929f4317e2a29ca6b879d3d7e8b42e9880ccd1da3e7ad2f2f38293513e4e4169640b343a0d73e9055a1cf9b057ab4d476eca1127e3c710c3dc37ad50d7100e660a1203d2278ea2de407a17c04b439365962f0c3ff7fb62a9bb9854880bc4d76b603d721d5e4e5b35a05ce3e08e533e3e4e1279e10afd2f517cc4f8bc15f9f37c658c1eb2f6a91a4e436a81561e2fe48320d45da667507228d9ad27772f6b63f5951248f5f4abee2a5718766521f2352d21512062491f3f458f96f24617c56c91d66001b853f5bb4ebff9f61d581aaae6fbe058ebfbc59c7eb6b58355d63b901b21174db34913d745ebe990d0488d1b0a0b9f0c05dfa3275419c37664a2164c1d66023f0e85162088c37517d6a022f8f2d1f3df9437c17364baabe817b1145f48c20fde975190064e3190bebd59910709bc531396d4eacfa19d1084f91cc2655e8d60e77c46375048de1a1f50f961a94ed72cb7c5f7868872b19c0c807d44bf9739750383e5958115c06a3f6ffc15d2064a7961d705b52e0bed020ca4fde003eb0dcd1d701f74dcb17043bb20f6f23af18a4431714c71d5865fa48d6302d0796696f897615d048aeee7f1d6766e3c0171eb8fbbff9712d06733cb12dcbfbed843fc79a0195fae2f1b399c7dd35a4a75b533600208dee8d8ec73157abe2818db650a5f83aa9e6d9f3c2bf439aa1bc722dc8982df15c3f4e611298e924c35bee8ee5c7fc4552155d1bbc34c17f13be15afe2cda9e6d0585700c133696f4c5708b68a20d5ebef78cc547376be755cca823924da0bcbf7b0ef2b3a3e2e97ac8d93f336e0b289c8db8a93b10582e2ddca4a61a9cfb0f5b8ff10737652d59680342f8ad66a5f425f19e6f9c6652fb55963b64d2f04563d0627557dd53b15418e84dcf5a89629d8c54986a41bbb57527f66f2eb9feb9f28e0de990370e9117cd1f558a0e7928b029aee2148fd4b4a12fe78d68b4a67cae45fd698f6e29335e68b4a36d55985bf151a39ba6660a22995787088abfc8d78ac8d260e2fe50fda6379dfb2d381868152f72b999116a4a8d7e5d4cfba625f7a97eebb37020df8dc43b6835b7bfa2e7d66fd67aec9ae1b469e8b15b9f90ccc1d538c06568ae2950bf97ea2b07f364bb0064ea1a66d46caab3ed6081fd664e71c509b837b859064fd4a1d0c1cf5646022079a52c76369349f7ca367e467cfee8fe3087b72df577ee1297362b8f6740ce2f2b5d5c740bea38899230e912db14a17ea7425ef83233916811b96907eebe87878c095f7ada17ee0e132fbac4e35cd5d5b206625b75d0fd779a82a7b8bb1efff39cd5f34228c51704e4524f4dde0dd93f22b6fcf90fe0d3f4306d836fa7906864c6a1aa9e7ce59bfd3b7d46d298de8202cdac178cbce14cdb31f80c7944e616396383ee04b836f7813e9f4a5d7275b97960fb4c9b80c8dfe22228d1e5877b046db96f57d2ea0788a43430d22d8bc2325c7b80cb3ef63038db3ad1da45019e7278039066fab3ec8ba214e2d89024017d7e4bd00f127c5053ded2a89cf2e5bbb008433977326db90eecaa5747c7cadb6b8f1946502083a562a7129753816f3e2b0d906e3ff987dff69d331f858f6009c603ce7434d657cb39753f8c04d5655f7a0033a3de303dabac98f3abd783781db8837af33a881d0b1a16b3527d7983005f86bab1d72e3a534513992ce61642acfcd24add853e04a84cb9031f58916dc85812d193d9143c6f851ffec1fdcbeaf5fda7c430e40308b1ca9ee34f309f42d9acdc1fe85fa96ec5e9a2c72d116c25f262b1608ffd5451361e7a5bb40e1798d863f9674f9ee30ff4f48cfb09b811971e52967fa90cb0d9a31db3f81e514d03c536b1777ca206267a164e3bc95a314b04287a93931072a1260b361ffa7dfa807b1dd56180e99c42be020ffaead458eec3984d67aa0f60b5716a0575a63df89d863d18eaa39ad0cb7daf1d5b93a493e76ffdaf6759d413439ebba81f729eaafce331fc381d33eafa960e85609e6fa520d22c2b7fb6c2ec6f34f87a8d124ef432ba372182b419e70a5f6de50a051555ec39afad33e944a3a1a0391bdb26f2e55bae67f2afbd157e356786a3c42d7a4c818993883af770421108fccfe5c4f6dbb2ccda592c7e2931aa8f27646c740ff2449a59c6f3c7cd44b0f731060717b778dbc185447020105aa3967d66b6cb87741aae11862ee41c6b0c2daedf18750e0c7fce997c00296c236ae3f44225bf2a2f1429f8a71de575abd95b6699ec1dcf8850fc0b6b0008ae86c032ef8cfa75bc643872010c96bca1b9de935c066d354eca44a81291a9d28ffc783118ede1435ceae8d74b2e0abbc4ad36fd11e859972e296bf232c569cf41e05b922745bdf590feadc60ede2c949b12f You must enter the password to read.","tags":["常识","货币"],"categories":["货币","常识"]},{"title":"CentOS7安装Redis","path":"/d9ac23cc/","content":"0、更新文件1yum update -y 这里会更新好多内容，需要等待一会。 1、下载redishttps://redis.io/ 2、将压缩包放到Linux，我放在了export&#x2F;intstall并解压12cd export/installtar -zxvf redis-6.2.1.tar.gz 3、安装环境c++1234#安装c++yum install gcc-c++ -y#查看版本gcc -v 4、配置基本文件12cd redis-6.2.1make 5、安装服务这是默认安装1make install 这是自定义安装1make install PREFIX=/usr/local/redis//后面的是你想要安装的路径 我是默认安装。 6、启动服务123cd /cd usr/local/bin./redis-server 启动成功如下图。 按ctrl+c即可退出。7、设置后台启动先将配置文件copy到启动项下。 123cd /cd export/install/redis-6.2.1cp redis.conf /usr/local/bin/ 7.1、修改配置文件123cd /cd usr/local/binvim redis.conf 这里是修改运行为后台运行。打开文件后，如果你想查找，直接输入 &#x2F; +你想要查找的字段 比如 &#x2F; daemonized然后回车就可以查找了，按n表示下一个匹配字符： 查询到这个，将显示的no改成yes，然后按esc 输入：wq保存文件。 7.2、启动服务1./redis-server redis.conf 7.3、查看进程是否启动1ps aux|grep redis 8、关闭服务1./redis-cli shutdown 9、简单使用redis开启redis服务：开启redis客户端： 12./redis-server redis.conf./redis-cli 出现下面是开启成功： 测试：出现pong是对的。 退出1quit 10、启动远程连接防火墙放行。12firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reload 修改redis.conf配置文件关闭protected-mode模式，此时外部网络可以直接访问 1234修改redis.conf 文件，protected-mode 要设置成no。//如果需要设置密码requirepass 空格后面跟设置的密码修改redis.conf 文件，将 bind 127.0.0.1 修改成bind * -::* 或者直接将bind这一行注释掉 这是设置密码的格式展示。 记得修改完执行重启一下服务。123redis-cli -h 127.0.0.1 -p 6379 shutdown# 干掉redis服务器（比较暴力，谨慎使用）sudo kill -9 pid 进程号 链接其他ip地址的redis这里的ip是根据你要链接的ip地址进行更换的 1./redis-cli -h 192.168.10.20 -p 6379 如果设置了密码，那么就再输入auth空格+密码 1auth 密码 2、在链接时直接加上你的密码 1./redis-cli -h 你服务器的ip -p 6379 -a 你的密码","tags":["Linux","CentOS","Redis"],"categories":["CSDN"]},{"title":"CentOS7安装nginx的两种方法介绍","path":"/4936baa0/","content":"第一种方式：通过yum安装直接通过 yum install nginx 肯定是不行的,因为yum没有nginx，所以首先把 nginx 的源加入 yum 中。 运行下面的命令: 1.将nginx放到yum repro库中 1[root@localhost ~]# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2.查看nginx信息 1[root@localhost ~]# yum info nginx 3.使用yum安装ngnix 1[root@localhost ~]# yum install nginx 4.启动nginx 1[root@localhost ~]# service nginx start 5.查看nginx版本 1[root@localhost ~]# nginx -v 6.访问nginx，现在你可以通过公网ip (本地可以通过 localhost &#x2F;或 127.0.0.1 ) 查看nginx 服务返回的信息。 1[root@localhost ~]# curl -i localhost 7.nginx配置文件位置在&#x2F;etc&#x2F;nginx&#x2F; 1[root@localhost /]# ll /etc/nginx/ 8.实践： 目的：修改服务名，接着从外部访问这个服务 操作： a.修改nginx配置文件 1[root@localhost nginx]# vim /etc/nginx/conf.d/default.conf 修改server_name部分：server_name yytest.com; b.重载服务 1[root@localhost nginx]# /usr/sbin/nginx -s reload c.从外部访问nginx服务(192.168.10.11) 如在客户机(192.168.10.10)的浏览器访问：http://yytest.com d.你发现访问不了，原因1，你没有在hosts文件做映射；原因2，及时你在hosts文件中了映射，由于nginx服务器的80端口堵塞或防火墙没关 e.解决办法： 步骤一：修改客户机(192.168.10.10)的hosts文件，使用SwitchHosts工具添加 192.168.10.11 yytest.com 步骤二：关闭防火墙，具体下文有说明 9.nginx常用操作 启动: 1$ /usr/sbin/nginx或任意路径下运行service nginx start(centos7是systemctl start nginx.service ) 重启： 1$ /usr/sbin/nginx –s reload 停止： 1$ /usr/sbin/nginx –s stop 测试配置文件是否正常： 1$ /usr/sbin/nginx –t 可能遇到的问题: 具体情况如下 1。本机能ping通虚拟机 2。虚拟机也能ping通本机 3。虚拟机能访问自己的web 4。本机无法访问虚拟己的web 这个问题的原因是服务器的80端口没有打开或防火墙没有关闭解决办法 如果是centos6: 解决方法如下： 1/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT 然后保存： 1/etc/rc.d/init.d/iptables save 重启防火墙 1/etc/init.d/iptables restart CentOS防火墙的关闭，关闭其服务即可： 查看CentOS防火墙信息：&#x2F;etc&#x2F;init.d&#x2F;iptables status 关闭CentOS防火墙服务：&#x2F;etc&#x2F;init.d&#x2F;iptables stop 永久关闭防火墙： chkconfig –level 35 iptables off 如果是centos7 1234567[root@rhel7 ~]# systemctl status firewalld.service[root@rhel7 ~]# systemctl stop firewalld.service[root@rhel7 ~]# systemctl disable firewalld.service[root@rhel7 ~]# systemctl status firewalld.service 扩展知识： 启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service;echo $? 查看已启动的服务列表：systemctl list-unit-files|grep enabled 第二种方式：通过手动下载安装包解压安装1.下载nginx包。 1[root@localhost ~]# wget http://nginx.org/download/nginx-1.10.1.tar.gz 2.复制包到你的安装目录 1[root@localhost ~]# cp nginx-1.10.1.tar.gz /usr/local/ 3.解压 1[root@localhost ~]# tar -zxvf nginx-1.10.1.tar.gz``[root@localhost ~]``# cd nginx-1.10.1 4.启动nginx 1[root@localhost ~]# /usr/local/nginx/sbin/nginx 5.查看版本 1[root@localhost ~]# nginx -v 6.url访问nginx localhost或127.0.0.1","tags":["Linux","CentOS","Nginx"],"categories":["脚本之家"]},{"title":"CentOS8安装MySQL8","path":"/7b1345f/","content":"检查是否已安装（强力卸载）123456for i in $(rpm -qa|grep mysql);do rpm -e $i --nodeps;donerm -rf /var/lib/mysql &amp;&amp; rm -rf /etc/my.cnf &amp;&amp; rm -rf /usr/share/mysql &amp;&amp; rm -rf /var/log/mysql# 备注：可配合以下方式查找whereis mysqlfind / -name mysqlyum remove mysql mysql-server mysql-libs 安装MySQL8.0方式一：使用最新的包管理器安装MySQL 1dnf install @mysql -y 方式二：yum 安装 1yum install mysql-server -y 查看 mysql 是否安装成功12ps -ef | grep mysqlmysqladmin --version 设置MySQL服务为开机启动项安装完成后，运行以下命令设置MySQL服务为开机启动项： 1systemctl enable mysqld 要检查MySQL服务器是否正在运行： 1systemctl status mysqld 启动 mysql 服务1systemctl start mysqld 要检查MySQL服务器是否正在运行： 1systemctl status mysqld 相关安装目录1234# 查看mysql相关命令cd /usr/bin/pwdfind my* 1234# 查看配置文件目录cd /usr/share/mysql/pwdls -lh 1234# 数据库文件存放目录cd /var/lib/mysql/pwdls -lh 12345678910# mysql的启动配置文件cd /etc/my.cnf.d/pwdls -lh# mysql客户端配置文件client.cnf# mysql守护进程配置文件mysql-server.cnf# 默认权限授权配置文件mysql-default-authentication-plugin.cnf mysql 登录（不用密码登录）1mysql -uroot 重置 root 密码123456# 选择数据库use mysql;# 修改密码,备注：mysql8.0修改用户密码命令（新的修改方式）alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;root&#x27;;# 刷新权限表flush privileges; 修改密码前 修改密码后，为了方便记忆，这里把root用户密码设置为root 重新登录（使用新密码）1mysql -uroot -p navicat远程连接注意：记得先开放3306端口，或者关闭防火墙 navicat远程连接报错 授权 root 用户的所有权限并设置远程访问，GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。 12# 执行如下语句报错，ERROR 1410 (42000): You are not allowed to create a user with GRANTGRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION; 后来想到了mysql数据表user中的host，于是修改host： 1update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;; 刷新权限 1flush privileges; navicat可以成功访问。","tags":["Linux","CentOS","MySQL"],"categories":["公众号"]},{"title":"Nginx通过Lua+Redis实现动态封禁IP","path":"/eee67787/","content":"为了封禁某些爬虫或者恶意用户对服务器的请求，我们需要建立一个动态的 IP 黑名单。对于黑名单之内的 IP ，拒绝提供服务。 实现 IP 黑名单的功能有很多途径： 1、在操作系统层面，配置 iptables，拒绝指定 IP 的网络请求；2、在 Web Server 层面，通过 Nginx 自身的 deny 选项 或者 lua 插件 配置 IP 黑名单；3、在应用层面，在请求服务之前检查一遍客户端 IP 是否在黑名单。 为了方便管理和共享，我们选择通过 Nginx+Lua+Redis 的架构实现 IP 黑名单的功能，架构图如下： 安装 Nginx+Lua模块，推荐使用 OpenResty，这是一个集成了各种 Lua 模块的 Nginx 服务器： 安装并启动 Redis 服务器 配置 Nginx 示例： Nginx 配置，其中 1lua_shared_dict ip_blacklist 1m 由 Nginx 进程分配一块 1M 大小的共享内存空间，用来缓存 IP 黑名单。 1access_by_lua_file lua/ip_blacklist.lua; 指定 lua 脚本位置。 配置 lua 脚本，定期从 Redis 获取最新的 IP 黑名单。 在 Redis 服务器上新建 Set 类型的数据 ip_blacklist，并加入最新的 IP 黑名单。 完成以上步骤后，重新加载 nginx，配置便开始生效了。这时访问服务器，如果你的 IP 地址在黑名单内的话，将出现拒绝访问，如下图： 以上，便是 Nginx+Lua+Redis 实现的 IP 黑名单功能，具有如下优点： 配置简单、轻量，几乎对服务器性能不产生影响； 多台服务器可以通过Redis实例共享黑名单； 动态配置，可以手工或者通过某种自动化的方式设置 Redis 中的黑名单。","tags":["Nginx"],"categories":["公众号"]},{"title":"Nginx+Redis：高性能缓存利器","path":"/7a99677/","content":"一. OpenRestyOpenResty是一个基于 Nginx与 Lua的高性能 Web平台，其内部集成了大量精良的 Lua库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态Web 应用、Web 服务和动态网关。 接入层缓存技术就是使用OpenResty的技术用Lua语言进行二次开发。 二. Nginx + redis下图左边是常用的架构，http请求经过nginx负载均衡转发到tomcat，tomcat再从redis读取数据，整个链路过程是串行的，当tomcat挂掉或者tomcat线程数被消耗完，就无法正常返回数据。 使用OpenResty的lua-resty-redis模块使nginx具备直接访问redis的能力，不占用tomcat线程，Tomcat暂时挂掉仍可正常处理请求，减少响应时长，提高系统并发能力。 三. 压缩减少带宽数据大于1K，nginx压缩再保存到redis: 提高redis的读取速度 减少带宽的占用 压缩会消耗cpu时间，小于1K的数据不压缩tps更高。 OpenResty并没有提供redis连接池的实现，需要自己用lua实现redis的连接池，在网上已有实现的例子http://wiki.jikexueyuan.com/project/openresty/redis/out_package.html，直接参照使用。 Redis的value值用json格式保存&#123;length:xxx,content:yyy&#125;,content是压缩后的页面内容，length是content压缩前的大小，length字段是为了在读取redis时，根据length的大小来判断是否要解压缩content的数据。 使用lua-zlib库进行压缩。 四. 定时更新按下图第1和第2步定时执行，nginx lua定时器定时请求tomcat页面的url，返回的页面html保存在redis。 缓存有效期可设置长些，比如1个小时，可保证1个小时内tomcat挂掉，仍可使用缓存数据返回，缓存的定时更新时间可设置短些，比如1分钟，保证缓存快速更新 五.请求转发浏览器打开页面: nginx先从redis获取页面html redis不存在数据时，从tomcat获取页面，同时更新redis 返回页面HTML给浏览器 六. 单进程定时更新Nginx的所有worker进程都可以处理前端请求转发到redis,只有nginx worker 0才运行定时任务定时更新redis,lua脚本中通过ngx.worker.id()获取worker进程编号。 七 . 可配置化通过管理后台配置需要缓存的URL,可配置缓存URL、缓存有效期、定时更新时间,比如modify?url=index&amp;&amp;expire=3600000&amp;&amp;intervaltime=300000&amp;sign=xxxx,sign的值是管理后台secretkey对modify?url=index&amp;&amp;expire=3600000&amp;&amp;intervaltime=300000签名运算得到的，nginx端用相同的secretkey对modify?url=index&amp;&amp;expire=3600000&amp;&amp;intervaltime=300000签名运算，得到的值与sign的值相同则鉴权通过,允许修改nginx的配置。","tags":["Nginx","redis"],"categories":["公众号"]},{"title":"Nginx的五大应用场景","path":"/b44297cf/","content":"一、HTTP服务器 Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。 1、 首先在文档根目录Docroot(/usr/local/var/www)下创建html目录, 然后在html中放一个test.html; 2、 配置nginx.conf中的server 123456789101112131415user mengday staff;http &#123; server &#123; listen 80; server_name localhost; client_max_body_size 1024M; # 默认location location / &#123; root /usr/local/var/www/html; index index.html index.htm; &#125; &#125;&#125; 3、访问测试 http://localhost/ 指向/usr/local/var/www/index.html, index.html是安装nginx自带的html http://localhost/test.html 指向/usr/local/var/www/html/test.html 注意：如果访问图片出现403 Forbidden错误，可能是因为nginx.conf 的第一行user配置不对，默认是#user nobody;是注释的，linux下改成user root; macos下改成user 用户名 所在组; 然后重新加载配置文件或者重启，再试一下就可以了， 用户名可以通过who am i 命令来查看。 4、指令简介 server : 用于定义服务，http中可以有多个server块 listen : 指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口 server_name : 服务名称，用于配置域名 location : 用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式, &#x2F; 表示匹配任意路径, 当客户端访问的路径满足这个uri时就会执行location块里面的代码 root : 根路径，当访问http://localhost/test.html，“&#x2F;test.html”会匹配到”&#x2F;”uri, 找到root为/usr/local/var/www/html，用户访问的资源物理地址&#x3D;root + uri = /usr/local/var/www/html + /test.html=/usr/local/var/www/html/test.html index : 设置首页，当只访问server_name时后面不跟任何路径是不走root直接走index指令的；如果访问路径中没有指定具体的文件，则返回index设置的资源，如果访问http://localhost/html/ 则默认返回index.html 5、location uri正则表达式 . ：匹配除换行符以外的任意字符 ? ：重复0次或1次 + ：重复1次或更多次 * ：重复0次或更多次 \\d ：匹配数字 ^ ：匹配字符串的开始 $ ：匹配字符串的结束 &#123;n&#125; ：重复n次 &#123;n,&#125; ：重复n次或更多次 [c] ：匹配单个字符c [a-z] ：匹配a-z小写字母的任意一个 (a|b|c) : 属线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括括住，匹配符合a字符 或是b字符 或是c字符的字符串 \\ 反斜杠：用于转义特殊字符 小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 二、静态服务器在公司中经常会遇到静态服务器，通常会提供一个上传的功能，其他应用如果需要静态资源就从该静态服务器中获取。 1、在/usr/local/var/www 下分别创建images和img目录，分别在每个目录下放一张test.jpg 1234567891011121314151617http &#123; server &#123; listen 80; server_name localhost; set $doc_root /usr/local/var/www; # 默认location location / &#123; root /usr/local/var/www/html; index index.html index.htm; &#125; location ^~ /images/ &#123; root $doc_root; &#125; location ~* \\.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123; root $doc_root/img; &#125; &#125;&#125; 自定义变量使用set指令，语法 set 变量名值;引用使用变量名值;引用使用变量名; 这里自定义了doc_root变量。 静态服务器location的映射一般有两种方式： 使用路径，如 &#x2F;images&#x2F; 一般图片都会放在某个图片目录下， 使用后缀，如 .jpg、.png 等后缀匹配模式 访问http://localhost/test.jpg 会映射到 $doc_root/img 访问http://localhost/images/test.jpg 当同一个路径满足多个location时，优先匹配优先级高的location，由于^~ 的优先级大于 ~, 所以会走/images/对应的location 常见的location路径映射路径有以下几种： = 进行普通字符精确匹配。也就是完全匹配。 ^~ 前缀匹配。如果匹配成功，则不再匹配其他location。 ~ 表示执行一个正则匹配，区分大小写 ~* 表示执行一个正则匹配，不区分大小写 /xxx/ 常规字符串路径匹配 / 通用匹配，任何请求都会匹配到 location优先级当一个路径匹配多个 location 时究竟哪个location能匹配到时有优先级顺序的，而优先级的顺序于location值的表达式类型有关，和在配置文件中的先后顺序无关。相同类型的表达式，字符串长的会优先匹配。 以下是按优先级排列说明： 等号类型（&#x3D;）的优先级最高。一旦匹配成功，则不再查找其他匹配项，停止搜索。 ^~类型表达式，不属于正则表达式。一旦匹配成功，则不再查找其他匹配项，停止搜索。 正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。 常规字符串匹配类型。按前缀匹配。 &#x2F; 通用匹配，如果没有匹配到，就匹配通用的 优先级搜索问题：不同类型的location映射决定是否继续向下搜索 等号类型、^~类型：一旦匹配上就停止搜索了，不会再匹配其他location了 正则表达式类型(~ ~*）,常规字符串匹配类型/xxx/ : 匹配到之后，还会继续搜索其他其它location，直到找到优先级最高的，或者找到第一种情况而停止搜索 location优先级从高到底： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 1234567891011121314151617181920212223242526272829303132333435363738location = / &#123; # 精确匹配/，主机名后面不能带任何字符串 / [ configuration A ]&#125;location / &#123; # 匹配所有以 / 开头的请求。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration B ]&#125;location /documents/ &#123; # 匹配所有以 /documents/ 开头的请求，匹配符合以后，还要继续往下搜索。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration C ]&#125;location ^~ /images/ &#123; # 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。 # 所以，即便有符合的正则表达式location，也不会被使用 [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif jpg jpeg结尾的请求。 # 但是 以 /images/开头的请求，将使用 Configuration D，D具有更高的优先级 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，还会继续往下搜索 [ configuration F ]&#125;location = /test.htm &#123; root /usr/local/var/www/htm; index index.htm;&#125; 注意：location的优先级与location配置的位置无关 三、反向代理反向代理应该是Nginx使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 反向代理通过proxy_pass指令来实现。 启动一个Java Web项目，端口号为8081 1234567891011121314server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:8081; proxy_set_header Host $host:$server_port; # 设置用户ip地址 proxy_set_header X-Forwarded-For $remote_addr; # 当请求服务器出错去寻找其他服务器 proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; &#125;&#125; 当我们访问localhost的时候，就相当于访问 localhost:8081了 四、负载均衡负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。 负载均衡通过upstream指令来实现。 1. RR(round robin :轮询 默认)每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器down掉，能自动剔除。轮询是默认配置，不需要太多的配置 同一个项目分别使用8081和8082端口启动项目 1234567891011121314151617upstream web_servers &#123; server localhost:8081; server localhost:8082;&#125;server &#123; listen 80; server_name localhost; #access_log logs/host.access.log main; location / &#123; proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; &#125; &#125; 访问地址仍然可以获得响应 http://localhost/api/user/login?username=zhangsan&amp;password=111111 ，这种方式是轮询的 2. 权重指定轮询几率，weight和访问比率成正比, 也就是服务器接收请求的比例就是各自配置的weight的比例，用于后端服务器性能不均的情况,比如服务器性能差点就少接收点请求，服务器性能好点就多处理点请求。 12345upstream test &#123; server localhost:8081 weight=1; server localhost:8082 weight=3; server localhost:8083 weight=4 backup;&#125; 示例是4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083 3. ip_hash上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候(采用了session保存数据)，这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream test &#123; ip_hash; server localhost:8080; server localhost:8081;&#125; 4. fair(第三方) 按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应 12345upstream backend &#123; fair; server localhost:8080; server localhost:8081;&#125; 5. url_hash(第三方) 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream backend &#123; hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081;&#125; 以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用。 五、动静分离动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。 123456789101112131415161718192021222324252627upstream web_servers &#123; server localhost:8081; server localhost:8082;&#125;server &#123; listen 80; server_name localhost; set $doc_root /usr/local/var/www; location ~* \\.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123; root $doc_root/img; &#125; location / &#123; proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root $doc_root; &#125; &#125; 六、其他 1.return指令返回http状态码 和 可选的第二个参数可以是重定向的URL 123location /permanently/moved/url &#123; return 301 http://www.example.com/moved/here;&#125; 2. rewrite指令 重写URI请求 rewrite，通过使用rewrite指令在请求处理期间多次修改请求URI，该指令具有一个可选参数和两个必需参数。 第一个(必需)参数是请求URI必须匹配的正则表达式。 第二个参数是用于替换匹配URI的URI。 可选的第三个参数是可以停止进一步重写指令的处理或发送重定向(代码301或302)的标志 123location /users/ &#123; rewrite ^/users/(.*)$ /show?user=$1 break;&#125; 3. error_page指令 使用error_page指令，您可以配置NGINX返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他URI。在以下示例中，error_page指令指定要返回404页面错误代码的页面(&#x2F;404.html)。 1error_page 404 /404.html; 4. 日志 访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开log_format、access_log注释 1234567log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;access_log /usr/local/etc/nginx/logs/host.access.log main;gzip on; 5. deny 指令 12345# 禁止访问某个目录location ~* \\.(txt|doc)$&#123; root $doc_root; deny all;&#125; **6. 内置变量** nginx的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。 $args ：#这个变量等于请求行中的参数，同$query_string $content_length ：请求头中的Content-length字段。 $content_type ：请求头中的Content-Type字段。 $document_root ：当前请求在root指令中指定的值。 $host ：请求主机头字段，否则为服务器名称。 $http_user_agent ：客户端agent信息 $http_cookie ：客户端cookie信息 $limit_rate ：这个变量可以限制连接速率。 $request_method ：客户端请求的动作，通常为GET或POST。 $remote_addr ：客户端的IP地址。 $remote_port ：客户端的端口。 $remote_user ：已经经过Auth Basic Module验证的用户名。 $request_filename ：当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme ：HTTP方法（如http，https）。 $server_protocol ：请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。 $server_addr ：服务器地址，在完成一次系统调用后可以确定这个值。 $server_name ：服务器名称。 $server_port ：请求到达服务器的端口号。 $request_uri ：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri ：不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri ：与$uri相同","tags":["Nginx"],"categories":["公众号"]},{"title":"Nginx常用配置清单","path":"/488ea114/","content":"Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP&#x2F;POP3&#x2F;SMTP 服务，其因丰富的功能集、稳定性、示例配置文件和低系统资源的消耗受到了开发者的欢迎。本文，我们总结了一些常用的 Nginx 配置代码，希望对大家有所帮助。 侦听端口 123456789101112server &#123;# Standard HTTP Protocollisten 80;# Standard HTTPS Protocollisten 443 ssl;# For http2listen 443 ssl http2;# Listen on 80 using IPv6listen [::]:80;# Listen only on using IPv6listen [::]:80 ipv6only=on;&#125; 访问日志 123456server &#123;# Relative or full path to log fileaccess_log /path/to/file.log;# Turn &#x27;on&#x27; or &#x27;off&#x27; access_log on;&#125; 域名 1234567891011server &#123;# Listen to yourdomain.comserver_name yourdomain.com;# Listen to multiple domains server_name yourdomain.com www.yourdomain.com;# Listen to all domainsserver_name *.yourdomain.com;# Listen to all top-level domainsserver_name yourdomain.*;# Listen to unspecified Hostnames (Listens to IP address itself)server_name &quot;&quot;;&#125; 静态资产 1234567server &#123;listen 80;server_name yourdomain.com;location / &#123;root /path/to/website;&#125;&#125; 重定向 123456789101112server &#123;listen 80;server_name www.yourdomain.com;return 301 http://yourdomain.com$request_uri;&#125;server &#123;listen 80;server_name www.yourdomain.com;location /redirect-url &#123;return 301 http://otherdomain.com;&#125;&#125; 反向代理 12345678server &#123;listen 80;server_name yourdomain.com;location / &#123;proxy_pass http://0.0.0.0:3000;# where 0.0.0.0:3000 is your application server (Ex: node.js) bound on 0.0.0.0 listening on port 3000&#125;&#125; 负载均衡 12345678910111213upstream node_js &#123;server 0.0.0.0:3000;server 0.0.0.0:4000;server 123.131.121.122;&#125;server &#123;listen 80;server_name yourdomain.com;location / &#123;proxy_pass http://node_js;&#125;&#125; SSL 协议 123456789101112131415161718192021server &#123;listen 443 ssl;server_name yourdomain.com;ssl on;ssl_certificate /path/to/cert.pem;ssl_certificate_key /path/to/privatekey.pem;ssl_stapling on;ssl_stapling_verify on;ssl_trusted_certificate /path/to/fullchain.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_session_timeout 1h;ssl_session_cache shared:SSL:50m;add_header Strict-Transport-Security max-age=15768000;&#125;# Permanent Redirect for HTTP to HTTPSserver &#123;listen 80;server_name yourdomain.com;return 301 https://$host$request_uri;&#125; 其实可以采用可视化的方式对 Nginx 进行配置，我在 GitHub 上发现了一款可以一键生成 Nginx 配置的神器，相当给力。 先来看看它都支持什么功能的配置：反向代理、HTTPS、HTTP&#x2F;2、IPv6, 缓存、WordPress、CDN、Node.js 支持、 Python (Django) 服务器等等。 如果你想在线进行配置，只需要打开网站：https://nginxconfig.io/，按照自己的需求进行操作就行了。 选择你的场景，填写好参数，系统就会自动生成配置文件。 开源地址：github.com&#x2F;digitalocean&#x2F;nginxconfig.io 网站：digitalocean.com&#x2F;community&#x2F;tools&#x2F;nginx","tags":["Nginx"],"categories":["公众号"]},{"title":"Nginx全面认识","path":"/615ffc57/","content":"Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， Nginx 是免费的并可以商业化，配置使用也比较简单。 Nginx 特点 高并发、高性能； 模块化架构使得它的扩展性非常好； 异步非阻塞的事件驱动模型这点和 Node.js 相似； 相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性； 热部署、平滑升级； 完全开源，生态繁荣； Nginx 作用Nginx 的最重要的几个使用场景： 静态资源服务，通过本地文件系统提供服务； 反向代理服务，延伸出包括缓存、负载均衡等； API 服务， OpenResty ； 对于前端来说 Node.js 并不陌生， Nginx 和 Node.js 的很多理念类似， HTTP 服务器、事件驱动、异步非阻塞等，且 Nginx 的大部分功能使用 Node.js 也可以实现，但 Nginx 和 Node.js 并不冲突，都有自己擅长的领域。Nginx 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， Node.js 更擅长上层具体业务逻辑的处理，两者可以完美组合。 用一张图表示： Nginx 安装 本文演示的是 Linux centOS 7.x 的操作系统上安装 Nginx ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。 使用 yum 安装 Nginx ： 1yum install nginx -y 安装完成后，通过 rpm \\-ql nginx 命令查看 Nginx 的安装信息： 1234567891011121314151617181920212223242526# Nginx配置文件/etc/nginx/nginx.conf # nginx 主配置文件/etc/nginx/nginx.conf.default# 可执行程序文件/usr/bin/nginx-upgrade/usr/sbin/nginx# nginx库文件/usr/lib/systemd/system/nginx.service # 用于配置系统守护进程/usr/lib64/nginx/modules # Nginx模块目录# 帮助文档/usr/share/doc/nginx-1.16.1/usr/share/doc/nginx-1.16.1/CHANGES/usr/share/doc/nginx-1.16.1/README/usr/share/doc/nginx-1.16.1/README.dynamic/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10# 静态资源目录/usr/share/nginx/html/404.html/usr/share/nginx/html/50x.html/usr/share/nginx/html/index.html# 存放Nginx日志文件/var/log/nginx 主要关注的文件夹有两个： 1. /etc/nginx/conf.d/ 是子配置项存放处， /etc/nginx/nginx.conf 主配置文件会默认把这个文件夹中所有子配置项都引入； 2. /usr/share/nginx/html/ 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方； Nginx 常用命令 systemctl 系统命令： 123456789101112131415161718192021222324# 开机配置systemctl enable nginx # 开机自动启动systemctl disable nginx # 关闭开机自动启动# 启动Nginxsystemctl start nginx # 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面# 停止Nginxsystemctl stop nginx# 重启Nginxsystemctl restart nginx# 重新加载Nginxsystemctl reload nginx# 查看 Nginx 运行状态systemctl status nginx# 查看Nginx进程ps -ef | grep nginx# 杀死Nginx进程kill -9 pid # 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程 Nginx 应用程序命令： 123456nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启nginx -s reopen # 重启 Nginxnginx -s stop # 快速关闭nginx -s quit # 等待工作进程处理完成后关闭nginx -T # 查看当前 Nginx 最终的配置nginx -t # 检查配置是否有问题 Nginx 核心配置配置文件结构Nginx 的典型配置示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# main段配置信息user nginx; # 运行用户，默认即是nginx，可以不进行设置worker_processes auto; # Nginx 进程数，一般设置为和 CPU 核数一样error_log /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录pid /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置# events段配置信息events &#123; use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的) worker_connections 1024; # 每个进程允许最大并发数&#125;# http段配置信息# 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置http &#123; # 设置日志模式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; # Nginx访问日志存放位置 sendfile on; # 开启高效传输模式 tcp_nopush on; # 减少网络报文段的数量 tcp_nodelay on; keepalive_timeout 65; # 保持连接的时间，也叫超时时间，单位秒 types_hash_max_size 2048; include /etc/nginx/mime.types; # 文件扩展名与类型映射表 default_type application/octet-stream; # 默认文件类型 include /etc/nginx/conf.d/*.conf; # 加载子配置项 # server段配置信息 server &#123; listen 80; # 配置监听的端口 server_name localhost; # 配置的域名 # location段配置信息 location / &#123; root /usr/share/nginx/html; # 网站根目录 index index.html index.htm; # 默认首页文件 deny 172.168.22.11; # 禁止访问的ip地址，可以为all allow 172.168.33.44；# 允许访问的ip地址，可以为all &#125; error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面 error_page 400 404 error.html; # 同上 &#125;&#125; 全局配置，对全局生效； events 配置影响 Nginx 服务器与用户的网络连接； http 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置； server 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块； location 用于配置匹配的 uri ； upstream 配置后端服务器具体地址，负载均衡配置不可或缺的部分； 用一张图清晰的展示它的层级结构： 配置文件 main 段核心参数user指定运行 Nginx 的 woker 子进程的属主和属组，其中组可以不指定。 123user USERNAME [GROUP]user nginx lion; # 用户是nginx;组是lion pid 指定运行 Nginx master 主进程的 pid 文件存放路径。 1pid /opt/nginx/logs/nginx.pid # master主进程的的pid存放在nginx.pid的文件 worker_rlimit_nofile_number指定 worker 子进程可以打开的最大文件句柄数。 1worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。 worker_rlimit_core 指定 worker 子进程异常终止后的 core 文件，用于记录分析问题。 12worker_rlimit_core 50M; # 存放大小限制working_directory /opt/nginx/tmp; # 存放目录 worker_processes_number指定 Nginx 启动的 worker 子进程数量。 12worker_processes 4; # 指定具体子进程数量worker_processes auto; # 与当前cpu物理核心数一致 worker_cpu_affinity将每个 worker 子进程与我们的 cpu 物理核心绑定。 1worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程 将每个 worker 子进程与特定 CPU 物理核心绑定，优势在于，避免同一个 worker 子进程在不同的 CPU 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。 worker_priority 指定 worker 子进程的 nice 值，以调整运行 Nginx 的优先级，通常设定为负值，以优先调用 Nginx 。 1worker_priority -10; # 120-10=110，110就是最终的优先级 Linux 默认进程的优先级值是120，值越小越优先；nice 定范围为 -20 到 +19 。 [备注] 应用的默认优先级值是120加上 nice 值等于它最终的值，这个值越小，优先级越高。 worker_shutdown_timeout指定 worker 子进程优雅退出时的超时时间。 1worker_shutdown_timeout 5s; timer_resolutionworker 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。 1timer_resolution 100ms; 在 Linux 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。 daemon 指定 Nginx 的运行方式，前台还是后台，前台用于调试，后台用于生产。 1daemon off; # 默认是on，后台运行模式 配置文件 events 段核心参数useNginx 使用何种事件驱动模型。 123use method; # 不推荐配置它，让nginx自己选择method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport worker_connectionsworker 子进程能够处理的最大并发连接数。 1worker_connections 1024 # 每个子进程的最大连接数为1024 accept_mutex 是否打开负载均衡互斥锁。 1accept_mutex on # 默认是off关闭的，这里推荐打开 server_name 指令 指定虚拟主机域名。 1234server_name name1 name2 name3# 示例：server_name www.nginx.com; 域名匹配的四种写法： 精确匹配：server_name www.nginx.com ; 左侧通配：server_name *.nginx.com ; 右侧统配：server_name www.nginx.* ; 正则匹配：server_name ~^www\\.nginx\\.*$ ; 匹配优先级：精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配 server_name 配置实例： 1、配置本地 DNS 解析 vim /etc/hosts （ macOS 系统） 1234567# 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址121.42.11.34 www.nginx-test.com121.42.11.34 mail.nginx-test.com121.42.11.34 www.nginx-test.org121.42.11.34 doc.nginx-test.com121.42.11.34 www.nginx-test.cn121.42.11.34 fe.nginx-test.club [注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 DNS 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。 2、配置阿里云 Nginx ，vim /etc/nginx/nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738394041# 这里只列举了http端中的sever端配置# 左匹配server &#123; listen 80; server_name *.nginx-test.com; root /usr/share/nginx/html/nginx-test/left-match/; location / &#123; index index.html; &#125;&#125;# 正则匹配server &#123; listen 80; server_name ~^.*\\.nginx-test\\..*$; root /usr/share/nginx/html/nginx-test/reg-match/; location / &#123; index index.html; &#125;&#125;# 右匹配server &#123; listen 80; server_name www.nginx-test.*; root /usr/share/nginx/html/nginx-test/right-match/; location / &#123; index index.html; &#125;&#125;# 完全匹配server &#123; listen 80; server_name www.nginx-test.com; root /usr/share/nginx/html/nginx-test/all-match/; location / &#123; index index.html; &#125;&#125; 3、访问分析 当访问 www.nginx-test.com 时，都可以被匹配上，因此选择优先级最高的“完全匹配”； 当访问 mail.nginx-test.com 时，会进行“左匹配”； 当访问 www.nginx-test.org 时，会进行“右匹配”； 当访问 doc.nginx-test.com 时，会进行“左匹配”； 当访问 www.nginx-test.cn 时，会进行“右匹配”； 当访问 fe.nginx-test.club 时，会进行“正则匹配”； root指定静态资源目录位置，它可以写在 http 、 server 、 location 等配置中。 12345678root path例如：location /image &#123; root /opt/nginx/static;&#125;当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png [注意] root 会将定义路径与 URI 叠加， alias 则只取定义路径。 alias它也是指定静态资源目录位置，它只能写在 location 中。 12345location /image &#123; alias /opt/nginx/static/image/;&#125;当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png [注意] 使用 alias 末尾一定要添加 / ，并且它只能位于 location 中。 location 配置路径。 123location [ = | ~ | ~* | ^~ ] uri &#123; ...&#125; 匹配规则： = 精确匹配； ~ 正则匹配，区分大小写； ~* 正则匹配，不区分大小写； ^~ 匹配到即停止搜索； 匹配优先级：= &gt; ^~ &gt; ~ &gt; ~* &gt; 不带任何字符。 实例： 123456789101112131415161718192021server &#123; listen 80; server_name www.nginx-test.com; # 只有当访问 www.nginx-test.com/match_all/ 时才会匹配到/usr/share/nginx/html/match_all/index.html location = /match_all/ &#123; root /usr/share/nginx/html index index.html &#125; # 当访问 www.nginx-test.com/1.jpg 等路径时会去 /usr/share/nginx/images/1.jpg 找对应的资源 location ~ \\.(jpeg|jpg|png|svg)$ &#123; root /usr/share/nginx/images; &#125; # 当访问 www.nginx-test.com/bbs/ 时会匹配上 /usr/share/nginx/html/bbs/index.html location ^~ /bbs/ &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125; location 中的反斜线 1234567location /test &#123; ...&#125;location /test/ &#123; ...&#125; 不带 / 当访问 www.nginx-test.com/test 时， Nginx 先找是否有 test 目录，如果有则找 test 目录下的 index.html ；如果没有 test 目录， nginx 则会找是否有 test 文件。 带 / 当访问 www.nginx-test.com/test 时， Nginx 先找是否有 test 目录，如果有则找 test 目录下的 index.html ，如果没有它也不会去找是否存在 test 文件。 return停止处理请求，直接返回响应码或重定向到其他 URL ；执行 return 指令后， location 中后续指令将不会被执行。 1234567891011121314151617181920return code [text];return code URL;return URL;例如：location / &#123; return 404; # 直接返回状态码&#125;location / &#123; return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本&#125;location / &#123; return 302 /bbs ; # 返回状态码 + 重定向地址&#125;location / &#123; return https://www.baidu.com ; # 返回重定向地址&#125; rewrite根据指定正则表达式匹配规则，重写 URL 。 12345语法：rewrite 正则表达式 要替换的内容 [flag];上下文：server、location、if示例：rewirte /images/(.*\\.jpg)$ /pic/$1; # $1是前面括号(.*\\.jpg)的反向引用 flag 可选值的含义： last 重写后的 URL 发起新请求，再次进入 server 段，重试 location 的中的匹配； break 直接使用重写后的 URL ，不再匹配其它 location 中语句； redirect 返回302临时重定向； permanent 返回301永久重定向； 1234567891011121314151617181920server&#123; listen 80; server_name fe.lion.club; # 要在本地hosts文件进行配置 root html; location /search &#123; rewrite ^/(.*) https://www.baidu.com redirect; &#125; location /images &#123; rewrite /images/(.*) /pics/$1; &#125; location /pics &#123; rewrite /pics/(.*) /photos/$1; &#125; location /photos &#123; &#125;&#125; 按照这个配置我们来分析： 当访问 fe.lion.club/search 时，会自动帮我们重定向到 https://www.baidu.com。 当访问 fe.lion.club/images/1.jpg 时，第一步重写 URL 为 fe.lion.club/pics/1.jpg ，找到 pics 的 location ，继续重写 URL 为 fe.lion.club/photos/1.jpg ，找到 /photos 的 location 后，去 html/photos 目录下寻找 1.jpg 静态资源。 if 指令12345678语法：if (condition) &#123;...&#125;上下文：server、location示例：if($http_user_agent ~ Chrome)&#123; rewrite /(.*)/browser/$1 break;&#125; condition 判断条件： $variable 仅为变量时，值为空或以0开头字符串都会被当做 false 处理； = 或 != 相等或不等； ~ 正则匹配； ! ~ 非正则匹配； ~* 正则匹配，不区分大小写； -f 或 ! -f 检测文件存在或不存在； -d 或 ! -d 检测目录存在或不存在； -e 或 ! -e 检测文件、目录、符号链接等存在或不存在； -x 或 ! -x 检测文件可以执行或不可执行； 实例： 1234567891011server &#123; listen 8080; server_name localhost; root html; location / &#123; if ( $uri = &quot;/images/&quot; )&#123; rewrite (.*) /pics/ break; &#125; &#125;&#125; 当访问 localhost:8080/images/ 时，会进入 if 判断里面执行 rewrite 命令。 autoindex 用户请求以 / 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。 autoindex.conf 配置信息： 12345678910111213server &#123; listen 80; server_name fe.lion-test.club; location /download/ &#123; root /opt/source; autoindex on; # 打开 autoindex，，可选参数有 on | off autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩ autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间 &#125;&#125; 当访问 fe.lion.com/download/ 时，会把服务器 /opt/source/download/ 路径下的文件展示出来，如下图所示： 变量 Nginx 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， Nginx 将这些数据以变量的形式提供给使用者。 下面列举些项目中常用的变量： 实例演示 var.conf ： 123456789101112131415161718192021222324252627282930313233server&#123; listen 8081; server_name var.lion-test.club; root /usr/share/nginx/html; location / &#123; return 200 &quot;remote_addr: $remote_addrremote_port: $remote_portserver_addr: $server_addrserver_port: $server_portserver_protocol: $server_protocolbinary_remote_addr: $binary_remote_addrconnection: $connectionuri: $urirequest_uri: $request_urischeme: $schemerequest_method: $request_methodrequest_length: $request_lengthargs: $argsarg_pid: $arg_pidis_args: $is_argsquery_string: $query_stringhost: $hosthttp_user_agent: $http_user_agenthttp_referer: $http_refererhttp_via: $http_viarequest_time: $request_timehttps: $httpsrequest_filename: $request_filenamedocument_root: $document_root&quot;; &#125;&#125; 当我们访问 http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd 时，由于 Nginx 中写了 return 方法，因此 chrome 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容： 123456789101112131415161718192021222324remote_addr: 27.16.220.84remote_port: 56838server_addr: 172.17.0.2server_port: 8081server_protocol: HTTP/1.1binary_remote_addr: 茉connection: 126uri: /test/request_uri: /test/?pid=121414&amp;cid=sadasdscheme: httprequest_method: GETrequest_length: 518args: pid=121414&amp;cid=sadasdarg_pid: 121414is_args: ?query_string: pid=121414&amp;cid=sadasdhost: var.lion-test.clubhttp_user_agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36http_referer:http_via:request_time: 0.000https:request_filename: /usr/share/nginx/html/test/document_root: /usr/share/nginx/html Nginx 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。 Nginx 应用核心概念 代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。 正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 反向代理 反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。 反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。 反向代理的优势： 隐藏真实服务器； 负载均衡便于横向扩充后端动态服务； 动静分离，提升系统健壮性； 那么“动静分离”是什么？负载均衡又是什么？ 动静分离 动静分离是指在 web 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。 一般来说，都需要将动态资源和静态资源分开，由于 Nginx 的高并发和静态资源缓存等特性，经常将静态资源部署在 Nginx 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。 使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。 负载均衡 一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。 这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。 很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。 请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。 举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 B 口， B 口人少车空….”，这个工作人员的作用就是负载均衡。 Nginx 实现负载均衡的策略： 轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 最快响应时间策略：优先分配给响应时间最短的服务器。 客户端 ip 绑定策略：来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。 Nginx 实战配置 在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 Nginx 应用配置中的核心，它们分别是：upstream 、proxy_pass 。 upstream 用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。 12345678910语法：upstream name &#123; ...&#125;上下文：http示例：upstream back_end_server&#123; server 192.168.100.33:8081&#125; 在 upstream 内可使用的指令： server 定义上游服务器地址； zone 定义共享内存，用于跨 worker 子进程； keepalive 对上游服务启用长连接； keepalive_requests 一个长连接最多请求 HTTP 的个数； keepalive_timeout 空闲情形下，一个长连接的超时时长； hash 哈希负载均衡算法； ip_hash 依据 IP 进行哈希计算的负载均衡算法； least_conn 最少连接数负载均衡算法； least_time 最短响应时间负载均衡算法； random 随机负载均衡算法； server定义上游服务器地址。 123语法：server address [parameters]上下文：upstream parameters 可选值： weight=number 权重值，默认为1； max_conns=number 上游服务器的最大并发连接数； fail_timeout=time 服务器不可用的判定时间； max_fails=numer 服务器不可用的检查次数； backup 备份服务器，仅当其他服务器都不可用时才会启用； down 标记服务器长期不可用，离线维护； keepalive限制每个 worker 子进程与上游服务器空闲长连接的最大数量。 12345keepalive connections;上下文：upstream示例：keepalive 16; keepalive_requests单个长连接可以处理的最多 HTTP 请求个数。 12345语法：keepalive_requests number;默认值：keepalive_requests 100;上下文：upstream keepalive_timeout 空闲长连接的最长保持时间。 12345语法：keepalive_timeout time;默认值：keepalive_timeout 60s;上下文：upstream 配置实例123456upstream back_end&#123; server 127.0.0.1:8081 weight=3 max_conns=1000 fail_timeout=10s max_fails=2; keepalive 32; keepalive_requests 50; keepalive_timeout 30s;&#125; proxy_pass用于配置代理服务器。 1234567语法：proxy_pass URL;上下文：location、if、limit_except示例：proxy_pass http://127.0.0.1:8081proxy_pass http://127.0.0.1:8081/proxy URL 参数原则 1. URL 必须以 http 或 https 开头； 2. URL 中可以携带变量； 3. URL 中是否带 URI ，会直接影响发往上游请求的 URL ； 接下来让我们来看看两种常见的 URL 用法： proxy_pass http://192.168.100.33:8081 proxy_pass http://192.168.100.33:8081/ 这两种用法的区别就是带 / 和不带 / ，在配置代理时它们的区别可大了： 不带 / 意味着 Nginx 不会修改用户 URL ，而是直接透传给上游的应用服务器； 带 / 意味着 Nginx 会修改用户 URL ，修改方法是将 location 后的 URL 从用户 URL 中删除； 不带 / 的用法： 123location /bbs/&#123; proxy_pass http://127.0.0.1:8080;&#125; 分析： \\1. 用户请求 URL ：/bbs/abc/test.html \\2. 请求到达 Nginx 的 URL ：/bbs/abc/test.html 3 .请求到达上游应用服务器的 URL ：/bbs/abc/test.html 带 / 的用法： 123location /bbs/&#123; proxy_pass http://127.0.0.1:8080/;&#125; 分析： \\1. 用户请求 URL ：/bbs/abc/test.html \\2. 请求到达 Nginx 的 URL ：/bbs/abc/test.html \\3. 请求到达上游应用服务器的 URL ：/abc/test.html 并没有拼接上 /bbs ，这点和 root 与 alias 之间的区别是保持一致的。 配置反向代理 这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 IP 分别是：121.42.11.34 与 121.5.180.193 。 我们把 121.42.11.34 服务器作为上游服务器，做如下配置： 12345678910111213# /etc/nginx/conf.d/proxy.confserver&#123; listen 8080; server_name localhost; location /proxy/ &#123; root /usr/share/nginx/html/proxy; index index.html; &#125;&#125;# /usr/share/nginx/html/proxy/index.html&lt;h1&gt; 121.42.11.34 proxy html &lt;/h1&gt; 配置完成后重启 Nginx 服务器 nginx \\-s reload 。 把 121.5.180.193 服务器作为代理服务器，做如下配置： 123456789101112131415# /etc/nginx/conf.d/proxy.confupstream back_end &#123; server 121.42.11.34:8080 weight=2 max_conns=1000 fail_timeout=10s max_fails=3; keepalive 32; keepalive_requests 80; keepalive_timeout 20s;&#125;server &#123; listen 80; server_name proxy.lion.club; location /proxy &#123; proxy_pass http://back_end/proxy; &#125;&#125; 本地机器要访问 proxy.lion.club 域名，因此需要配置本地 hosts ，通过命令：vim /etc/hosts 进入配置文件，添加如下内容： 1121.5.180.193 proxy.lion.club 分析： 当访问 proxy.lion.club/proxy 时通过 upstream 的配置找到 121.42.11.34:8080 ； 因此访问地址变为 http://121.42.11.34:8080/proxy ； 连接到 121.42.11.34 服务器，找到 8080 端口提供的 server ； 通过 server 找到 /usr/share/nginx/html/proxy/index.html 资源，最终展示出来。 配置负载均衡配置负载均衡主要是要使用 upstream 指令。 我们把 121.42.11.34 服务器作为上游服务器，做如下配置（ /etc/nginx/conf.d/balance.conf ）： 1234567891011121314151617181920server&#123; listen 8020; location / &#123; return 200 &#x27;return 8020 &#x27;; &#125;&#125;server&#123; listen 8030; location / &#123; return 200 &#x27;return 8030 &#x27;; &#125;&#125;server&#123; listen 8040; location / &#123; return 200 &#x27;return 8040 &#x27;; &#125;&#125; 配置完成后： 1. nginx -t 检测配置是否正确； 2. nginx -s reload 重启 Nginx 服务器； \\3. 执行 ss -nlt 命令查看端口是否被占用，从而判断 Nginx 服务是否正确启动。 把 121.5.180.193 服务器作为代理服务器，做如下配置（ /etc/nginx/conf.d/balance.conf ）： 1234567891011121314upstream demo_server &#123; server 121.42.11.34:8020; server 121.42.11.34:8030; server 121.42.11.34:8040;&#125;server &#123; listen 80; server_name balance.lion.club; location /balance/ &#123; proxy_pass http://demo_server; &#125;&#125; 配置完成后重启 Nginx 服务器。并且在需要访问的客户端配置好 ip 和域名的映射关系。 123# /etc/hosts121.5.180.193 balance.lion.club 在客户端机器执行 curl http://balance.lion.club/balance/ 命令： 不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。 接下来，我们再来了解下 Nginx 的其它分发策略。 hash 算法 通过制定关键字作为 hash key ，基于 hash 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。 123456789101112131415upstream demo_server &#123; hash $request_uri; server 121.42.11.34:8020; server 121.42.11.34:8030; server 121.42.11.34:8040;&#125;server &#123; listen 80; server_name balance.lion.club; location /balance/ &#123; proxy_pass http://demo_server; &#125;&#125; hash $request_uri 表示使用 request_uri 变量作为 hash 的 key 值，只要访问的 URI 保持不变，就会一直分发给同一台服务器。 ip_hash 根据客户端的请求 ip 进行判断，只要 ip 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 session 保持的问题。 123456789101112131415upstream demo_server &#123; ip_hash; server 121.42.11.34:8020; server 121.42.11.34:8030; server 121.42.11.34:8040;&#125;server &#123; listen 80; server_name balance.lion.club; location /balance/ &#123; proxy_pass http://demo_server; &#125;&#125; 最少连接数算法各个 worker 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。 123语法：least_conn;上下文：upstream; 示例： 12345678910111213141516upstream demo_server &#123; zone test 10M; # zone可以设置共享内存空间的名字和大小 least_conn; server 121.42.11.34:8020; server 121.42.11.34:8030; server 121.42.11.34:8040;&#125;server &#123; listen 80; server_name balance.lion.club; location /balance/ &#123; proxy_pass http://demo_server; &#125;&#125; 最后你会发现，负载均衡的配置其实一点都不复杂。 配置缓存 缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ Nginx ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习 Nginx 中如何设置缓存策略。 proxy_cache 存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。 12345语法：proxy_cache zone | off ; # zone 是共享内存的名称默认值：proxy_cache off;上下文：http、server、location proxy_cache_path 设置缓存文件的存放路径。 12345语法：proxy_cache_path path [level=levels] ...可选参数省略，下面会详细列举默认值：proxy_cache_path off上下文：http 参数含义： path 缓存文件的存放路径； level path 的目录层级； keys_zone 设置共享内存； inactive 在指定时间内没有被访问，缓存会被清理，默认10分钟； proxy_cache_key设置缓存文件的 key 。 12345语法：proxy_cache_key默认值：proxy_cache_key $scheme$proxy_host$request_uri;上下文：http、server、location proxy_cache_valid 配置什么状态码可以被缓存，以及缓存时长。 12345语法：proxy_cache_valid [code...] time;上下文：http、server、location配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟 proxy_no_cache定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。 12345语法：proxy_no_cache string;上下文：http、server、location示例：proxy_no_cache $http_pragma $http_authorization; proxy_cache_bypass定义条件，在该条件下将不会从缓存中获取响应。 12345语法：proxy_cache_bypass string;上下文：http、server、location示例：proxy_cache_bypass $http_pragma $http_authorization; upstream_cache_status 变量它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。 1234567MISS: 未命中缓存HIT：命中缓存EXPIRED: 缓存过期STALE: 命中了陈旧缓存REVALIDDATED: Nginx验证陈旧缓存依然有效UPDATING: 内容陈旧，但正在更新BYPASS: X响应从原始服务器获取 配置实例我们把 121.42.11.34 服务器作为上游服务器，做如下配置（ /etc/nginx/conf.d/cache.conf ）： 123456789101112131415server &#123; listen 1010; root /usr/share/nginx/html/1010; location / &#123; index index.html; &#125;&#125;server &#123; listen 1020; root /usr/share/nginx/html/1020; location / &#123; index index.html; &#125;&#125; 把 121.5.180.193 服务器作为代理服务器，做如下配置（ /etc/nginx/conf.d/cache.conf ）： 123456789101112131415161718proxy_cache_path /etc/nginx/cache_temp levels=2:2 keys_zone=cache_zone:30m max_size=2g inactive=60m use_temp_path=off;upstream cache_server&#123; server 121.42.11.34:1010; server 121.42.11.34:1020;&#125;server &#123; listen 80; server_name cache.lion.club; location / &#123; proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的 proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟 proxy_cache_key $request_uri; # 缓存文件的key为请求的URI add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端 proxy_pass http://cache_server; # 代理转发 &#125;&#125; 缓存就是这样配置，我们可以在 /etc/nginx/cache_temp 路径下找到相应的缓存文件。 对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。 12345678910111213141516171819...server &#123; listen 80; server_name cache.lion.club; # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot; if ($request_uri ~ \\.(txt|text)$) &#123; set $cache_name &quot;no cache&quot; &#125; location / &#123; proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存 proxy_cache cache_zone; # 设置缓存内存 proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟 proxy_cache_key $request_uri; # 缓存文件的key为请求的URI add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端 proxy_pass http://cache_server; # 代理转发 &#125;&#125; HTTPS**** 在学习如何配置 HTTPS 之前，我们先来简单回顾下 HTTPS 的工作流程是怎么样的？它是如何进行加密保证安全的？ HTTPS 工作流程 \\1. 客户端（浏览器）访问 https://www.baidu.com 百度网站； \\2. 百度服务器返回 HTTPS 使用的 CA 证书； \\3. 浏览器验证 CA 证书是否为合法证书； \\4. 验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密； \\5. 发送公钥加密后的随机数给百度服务器； \\6. 百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）； \\7. 百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器； \\8. 此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容； 这就是 HTTPS 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。 关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。 配置证书下载证书的压缩文件，里面有个 Nginx 文件夹，把 xxx.crt 和 xxx.key 文件拷贝到服务器目录，再进行如下配置： 12345678910111213server &#123; listen 443 ssl http2 default_server; # SSL 访问端口号为 443 server_name lion.club; # 填写绑定证书的域名(我这里是随便写的) ssl_certificate /etc/nginx/https/lion.club_bundle.crt; # 证书地址 ssl_certificate_key /etc/nginx/https/lion.club.key; # 私钥地址 ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2] location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125; 如此配置后就能正常访问 HTTPS 版的网站了。 配置跨域 CORS 先简单回顾下跨域究竟是怎么回事。 跨域的定义 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 同源的定义 如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 下面给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例: 1234http://store.company.com/dir2/other.html 同源https://store.company.com/secure.html 不同源，协议不同http://store.company.com:81/dir/etc.html 不同源，端口不同http://news.company.com/dir/other.html 不同源，主机不同 不同源会有如下限制： Web 数据层面，同源策略限制了不同源的站点读取当前站点的 Cookie 、 IndexDB 、 LocalStorage 等数据。 DOM 层面，同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。 网络层面，同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。 Nginx 解决跨域的原理例如： 前端 server 的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在 fe.server.com 对 dev.server.com 发起请求一定会出现跨域。 现在我们只需要启动一个 Nginx 服务器，将 server_name 设置为 fe.server.com 然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回 dev.server.com 。如下面的配置： 1234567server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略：fe.server.com 访问 Nginx 的 fe.server.com 属于同源访问，而 Nginx 对服务端转发的请求不会触发浏览器的同源策略。 配置开启 gzip 压缩 GZIP 是规定的三种标准 HTTP 压缩格式之一。目前绝大多数的网站都在使用 GZIP 传输 HTML 、CSS 、 JavaScript 等资源文件。 对于文本文件， GZiP 的效果非常明显，开启后传输所需流量大约会降至 1/4~1/3 。 并不是每个浏览器都支持 gzip 的，如何知道客户端是否支持 gzip 呢，请求头中的 Accept-Encoding 来标识对压缩的支持。 启用 gzip 同时需要客户端和服务端的支持，如果客户端支持 gzip 的解析，那么只要服务端能够返回 gzip 的文件就可以启用 gzip 了,我们可以通过 Nginx 的配置来让服务端支持 gzip 。下面的 respone 中 content-encoding:gzip ，指服务端开启了 gzip 的压缩方式。 在 /etc/nginx/conf.d/ 文件夹中新建配置文件 gzip.conf ： 123456789101112131415161718192021222324252627# # 默认off，是否开启gzipgzip on;# 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;# ---- 以上两个参数开启就可以支持Gzip压缩了 ---- ## 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；gzip_static on;# 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；gzip_proxied any;# 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；gzip_vary on;# gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；gzip_comp_level 6;# 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；gzip_buffers 16 8k;# 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；# gzip_min_length 1k;# 默认 1.1，启用 gzip 所需的 HTTP 最低版本；gzip_http_version 1.1; 其实也可以通过前端构建工具例如 webpack 、rollup 等在打生产包时就做好 Gzip 压缩，然后放到 Nginx 服务器中，这样可以减少服务器的开销，加快访问速度。 关于 Nginx 的实际应用就学习到这里，相信通过掌握了 Nginx 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 Nginx 的架构。 Nginx 架构 进程结构 多进程结构 Nginx 的进程模型图： 多进程中的 Nginx 进程架构如下图所示，会有一个父进程（ Master Process ），它会有很多子进程（ Child Processes ）。 Master Process 用来管理子进程的，其本身并不真正处理用户请求。 某个子进程 down 掉的话，它会向 Master 进程发送一条消息，表明自己不可用了，此时 Master 进程会去新起一个子进程。 某个配置文件被修改了 Master 进程会去通知 work 进程获取新的配置信息，这也就是我们所说的热部署。 子进程间是通过共享内存的方式进行通信的。 配置文件重载原理reload 重载配置文件的流程： \\1. 向 master 进程发送 HUP 信号（ reload 命令）； 2. master 进程检查配置语法是否正确； 3. master 进程打开监听端口； 4. master 进程使用新的配置文件启动新的 worker 子进程； 5. master 进程向老的 worker 子进程发送 QUIT 信号； \\6. 老的 worker 进程关闭监听句柄，处理完当前连接后关闭进程； \\7. 整个过程 Nginx 始终处于平稳运行中，实现了平滑升级，用户无感知； Nginx 模块化管理机制Nginx 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。Nginx 的模块是互相独立的,低耦合高内聚。","tags":["Nginx"],"categories":["公众号","稀土掘金"]},{"title":"Nginx从安装到高可用","path":"/832692b3/","content":"Nginx从安装到高可用一、Nginx安装 1、去官网http://nginx.org/下载对应的nginx包，推荐使用稳定版本2、上传nginx到linux系统3、安装依赖环境（1)安装gcc环境 1yum install gcc-c++ (2)安装PCRE库，用于解析正则表达式 1yum install -y pcre pcre-devel (3)zlib压缩和解压缩依赖 1yum install -y zlib zlib-devel (4)SSL 安全的加密的套接字协议层，用于HTTP安全传输，也就是https 1yum install -y openssl openssl-devel 4、解压，需要注意，解压后得到的是源码，源码需要编译后才能安装1tar -zxvf nginx-1.16.1.tar.gz 5、编译之前，先创建nginx临时目录，如果不创建，在启动nginx的过程中会报错1mkdir /var/temp/nginx -p 6、在nginx目录，输入如下命令进行配置，目的是为了创建makefile文件123456789101112./configure \\ --prefix=/usr/local/nginx \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi 注：代表在命令行中换行，用于提高可读性配置命令： 7、make编译&amp;安装12makemake install 8、进入sbin目录启动nginx123启动：nginx停止：./nginx -s stop重新加载：./nginx -s reload 二、配置反向代理1、配置upstream 12345upstream [proxyName] &#123; server 192.168.1.173:8080; server 192.168.1.174:8080; server 192.168.1.175:8080;&#125; 2、配置server 12345678server &#123; listem 80; server_name www.tomcats.com; location / &#123; proxy_pass http://tomcats; &#125;&#125; 三、配置负载均衡nginx默认采用轮训的方式进行负载均衡 1、使用加权轮询 12345upstream [proxyName] &#123; server 192.168.1.173:8080 weight=1; server 192.168.1.174:8080 weight=5; server 192.168.1.175:8080 weight=2;&#125; 2、hash负载均衡 1234567upstream [proxyName] &#123; ip_hash server 192.168.1.173:8080; server 192.168.1.174:8080; server 192.168.1.175:8080;&#125; hash算法实际上只会计算 192.168.1这段做哈希 使用ip_hash的注意点： 不能把后台服务器直接移除，只能标记down. 3、url hash负载均衡 1234567upstream [proxyName] &#123; hash $request_url; server 192.168.1.173:8080; server 192.168.1.174:8080; server 192.168.1.175:8080;&#125; 4、最小连接负载均衡 1234567upstream [proxyName] &#123; least_conn; server 192.168.1.173:8080; server 192.168.1.174:8080; server 192.168.1.175:8080;&#125; 四、upstream指令参数max_conns：限制最大同时连接数 1.11.5之前只能用于商业版 slow_start：单位秒，权重在指定时间内从1上升到指定值，不适用与hash负载均衡、随机负载均衡 如果在 upstream 中只有一台 server，则该参数失效（商业版才有） down：禁止访问 backup：备用机 只有在其他服务器无法访问的时候才能访问到 不适用与hash负载均衡、随机负载均衡 max_fails：表示失败几次，则标记server已宕机，剔出上游服务 默认值1 fail_timeout：表示失败的重试时间 默认值10 1、keepalived 123456789101112131415161718upstream [proxyName] &#123; server 192.168.1.173:8080 weight=1; server 192.168.1.174:8080 weight=5; server 192.168.1.175:8080 weight=2; keepalive 32; #保持的连接数&#125;server &#123; listem 80; server_name www.tomcats.com; location / &#123; proxy_pass http://tomcats; proxy_http_version 1.1; #连接的协议版本 proxy_set_header Connection &quot;&quot;; 清空连接请求头 &#125;&#125; 2、控制浏览器缓存 1234567891011121314server &#123; listem 80; server_name www.tomcats.com; location / &#123; proxy_pass http://tomcats; expires 10s; #浏览器缓存10秒钟 #expires @22h30m #在晚上10点30的时候过期 #expires -1h #缓存在一小时前时效 #expires epoch #不设置缓存 #expires off #缓存关闭，浏览器自己控制缓存 #expires max #最大过期时间 &#125;&#125; 3、反向代理缓存 12345678910111213141516171819202122232425upstream [proxyName] &#123; server 192.168.1.173:8080 weight=1; server 192.168.1.174:8080 weight=5; server 192.168.1.175:8080 weight=2;&#125;#proxy_cache_path 设置缓存保存的目录的位置#keys_zone设置共享内以及占用的空间大小#mas_size 设置缓存最大空间#inactive 缓存过期时间，错过此时间自动清理#use_temp_path 关闭零时目录proxy_cache_path /usr/local/nginx/upsteam_cache keys_zone=mycache:5m max_size=1g inactive=8h use_temp_path=off;server &#123; listem 80; server_name www.tomcats.com; #开启并使用缓存 proxy_cache mycache; #针对200和304响应码的缓存过期时间 proxy_cache_valid 200 304 8h; location / &#123; proxy_pass http://tomcats; &#125;&#125; 五、配置ssl证书提供https访问1. 安装SSL模块要在nginx中配置https，就必须安装ssl模块，也就是: http_ssl_module。 进入到nginx的解压目录：/home/software/nginx-1.16.1 新增ssl模块(原来的那些模块需要保留) 12345678910111213./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi \\--with-http_ssl_module 编译和安装 12makemake install 2、配置HTTPS把ssl证书 *.crt 和 私钥 *.key 拷贝到/usr/local/nginx/conf目录中。 新增 server 监听 443 端口： 1234567891011121314151617181920212223server &#123; listen 443; server_name www.imoocdsp.com; # 开启ssl ssl on; # 配置ssl证书 ssl_certificate 1_www.imoocdsp.com_bundle.crt; # 配置证书秘钥 ssl_certificate_key 2_www.imoocdsp.com.key; # ssl会话cache ssl_session_cache shared:SSL:1m; # ssl会话超时时间 ssl_session_timeout 5m; # 配置加密套件，写法遵循 openssl 标准 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://tomcats/; index index.html index.htm; &#125;&#125; 六、配置ha nginx1、安装keepalived(1)下载 1https://www.keepalived.org/download.html (2)解压 1tar -zxvf keepalived-2.0.18.tar.gz (3)使用configure命令配置安装目录与核心配置文件所在位置： 1./configure --prefix=/usr/local/keepalived --sysconf=/etc prefix：keepalived安装的位置sysconf：keepalived核心配置文件所在位置，固定位置，改成其他位置则keepalived启动不了，/var/log/messages中会报错 sysconf：keepalived核心配置文件所在位置，固定位置，改成其他位置则keepalived启动不了，/var/log/messages中会报错 配置过程中可能会出现警告信息，如下所示： 1234*** WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-3 dev libraries to support IPv6 with IPVS.# 安装libnl/libnl-3依赖yum -y install libnl libnl-devel (4)安装keepalived 1make &amp;&amp; make install (5)配置文件 在/etc/keepalived/keepalived.conf (6)忘记安装配置的目录，则通过如下命令找到： 1whereis keepalived (7)启动keepalived 进入sbin目录 1./keepalived 2、配置keepalived 主机(1)通过命令 vim keepalived.conf 打开配置文件 1234567891011121314151617181920212223242526global_defs &#123; # 路由id：当前安装keepalived的节点主机标识符，保证全局唯一 router_id keep_171 &#125; vrrp_instance VI_1 &#123; # 表示状态是MASTER主机还是备用机BACKUP state MASTER # 该实例绑定的网卡 interface ens33 # 保证主备节点一致即可 virtual_router_id 51 # 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选 priority 100 # 主备之间同步检查时间间隔，单位秒 advert_int 2 # 认证权限密码，防止非法节点进入 authentication &#123; auth_type PASS auth_pass 1111 &#125; # 虚拟出来的ip，可以有多个（vip） virtual_ipaddress &#123; 192.168.1.161 &#125;&#125; 附：查看网卡信息命令 1ip addr (2)启动keepalived (3)查看进程 1ps -ef|grep keepalived (4)查看vip(虚拟ip) 在网卡ens33下，多了一个192.168.1.161，这个就是虚拟ip 3、把keepalived注册为系统服务(1)拷贝配置文件 将keepalived目录下etc/init.d/keepalived拷贝到/etc/init.d/下 将keepalived目录下etc/sysconfig/keepalived拷贝到/etc/sysconfig/下 (2)刷新systemctl 1systemctl daemon-reload (3)启动、停止、重启keepalived 123456#启动systemctl start keepalived.service#停止systemctl stop keepalived.service#重启systemctl restart keepalived.service 4、实现双机主备高可用 (1)修改备机配置 12345678910111213141516171819global_defs &#123; router_id keep_172 &#125; vrrp_instance VI_1 &#123; # 备用机设置为BACKUP state BACKUP interface ens33 virtual_router_id 51 # 权重低于MASTER priority 80 advert_int 2 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; # 注意：主备两台的vip都是一样的，绑定到同一个vip 192.168.1.161 &#125; &#125; (2) 启动 Keepalived (3) 访问vip即可访问主机，当主机失效时访问vip就会访问到备机 5、keepalived配置nginx自动重启(1)编写脚本 在/etc/keepalived/下创建脚本check_nginx_alive_or_not 123456789101112#!/bin/bash A=`ps -C nginx --no-header |wc -l` # 判断nginx是否宕机，如果宕机了，尝试重启 if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx # 等待一小会再次检查nginx，如果没有启动成功，则停止keepalived，使其启动备用机 sleep 3 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fi fi (2)添加运行权限 1chmod +x /etc/keepalived/check_nginx_alive_or_not.sh (3)配置keepalived监听nginx脚本 12345vrrp_script check_nginx_alive &#123; script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot; interval 2 # 每隔两秒运行上一行脚本 weight 10 # 如果脚本运行失败，则升级权重+10 &#125; (4)在vrrp_instance中新增监控的脚本 123track_script &#123; check_nginx_alive # 追踪 nginx 脚本&#125; (5)重启Keepalived使得配置文件生效 1systemctl restart keepalived 6、keepalived双主热备(1)配置DNS轮询 在同一个域名下配置两个ip，自行百度 (2)配置第一台主机 1234567891011121314151617181920212223242526272829303132global_defs &#123; router_id keep_171 &#125; vrrp_instance VI_1 &#123; state MASTER i nterface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.161 &#125; &#125; vrrp_instance VI_2 &#123; state BACKUP interface ens33 virtual_router_id 52 priority 80 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.162 &#125;&#125; (3)配置第二台主机 1234567891011121314151617181920212223242526272829303132global_defs &#123; router_id keep_172 &#125; vrrp_instance VI_1 &#123; state BACKUP interface ens33 virtual_router_id 51 priority 80 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.161 &#125;&#125; vrrp_instance VI_2 &#123; state MASTER interface ens33 virtual_router_id 52 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.162 &#125;&#125; (4)重启两台Keepalived 1systemctl restart keepalived 七、LVS（Linux Virtual Server）实现高可用负载均衡1、为什么要使用LVS+Nginx lvs基于四层负载均衡，工作效率较Nginx的七层负载更高，使用LVS搭建Nginx集群，可以提高性能 四层负载均衡无法对信息处理，只能通过ip+端口的形式转发，所以需要七成负载进行数据的处理 Nginx接收请求来回，LVS可以只接受不响应 2、LVS的三种模式(1)NAT模式 客户端将请求发往LVS，LVS会选择一台服务器响应请求，服务器将结果返回给LVS，LVS再返回给客户端。 在NAT模式中，服务器的网关必须指向LVS，否则报文无法送达客户端 NAT 技术将请求的报文和响应的报文都需要通过LVS进行地址改写，因此网站访问量比较大的时候负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点 NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致 (2)TUN模式 客户端将请求发往LVS，LVS会选择一台服务器响应请求，在客户端与服务器之间建立隧道，返回结果的时候直接由服务器返回响应，不在经过LVS。 TUN模式必须所有的服务器上都绑定VIP的IP地址，所有的服务器都必须有网卡。 TUN模式走隧道运维难度大，并且会直接暴露服务器地址 服务器将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多服务器进行分发。而且跑在公网上就能进行不同地域的分发 (3)DR模式 客户端将请求发往LVS，LVS会选择一台服务器响应请求，返回结果的时候通过统一的路由进行返回，不在经过LVS。 和TUN模式一样，LVS只是分发请求，应答包通过单独的路由返回给客户端，与TUN相比这种方式不需要隧道结构，可以兼容大多数的操作系统，同时统一路由可以隐藏真实的物理服务器。DR模式效率更高，但配置更复杂. 所有服务器节点和LVS只能在一个局域网里面。 3、搭建LVS-DR模式先关闭掉服务器上网络配置管理器，避免网络接口冲突 12systemctl stop NetworkManagersystemctl disable NetworkManager (1)创建子接口（创建LVS的虚拟ip） 进入网卡配置目录/etc/sysconfig/network-scripts/,找到网卡配置文件，这里以ifcfg-ens33为例，拷贝并创建子接口 1cp ifcfg-ens33 ifcfg-ens33:1 修改子接口配置如下 配置中的 192.168.1.150 就是vip，是提供给外网用户访问的ip地址 12345DEVICE=&quot;ens33:1&quot;ONBOOT=&quot;yes&quot;IPADDR=192.168.1.150NETMASK=255.255.255.0BOOTPROTO=static 重启网络服务 1service network restart 重启成功后，ip addr 查看一下，你会发现多了一个ip，也就是虚拟ip（vip） 注意：阿里云不支持配置网卡，需要购买相应的负载均衡服务，腾讯云支持配置网卡，但需要购买网卡支持，一个网卡支持10个虚拟ip配置 (2)安装ipvsadm 如今的centos都集成了LVS，所以ipvs是自带的，我们只需要安装ipvsadm即可（ipvsadm是管理集群的工具，通过ipvs可以管理集群，查看集群等操作） 1yum install ipvsadm (3)配置服务器（RS）的虚拟ip 进入网卡配置目录/etc/sysconfig/network-scripts/,找到ifcfg-lo，拷贝并创建子接口 1cp ifcfg-lo ifcfg-lo:1 修改子接口配置如下 1234567DEVICE=&quot;lo:1&quot;IPADDR=192.168.1.150NETMASK=255.255.255.255NETWORK=127.0.0.0BROADCAST=127.255.255.255ONBOOT=&quot;yes&quot;NAME=loopback 重启网络服务成功后，ip addr 查看一下，你会发现多了一个ip，也就是虚拟ip（vip） (4)为服务器（RS）配置arp ARP响应级别与通告行为参数说明 123456arp-ignore：ARP响应级别（处理请求） 0：只要本机配置了ip，就能响应请求 1：请求的目标地址到达对应的网络接口，才会响应请求arp-announce：ARP通告行为（返回响应） 0：本机上任何网络接口都向外通告，所有的网卡都能接受到通告 1：尽可能避免本网卡与不匹配的目标进行通告2：只在本网卡通告 打开sysctl.conf: 1vim /etc/sysctl.conf 配置所有网卡、默认网卡以及虚拟网卡的arp响应级别和通告行为，分别对应：all，default，lo 12345678# configration for lvs net.ipv4.conf.all.arp_ignore = 1 net.ipv4.conf.default.arp_ignore = 1 net.ipv4.conf.lo.arp_ignore = 1 net.ipv4.conf.all.arp_announce = 2 net.ipv4.conf.default.arp_announce = 2 net.ipv4.conf.lo.arp_announce = 2 刷新配置文件 1sysctl -p 增加一个网关，用于接收数据报文，当有请求到本机后，会交给lo去处理 1route add -host 192.168.1.150 dev lo:1 将网关添加至开机启动 1echo &quot;route add -host 192.168.1.150 dev lo:1&quot; &gt;&gt; /etc/rc.local (4)使用ipvsadm配置集群规则 创建LVS节点，用户访问的集群调度者 1ipvsadm -A -t 192.168.1.150:80 -s rr -p 5 -A：添加集群 -t：tcp协议ip地址：设定集群的访问 ip：也就是LVS的虚拟ip -s：设置负载均衡的算法， rr：表示轮询 -p：设置连接持久化的时间,在指定时间内同一个用户的请求会访问到同一个服务器中 创建多台RS真实服务器 12ipvsadm -a -t 192.168.1.150:80 -r 192.168.1.171:80 -g ipvsadm -a -t 192.168.1.150:80 -r 192.168.1.172:80 -g -a：添加真实服务器 -t：tcp协议 -r：真实服务器的ip地址 -g：设定DR模式 保存到规则库，否则重启失效 1ipvsadm -S 检查集群 1234#查看集群列表ipvsadm -Ln#查看集群状态ipvsadm -Ln --stats 一些其他命令 12345678910# 重启ipvsadm，重启后需要重新配置 service ipvsadm restart # 查看持久化连接 ipvsadm -Ln --persistent-conn # 查看连接请求过期时间以及请求源ip和目标ip ipvsadm -Lnc # 设置tcp tcpfin udp 的过期时间（一般保持默认） ipvsadm --set 1 1 1 # 查看过期时间 ipvsadm -Ln --timeout (5)访问虚拟ip，完成LVS搭建 附：LVS的负载均衡算法(1)静态算法静态：根据LVS本身自由的固定的算法分发用户请求。 轮询（Round Robin 简写’rr’）：轮询算法假设所有的服务器处理请求的能力都一样的，调度器会把所有的请求平均分配给每个真实服务器。（同Nginx的轮询） 加权轮询（Weight Round Robin 简写’wrr’）：安装权重比例分配用户请求。权重越高，被分配到处理的请求越多。（同Nginx的权重） 源地址散列（Source Hash 简写’sh’）：同一个用户ip的请求，会由同一个RS来处理。（同Nginx的ip_hash） 目标地址散列（Destination Hash 简写’dh’）：根据url的不同，请求到不同的RS。（同Nginx的url_hash） (2)动态算法动态：会根据流量的不同，或者服务器的压力不同来分配用户请求，这是动态计算的。 最小连接数（Least Connections 简写’lc’）：把新的连接请求分配到当前连接数最小的服务器。 加权最少连接数（Weight Least Connections 简写’wlc’）：服务器的处理性能用数值来代表，权重越大处理的请求越多。Real Server 有可能会存在性能上的差异，wlc动态获取不同服务器的负载状况，把请求分发到性能好并且比较空闲的服务器。 最短期望延迟（Shortest Expected Delay 简写’sed’）：特殊的wlc算法。举例阐述，假设有ABC三台服务器，权重分别为1、2、3 。如果使用wlc算法的话，当一个新请求进来，它可能会分给ABC中的任意一个。使用sed算法后会进行如下运算： A：（1+1）&#x2F;1&#x3D;2 B：（1+2）&#x2F;2&#x3D;3&#x2F;2 C：（1+3）&#x2F;3&#x3D;4&#x2F;3 最终结果，会把这个请求交给得出运算结果最小的服务器。最少队列调度（Never Queue 简写’nq’）：永不使用队列。如果有Real Server的连接数等于0，则直接把这个请求分配过去，不需要在排队等待运算了（sed运算）。 八、搭建Keepalived+Lvs+Nginx高可用集群负载均衡如果原先服务器上配置了LVS+nginx需要清空ipvsadm中的配置 1ipvsadm -C 如果配置了Keepalived+Nginx双主集群也需要去除掉Keepalived中原先的配置，按照的后文进行配置 (1)使用keepalived配置Master LVS在LVS的机器上安装keepalived，安装过程参考上文 (1)修改keepalived的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657global_defs &#123; router_id keep_151 &#125; vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 41 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.150 &#125;&#125; #配置集群访问的ip+端口，端口和nginx保持一致virtual_server 192.168.1.150 80&#123; #健康检查的时间，单位：秒 delay_loop 6 #配置负载均衡的算法，默认的轮询 lb_algo rr #设置LVS的模式 NAT|TUN|DR lb-kind DR #设置会话持久化的时间 persistence_timeout 5 #协议 protocol TCP #配置负载均衡的真实服务器，也就是nginx节点的具体的ip地址 real_server 192.168.1.171 80&#123; #轮询权重配比 weight 1 #设置健康检查 TCP_CHECK &#123; #检查80端口 connect_port 80 #超时时间 connect_timeout 2 #重试次数 nb_get_retry 2 #重试间隔时间 delay_before_retry 3 &#125; &#125; real_server 192.168.1.171 80&#123; weight 1 TCP_CHECK &#123; connect_port 80 connect_timeout 2 nb_get_retry 2 delay_before_retry 3 &#125; &#125;&#125; (2)启动&#x2F;重启keepalived 1systemctl restart keepalived (2)使用keepalived配置Backup LVS配置在备用机上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657global_defs &#123; router_id keep_152 &#125; vrrp_instance VI_1 &#123; state BACKUP interface ens33 virtual_router_id 41 priority 50 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.150 &#125;&#125; #配置集群访问的ip+端口，端口和nginx保持一致virtual_server 192.168.1.150 80&#123; #健康检查的时间，单位：秒 delay_loop 6 #配置负载均衡的算法，默认的轮询 lb_algo rr #设置LVS的模式 NAT|TUN|DR lb-kind DR #设置会话持久化的时间 persistence_timeout 5 #协议 protocol TCP #配置负载均衡的真实服务器，也就是nginx节点的具体的ip地址 real_server 192.168.1.171 80&#123; #轮询权重配比 weight 1 #设置健康检查 TCP_CHECK &#123; #检查80端口 connect_port 80 #超时时间 connect_timeout 2 #重试次数 nb_get_retry 2 #重试间隔时间 delay_before_retry 3 &#125; &#125; real_server 192.168.1.171 80&#123; weight 1 TCP_CHECK &#123; connect_port 80 connect_timeout 2 nb_get_retry 2 delay_before_retry 3 &#125; &#125;&#125;","tags":["Nginx"],"categories":["公众号"]},{"title":"Linux命令总结","path":"/51ea15a6/","content":"2 W 字的 Linux 命令总结！Linux 基础 操作系统 操作系统 Operating System 简称 OS ，是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁。 操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序。 操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序。 什么是 LinuxLinux 系统内核与 Linux 发行套件的区别 Linux 系统内核指的是由 Linus Torvalds 负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。 Linux 发行套件系统是我们常说的 Linux 操作系统，也即是由 Linux 内核与各种常用软件的集合产品。 总结：真正的 Linux 指的是系统内核，而我们常说的 Linux 指的是“发行版完整的包含一些基础软件的操作系统”。 Linux 对比 Windows 稳定且有效率； 免费（或少许费用）； 漏洞少且快速修补； 多任务多用户； 更加安全的用户与文件权限策略； 适合小内核程序的嵌入系统； 相对不耗资源。 Linux 系统种类 红帽企业版 Linux ：RHEL 是全世界内使用最广泛的 Linux 系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。 Fedora ：由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 RHEL 系统中，因此 Fedora 也成为 RHEL 系统的试验版本。 CentOS ：通过把 RHEL 系统重新编译并发布给用户免费使用的 Linux 系统，具有广泛的使用人群。 Deepin ：中国发行，对优秀的开源成品进行集成和配置。 Debian ：稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。 Ubuntu ：是一款派生自 Debian 的操作系统，对新款硬件具有极强的兼容能力。Ubuntu 与 Fedora 都是极其出色的 Linux 桌面系统，而且 Ubuntu 也可用于服务器领域。 终端连接阿里云服务器 通过执行 ssh root@121.42.11.34 命令，然后输入服务器连接密码就可以顺利登陆远程服务器。从现在开始我们就可以在本地电脑操作远程服务器。 这个黑色的面板就是终端也就是 Shell （命令行环境）。 ssh root@xxx 这是一条命令，必须要在 Shell 中才能执行。 ShellShell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。 Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（ command line interface ，简写为 CLI ）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。 Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为 Shell 脚本。这些脚本都通过Shell 的解释执行，而不通过编译。 Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。 Shell 的种类Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell 。 历史上，主要的 Shell 有下面这些： Bourne Shell（sh） Bourne Again shell（bash） C Shell（csh） TENEX C Shell（tcsh） Korn shell（ksh） Z Shell（zsh） Friendly Interactive Shell（fish） 其中 Bash 是目前最常用的 Shell 。MacOS 中的默认 Shell 就是 Bash 。 通过执行 echo $SHELL 命令可以查看到当前正在使用的 Shell 。还可以通过 cat /etc/shells 查看当前系统安装的所有 Shell 种类。 命令命令行提示符进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 $ 结尾，用户可以在这个符号后面输入各种命令。 执行一个简单的命令 pwd ： 12[root@iZm5e8dsxce9ufaic7hi3uZ ~]# pwd/root 命令解析： root：表示用户名； iZm5e8dsxce9ufaic7hi3uZ：表示主机名； ~：表示目前所在目录为家目录，其中 root 用户的家目录是 /root 普通用户的家目录在 /home 下； #：指示你所具有的权限（ root 用户为 # ，普通用户为 $ ）。 执行 whoami 命令可以查看当前用户名； 执行 hostname 命令可以查看当前主机名； 关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用 root 用户进行演示。 [备注] root 是超级用户，具备操作系统的一切权限。 命令格式1command parameters（命令 参数） 长短参数12345单个参数：ls -a（a 是英文 all 的缩写，表示“全部”）多个参数：ls -al（全部文件 + 列表形式展示）单个长参数：ls --all多个长参数：ls --reverse --all长短混合参数：ls --all -l 参数值12短参数：command -p 10（例如：ssh root@121.42.11.34 -p 22）长参数：command --paramters=10（例如：ssh root@121.42.11.34 --port=22） 快捷方式在开始学习 Linux 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 Linux 使用生涯。 通过上下方向键 ↑ ↓ 来调取过往执行过的 Linux 命令； 命令或参数仅需输入前几位就可以用 Tab 键补全； Ctrl + R ：用于查找使用过的命令（history 命令用于列出之前使用过的所有命令，然后输入 ! 命令加上编号( !2 )就可以直接执行该历史命令）； Ctrl + L：清除屏幕并将当前行移到页面顶部； Ctrl + C：中止当前正在执行的命令； Ctrl + U：从光标位置剪切到行首； Ctrl + K：从光标位置剪切到行尾； Ctrl + W：剪切光标左侧的一个单词； Ctrl + Y：粘贴 Ctrl + U | K | Y 剪切的命令； Ctrl + A：光标跳到命令行的开头； Ctrl + E：光标跳到命令行的结尾； Ctrl + D：关闭 Shell 会话； 文件和目录文件的组织 查看路径pwd显示当前目录的路径 which查看命令的可执行文件所在路径， Linux 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， which 命令本身对应的程序也存在于 Linux 中。 总的来说一个命令就是一个可执行程序。 浏览和切换目录ls列出文件和目录，它是 Linux 最常用的命令之一。 【常用参数】 -a 显示所有文件和目录包括隐藏的 -l 显示详细列表 -h 适合人类阅读的 -t 按文件最近一次修改时间排序 -i 显示文件的 inode （ inode 是文件内容的标识） cdcd 是英语 change directory 的缩写，表示切换目录。 123456cd / --&gt; 跳转到根目录cd ~ --&gt; 跳转到家目录cd .. --&gt; 跳转到上级目录cd ./home --&gt; 跳转到当前目录的home目录下cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录cd --&gt; 不添加任何参数，也是回到家目录 [注意] 输入cd /ho + 单次 tab 键会自动补全路径 + 两次 tab 键会列出所有可能的目录列表。 du列举目录大小信息。 【常用参数】 -h 适合人类阅读的； -a 同时列举出目录下文件的大小信息； -s 只显示总计大小，不显示具体信息。 浏览和创建文件cat一次性显示文件所有内容，更适合查看小的文件。 1cat cloud-init.log 【常用参数】 -n 显示行号。 less分页显示文件内容，更适合查看大的文件。 1less cloud-init.log 【快捷操作】 空格键：前进一页（一个屏幕）； b 键：后退一页； 回车键：前进一行； y 键：后退一行； 上下键：回退或前进一行； d 键：前进半页； u 键：后退半页； q 键：停止读取文件，中止 less 命令； = 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息； h 键：显示帮助文档； / 键：进入搜索模式后，按 n 键跳到一个符合项目，按 N 键跳到上一个符合项目，同时也可以输入正则表达式匹配。 head显示文件的开头几行（默认是10行） 1head cloud-init.log 【参数】 -n 指定行数 head cloud-init.log -n 2 tail显示文件的结尾几行（默认是10行） 1tail cloud-init.log 【参数】 -n 指定行数 tail cloud-init.log -n 2 -f 会每过1秒检查下文件是否有更新内容，也可以用 -s 参数指定间隔时间 tail -f -s 4 xxx.log touch创建一个文件 1touch new_file mkdir创建一个目录 1mkdir new_folder 【常用参数】 -p 递归的创建目录结构 mkdir -p one/two/three 文件的复制和移动cp拷贝文件和目录 1234cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件cp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 filecp file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copycp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下 【常用参数】 -r 递归的拷贝，常用来拷贝一整个目录 mv移动（重命名）文件或目录，与cp命令用法相似。 1234mv file one --&gt; 将 file 文件移动到 one 目录下mv new_folder one --&gt; 将 new_folder 文件夹移动到one目录下mv *.txt folder --&gt; 把当前目录下所有 txt 文件移动到 folder 目录下mv file new_file --&gt; file 文件重命名为 new_file 文件的删除和链接rm删除文件和目录，由于 Linux 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作 12rm new_file --&gt; 删除 new_file 文件rm f1 f2 f3 --&gt; 同时删除 f1 f2 f3 3个文件 【常用参数】 -i 向用户确认是否删除； -f 文件强制删除； -r 递归删除文件夹，著名的删除操作 rm -rf 。 ln英文 Link 的缩写，表示创建链接。 学习创建链接之前，首先要理解链接是什么，我们先来看看 Linux 的文件是如何存储的： Linux 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 inode 标识绑定到文件内容。 Linux 下有两种链接类型：硬链接和软链接。 硬链接使链接的两个文件共享同样文件内容，就是同样的 inode ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。 1ln file1 file2 --&gt; 创建 file2 为 file1 的硬链接 如果我们用 rm file1 来删除 file1 ，对 file2 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 file1 与file2 后，它们共同指向的文件内容才会消失。 软链接软链接就类似 windows 下快捷方式。 1ln -s file1 file2 执行 ls -l 命名查看当前目录下文件的具体信息 123total 0-rw-r--r-- 1 root root 0 Jan 14 06:29 file1lrwxrwxrwx 1 root root 5 Jan 14 06:42 file2 -&gt; file1 # 表示file2 指向 file1 其实 file2 只是 file1 的一个快捷方式，它指向的是 file1 ，所以显示的是 file1 的内容，但其实 file2 的 inode 与 file1 并不相同。如果我们删除了 file2 的话， file1是不会受影响的，但如果删除 file1 的话， file2 就会变成死链接，因为指向的文件不见了。 用户与权限用户Linux 是一个多用户的操作系统。在 Linux 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 root ，是一个很特殊的用户，它是超级用户，拥有最高权限。 自己创建的用户是有限权限的用户，这样大大提高了 Linux 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 sudo 命令。 sudo以 root 身份运行命令 1sudo date --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的复制代码 useradd + passwd useradd 添加新用户 passwd 修改用户密码 这两个命令需要 root 用户权限 12useradd lion --&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看passwd lion --&gt; 修改lion用户的密码复制代码 userdel删除用户，需要 root 用户权限 12userdel lion\t--&gt; 只会删除用户名，不会从/home中删除对应文件夹userdel lion -r\t--&gt; 会同时删除/home下的对应文件夹 su切换用户，需要 root 用户权限 123sudo su\t--&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）su lion\t--&gt; 切换为普通用户su -\t--&gt; 切换为root用户 群组的管理Linux 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。 groupadd创建群组，用法和 useradd 类似。 1groupadd friends groupdel删除一个已存在的群组 1groupdel foo --&gt; 删除foo群组 groups查看用户所在群组 1groups lion --&gt; 查看 lion 用户所在的群组 usermod用于修改用户的账户。 【常用参数】 -l 对用户重命名。需要注意的是 /home 中的用户家目录的名字不会改变，需要手动修改。 -g 修改用户所在的群组，例如 usermod -g friends lion 修改 lion 用户的群组为 friends 。 -G 一次性让用户添加多个群组，例如 usermod -G friends,foo,bar lion 。 -a -G 会让你离开原先的群组，如果你不想这样做的话，就得再添加 -a 参数，意味着 append 追加的意思。 chgrp用于修改文件的群组。 1chgrp bar file.txt\t--&gt; file.txt文件的群组修改为bar chown改变文件的所有者，需要 root 身份才能运行。 12chown lion file.txt\t--&gt; 把其它用户创建的file.txt转让给lion用户chown lion:bar file.txt\t--&gt; 把file.txt的用户改为lion，群组改为bar 【常用参数】 -R 递归设置子目录和子文件， chown -R lion:lion /home/frank 把 frank 文件夹的用户和群组都改为 lion 。 文件权限管理chmod修改访问权限。 1chmod 740 file.txt 【常用参数】 -R 可以递归地修改文件访问权限，例如 chmod -R 777 /home/lion 修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习 Linux 的文件权限。 1234[root@lion ~]# ls -ldrwxr-xr-x 5 root root 4096 Apr 13 2020 climblrwxrwxrwx 1 root root 7 Jan 14 06:41 hello2.c -&gt; hello.c-rw-r--r-- 1 root root 149 Jan 13 06:14 hello.c 其中 drwxr-xr-x 表示文件或目录的权限。让我们一起来解读它具体代表什么？ d ：表示目录，就是说这是一个目录，普通文件是 - ，链接是 l 。 r ： read 表示文件可读。 w ： write 表示文件可写，一般有写的权限，就有删除的权限。 x ： execute 表示文件可执行。 - ：表示没有相应权限。 权限的整体是按用户来划分的，如下图所示： 现在再来理解这句权限 drwxr-xr-x 的意思： 它是一个文件夹； 它的所有者具有：读、写、执行权限； 它的群组用户具有：读、执行的权限，没有写的权限； 它的其它用户具有：读、执行的权限，没有写的权限。 现在理解了权限，我们使用 chmod 来尝试修改权限。 chmod 它不需要是 root 用户才能运行的，只要你是此文件所有者，就可以用 chmod 来修改文件的访问权限。 数字分配权限 权限 数字 r 4 w 2 x 1 因此要改变权限，只要做一些简单的加法就行： 因此要改变权限，只要做一些简单的加法就行： 12345678chmod 640 hello.c # 分析6 = 4 + 2 + 0 表示所有者具有 rw 权限4 = 4 + 0 + 0 表示群组用户具有 r 权限0 = 0 + 0 + 0 表示其它用户没有权限对应文字权限为：-rw-r----- 用字母来分配权限 u ： user 的缩写，用户的意思，表示所有者。 g ： group 的缩写，群组的意思，表示群组用户。 o ： other 的缩写，其它的意思，表示其它用户。 a ： all 的缩写，所有的意思，表示所有用户。 + ：加号，表示添加权限。 - ：减号，表示去除权限。 = ：等于号，表示分配权限。 1234567chmod u+rx file\t--&gt; 文件file的所有者增加读和运行的权限chmod g+r file\t--&gt; 文件file的群组用户增加读的权限chmod o-r file\t--&gt; 文件file的其它用户移除读的权限chmod g+r o-r file\t--&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限chmod go-r file\t--&gt; 文件file的群组和其他用户移除读的权限chmod +x file\t--&gt; 文件file的所有用户增加运行的权限chmod u=rwx,g=r,o=- file\t--&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限 查找文件locate搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。 安装 locate1234yum -y install mlocate\t--&gt; 安装包updatedb\t--&gt; 更新数据库locate file.txtlocate fil*.txt [注意] locate 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 updatedb 命令去更新数据库。 find用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。 1find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt; 何处：指定在哪个目录查找，此目录的所有子目录也会被查找。 何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。 做什么：找到文件后，可以进行后续处理，如果不指定这个参数， find 命令只会显示找到的文件。 根据文件名查找123456find -name &quot;file.txt&quot;\t--&gt; 当前目录以及子目录下通过名称查找文件find . -name &quot;syslog&quot;\t--&gt; 当前目录以及子目录下通过名称查找文件find / -name &quot;syslog&quot;\t--&gt; 整个硬盘下查找syslogfind /var/log -name &quot;syslog&quot;\t--&gt; 在指定的目录/var/log下查找syslog文件find /var/log -name &quot;syslog*&quot;\t--&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有find /var/log -name &quot;*syslog*&quot;\t--&gt; 查找包含syslog的文件 [注意] find 命令只会查找完全符合 “何物” 字符串的文件，而 locate 会查找所有包含关键字的文件。 根据文件大小查找1234find /var -size +10M\t--&gt; /var 目录下查找文件大小超过 10M 的文件find /var -size -50k\t--&gt; /var 目录下查找文件大小小于 50k 的文件find /var -size +1G\t--&gt; /var 目录下查找文件大小查过 1G 的文件find /var -size 1M\t--&gt; /var 目录下查找文件大小等于 1M 的文件 根据文件最近访问时间查找1find -name &quot;*.txt&quot; -atime -7 --&gt; 近 7天内访问过的.txt结尾的文件 仅查找目录或文件12find . -name &quot;file&quot; -type f --&gt; 只查找当前目录下的file文件find . -name &quot;file&quot; -type d --&gt; 只查找当前目录下的file目录 操作查找结果1234find -name &quot;*.txt&quot; -printf &quot;%p - %u &quot;\t--&gt; 找出所有后缀为txt的文件，并按照 %p - %u 格式打印，其中%p=文件名，%u=文件所有者find -name &quot;*.jpg&quot; -delete\t--&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用find -name &quot;*.c&quot; -exec chmod 600 &#123;&#125; \\;\t--&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，&#123;&#125; 会被查找到的文件替代，\\; 是必须的结尾find -name &quot;*.c&quot; -ok chmod 600 &#123;&#125; \\;\t--&gt; 和上面的功能一直，会多一个确认提示 软件仓库Linux 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。 Red Hat 家族的软件包后缀名一般为 .rpm ， Debian 家族的软件包后缀是 .deb 。 Linux 的包都存在一个仓库，叫做软件仓库，它可以使用 yum 来管理软件包， yum 是 CentOS 中默认的包管理工具，适用于 Red Hat 一族。可以理解成 Node.js 的 npm 。 yum 常用命令 yum update | yum upgrade 更新软件包 yum search xxx 搜索相应的软件包 yum install xxx 安装软件包 yum remove xxx 删除软件包 切换 CentOS 软件源有时候 CentOS 默认的 yum 源不一定是国内镜像，导致 yum 在线安装及更新速度不是很理想。这时候需要将 yum 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。 1、首先备份系统自带 yum 源配置文件 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、下载阿里云的 yum 源配置文件到 /etc/yum.repos.d/CentOS7 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 3、生成缓存 1yum makecache 阅读手册Linux 命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。 man安装更新 man12sudo yum install -y man-pages\t--&gt; 安装sudo mandb\t--&gt; 更新 man 手册种类 可执行程序或 Shell 命令； 系统调用（ Linux 内核提供的函数）； 库调用（程序库中的函数）； 文件（例如 /etc/passwd ）； 特殊文件（通常在 /dev 下）； 游戏； 杂项（ man(7) ，groff(7) ）； 系统管理命令（通常只能被 root 用户使用）； 内核子程序。 man + 数字 + 命令输入 man + 数字 + 命令&#x2F;函数，可以查到相关的命令和函数，若不加数字， man 默认从数字较小的手册中寻找相关命令和函数 12man 3 rand --&gt; 表示在手册的第三部分查找 rand 函数man ls --&gt; 查找 ls 用法手册 man 手册核心区域解析：(以 man pwd 为例) 123456789101112131415161718192021NAME # 命令名称和简单描述 pwd -- return working directory nameSYNOPSIS # 使用此命令的所有方法 pwd [-L | -P]DESCRIPTION # 包括所有参数以及用法 The pwd utility writes the absolute pathname of the current working directory to the standard output. Some shells may provide a builtin pwd command which is similar or identical to this utility. Consult the builtin(1) manual page. The options are as follows: -L Display the logical current working directory. -P Display the physical current working directory (all symbolic links resolved). If no options are specified, the -L option is assumed.SEE ALSO # 扩展阅读相关命令 builtin(1), cd(1), csh(1), sh(1), getcwd(3) helpman 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， command --help 或 command -h ，它没有 man 命令显示的那么详细，但是它更加易于阅读。 Linux 进阶文本操作grep全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。 基础语法12345678910grep text file # text代表要搜索的文本，file代表供搜索的文件# 实例[root@lion ~]# grep path /etc/profilepathmunge () &#123; pathmunge /usr/sbin pathmunge /usr/local/sbin pathmunge /usr/local/sbin after pathmunge /usr/sbin afterunset -f pathmunge 常用参数 -i 忽略大小写， grep -i path /etc/profile -n 显示行号，grep -n path /etc/profile -v 只显示搜索文本不在的那些行，grep -v path /etc/profile -r 递归查找， grep -r hello /etc ，Linux 中还有一个 rgrep 命令，作用相当于 grep -r 高级用法grep 可以配合正则表达式使用。 123grep -E path /etc/profile --&gt; 完全匹配pathgrep -E ^path /etc/profile --&gt; 匹配path开头的字符串grep -E [Pp]ath /etc/profile --&gt; 匹配path或Path sort对文件的行进行排序。 基础语法1sort name.txt # 对name.txt文件进行排序 实例用法为了演示方便，我们首先创建一个文件 name.txt ，放入以下内容： 1234567ChristopherShawnTedRockNoahZacharyBella 执行 sort name.txt 命令，会对文本内容进行排序。 常用参数 -o 将排序后的文件写入新文件， sort -o name_sorted.txt name.txt ； -r 倒序排序， sort -r name.txt ； -R 随机排序， sort -R name.txt ； -n 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 -n 数字排序的话，则 25 会在 138 前面。 wcword count 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。 基础语法1wc name.txt # 统计name.txt 实例用法12[root@lion ~]# wc name.txt 13 13 91 name.txt 第一个13，表示行数； 第二个13，表示单词数； 第三个91，表示字节数。 常用参数 -l 只统计行数， wc -l name.txt ； -w 只统计单词数， wc -w name.txt ； -c 只统计字节数， wc -c name.txt ； -m 只统计字符数， wc -m name.txt 。 uniq删除文件中的重复内容。 基础语法12uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上uniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt 【注意】它只能去除连续重复的行数。 常用参数 -c 统计重复行数， uniq -c name.txt ； -d 只显示重复的行数， uniq -d name.txt 。 cut剪切文件的一部分内容。 基础语法1cut -c 2-4 name.txt # 剪切每一行第二到第四个字符 常用参数 -d 用于指定用什么分隔符（比如逗号、分号、双引号等等） cut -d , name.txt ； -f 表示剪切下用分隔符分割的哪一块或哪几块区域， cut -d , -f 1 name.txt 。 重定向 管道 流在 Linux 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。 命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 stdin 、 stdout 以及 stderr 。 标准输入 stdin ，终端接收键盘输入的命令，会产生两种输出； 标准输出 stdout ，终端输出的信息（不包含错误信息）； 标准错误输出 stderr ，终端输出的错误信息。 重定向把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。 输出重定向 &gt;&gt; 表示重定向到新的文件， cut -d , -f 1 notes.csv &gt; name.csv ，它表示通过逗号剪切 notes.csv 文件（剪切完有3个部分）获取第一个部分，重定向到 name.csv 文件。 我们来看一个具体示例，学习它的使用，假设我们有一个文件 notes.csv ，文件内容如下： 123456Mark1,951/100,很不错1Mark2,952/100,很不错2Mark3,953/100,很不错3Mark4,954/100,很不错4Mark5,955/100,很不错5Mark6,956/100,很不错6 执行命令： cut -d , -f 1 notes.csv &gt; name.csv 最后输出如下内容： 123456Mark1Mark2Mark3Mark4Mark5Mark6 【注意】使用 &gt; 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。 输出重定向 &gt;&gt;表示重定向到文件末尾，因此它不会像 &gt; 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。 再次执行 cut -d , -f 1 notes.csv &gt;&gt; name.csv ，则会把名字追加到 name.csv 里面。 123456789101112Mark1Mark2Mark3Mark4Mark5Mark6Mark1Mark2Mark3Mark4Mark5Mark6 我们平时读的 log 日志文件其实都是用这个命令输出的。 输出重定向 2&gt;标准错误输出 1cat not_exist_file.csv &gt; res.txt 2&gt; errors.log 当我们 cat 一个文件时，会把文件内容打印到屏幕上，这个是标准输出； 当使用了 &gt; res.txt 时，则不会打印到屏幕，会把标准输出写入文件 res.txt 文件中； 2&gt; errors.log 当发生错误时会写入 errors.log 文件中。 输出重定向 2&gt;&gt;标准错误输出（追加到文件末尾）同 &gt;&gt; 相似。 输出重定向 2&gt;&amp;1标准输出和标准错误输出都重定向都一个地方 12cat not_exist_file.csv &gt; res.txt 2&gt;&amp;1 # 覆盖输出cat not_exist_file.csv &gt;&gt; res.txt 2&gt;&amp;1 # 追加输出 目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。 输入重定向 &lt;&lt; 符号用于指定命令的输入。 1cat &lt; name.csv # 指定命令的输入为 name.csv 虽然它的运行结果与 cat name.csv 一样，但是它们的原理却完全不同。 cat name.csv 表示 cat 命令接收的输入是 notes.csv 文件名，那么要先打开这个文件，然后打印出文件内容。 cat &lt; name.csv 表示 cat 命令接收的输入直接是 notes.csv 这个文件的内容， cat 命令只负责将其内容打印，打开文件并将文件内容传递给 cat 命令的工作则交给终端完成。 输入重定向 &lt;&lt;将键盘的输入重定向为某个命令的输入。 123sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）wc -m &lt;&lt; END # 统计输入的单词 管道 |把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 pipeline ，可以想象一个个水管连接起来，管道算是重定向流的一种。 举几个实际用法案例： 12345678910111213cut -d , -f 1 name.csv | sort &gt; sorted_name.txt # 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txtdu | sort -nr | head # du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件grep log -Ir /var/log | cut -d : -f 1 | sort | uniq# grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重 流流并非一个命令，在计算机科学中，流 stream 的含义是比较难理解的，记住一点即可：流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。 上面提及的重定向或管道，就是把数据当做流去运转的。 到此我们就接触了，流、重定向、管道等 Linux 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。 Angular 中的模板语法中可以使用管道。 Node.js 中也有 stream 流的概念。 查看进程在 Windows 中通过 Ctrl + Alt + Delete 快捷键查看软件进程。 w帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。 123456789101112131415161718[root@lion ~]# w 06:31:53 up 25 days, 9:53, 1 user, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 118.31.243.53 05:56 1.00s 0.02s 0.00s w 06:31:53：表示当前时间up 25 days, 9:53：表示系统已经正常运行了“25天9小时53分钟”1 user：表示一个用户load average: 0.00, 0.01, 0.05：表示系统的负载，3个值分别表示“1分钟的平均负载”，“5分钟的平均负载”，“15分钟的平均负载” USER：表示登录的用于 TTY：登录的终端名称为pts/0 FROM：连接到服务器的ip地址 LOGIN@：登录时间 IDLE：用户有多久没有活跃了 JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时 PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序 WHAT：表示当下用户正运行的程序是什么，这里我运行的是 w ps用于显示当前系统中的进程， ps 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。 基础语法123456789[root@lion ~]# ps PID TTY TIME CMD 1793 pts/0 00:00:00 bash 4756 pts/0 00:00:00 ps PID：进程号，每个进程都有唯一的进程号 TTY：进程运行所在的终端 TIME：进程运行时间 CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程 常用参数 -ef 列出所有进程; -efH 以乔木状列举出所有进程; -u 列出此用户运行的进程; -aux 通过 CPU 和内存使用来过滤进程 ps -aux | less ; -aux --sort -pcpu 按 CPU 使用降序排列， -aux --sort -pmem 表示按内存使用降序排列; -axjf 以树形结构显示进程， ps -axjf 它和 pstree 效果类似。 top获取进程的动态列表。 1234567891011top - 07:20:07 up 25 days, 10:41, 1 user, load average: 0.30, 0.10, 0.07Tasks: 67 total, 1 running, 66 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.7 us, 0.3 sy, 0.0 ni, 99.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882072 total, 552148 free, 101048 used, 1228876 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 1594080 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 956 root 10 -10 133964 15848 10240 S 0.7 0.8 263:13.01 AliYunDun 1 root 20 0 51644 3664 2400 S 0.0 0.2 3:23.63 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.05 kthreadd 4 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H top - 07:20:07 up 25 days, 10:41, 1 user, load average: 0.30, 0.10, 0.07 相当 w 命令的第一行的信息。 展示的这些进程是按照使用处理器 %CPU 的使用率来排序的。 kill结束一个进程， kill + PID 。 123kill 956 # 结束进程号为956的进程kill 956 957 # 结束多个进程kill -9 7291 # 强制结束进程 管理进程进程状态主要是切换进程的状态。我们先了解下 Linux 下进程的五种状态： 状态码 R ：表示正在运行的状态； 状态码 S ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）； 状态码 D ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）； 状态码 Z ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 wait4() 系统函数后将进程释放）； 状态码 T ：表示停止（进程收到 SIGSTOP 、 SIGSTP 、 SIGTIN 、 SIGTOU 等停止信号后停止运行）。 前台进程 &amp; 后台进程默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 top 命令，这就是一个一直运行的前台进程。 后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 &amp; 符号，就表示启动一个后台进程。 &amp;启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。 1cp name.csv name-copy.csv &amp; nohup使进程不受挂断（关闭终端等动作）的影响。 1nohup cp name.csv name-copy.csv nohup 命令也可以和 &amp; 结合使用。 1nohup cp name.csv name-copy.csv &amp; bg使一个“后台暂停运行”的进程，状态改为“后台运行”。 1bg %1 # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程 实际案例1： 1231. 执行 grep -r &quot;log&quot; / &gt; grep_log 2&gt;&amp;1 命令启动一个前台进程，并且忘记添加 &amp; 符号2. ctrl + z 使进程状态转为后台暂停3. 执行 bg 将命令转为后台运行 实际案例2： 1234前端开发时我们经常会执行 yarn start 启动项目此时我们执行 ctrl + z 先使其暂停然后执行 bg 使其转为后台运行这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲） jobs显示当前终端后台进程状态。 123[root@lion ~]# jobs[1]+ Stopped top[2]- Running grep --color=auto -r &quot;log&quot; / &gt; grep_log 2&gt;&amp;1 &amp; fgfg 使进程转为前台运行，用法和 bg 命令类似。 我们用一张图来表示前后台进程切换： 我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。 守护进程一个运行起来的程序被称为进程。在 Linux 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是 PID 为1的进程， PID 为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 daemon 。 守护进程的名字通常会在最后有一个 d ，表示 daemon 守护的意思，例如 systemd 、httpd 。 systemdsystemd 是一个 Linux 系统基础组件的集合，提供了一个系统和服务管理器，运行为 PID 1 并负责启动其它程序。 123[root@lion ~]# ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.2 51648 3852 ? Ss Feb01 1:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 22 通过命令也可以看到 PID 为1的进程就是 systemd 的系统进程。 systemd 常用命令（它是一组命令的集合）： 123456789systemctl start nginx # 启动服务systemctl stop nginx # 停止服务systemctl restart nginx # 重启服务systemctl status nginx # 查看服务状态systemctl reload nginx # 重载配置文件(不停止服务的情况)systemctl enable nginx # 开机自动启动服务systemctl disable nginx # 开机不自动启动服务systemctl is-enabled nginx # 查看服务是否开机自动启动systemctl list-unit-files --type=service # 查看各个级别下服务的启动和禁用情况 文件压缩解压 打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。 压缩：是将一个大文件（通常指归档）压缩变成一个小文件。 我们常常使用 tar 将多个文件归档为一个总的文件，称为 archive 。 然后用 gzip 或 bzip2 命令将 archive 压缩为更小的文件。 tar创建一个 tar 归档。 基础用法12tar -cvf sort.tar sort/ # 将sort文件夹归档为sort.tartar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar 常用参数 -cvf 表示 create（创建）+ verbose（细节）+ file（文件），创建归档文件并显示操作细节； -tf 显示归档里的内容，并不解开归档； -rvf 追加文件到归档， tar -rvf archive.tar file.txt ； -xvf 解开归档， tar -xvf archive.tar 。 gzip &#x2F; gunzip“压缩&#x2F;解压”归档，默认用 gzip 命令，压缩后的文件后缀名为 .tar.gz 。 12gzip archive.tar # 压缩gunzip archive.tar.gz # 解压 tar 归档+压缩可以用 tar 命令同时完成归档和压缩的操作，就是给 tar 命令多加一个选项参数，使之完成归档操作后，还是调用 gzip 或 bzip2 命令来完成压缩操作。 12tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压 zcat、zless、zmore之前讲过使用 cat less more 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 zcat、zless、zmore 进行查看。 1zcat archive.tar.gz zip&#x2F;unzip“压缩&#x2F;解压” zip 文件（ zip 压缩文件一般来自 windows 操作系统）。 命令安装123# Red Hat 一族中的安装方式yum install zip yum install unzip 基础用法1234unzip archive.zip # 解压 .zip 文件unzip -l archive.zip # 不解开 .zip 文件，只看其中内容zip -r sort.zip sort/ # 将sort文件夹压缩为 sort.zip，其中-r表示递归 编译安装软件之前我们学会了使用 yum 命令进行软件安装，如果碰到 yum 仓库中没有的软件，我们就需要会更高级的软件安装“源码编译安装”。 编译安装简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 Linux 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。 基本步骤如下： 下载源代码 解压压缩包 配置 编译 安装 实际案例1、下载我们来编译安装 htop 软件，首先在它的官网下载源码：bintray.com&#x2F;htop&#x2F;source… 下载好的源码在本机电脑上使用如下命令同步到服务器上： 123scp 文件名 用户名@服务器ip:目标路径scp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:. 也可以使用 wegt 进行下载： 123wegt+下载地址wegt https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz 2、解压文件123tar -zxvf htop-3.0.0.tar.gz # 解压cd htop-3.0.0 # 进入目录 3、配置执行 ./configure ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。 4、编译执行 make 命令 5、安装执行 make install 命令，安装完成后执行 ls /usr/local/bin/ 查看是否有 htop 命令。如果有就可以执行 htop 命令查看系统进程了。 网络ifconfig查看 ip 网络相关信息，如果命令不存在的话， 执行命令 yum install net-tools 安装。 1234567891011121314151617[root@lion ~]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.24.78 netmask 255.255.240.0 broadcast 172.31.31.255 ether 00:16:3e:04:9c:cd txqueuelen 1000 (Ethernet) RX packets 1592318 bytes 183722250 (175.2 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1539361 bytes 154044090 (146.9 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 参数解析： eth0 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。 eth 是 Ethernet 的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 eht0 ，你还会看到 eth1 、 eth2 等。 lo 表示本地回环（ Local Loopback 的缩写，对应一个虚拟网卡）可以看到它的 ip 地址是 127.0.0.1 。每台电脑都应该有这个接口，因为它对应着“连向自己的链接”。这也是被称之为“本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 127.0.0.1:3000 启动项目就能查看到自己的 web 网站，并且它只有你能看到。 wlan0 表示无线局域网（上面案例并未展示）。 hostip 地址和主机名的互相转换。 软件安装1yum install bind-utils 基础用法12345[root@lion ~]# host github.combaidu.com has address 13.229.188.59 [root@lion ~]# host 13.229.188.5959.188.229.13.in-addr.arpa domain name pointer ec2-13-229-188-59.ap-southeast-1.compute.amazonaws.com. ssh 连接远程服务器通过非对称加密以及对称加密的方式（同 HTTPS 安全连接原理相似）连接到远端服务器。 1234ssh 用户@ip:port1、ssh root@172.20.10.1:22 # 端口号可以省略不写，默认是22端口2、输入连接密码后就可以操作远端服务器了 配置 sshconfig 文件可以配置 ssh ，方便批量管理多个 ssh 连接。 配置文件分为以下几种： 全局 ssh 服务端的配置： /etc/ssh/sshd_config ； 全局 ssh 客户端的配置： /etc/ssh/ssh_config（很少修改）； 当前用户 ssh 客户端的配置： ~/.ssh/config 。 【服务端 config 文件的常用配置参数】 服务端 config 参数 作用 Port sshd 服务端口号（默认是22） PermitRootLogin 是否允许以 root 用户身份登录（默认是可以） PasswordAuthentication 是否允许密码验证登录（默认是可以） PubkeyAuthentication 是否允许公钥验证登录（默认是可以） PermitEmptyPasswords 是否允许空密码登录（不安全，默认不可以） [注意] 修改完服务端配置文件需要重启服务 systemctl restart sshd 【客户端 config 文件的常用配置参数】 客户端 config 参数 作用 Host 别名 HostName 远程主机名（或 IP 地址） Port 连接到远程主机的端口 User 用户名 配置当前用户的 config ： 12345678# 创建configvim ~/.ssh/config# 填写一下内容Host lion # 别名\tHostName 172.x.x.x # ip 地址 Port 22 # 端口 User root # 用户 这样配置完成后，下次登录时，可以这样登录 ssh lion 会自动识别为 root 用户。 [注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。 免密登录ssh 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。 基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。 基于密钥验证原理客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为“公钥验证登录”。 具体实现步骤1、在客户机中生成密钥对（公钥和私钥） ssh-keygen（默认使用 RSA 非对称加密算法） 运行完 ssh-keygen 会在 ~/.ssh/ 目录下，生成两个文件： id_rsa.pub ：公钥 id_rsa ：私钥 2、把客户机的公钥传送到服务 执行 ssh-copy-id root@172.x.x.x（ssh-copy-id 它会把客户机的公钥追加到服务器 ~/.ssh/authorized_keys 的文件中）。 执行完成后，运行 ssh root@172.x.x.x 就可以实现免密登录服务器了。 配合上面设置好的别名，直接执行 ssh lion 就可以登录，是不是非常方便。 wget可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。 123wget [参数][URL地址]wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip wget 非常稳定，如果是由于网络原因下载失败， wget 会不断尝试，直到整个文件下载完毕。 常用参数 -c 继续中断的下载。 备份scp它是 Secure Copy 的缩写，表示安全拷贝。 scp 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。 scp 是基于 ssh 的原理来运作的， ssh 会在两台通过网络连接的电脑之间创建一条安全通信的管道， scp 就利用这条管道安全地拷贝文件。 1scp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件 其中 source_file 和 destination_file 都可以这样表示： user@ip:file_name ， user 是登录名， ip 是域名或 ip 地址。 file_name 是文件路径。 12scp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑scp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机 rsyncrsync 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于“增量备份”的命令了。它就是智能版的 scp 命令。 软件安装1yum install rsync 基础用法12rsync -arv Images/ backups/ # 将Images 目录下的所有文件备份到 backups 目录下rsync -arv Images/ root@192.x.x.x:backups/ # 同步到服务器的backups目录下 常用参数 -a 保留文件的所有信息，包括权限，修改日期等； -r 递归调用，表示子目录的所有文件也都包括； -v 冗余模式，输出详细操作信息。 默认地， rsync 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 rsync 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做： rsync -arv --delete Images/ backups/ 。 系统halt关闭系统，需要 root 身份。 1halt reboot重启系统，需要 root 身份。 1reboot poweroff直接运行即可关机，不需要 root 身份。 Vim 编辑器Vim 是什么？Vim 是从 vi 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。 Vim 常用模式 交互模式 插入模式 命令模式 可视模式 交互模式也成为正常模式，这是 Vim 的默认模式，每次运行 Vim 程序的时候，就会进入这个模式。 例如执行 vim name.txt 则会进入交互模式。 交互模式特征： 在这个模式下，你不能输入文本； 它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等。 插入模式这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 i （ i、I、a、A、o、O 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 Esc 键。 i, I 进入输入模式 Insert mode ： i 为“从目前光标所在处输入”， I 为“在目前所在行的第一个非空格符处开始输入”； a, A 进入输入模式 Insert mode ： a 为“从目前光标所在的下一个字符处开始输入”， A 为“从光标所在行的最后一个字符处开始输入”； o, O 进入输入模式 Insert mode ： o 为“在目前光标所在的下一行处输入新的一行”； O 为在目前光标所在处的上一行输入新的一行。 命令模式命令模式也称为底线命令模式，这个模式下可以运行一些命令例如“退出”，“保存”，等动作。 也可以用这个模式来激活一些 Vim 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 ls、cp 。 为了进入命令模式，首先要进入交互模式，再按下冒号键。 用一张图表示三种模式如何切换： 基本操作打开 Vim在终端命令行中输入 vim 回车后 Vim 就会被运行起来，也可以用 Vim 来打开一个文件，只需要在 vim 后面再加文件名。如 vim file.name ，如果文件不存在，那么会被创建。 插入进入文件之后，此时处于交互模式，可以通过输入 i 进入插入模式。 移动在 Vim 的交互模式下，我们可以在文本中移动光标。 h 向左移动一个字符 j 向下移动一个字符 k 向上移动一个字符 i 向右移动一个字符 当然也可以使用四个方向键进行移动，效果是一样的。 跳至行首和行末 行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 0 即可，键盘上的 Home 键也有相同效果。 行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 $ 即可，键盘上的 End 键也有相同效果。 按单词移动在交互模式下，按字母键 w 可以一个单词一个单词的移动。 退出文件在交互模式下，按下冒号键 : 进入命令模式，再按下 q 键，就可以退出了。 如果在退出之前又修改了文件，就直接想用 :q 退出 Vim ，那么 Vim 会显示一个红字标明错误信息。此时我们有两个选择： 保存并退出 :wq 或 :x ； 不保存且退出 :q! 。 标准操作删除字符在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 x 你会发现这个字符被删除了。 也可以一次性删除多个字符，只需要在按 x 键之前输入数字即可。 删除（剪切）单词，行 删除一行：连按两次 d 来删除光标所在的那一行。 删除多行：例如先输入数字 2 ，再按下 dd ，就会删除从光标所在行开始的两行。 删除一个单词：将光标置于一个单词的首字母处，然后按下 dw 。 删除多个单词：例如先按数字键 2 再按 dw 就可以删除两个单词了。 从光标所在位置删除至行首： d0 。 从光标所在位置删除至行末： d$ 。 复制单词，行 复制行：按两次 y 会把光标所在行复制到内存中，和 dd 类似， dd 用于“剪切”光标所在行。 复制单词： yw 会复制一个单词。 复制到行末： y$ 是复制从光标所在处到行末的所有字符。 复制到行首： y0 是复制光标所在处到行首的所有字符。 粘贴如果之前用 dd 或者 yy 剪切复制过来的，可以使用 p 来粘贴。同样也可以使用 数字+p 来表示复制多次。 替换一个字符在交互模式下，将光标置于想要替换的字符上。按下 r 键，接着输入你要替换的字符即可。 撤销操作如果要撤销最近的修改，只需要按下 u 键，如果想要撤销最近四次修改，可以按下4，再按下 u 。 重做取消撤销，也就是重做之前的修改使用 ctrl + r 。 跳转到指定行Vim 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。 行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 set nu ，如果要隐藏行号的话，使用 set nonu 。 跳转到指定行： 数字+gg ，例如 7gg ，表示跳转到第7行。 要跳转到最后一行，按下 G 。 要跳转到第一行，按下 gg 。 高级操作查找处于交互模式下，按下 / 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 &quot;pattern not found&quot; 。 n 跳转到下一个匹配项； N 跳转到上一个匹配项。 [注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 ? ，当然也可以先按下 gg 跳转到第一行在进行全文搜索。 查找并替换替换光标所在行第一个匹配的字符串： 12345# 语法:s/旧字符串/新字符串# 实例:s/one/two 替换光标所在行所有旧字符串为新字符串： 12# 语法:s/旧字符串/新字符串/g 替换第几行到第几行中所有字符串： 12345# 语法:n,m s/旧字符串/新字符串/g# 实例:2,4 s/one/two/g 最常用的就是全文替换了： 12# 语法:%s/旧字符串/新字符串/g 合并文件可以用冒号 +r ( :r ) 实现在光标处插入一个文件的内容。 1:r filename # 可以用Tab键来自动补全另外一个文件的路径 分屏Vim 有一个特别便捷的功能那就是分屏，可以同时打开好几个文件，分屏之后，屏幕每一块被称为一个 viewport ，表示“视口”。 横向分屏 :sp 文件名 垂直分屏 :vsp 文件名 分屏模式下的快捷键 Ctrl + w 再加 Ctrl + w ，表示从一个 viewport 移动光标到另外一个 viewport ； Ctrl + w 再加 “方向键”，就可以移动到这个方向所处的下一个视口了； Ctrl + w 再加 + 号，表示扩大当前视口； Ctrl + w 再加 - 号，表示缩小当前视口； Ctrl + w 再加 = 号，表示平均当前视口； Ctrl + w 再加 r 键，会反向调换视口位置； Ctrl + w 再加 q 键，会关闭当前视口； Ctrl + w 再加 o 键，会关闭除当前视口以外的所有视口； 运行外部命令 :!在 Vim 中可以运行一些终端命令，只要先输入 :! ，然后接命令名称。 例如： 1:!ls # 在Vim中打开的文件所在的目录运行ls命令 可视模式前面只讲了 Vim 的三种模式，其实还有一种模式叫做可视模式。 进入它的三种方式（都是从交互模式开始）： v 字符可视模式，进入后配合方向键选中字符后，然后再按 d 键可以删除选中。 V 行可视模式，进入后光标所在行默认被选中，然后再按 d 键可以删除所在行。 Ctrl + v 块可视模式，它是可视模式最有用的功能了，配合 d 和 I 键可以实现删除选中的内容和插入内容。 同时选中多行，并在选中行头部插入内容的具体操作步骤： 12341. ctrl + v 进入块可视模式2. 使用方向键进行选中（上下左右）假设选中5行3. 输入 I 键进行多行同时插入操作4. 插入完成后连续按两下 esc 键，实现多行同时插入相同字符 进入可视模式之后的操作键： d 键，表示删除选中； I 键，表示在选中之前插入； u 键，表示选中变为小写； U 键，表示选中变为大写； Vim 配置选项参数在 Vim 被启动后，可以运行一些指令来激活一些选项参数，但是这些选项参数的配置在退出 Vim 时会被忘记，例如前面讲解的激活行号。如果希望所在的配置是永久性的，那么需要在家目录（ cd ~ ）创建一个 Vim 的配置文件 .vimrc 。 .vimrc12345set number &quot; 显示行号syntax on &quot; 激活语法高亮set showcmd &quot; 实时看到输入的命令set ignorecase &quot; 搜索时不区分大小写set mouse=a &quot; 激活鼠标，用鼠标选中时相当于进入可视模式 Vim 配置非常丰富，我们可以通过个性化配置把 Vim 打造成属于自己的 IDE 等等。在 github 上也可以搜索到一些强大的 Vim 配置文件。 总结相信通过本文的学习，你应该会对 Linux 有一个更加全面的认识。","tags":["Linux","Linux命令"],"categories":["稀土掘金","公众号"]},{"title":"Linux基础","path":"/a4a81253/","content":"Linux基础Linux简介操作系统是什么，操作系统概述Linux 也是众多操作系统之一，要想知道 Linux 是什么，首先得说一说什么是操作系统。 计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成： 硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。 操作系统（Operating System，OS）是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。 操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如： 1) 文件系统提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。 2) 设备驱动程序提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。简单来说，就是让你能吃到鸡蛋，但不用养一只鸡。 3) 用户接口操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。 4) 系统服务程序当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。 打个比方，操作系统就好像是一个政府，其它软件都会被它管控；操作系统在给其他软件提供各种便利的同时，还会约束其他软件不能为所欲为。 目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS、Windows Phone（简称 WP），嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等。 UNIX&#x2F;Linux系统结构UNIX&#x2F;Linux 系统可以粗糙地抽象为 3 个层次（所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解），如图 3 所示。底层是 UNIX&#x2F;Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层。 1) 内核层内核层是 UNIX&#x2F;Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。 2) Shell层Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。 3) 应用层应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP&#x2F;IP 是一个协议，定义软件所应具备的功能），可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。 现在大多数的 UNIX 系统上（包括 Solaris、HP-UX、AIX 等）都可以运行 CDE （Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境）的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。 X Window 与微软的 Windows 图形环境有很大的区别： UNIX&#x2F;Linux 系统与 X Window 没有必然捆绑的关系，也就是说，UNIX&#x2F;Linux 可以安装 X Window，也可以不安装；而微软的 Windows 图形环境与内核捆绑密切。 UNIX&#x2F;Linux 系统不依赖图形环境，依然可以通过命令行完成 100% 的功能，而且因为不使用图形环境还会节省大量的系统资源。 Linux系统的优缺点1) 大量的可用软件及免费软件Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。 但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。 2) 良好的可移植性及灵活性Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。 如果读者希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS&#x2F;BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。 3) 优良的稳定性和安全性著名的黑客埃里克•雷蒙德（EricS.Raymond）有一句名言：“足够多的眼睛，就可让所有问题浮现”。举个例子，假如笔者在演讲，台下人山人海，明哥中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算明哥衣领上有一大块油渍也不会被发现。 Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。 提到 Linux 的安全性，我们可以做一个实验：在一台计算机上，在安装了 Windows 系统后不安装杀毒软件联网一个月，看看会有什么情况；同样，在安装了 Linux 系统后不安装杀毒软件联网一个月，我们比较一下，大家就明白了什么是 Linux 的安全性。Windows 系统不安装杀毒软件，相信大家都知道会有什么下场吧…… 4) 支持几乎所有的网络协议及开发语言经常有初学的朋友问我，Linux 是不是对 TCP&#x2F;IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP&#x2F;IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP&#x2F;IP 无关呢？所以，Linux 对网络协议和开发语言的支持很好。 Linux 的优点在此不一一列举，只说明这几点供读者参考。诚然，Linux 不可能没有缺点，如桌面应用还有待完善、Linux 的标准统一还需要推广、开源软件的盈利模式与发展还有待考验等，不过，瑕不掩瑜。 常见Linux发行版本有哪些？从技术上来说，李纳斯•托瓦兹开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。 在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以Linux为核心的操作系统软件包”。 Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层（由发行商整合开发的应用）才有所体现。 Linux 的发行版本可以大体分为两类： 商业公司维护的发行版本，以著名的 Red Hat 为代表； 社区组织维护的发行版本，以 Debian 为代表。 版本名称 网 址 特 点 软件包管理器 Debian Linux www.debian.org 开放的开发模式，且易于进行软件包升级 apt Fedora Core www.redhat.com 拥有数量庞人的用户，优秀的社区技术支持. 并且有许多创新 up2date（rpm），yum （rpm） CentOS www.centos.org CentOS 是一种对 RHEL（Red Hat Enterprise Linux）源代码再编译的产物，由于 Linux 是开发源代码的操作系统，并不排斥样基于源代码的再分发，CentOS 就是将商业的 Linux 操作系统 RHEL 进行源代码再编译后分发，并在 RHEL 的基础上修正了不少已知的漏洞 rpm SUSE Linux www.suse.com 专业的操作系统，易用的 YaST 软件包管理系统 YaST（rpm），第三方 apt （rpm）软件库（repository） Mandriva www.mandriva.com 操作界面友好，使用图形配置工具，有庞大的社区进行技术支持，支持 NTFS 分区的大小变更 rpm KNOPPIX www.knoppix.com 可以直接在 CD 上运行，具有优秀的硬件检测和适配能力，可作为系统的急救盘使用 apt Gentoo Linux www.gentoo.org 高度的可定制性，使用手册完整 portage Ubuntu www.ubuntu.com 优秀已用的桌面环境，基于 Debian 构建 apt Linux 发行版本的选择Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议： 如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。 如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。 如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。 如果你对系统稳定性要求很高，则可以考虑 FreeBSD。 如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。 以上纯属个人化建议，非官方指导意见。其实 Linux 的发行版本众多，但是系统的核心——内核却系出同门，所以只要学会使用其中一种，即可触类旁通。 Linux桌面环境（桌面系统）大比拼[附带优缺点]Linux 中的桌面环境也是一个程序，它和内核不是绑定的，两者的开发也不是同步的；给不带界面的 Linux 系统安装上一个桌面环境，你就能看到各种漂亮的窗口，并能用鼠标点击它们了。 1. KDE 桌面系统KDE 是 K Desktop Environment 的缩写，中文译为“K桌面环境”。 许多流行的 Linux 发行版都提供了 KDE 桌面环境，比如 Ubuntu、Linux Mint、OpenSUSE、Fedora、Kubuntu、PC Linux OS 等。 KDE 和 Windows 比较类似，各位初学者相信都是 Windows 的用户，所以切换到 KDE 也不会有太大的障碍。 KDE 允许你把应用程序图标和文件图标放置在桌面的特定位置上。单击应用程序图标，Linux 系统就会运行该应用程序。单击文件图标，KDE 桌面就会确定使用哪种应用程序来处理该文件。 KDE 是所有桌面环境中最容易定制的。在其他桌面环境中，你需要几个插件、窗口组件和调整工具才可以定制环境，KDE 将所有工具和窗口组件都塞入到系统设置中。借助先进的设置管理器，可以控制一切，不需要任何第三方工具，就可以根据用户的喜好和要求来美化及调整桌面。 KDE 项目组还还发了大量的可运行在 KDE 环境中的应用程序，包括 Dolphin（文件管理工具）、Konsole（终端）、Kate（文本编辑工具）、Gwenview（图片查看工具）、Okular（文档及PDF查看工具）、Digikam（照片编辑和整理工具）、KMail（电子邮件客户软件）、Quassel（IRC客户软件）、K3b（DVD刻录程序）、Krunner（启动器）等，它们都是默认安装的。 对 KDE 优缺点的总结： 优点：KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备 缺点：Kmail 等一些组件的配置对新手来说过于复杂。 2. GNOME 桌面环境GNOME 是 the GNU Network Object Model Environment 的缩写，中文译为“GNU网络对象模型环境”。 GNOME 的特点是简洁、运行速度快，但是没有太多的定制选项，用户需要安装第三方工具来实现。 GNOME 甚至不包括一些简单的调整选项，比如更改主题、更改字体等，就这两种基本的调整而言，用户都需要安装第三方工具。所以，GONME 适合那些不需要高度定制界面的用户。 GNOME 被用作 Fedora 中的默认桌面环境，提供在几款流行的 Linux 发行版中，比如 Ubuntu、Debian、OpenSUSE 等。 对 GNOME 优缺点的总结： 优点：简单易用，可通过插件来扩展功能。 缺点：对插件的管理能力比较差，也缺少其它桌面环境拥有的许多功能。 3. UnityUnity 是由 Ubuntu 的母公司 Canonical 开发的一款外壳。之所以说它是外壳，是因为 Unity 运行在 GNOME 桌面环境之上，使用了所有 GNOME 的核心应用程序。 Unity 使用了不同的界面风格，如果你用的是 Ubuntu Linux 发行版，你会注意到 Unity 与 KDE 和 GNOME 桌面环境有些不一样。 Unity 在左边有一个启动器，位于启动器顶部的是搜索图标，又叫“Dash”。在 Dash 上搜索文件时，不仅会给出来自硬盘的搜索结果，还会给出来自在线来源的搜索结果，比如 Google Drive、Facebook、Picasa、Flick 及其他。 Unity 还提供了隐藏启动器、触摸侧边栏就显示的选项，用户还可以调高&#x2F;调低显示启动器菜单的灵敏度。 Unity 很简单、运行速度快，但 Unity 在系统设置下却没有定制桌面的太多选项，要想安装主题或者定制另外不同的选项，比如系统菜单是否应该总是可见，或者“从启动器图标一次点击最小化”，用户需要安装第三方工具。 CCSM 和 Unity Tweak Tool 是面向 Unity 桌面环境的非常流行的定制工具。 对 Unity 优缺点的总结： 优点：界面简洁直观，可以通过第三方工具来深度定制，而且使用了平视显示器（HUD）等新技术。 缺点：默认的定制功能比较差劲，通知机制一般。 4. MATE上面我们提到，GNOME 3 进行了全新的界面设计，这招致一些用户的不满，他们推出了其它的桌面环境，MATE 就是其中之一。 MATE 是一种从现在无人维护的 GNOME 2 代码库派生出来的桌面环境。 MATE 让人觉得在使用旧的桌面环境，但是结合了历年来界面方面的诸多改进。MATE 还非常适用于低配计算机，所以如果你有一台旧的或速度较慢的计算机，可以使用 MATE。 MATE 还是许多流行的 Linux 发行版随带的，比如 Ubuntu、Linux Mint、Mageia、Debian 及另外更多发行版。Ubuntu MATE 头一回是官方版本。 “欢迎首次发布的 Ubuntu MATE 官方版本。现在，用户将更容易更新软件，因为所有组件现在都在 Ubuntu 软件库中。” MATE 自带的应用程序包括 Caja（文件管理工具）、Pluma（文本编辑工具）、Atril（文档查看工具）、Eye of MATE（图像查看工具）等，如果用户不需要其他功能完备的桌面环境的所有额外功能，那么 MATE 对他们来说是一款简单的轻量级桌面环境。 对 META 优缺点的总结： 优点：轻量级的桌面环境，能够兼容教旧的硬件设备。 缺点：我也不知道有什么明显的缺点，欢迎读者留言告知。 5. Cinnamon与 MATE 类似，Cinnamon 是由 Linux Mint 团队因为不满 Gnome 3 的改进而开发的另一种桌面环境。但 Cinnamon 与 MATE 不同之处在于，Cinnamon 建立在 Gnome 3 的基础上。Cinnamon 是新的，而且在积极开发之中，但这款出色的桌面环境没有因新颖而在功能方面有所减弱。 Cinnamon 拥有 GNOME 和 Unity 等其它桌面环境所没有的种种功能。Cinnamon 是高度可定制的桌面环境，不需要任何外部插件、窗口组件和调整工具来定制桌面。Cinnamon 甚至可以通过设置管理器本身来下载并安装主题，甚至不需要打开互联网浏览器。 由于种种出色的所需功能，Cinnamon 对任何刚接触 Linux 的新用户来说都非常方便。许多用户放弃使用 Linux，是因为他们并不了解 Linux 的工作方式，但是我强烈建议新手应从 Cinnamon 桌面环境开始入手。 许多流行的 Linux 发行版提供了各自版本的 Cinnamon，比如 Ubuntu、Fedora、OpenSUSE、Gentoo、Arch Linux 等。Cinnamon 还是 Linux Mint 的默认桌面环境。 对 Cinnamon 优缺点的总结： 优点：成熟完美，高度可性质，适合 Linux 新手。 缺点：有时候可能会有软件错误。 6. 适用于较老硬件设备的 Linux 桌面环境图形化桌面环境的弊端在于它们要占用相当一部分的系统资源来保证正常运行。在 Linux 发展之初，Linux 的标志和卖点之一就是它可以运行在处理能力较弱的老旧 PC 上，这些 PC 无力运行较新的 Windows 桌面。 然而随着 KDE 和 GNOME 桌面环境的普及，情况发生了变化。运行 KDE 或 GNOME 桌面要占用的内存资源和较新的 Windows 桌面环境旗鼓相当。 如果你的 PC 已经有些年代了，也不要泄气。Linux 开发人员已经联手让 Linux 返璞归真。他们开发了一些低内存开销的图形化桌面应用，提供了能够在老旧 PC 上完美运行的基本功能。尽管这些图形化桌面环境并没有大量专为其设计的应用，但它们仍然能运行许多基本的图形化程序，支持如文字处理、电子表格、数据库、绘图以及多媒体等功能。 下表列出了一些可在配置较低的 PC 和笔记本电脑上运行的轻量级 Linux 图形化桌面环境。 桌面环境 说明 Fluxbox 一个没有面板的轻型桌面，仅有一个可用来启动程序的弹出式菜单。 Xfce 和 KDE 很像的一个桌面，但少了很多图像以适应低内存环境。 JWM Joe 的窗口管理器（Joe’s Window Manager），非常适用于低内存低硬盘空间环境的超轻型桌面。 Fvwm 支持如虚拟桌面和面板等高级桌面功能，但能够在低内存环境中运行。 fvwm95 从 fvwm 衍生而来，但看起来更像是 Windows 95 桌面。 以上这些图形化桌面环境并不如 KDE 或 GNOME 桌面一样绚丽，但却提供了恰到好处的基本图形化功能。 如果你用的是老旧 PC，尝试一下基于上述某个桌面环境的 Linux 发行版，看看怎么样，可能会有惊喜哦。 查看桌面环境我们可以通过环境变量 DESKTOP_SESSION 来查看当前 Linux 发行版使用了哪种桌面环境，例如： 12[]$ echo $DESKTOP_SESSIONgnome-classic 这表明我使用的是 GNOME。 另外，你也可以查看/etc下有没有对应的目录，例如 gnome 目录或者 kde 目录，如果有的话，就说明已经安装了。 开源软件是什么？有哪些？Linux 是一款开源软件，我们可以随意浏览和修改它的源代码，学习 Linux，不得不谈到开源精神。Linux 本身就是开源精神的受益者，它几乎是全球最大的开源软件。 简单来说，开源软件就是把软件程序与源代码文件一起打包提供给用户，用户既可以不受限制地使用该软件的全部功能，也可以根据自己的需求修改源代码，甚至编制成衍生产品再次发布出去。 用户具有使用自由、修改自由、重新发布自由和创建衍生品自由，这正好符合了黑客和极客对自由的追求，因此开源软件在国内外都有着很高的人气，大家聚集在开源社区，共同推动开源软件的进步。 坦白来讲，每一位投身 Linux 的技术人或者程序员，只要听到开源项目就会由衷地感到自豪，这是一种从骨子里面带有的独特情况。 支持开源软件的企业不单出是为了利益，而是相互扶持，共同努力服务好更多的用户。 优点 说明 低风险 使用闭源软件无疑是把命运交给他人，一旦封闭的源代码没有人来维护，你将进退维谷；而且相较于商业软件公司，开源社区很少存在倒闭的问题。 高品质 相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的 bug 还没有等爆发就已经被修补。 低成本 开源工作者都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。 更透明 没有哪个笨蛋会把木马、后门等放到开放的源代码中，这样无疑是把自己的罪行暴露在阳光之下。 软件 说明 Linux Linux 是一款开源的操作系统，它的内核由多名极客共同维护。Linux 是开源软件的经典之作、代表之作、巅峰之作。 Apache 世界使用排名第一的 Web 服务器软件。 MySQL 世界上最流行的关系型数据库，适合中小型网站。 Firefox 火狐浏览器。在 Chrome 推出之前，Firefox 几乎是最快速的浏览器，直到现在也是 Web 开发人员的调试利器。 OpenOffice 套跨平台的办公软件套件，类似 Microsoft Office。 GCC C语言&#x2F;C++编译器。 Java、PHP、Python 开源的编程语言。 国内外开源社区推荐：开源中国、ChinaUnix、GitHub、Apache、SourceForge、 开源社区以国外为主，国内开源社区由于资金、人才、气氛等问题一直不太稳定，最后附上一张开源社区汇总图。 开源协议是什么？有哪些？如何选择？开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织（Open Source Initiative）认可的开源许可协议来保证开源工作者的权益。 开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。 开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。 对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。 1) GNU GPL（GNU General Public License，GNU通用公共许可证） 只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件。 遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。 特点 说明 复制自由 允许把软件复制到任何人的电脑中，并且不限制复制的数量。 传播自由 允许软件以各种形式进行传播。 收费传播 允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。 修改自由 允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。 2) BSD（Berkeley Software Distribution，伯克利软件发布版）协议 BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件： 如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。 不允许用原始软件的名字、作者名字或机构名称进行市场推广。 BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。 3) Apache 许可证版本（Apache License Version）协议 Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。 现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件： 该软件及其衍生品必须继续使用 Apache 许可协议。 如果修改了程序源代码，需要在文档中进行声明。 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。 如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。 4) MIT（Massachusetts Institute of Technology）协议目前限制最少的开源许可协议之一（比 BSD 和 Apache 的限制都少），只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。 使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。 5) GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议。 LGPL 允许商业软件通过类库引用（link）的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 如何选择开源协议世界上的开源协议有上百种（有兴趣的读者请猛击这里了解），很少有人能彻底搞清它们之间的区别，即使在最流行的六种开源协议——GPL、BSD、MIT、Mozilla、Apache 和 LGPL——之中做选择，也很复杂。 乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议，大家看了一目了然，真是清爽。 Linux系统安装教程Linux远程管理协议（RFB、RDP、Telnet和SSH）提到远程管理，通常指的是远程管理服务器，而非个人计算机。个人计算机可以随时拿来用，服务器通常放置在机房中，用户无法直接接触到服务器硬件，只能采用远程管理的方式。 远程管理，实际上就是计算机（服务器）之间通过网络进行数据传输（信息交换）的过程，与浏览器需要 HTTP 协议（超文本传输协议）浏览网页一样，远程管理同样需要远程管理协议的支持。 目前，常用的远程管理协议有以下 4 种： RDP（remote desktop protocol）协议：远程桌面协议，大部分 Windows 系统都默认支持此协议，Windows 系统中的远程桌面管理就基于该协议。 RFB（Remote FrameBuffer）协议：图形化远程管理协议，VNC 远程管理工具就基于此协议。 Telnet：命令行界面远程管理协议，几乎所有的操作系统都默认支持此协议。此协议的特点是，在进行数据传送时使用明文传输的方式，也就是不对数据进行加密。 SSH（Secure Shell）协议：命令行界面远程管理协议，几乎所有操作系统都默认支持此协议。和 Telnet 不同，该协议在数据传输时会对数据进行加密并压缩，因此使用此协议传输数据既安全速度又快。 RDP 对比 RFBRDP 协议和 RFB 协议都允许用户通过图形用户界面访问远程系统，但 RFB 协议倾向于传输图像，RDP 协议倾向于传输指令： RFB 协议会在服务器端将窗口在显存中画好，然后将图像传给客户端，客户端只需要将得到的图像解码显示即可； RDP 会将画图的工作交给客户端，服务器端需要根据客户端的显示能力做适当的调整。 因此，完成相同的操作，使用 RFB 协议传输的数据量会比 RDP 大，而 RDP 对客户端的要求比 RFB 更苛刻，RFB 适用于瘦客户端，而 RDP 适用于低速网络。 瘦客户端是相对于胖客户端而言的，比如，人们使用 QQ，需要下载客户端，这属于“胖客户”；反之，通过浏览器就可查阅网络上各种资料，无需再下载其他任何软件，这属于“瘦客户”。简单理解，瘦客户端指的是最大可能减轻客户端的负担，多数工作由服务器端完成；胖客户端则相反。 Telnet 对比 SSHTelnet 协议和 SSH 协议都是命令行远程管理协议，有共同的应用领域，常用于远程访问服务器。 相比 Telnet 协议，SSH 协议在发送数据时会对数据进行加密操作，数据传输更安全，因此 SSH 协议几乎在所有应用领域代替了 Telnet 协议。 在一些测试、无需加密的场合（如局域网），Telnet协议仍常被使用。 Linux远程管理软件基于以上 4 种远程管理协议，Linux 远程管理服务器的软件可分为以下 3 种： 类似于 VNC（基于 RFB 协议）的图形远程管理软件，如 Xmanager、VNC VIEWER 以及 TightVNC 等； 基于 SSH 协议的命令行操作管理； 类似 Webmin 的基于浏览器的远程管理，此种管理方式只提供简单的管理窗口，可用的管理功能有限； 介于安全性和稳定性的考虑，大部分的服务器都舍弃图形管理界面而选择命令行界面，因此远程管理 Linux 服务器常使用基于 SSH 协议的命令行管理方式。 目前，基于 SSH 协议常用的远程管理工具有 PuTTY、SecureCRT、WinSCP 等，这些管理工具的具体使用下节给大家详细介绍。 Linux文件目录结构一览表学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。 使用 Linux 时，通过命令行输入 ls -l / 可以看到，在 Linux 根目录（&#x2F;）下包含很多的子目录（称为一级目录），例如 bin、boot、dev 等。同时，各一级目录下还含有很多子目录（称为二级目录），比如 &#x2F;bin&#x2F;bash、&#x2F;bin&#x2F;ed 等。Linux 文件系统目录总体呈现树形结构，&#x2F; 根目录就相当于树根。 由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果你进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。 为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。 FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（&#x2F;usr 和 &#x2F;var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。 Linux 根目录（&#x2F;）FHS 认为，Linux 系统的根目录（&#x2F;）最为重要（没有之一），其原因有以下 2 点： 所有目录都是由根目录衍生出来的； 根目录与系统的开机、修复、还原密切相关； 因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件，如表 1 所示。 一级目录 功能（作用） &#x2F;bin&#x2F; 存放系统命令，普通用户和 root 都可以执行。放在 &#x2F;bin 下的命令在单用户模式下也可以执行 &#x2F;boot&#x2F; 系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 &#x2F;dev&#x2F; 设备文件保存位置 &#x2F;etc&#x2F; 配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 &#x2F;home&#x2F; 普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 &#x2F;home&#x2F; 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 &#x2F;home&#x2F;liming &#x2F;lib&#x2F; 系统调用的函数库保存位置 &#x2F;media&#x2F; 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘 &#x2F;mnt&#x2F; 挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区 &#x2F;misc&#x2F; 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 &#x2F;media&#x2F;、&#x2F;mnt&#x2F;、&#x2F;misc&#x2F;，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 &#x2F;mnt&#x2F;，所以养成了在 &#x2F;mnt&#x2F; 下建立不同目录挂载不同设备的习惯，如 &#x2F;mnt&#x2F;cdrom&#x2F; 挂载光盘、&#x2F;mnt&#x2F;usb&#x2F; 挂载 U 盘，都是可以的 &#x2F;opt&#x2F; 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 &#x2F;usr&#x2F;local&#x2F; 目录中，也就是说，&#x2F;usr&#x2F;local&#x2F; 目录也可以用来安装软件 &#x2F;root&#x2F; root 的主目录。普通用户主目录在 &#x2F;home&#x2F; 下，root 主目录直接在“&#x2F;”下 &#x2F;sbin&#x2F; 保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看 &#x2F;srv&#x2F; 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 &#x2F;tmp&#x2F; 临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空 FHS 针对根目录中包含的子目录仅限于表 1，但除此之外，Linux 系统根目录下通常还包含表 2 中的几个一级目录。 一级目录 功能（作用） &#x2F;lost+found&#x2F; 当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，&#x2F;lost+found 就是根分区的备份恢复目录，&#x2F;boot&#x2F;lost+found 就是 &#x2F;boot 分区的备份恢复目录 &#x2F;proc&#x2F; 虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 &#x2F;proc&#x2F;cpuinfo 是保存 CPU 信息的，&#x2F;proc&#x2F;devices 是保存设备驱动的列表的，&#x2F;proc&#x2F;filesystems 是保存文件系统列表的，&#x2F;proc&#x2F;net 是保存网络协议信息的…… &#x2F;sys&#x2F; 虚拟文件系统。和 &#x2F;proc&#x2F; 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息 Linux &#x2F;usr目录usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 &#x2F;usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。 Linux 系统中，所有系统默认的软件都存储在 &#x2F;usr 目录下，&#x2F;usr 目录类似 Windows 系统中 C:\\Windows\\ + C:\\Program files\\ 两个目录的综合体。 FHS 建议，&#x2F;usr 目录应具备表 3 所示的子目录。 子目录 功能（作用） &#x2F;usr&#x2F;bin&#x2F; 存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行 &#x2F;usr&#x2F;sbin&#x2F; 存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。 &#x2F;usr&#x2F;lib&#x2F; 应用程序调用的函数库保存位置 &#x2F;usr&#x2F;XllR6&#x2F; 图形界面系统保存位置 &#x2F;usr&#x2F;local&#x2F; 手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置 &#x2F;usr&#x2F;share&#x2F; 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录 &#x2F;usr&#x2F;src&#x2F; 源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 &#x2F;usr&#x2F;local&#x2F;src&#x2F; 目录中，把内核源码保存到 &#x2F;usr&#x2F;src&#x2F;linux&#x2F; 目录中 &#x2F;usr&#x2F;include C&#x2F;C++ 等编程语言头文件的放置目录 Linux &#x2F;var 目录&#x2F;var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如表 4 所示的这些子目录。 &#x2F;var子目录 功能（作用） &#x2F;var&#x2F;lib&#x2F; 程序运行中需要调用或改变的数据保存位置。如 MySQL &#x2F;var&#x2F;log&#x2F; 登陆文件放置的目录，其中所包含比较重要的文件如 &#x2F;var&#x2F;log&#x2F;messages, &#x2F;var&#x2F;log&#x2F;wtmp 等。 &#x2F;var&#x2F;run&#x2F; 一些服务和程序运行后，它们的 PID（进程 ID）保存位置 &#x2F;var&#x2F;spool&#x2F; 里面主要都是一些临时存放，随时会被用户所调用的数据，例如 &#x2F;var&#x2F;spool&#x2F;mail&#x2F; 存放新收到的邮件，&#x2F;var&#x2F;spool&#x2F;cron&#x2F; 存放系统定时任务。 &#x2F;var&#x2F;www&#x2F; RPM 包安装的 Apache 的网页主目录 &#x2F;var&#x2F;nis和&#x2F;var&#x2F;yp NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录 &#x2F;var&#x2F;tmp 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除 根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？ 答案是用户的主目录或 &#x2F;tmp&#x2F; 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 &#x2F;proc&#x2F;fn&#x2F;sys&#x2F; 目录，因为它们是保存在内存中的，如果在这里写入数据，那么你的内存会越来越小，直至死机；&#x2F;boot&#x2F; 目录也不能保存额外数据，因为 &#x2F;boot&#x2F; 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。 总之，Linux 要在合理的目录下进行操作和修改。 什么是挂载，Linux挂载详解Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。 因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。 如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。 挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。 纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。 举个例子，我们想通过命令行访问某个 U 盘中的数据，图 1 所示为 U 盘文件目录结构和 Linux 系统中的文件目录结构。 目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。 接下来，我们在根目录下新建一个目录 &#x2F;sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，挂载效果如图 2 所示。 可以看到，U 盘文件系统已经成为 Linux 文件系统目录的一部分，此时访问 &#x2F;sdb-u&#x2F; 就等同于访问 U 盘。 前面讲过，根目录下的 &#x2F;dev&#x2F; 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件（比如 sdb1），就位于 &#x2F;dev&#x2F; 目录下（&#x2F;dev&#x2F;sdb1），但无法通过 &#x2F;dev&#x2F;sdb1&#x2F; 直接访问 U 盘数据，访问此目录只会提供给你此设备的一些基本信息（比如容量）。 总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。 Linux文件和目录管理Linux文件系统的层次结构在 Linux 操作系统中，所有的文件和目录都被组织成以一个根节点“&#x2F;”开始的倒置的树状结构，如图 1 所示。 其中，目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。 文件系统的最顶层是由根目录开始的，系统使用“&#x2F;”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。 其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。 现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。 注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“&#x2F;”来分隔。如 cat 的完整路径是 &#x2F;home&#x2F;cat。 在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“..”表示。 如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找时，不显示该目录或文件。 为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件（或子目录），比如说，在 &#x2F;bin 和 &#x2F;sbin 目录中存放的应该是可执行文件，有关各个目录存放文件的类型 Linux绝对路径和相对路径指明一个文件存放的位置，有 2 种方法，分别是使用绝对路径和相对路径。 我们知道，Linux 系统中所有的文件（目录）都被组织成以根目录“&#x2F;”开始的倒置的树状结构，如图 1 所示。 绝对路径一定是由根目录 &#x2F; 开始写起。例如，使用绝对路径的表示方式指明 bin 文件所在的位置，该路径应写为 &#x2F;usr&#x2F;bin，测试代码如下： 1234[root@localhost ~]# binbash： bin： command not found &lt;-- 没有找到[root@localhost ~]# /usr/binbash: /usr/bin: is a directory &lt;-- 是一个文件 可以看到，如果仅传递给 Linux 系统一个文件名，它无法找到指定文件；而当将 bin 文件的绝对路径传递 Linux 系统时，它就可以成功找到。 和绝对路径不同，相对路径不是从根目录 &#x2F; 开始写起，而是从当前所在的工作目录开始写起。使用相对路径表明某文件的存储位置时，经常会用到前面讲到的 2 个特殊目录，即当前目录（用 . 表示）和父目录（用 .. 表示）。 举个例子，当我们使用 root 身份登录 Linux 系统时，当前工作目录默认为 &#x2F;root，如果此时需要将当前工作目录调整到 root 的子目录 Desktop 中，当然可以使用绝对路径，示例代码如下： 12345[root@localhost ~]# pwd &lt;-- 显示当前所在的工作路径/root[root@localhost ~]# cd /root/Desktop[root@localhost Desktop]# pwd/root/Desktop 可以看到，通过使用绝对路径，我们成功地改变了当前工作路径。但除此之外，使用相对路径的方式会更简单。因为目前处于 &#x2F;root 的位置，而 Desktop 就位于当前目录下，所以： 12345[root@localhost ~]# pwd &lt;-- 显示当前所在的工作路径/root[root@localhost ~]# cd ./Desktop[root@localhost Desktop]# pwd/root/Desktop 此代码中，.&#x2F;Desktop 表示的就是 Destop 文件相对于 &#x2F;root 所在的路径。 再举一个例子，如果以 root 身份登录 Linux 系统，并实现将当前工作目录由 &#x2F;root 转换为 &#x2F;usr 目录，有以下 2 种方式： 123456789101112#使用绝对路径[root@localhost ~]# pwd &lt;-- 显示当前所在的工作路径/root[root@localhost ~]# cd /usr[root@localhost ~]# pwd/usr#使用相对路径[root@localhost ~]# pwd &lt;-- 显示当前所在的工作路径/root[root@localhost ~]# cd ../usr &lt;-- 相对 root，usr 位于其父目录 /，因此这里要用到 ..[root@localhost ~]# pwd/usr 总之，绝对路径是相对于根路径 &#x2F; 的，只要文件不移动位置，那么它的绝对路径是恒定不变的；而相对路径是相对于当前所在目录而言的，随着程序的执行，当前所在目录可能会改变，因此文件的相对路径不是固定不变的。 Linux文件（目录）命名规则我们知道，在 Linux 系统中，一切都是文件，既然是文件，就必须要有文件名。同其他系统相比，Linux 操作系统对文件或目录命名的要求相对比较宽松。 Linux 系统中，文件和目录的命名规则如下： 除了字符“&#x2F;”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 &lt;、&gt;、？、* 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。 目录名或文件名的长度不能超过 255 个字符。 目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。 与 Windows 操作系统不同，文件的扩展名对 Linux 操作系统没有特殊的含义，换句话说，Linux 系统并不以文件的扩展名开分区文件类型。例如，dog.exe 只是一个文件，其扩展名 .exe 并不代表此文件就一定是可执行文件。 需要注意的是，在 Linux 系统中，硬件设备也是文件，也有各自的文件名称。Linux 系统内核中的 udev 设备管理器会自动对硬件设备的名称进行规范，目的是让用户通过设备文件的名称，就可以大致猜测处设备的属性以及相关信息。 udev 设备管理器会一直以进程的形式运行，并侦听系统内核发出的信号来管理位于 &#x2F;dev 目录下的设备文件。 表 1 罗列出了Linux 系统中常见硬件设备的文件名。 硬件设备 文件名称 IDE设备 &#x2F;dev&#x2F;hd[a-d]，现在的 IDE设备已经很少见了，因此一般的硬盘设备会以 &#x2F;dev&#x2F;sd 开头。 SCSI&#x2F;SATA&#x2F;U盘 &#x2F;dev&#x2F;sd[a-p]，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。 软驱 &#x2F;dev&#x2F;fd[0-1] 打印机 &#x2F;dev&#x2F;lp[0-15] 光驱 &#x2F;dev&#x2F;cdrom 鼠标 &#x2F;dev&#x2F;mouse 磁带机 &#x2F;dev&#x2F;st0 或 &#x2F;dev&#x2F;ht0 Linux命令行下如何识别文件类型？对于第一次使用 Linux 命令行的用户，可能真的搞不清楚哪个是文件，哪个是目录，究其原因是很难直接通过名字看出来目录和文件的区别。 虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。例如： 图 1 &#x2F;root 目录下的文件和目录 注意，本节多处会使用 pwd（显示当前工作所在的目录）和 ls（列出当前目录中包含的所有文件和子目录）命令，读者只需了解它们的功能即可，本章后续会对它们做详细介绍。 和 Linux 不同，Windows 下带有 标记的行或使用中括号“[]”括起来的名称就是目录，其他的则是文件（如图 2 所示）。 图 2 Windows命令行区分文件和目录（文件夹) 不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。 但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 &#x2F;etc&#x2F;DIR_COLORS 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 man 命令，例如： [root@localhost ~]# man dir_colors 注意，有些 Linux 发行版单独使用 ls 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 ls –color&#x3D;auto 命令，明确令其使用颜色来区分文件类型。 在此基础上，如果不想每次使用 ls 命令时，都显式附带 –color&#x3D;auto，可以执行如下命令： [root@localhost ~]# alias ls &#x3D; ‘ls –color&#x3D;auto’ 通过给 ls –color&#x3D;&#x3D;auto 这个整体设置一个别名 ls，这样当后续使用 ls 命令时，就等同于执行 ls –color&#x3D;auto 命令。 同时，如果想使这个设置永远生效，还需要将其添加到 &#x2F;etc&#x2F;bashrc 或 &#x2F;home&#x2F;&#x2F;.bashrc 文件中，前者对所有用户有效，而后者仅对用户有效。 其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。 当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。 通过 ls -l 命令，我们就可以查看当前目录下所有文件和目录各自的属性，如图 3 所示。 查看属性](https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203151448472.gif)图 3 查看属性 图 3 显示的执行结构中，每行代表一个文件或目录，其中第一个字符表示的就是文件的类型，其可能的取值以及表示的文件类型，如表 4 所示。 第一个字符 文件类型 - 普通文件，包括纯文本文件、二进制文件、各种压缩文件等。 d 目录，类似 Windows 系统中的文件夹。 b 块设备文件，就是保存大块数据的设备，比如最常见的硬盘。 c 字符设备文件，例如键盘、鼠标等。 s 套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。 p 管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。 l 链接文件，类似 Windows 系统中的快捷方式。 除以上 2 种方法外，Linux 还提供了 file 命令，可以查询文件的类型 Linux命令基本格式我们不会再见到图形界面了，因为对服务器来讲，图形界面会占用更多的系统资源，而且会安装更多的服务、开放更多的端口，这对服务器的稳定性和安全性都有负面影响。其实，服务器是一个连显示器都没有的家伙，要图形界面干什么？对服务器来讲，稳定性、可靠性、安全性才是最主要的。而简单易用不是服务器需要考虑的事情，所以学习 Linux，这些枯燥的命令是必须学习和记忆的内容。 命令提示符登录系统后，第一眼看到的内容是： 1[root@localhost ~]# 这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢？ []：这是提示符的分隔符号，没有特殊含义。 root：显示的是当前的登录用户，笔者现在使用的是 root 用户登录。 @：分隔符号，没有特殊含义。 localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。 ~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。 #：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是 $。 家目录（又称主目录）是什么？ Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家： 超级用户的家目录：&#x2F;root。 普通用户的家目录：&#x2F;home&#x2F;用户名。 用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。 12[root@localhost ~]# cd /usr/local[root@localhost local]# 仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 &#x2F;usr&#x2F; local，只显示最后一个目录 local)。 命令的基本格式接下来看看 Linux 命令的基本格式: 1[root@localhost ~]# 命令[选项][参数] 命令格式中的 [] 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 ls 命令来解释一下命令的格式。如果按照命令的分类，那么 ls 命令应该属于目录操作命令。 12[root@localhost ~]# lsanaconda-ks.cfg install.log install.log.syslog 1) 选项的作用ls 命令之后不加选项和参数也能执行，不过只能执行最基本的功能，即显示当前目录下的文件名。那么加入一个选项，会出现什么结果？ 12345[root@localhost ~]# ls -l总用量44-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg-rw-r--r--.1 root root 24772 1 月 14 18:17 install.log-rw-r--r--.1 root root 7690 1 月 14 18:17 install.log.syslog 如果加一个”-l”选项，则可以看到显示的内容明显增多了。”-l”是长格式（long list）的意思，也就是显示文件的详细信息。至于 “-l” 选项的具体含义，我们稍后再详细讲解。可以看到选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。 Linux 的选项又分为短格式选项（-l）和长格式选项（–all）。短格式选项是英文的简写，用一个减号调用，例如： 1[root@localhost ~]# ls -l 而长格式选项是英文完整单词，一般用两个减号调用，例如： 1[root@localhost ~]# ls --all 一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 ls 命令的短格式选项 -l 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。 2) 参数的作用参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如： 12[root@localhost ~]# ls -l anaconda-ks.cfg-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg 但是为什么一开始 ls 命令可以省略参数？那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如： 12[root@localhost ~]# lsanaconda-ks.cfg install.log install.log.syslog 这个 ls 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。 总结一下：命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。 Linux cd命令：切换目录cd 命令，是 Change Directory 的缩写，用来切换工作目录。 Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 cd 命令是一个典型的 Shell 内置命令，所以 cd 命令没有执行文件所在路径。 cd 命令的基本格式如下： 12[root@localhost ~]# cd [相对路径或绝对路径]除此之外，cd 命令后面可以跟一些特殊符号，表达固定的含义，如表 1 所示： 特殊符号 作 用 ~ 代表当前登录用户的主目录 ~用户名 表示切换至指定用户的主目录 - 代表上次所在目录 . 代表当前目录 .. 代表上级目录 它们的用法分别是： 123456[root@localhost vbird]# cd ~#表示回到自己的主目录，对于 root 用户，其主目录为 /root[root@localhost ~]# cd#没有加上任何路径，也代表回到当前登录用户的主目录[root@localhost ~]# cd ~vbird#代表切换到 vbird 这个用户的主目录，亦即 /home/vbird 12[root@localhost ~]# cd ..#表示切换到目前的上一级目录，亦即是 /root 的上一级目录的意思； 需要注意的是，在 Linux 系统中，根目录确实存在 .（当前目录）以及 ..（当前目录的父目录）两个目录，但由于根目录是最顶级目录，因此根目录的 .. 和 . 的属性和权限完全一致，也就是说，根目录的父目录是自身。 12[root@localhost /]# cd -#表示回到刚刚的那个目录 如果你仔细观察的话，不难发现，其实在 [root@localhost ~] 中，就已经指明了当前所在的目录，通常刚登陆时会位于自己的主目录中，而 ~ 就表示主目录，因此也就有了通过使用 cd ~ 可以回到自己的主目录。 【例 1】学习 cd - 的用法。 12345678910[root@localhost ~]# cd /usr/local/src#进入/usr/local/src目录[root@localhost src]# cd -/root[root@localhost ~]##&quot;cd -&quot;命令回到进入 src 目录之前的主目录[root@localhost ~]# cd -/usr/local/src[root@localhost src]##再执行一遍&quot;cd -&quot;命令，又回到了 /usr/local/src 目录 【例 2】学习 cd . 和 cd .. 的用法。 123456789101112[root@localhost ~]# cd /usr/local/src#进入测试目录[root@localhost src]# cd ..#进入上级目录[root@localhost local]# pwd/usr/local#pwd是査看当前所在目录的命令，可以看到我们进入了上级目录 /usr/local[root@localhost local]# cd .#进入当前目录[root@localhost local]# pwd/usr/local#这个命令不会有目录的改变，只是告诉大家&quot;.&quot;代表当前目录 pwd 命令用于显示当前所在的目录 Linux pwd命令：显示当前路径由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录（目前的工作目录）搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。 当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢？可以使用 Linux 系统的 pwd 命令来显示当前目录的绝对路径。 pwd 命令，是 Print Working Directory （打印工作目录）的缩写，功能是显示用户当前所处的工作目录。该命令的基本格式为： 1[root@localhost ~]# pwd 【例 1】 1234[root@localhost ~]# whoamiroot[root@localhost ~]# pwd/root whoami 命令用于确定当前登陆的用户，后续会做详细介绍。可以看到，root 用户当前所在目录是它的主目录 &#x2F;root。 【例 2】 1234[demo@localhost ~]# whoamidemo[demo@localhost ~]# pwd/home/demo 以上代码表明，当前登陆 Linux 系统的是用户 demo，当前所在目录为 demo 的主目录 &#x2F;home&#x2F;demo。 注意，在 [demo@localhost ~]# 这一部分中，虽然也显示出当前所在的目录（例如 ~ 表示主目录），但此位置只会列出整个路径中最后的那一个目录，比如： 123[root@localhost ~]# cd /var/mail[root@localhost mail]# pwd/var/mail 我们知道，不同的目录中，目录名是可以重复的，因此，仅通过 [root@localhost mail] 中的 mail，根本无法判断其所在的具体位置，而使用 pwd 命令，可以输出当前所在目录的完整路径。 Linux ls命令：查看目录下文件如何知道某目录中存放了哪些文件或子目录。 ls 命令，list 的缩写，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。此命令的基本格式为： 1[root@localhost ~]# ls [选项] 目录名称 表 1 列出了 ls 命令常用的选项以及各自的功能。 选项 功能 -a 显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。 -A 显示全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录。 -d 仅列出目录本身，而不是列出目录内的文件数据。 -f ls 默认会以文件名排序，使用 -f 选项会直接列出结果，而不进行排序。 -F 在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，&#x2F; 代表目录，&#x3D; 代表 socket 文件，| 代表 FIFO 文件。 -h 以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。 -i 显示 inode 节点信息。 -l 使用长格式列出文件和目录信息。 -n 以 UID 和 GID 分别代替文件用户名和群组名显示出来。 -r 将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。 -R 连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。 -S 以文件容量大小排序，而不是以文件名排序。 -t 以时间排序，而不是以文件名排序。 –color&#x3D;never –color&#x3D;always –color&#x3D;auto never 表示不依据文件特性给予颜色显示。 always 表示显示颜色，ls 默认采用这种方式。 auto 表示让系统自行依据配置来判断是否给予颜色。 –full-time 以完整时间模式 （包含年、月、日、时、分）输出 –time&#x3D;{atime,ctime} 输出 access 时间或改变权限属性时间（ctime），而不是内容变更时间。 注意，当 ls 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色（蓝色显示目录，白色显示一般文件）。除此之外，如果想使用 ls 命令显示更多内容，就需要使用表 1 相应的选项。 【例 1】 123456789101112[root@www ~]# ls -al ~total 156drwxr-x--- 4 root root 4096 Sep 24 00:07 .drwxr-xr-x 23 root root 4096 Sep 22 12:09 ..-rw------- 1 root root 1474 Sep 4 18:27 anaconda-ks.cfg-rw------- 1 root root 955 Sep 24 00:08 .bash_history-rw-r--r-- 1 root root 24 Jan 6 2007 .bash_logout-rw-r--r-- 1 root root 191 Jan 6 2007 .bash_profile-rw-r--r-- 1 root root 176 Jan 6 2007 .bashrcdrwx------ 3 root root 4096 Sep 5 10:37 .gconf-rw-r--r-- 1 root root 42304 Sep 4 18:26 install.log-rw-r--r-- 1 root root 5661 Sep 4 18:25 install.log.syslog 通过使用 -a，你会看到以 . 为开头的几个文件，以及目录文件 （.）、（..）、.gconf 等等，这些都是隐藏的目录和文件。其中，目录文件名以蓝色显示，一般文件以白色显示。 注意，Linux 系统中，隐藏文件不是为了把文件藏起来不让其他用户找到，而是为了告诉用户这些文件都是重要的系统文件，如非必要，不要乱动！所以，不论是 Linux 还是 Windows 都可以非常简单地査看隐藏文件，只是在 Windows 中绝大多数的病毒和木马都会把自己变成隐藏文件，给用户带来了错觉，以为隐藏文件是为了不让用户发现。 不仅如此，这里的 ls 命令还使用了 -l 选项，因此才显示出了文件的详细信息，此选项显示的这 7 列的含义分别是： 第一列：规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。 第二列：引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。 第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。 第四列：所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。 第五列：大小，默认单位是字节。 第六列：文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。 第七列：文件名或目录名。 【例 2】如果我们想查看某个目录的详细信息，例如： 12345[root@localhost ~]# ls -l /root/总用量44-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg-rw-r-r--.1 root root 24772 1 月 14 18:17 install.log-rw-r-r--.1 root root 7690 1 月 14 18:17 install.log.syslog 这个命令会显示目录下的内容，而不会显示这个目录本身的详细信息。如果想显示目录本身的信息，就必须加入 “-d” 选项。 12[root@localhost ~]# ls -ld /root/dr-xr-x---.2 root root 4096 1 月 20 12:30 /root/ 【例 3】“ls-l” 显示的文件大小是字节，但是我们更加习惯的是千字节用 KB 显示，兆字节用 MB 显示，而 “-h” 选项就是按照人们习惯的单位显示文件大小的，例如： 12345[root@localhost ~]# ls -lh总用量44K-rw-------.1 root root 1.2K 1 月 14 18:18 anaconda-ks.cfg-rw-r-r--.1 root root 25K 1 月 14 18:17 install.log-rw-r-r--.1 root root 7.6K 1 月 14 18:17 install.log.syslog Linux mkdir命令：创建目录（文件夹）mkdir 命令，是 make directories 的缩写，用于创建新目录，此命令所有用户都可以使用。 mkdir 命令的基本格式为： 1[root@localhost ~]# mkdir [-mp] 目录名 -m 选项用于手动配置所创建目录的权限，而不再使用默认权限。 -p 选项递归创建所有目录，以创建 &#x2F;home&#x2F;test&#x2F;demo 为例，在默认情况下，你需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮你创建 &#x2F;home、&#x2F;home&#x2F;test 以及 &#x2F;home&#x2F;test&#x2F;demo。 【例 1】建立目录。 123[root@localhost ~]#mkdir cangls[root@localhost ~]#lsanaconda-ks.cfg cangls install.log install.log.syslog 我们建立一个名为 cangls 的目录，通过 ls 命令可以查看到这个目录已经建立。注意，我们在建立目录的时候使用的是相对路径，所以这个目录被建立到当前目录下。 【例 2】使用 -p 选项递归建立目录。 12345678[root@localhost ~]# mkdir lm/movie/jp/canglsmkdir:无法创建目录&quot;lm/movie/jp/cangls&quot;:没有那个文件或目录[root@localhost ~]# mkdir -p lm/movie/jp/cangls[root@localhost ~]# lsanaconda-ks.cfg cangls install.log install.log.syslog lm[root@localhost ~]# ls lm/movie#这里只查看一级子目录，其实后续的jp目录、cangls目录都已经建立 【例 3】使用 -m 选项自定义目录权限。 12345[root@localhost ~]# mkdir -m 711 test2[root@localhost ~]# ls -ldrwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2 仔细看上面的权限部分，也就是 ls 命令输出的第一列数据，test 和 test1 目录由于不是使用 -m 选项设定访问权限，因此这两个目录采用的是默认权限（这里的默认权限值是 755，后续章节再详细介绍默认权限）。 而在创建 test2 时，使用了 -m 选项，通过设定 711 权限值来给予新的目录 drwx–x–x 的权限 Linux rmdir命令：删除空目录和 mkdir 命令（创建空目录）恰好相反，rmdir（remove empty directories 的缩写）命令用于删除空目录，此命令的基本格式为： 1[root@localhost ~]# rmdir [-p] 目录名 -p 选项用于递归删除空目录。 【例 1】 1[root@localhost ~]#rmdir cangls 就这么简单，命令后面加目录名称即可，但命令执行成功与否，取决于要删除目录是否是空目录，因为 rmdir 命令只能删除空目录。 【例 2】通过学习 mkdir 命令我们知道，使用 mkdir -p 可以实现递归建立目录，同样地，rmdir 命令可以使用 -p 选项递归删除目录。例如： 1[root@localhost ~]# rmdir -p lm/movie/jp/cangls 注意，此方式先删除最低一层地目录（这里先删除 cangls），然后逐层删除上级目录，删除时也需要保证各级目录是空目录。 【例 3】rmdir 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。例如： 1234567[root@localhost # mkdir test#建立测试目录[root@localhost ~]# touch test/boduo[root@localhost ~]# touch test/longze#在测试目录中建立两个文件[root@localhost ~]# rmdir testrmdir:删除&quot;test&quot;失败：目录非空 这个命令比较”笨”，所以并不常用。后续我们会学习 rm 命令，使用此命令不但可以删除目录，还可以删除文件。 Linux touch命令：创建文件及修改文件时间戳既然知道了如何在 Linux 系统中创建目录，接下来你可能会想在这些目录中创建一些文件，可以使用 touch 命令。 需要注意的是，touch 命令不光可以用来创建文件（当指定操作文件不存在时，该命令会在当前位置建立一个空文件），此命令更重要的功能是修改文件的时间参数（但当文件存在时，会修改此文件的时间参数）。 Linux 系统中，每个文件主要拥有 3 个时间参数（通过 stat 命令进行查看），分别是文件的访问时间、数据修改时间以及状态修改时间： 访问时间（Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变。 数据修改时间（Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。 状态修改时间（Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。 touch 命令的基本格式如下： 1[root@localhost ~]# touch [选项] 文件名 选项： -a：只修改文件的访问时间； -c：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。 -d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。 -m：只修改文件的数据修改时间。 -t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。 可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变（更新为操作当前文件的真正时间）。 【例 1】 touch 命令创建文件。 12[root@localhost ~]#touch bols#建立名为 bols 的空文件 【例 2】 在例 1 的基础上修改文件的访问时间。 12345678[root@localhost ~]#ll --time=atime bols#查看文件的访问时间-rw-r--r-- 1 root root 0 Sep 25 21:23 bols#文件上次的访问时间为 9 月 25 号 21：23[root@localhost ~]#touch bols[root@localhost ~]#ll --time=atime bols-rw-r--r-- 1 root root 0 May 15 16:36 bols#而如果文件已经存在，则也不会报错，只是会修改文件的访问时间。 【例 3】 修改 bols 文件的 atime 和 mtime。 123456[root@localhost ~]# touch -d &quot;2017-05-04 15:44&quot; bols[root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols-rw-r--r-- 1 root root 0 May 4 2017 bols-rw-r--r-- 1 root root 0 May 4 2017 bols-rw-r--r-- 1 root root 0 Sep 25 21:40 bols#ctime不会变为设定时间，但更新为当前服务器的时间 Linux ln命令：建立链接（硬链接和软链接）文件如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统（Linux 文件系统）是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。如果用一张示意图来描述 ext4 文件系统，则可以参考图 1。 ext4 文件系统会把分区主要分为两大部分（暂时不提超级块）：小部分用于保存文件的 inode (i 节点）信息；剩余的大部分用于保存 block 信息。 inode 的默认大小为 128 Byte，用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。 block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。 由此，我们可以知道以下 2 个重要的信息： 每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向； 如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块； 了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。 ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种： 软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。 硬链接：我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。 ln 命令的基本格式如下： 1[root@localhost ~]# ln [选项] 源文件 目标文件 选项： -s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件； -f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件； 【例 1】创建硬链接： 1234[root@localhost ~]# touch cangls[root@localhost ~]# ln /root/cangls /tmp#建立硬链接文件，目标文件没有写文件名，会和原名一致#也就是/tmp/cangls 是硬链接文件 【例 2】创建软链接： 123[root@localhost ~]# touch bols[root@localhost ~]# In -s /root/bols /tmp#建立软链接文件 这里需要注意的是，软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。这是初学者非常容易犯的错误。 硬链接：硬链接是新的目录条目，其引用系统中的现有文件。文件系统中的每一文件默认具有一个硬链接。为节省空间，可以不复制文件，而创建引用同一文件的新硬链接。新硬链接如果在与现有硬链接相同的目录中创建，则需要有不同的文件名，否则需要在不同的目录中。指向同一文件的所有硬链接具有相同的权限、连接数、用户&#x2F;组所有权、时间戳以及文件内容。指向同一文件内容的硬链接需要在相同的文件系统中。简单说，硬链接就是一个 inode 号对应多个文件。就是同一个文件使用了多个别名 由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性： 文件有相同的 inode 及 data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其他有相同 inode 号的文件。 第三条不能交叉文件系统进行硬链接的创建，为什么？inode 是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，即当 inode 存在且链接计数器（link count）不为 0 时。inode 号仅在各文件系统下是唯一的，当 Linux 挂载多个文件系统后将出现 inode 号重复的现象，因此硬链接创建时不可跨文件系统。 第四条中不能对目录创建硬链接，为什么？简单说，如果针对文件做硬连接，等于针对这个文件对应的inode又做一个链接。所以硬链接等于是同一个inode对应多个文件名。对于目录来说，就是保存这些链接的一个inode。如果针对目录做硬链接，一个子目录的硬链接指向父目录的话，这样就循环了。现 Linux 文件系统中的目录均隐藏了两个个特殊的目录：当前目录（.）与父目录（..）。查看这两个特殊目录的inode号可知其实这两目录就是两个硬链接。若系统允许对目录创建硬链接，则会产生目录环。 软链接：（又称符号链接，即 soft link 或 symbolic link） 软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。软连接可以指向目录，而且软连接所指向的目录可以位于不同的文件系统中。 软链接可以指向目录。而后软连接作为目录使用。可以通过cd正常更改到软连接目录。 软链接特性： 软链接有自己的文件属性及权限等； 可对不存在的文件或目录创建软链接； 软链接可交叉文件系统； 软链接可对文件或目录创建； 创建软链接时，链接计数 i_nlink 不会增加； 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接或悬挂的软链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。 当然软链接的用户数据也可以是另一个软链接的路径，其解析过程是递归的。但需注意：软链接创建时原文件的路径指向使用绝对路径较好。使用相对路径创建的软链接被移动后该软链接文件将成为一个死链接，因为链接数据块中记录的亦是相对路径指向。 Linux硬链接和软链接详解对硬链接的深度剖析首先，我们再来建立一个硬链接文件，然后看看这两个文件的特点。 123456789[root@localhost ~]# touch test#建立源文件[root@localhost ~]# ln /root/test /tmp/test-hard#给源文件建立硬链接文件 /tmp/test-hard[root@localhost ~]# ll -i /root/test /tmp/test-hard262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /root/testhard262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /tmp/test-hard#查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，&quot;ll&quot;等同于&quot;ls -l&quot;。 这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。 但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢？我们来画一张示意图，如图 2 所示。 图 2 硬链接示意图 在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。 当我们查找一个文件，比如 &#x2F;root&#x2F;test 时，要经过以下步骤： 首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。 如果有权限，则可以在根目录的 block 中访问到 &#x2F;root 的文件名及对应的 inode 号。 通过 &#x2F;root&#x2F; 目录的 inode 号，可以查找到 &#x2F;root&#x2F; 目录的 inode 信息，接着判断用户是否有权限访问 &#x2F;root&#x2F; 目录的 block。 如果有权限，则可以从 &#x2F;root&#x2F; 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。 通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。 如果有权限，则可以读取 block 中的数据，这样就完成了 &#x2F;root&#x2F;test 文件的读取与访问。 按照这个步骤，在给源文件 &#x2F;root&#x2F;test 建立了硬链接文件 &#x2F;tmp&#x2F;test-hard 之后，在 &#x2F;root&#x2F; 目录和 &#x2F;tmp&#x2F; 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。 这就是硬链接的原理。硬链接的特点如下： 不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。 不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。 硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。 硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。 硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。 硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。 我们通过实验来测试一下。 123456789101112131415161718192021[root@localhost ~]# echo 1111 &gt;&gt;/root/test#向源文件中写入数据[root@localhost ~]# cat /root/test1111[root@localhost ~]# cat /tmp/test-hard1111#源文件和硬链接文件都会发生改变[root@localhost ~]# echo 2222 &gt;&gt; /tmp/test-hard#向硬链接文件中写入数据[root@localhost ~]# cat /root/test11112222[root@localhost ~】# cat /tmp/test-hard11112222#源文件和硬链接文件也都会发生改变[root@localhost ~]# rm -rf/root/test#删除源文件[root@localhost ~]# cat /tmp/test-hard1111 2222#硬链接文件依然可常读取 对软链接的深度剖析软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。 123456789[root@localhost ~]# touch check#建立源文件[root@localhost ~]# ln -s /root/check /tmp/check-soft#建立软链接文件[root@localhost ~]# ll -id /root/check /tmp/check-soft262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -&gt; /root/check#软链接和源文件的 inode 号不一致，软链接通过 -&gt; 明显地标识出源文件的位置#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件 再强调一下，软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用。 软链接的标志非常明显，首先，权限位中”l”表示这是一个软链接文件；其次，在文件的后面通过 “-&gt;” 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。 软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。 大家在学习软链接的时候会有一些疑问：Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢？ 笔者个人觉得，软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 &#x2F;etc&#x2F;rc.local 放置在 &#x2F;etc 目录中，而有些系统却将其放置在 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 中，那么干脆对这两个文件建立软链接，不论你习惯操作哪一个文件，结果都是一样的。 如果你比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图 3 所示。 图 3 软链接示意图 软链接和硬链接在原理上最主要的不同在于：硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。 我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。 首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。 如果有权限访问根目录的 block，就会在 block 中查找到 &#x2F;tmp&#x2F; 目录的 inode 号。 接着访问 &#x2F;tmp&#x2F; 目录的 inode 信息，判断用户是否有权限访问 &#x2F;tmp&#x2F; 目录的 block。 如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。 通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。 如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。 接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。 如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。 通过这个过程，我们就可以总结出软链接的特点（软链接的特点和 Windows 中的快捷方式完全一致）。 不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。 删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。 软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。 软链接可以链接目录。 软链接可以跨分区。 我们测试一下软链接的特性。 123456789101112131415161718192021[root@localhost ~]# echo 111&gt;&gt;/root/check#修改源文件[root@localhost ~]# cat /root/check111[root@localhost ~]# cat /tmp/check-soft111#不论是源文件还是软链接文件，数据都发生改变[root@localhost ~]# echo 2222 &gt;&gt;/tmp/check-soft#修改软链接文件[root@localhost ~]# cat /tmp/check-soft1112222[root@localhost ~]# cat /root/check1112222#不论是源文件还是软链接文件，数据也都会发生改变[root@localhost ~]# rm -rf/root/check#删除源文件[root@localhost ~]# cat /tmp/check-softcat: /tmp/check-soft:没有那个文件或目录#软链接无法正常使用 软链接是可以链接目录的，例如： 123456[root@localhost ~]# mkdir test#建立源目录[root@localhost ~]# ln -s /root/test/ /tmp/[root@localhost ~]# ll -d /tmp/testlrwxrwxrwx 1 root root 11 6月 19 12:43 /tmp/test-&gt;/root/test/#软链接可以链接目录 Linux cp命令：复制文件和目录cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。 cp 命令的基本格式如下： 1[root@localhost ~]# cp [选项] 源文件 目标文件 选项： -a：相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍； -d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接； -i：询问，如果目标文件已经存在，则会询问是否覆盖； -l：把目标文件建立为源文件的硬链接文件，而不是复制源文件； -s：把目标文件建立为源文件的软链接文件，而不是复制源文件； -p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）； -r：递归复制，用于复制目录； -u：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。 需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。 这里的软链接，类似于 Windows 系统中的快捷方式，而硬链接则是透过文件系统的 inode 号产生一个新的文件名。无论是复制软链接还是硬链接，都不是复制源文件。 【例 1】cp 命令基本用法cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如： 1234[root@localhost ~]# touch cangls#建立源文件[root@localhost ~]# cp cangls /tmp/#把源文件不改名复制到 /tmp/ 目录下 如果需要改名复制，则命令如下： 12[root@localhost ~]# cp cangls /tmp/bols#改名复制 如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是“cp -i”的别名，例如： 123[root@localhost ~]# cp cangls /tmp/cp:是否覆盖&quot;/tmp/cangls&quot;?y#目标位置有同名文件，所以会提示是否覆盖 接下来我们看看如何复制目录，其实复制目录只需使用“-r”选项即可，例如： 1234[root@localhost ~]# mkdir movie#建立测试目录[root@localhost ~]# cp -r /root/movie/ /tmp/#目录原名复制 【例 2】复制软链接文件如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢？我们试试： 1234567891011121314[root@localhost ~]# ln -s /root/cangls /tmp/cangls_slink#建立一个测试软链接文件/tmp/cangls_slink[root@localhost ~]# ll /tmp/cangls_slinklrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -&gt; /root/cangls#源文件本身就是一个软链接文件[root@localhost ~]# cp /tmp/cangls_slink /tmp/cangls_t1#复制软链接文件，但是不加&quot;-d&quot;选项[root@localhost ~]# cp -d /tmp/cangls_slink /tmp/cangls_t2#复制软链接文件，加入&quot;-d&quot;选项[root@localhost ~]# ll /tmp/cangls_t1 /tmp/cangls_t2-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1#会发现不加&quot;-d&quot;选项，实际复制的是软链接的源文件，而不是软链接文件lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-&gt; /root/cangls#而如果加入了&quot;-d&quot;选项，则会复制软链接文件 这个例子说明，如果在复制软链接文件时不使用 “-d” 选项，则 cp 命令复制的是源文件，而不是软链接文件；只有加入了 “-d” 选项，才会复制软链接文件。请大家注意，”-d” 选项对硬链接是无效的。 【例 3】保留源文件属性复制我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如： 1234567[root@localhost ~]# cp /var/lib/mlocate/mlocate.db /tmp/[root@localhost ~]# ll /var/lib/mlocate/mlocate.db-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db#注意源文件的时间和所属组[root@localhost ~]#ll /tmp/mlocate.db-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间 而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 “-p” 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如： 123456[root@localhost ~]# cp -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2#使用&quot;-p&quot;选项[root@localhost ~]# ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db#源文件和目标文件的所有属性都一致，包括时间 我们之前讲过，”-a” 选项相当于 “-d、-p、-r” 选项，这几个选项我们已经分别讲过了。所以，当我们使用 “-a” 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 “-a” 选项来取代 “-d、-p、-r” 选项更加方便。 例 4】 “-l” 和 “-s” 选项我们如果使用 “-l” 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 “-s” 选项，则目标文件会被建立为源文件的软链接。 这两个选项和 “-d” 选项是不同的，”d” 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 “-l” 和 “-s” 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如： 12345678910111213[root@localhost ~]# touch bols#建立测试文件[root@localhost ~]# ll -i bols262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols#源文件只是一个普通文件，而不是软链接文件[root@localhost ~]# cp -l /root/bols /tmp/bols_h[root@localhost ~]# cp -s /root/bols /tmp/bols_s#使用&quot;-l&quot; 和&quot;-s&quot;选项复制[root@localhost ~]# ll -i /tmp/bols_h /tmp/bols_s262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h#目标文件 /tmp/bols_h 为源文件的硬链接文件932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -&gt; /root/bols#目标文件 /tmp/bols_s 为源文件的软链接文件 Linux rm命令：删除文件或目录当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件（即垃圾），这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。 rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为： 1[root@localhost ~]# rm[选项] 文件或目录 选项： -f：强制删除（force），和 -i 选项相反，使用 -f，系统将不再询问，而是直接删除目标文件或目录。 -i：和 -f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 -i 可以有效防止不小心删除有用的文件或目录。 -r：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。 注意，rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。 【例 1】基本用法。rm 命令如果任何选项都不加，则默认执行的是”rm -i 文件名”，也就是在删除一个文件之前会先询问是否删除。例如： 1234[root@localhost ~]# touch cangls[root@localhost ~]# rm canglsrm:是否删除普通空文件&quot;cangls&quot;?y#删除前会询问是否删除 【例 2】 删除目录。如果需要删除目录，则需要使用”-r”选项。例如: 12345678910111213[root@localhost ~]# mkdir -p /test/lm/movie/jp#递归建立测试目录[root@localhost ~]# rm /testrm:无法删除&quot;/test/&quot;: 是一个目录#如果不加&quot;-r&quot;选项，则会报错[root@localhost ~]# rm -r /testrm:是否进入目录&quot;/test&quot;?yrm:是否进入目录&quot;/test/lm/movie&quot;?yrm:是否删除目录&quot;/test/lm/movie/jp&quot;?yrm:是否删除目录&quot;/test/lm/movie&quot;?yrm:是否删除目录&quot;/test/lm&quot;?yrm:是否删除目录&quot;/test&quot;?y#会分别询问是否进入子目录、是否删除子目录 大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难！ 【例 3】强制删除。如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如： 1234[root@localhost ~]# mkdir -p /test/lm/movie/jp#重新建立测试目录[root@localhost ~]# rm -rf /test#强制删除，一了百了 加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。 虽然 “-rf” 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 “-rf” 选项。 Linux mv命令：移动文件或改名mv 命令（move 的缩写），既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下： [root@localhost ~]# mv 【选项】 源文件 目标文件 选项： -f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖； -i：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）； -n：如果目标文件已经存在，则不会覆盖移动，而且不询问用户； -v：显示文件或目录的移动过程； -u：若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级； 需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。 【例 1】移动文件或目录。 12345[root@localhost ~]# mv cangls /tmp#移动之后，源文件会被删除，类似剪切[root@localhost ~]# mkdir movie[root@localhost ~]# mv movie/ /tmp#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 &quot;-r&quot; 选项 如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 “mv -i” 的别名，例如： 12345[root@localhost ~]# touch cangls#重新建立文件[root@localhost ~]# mv cangls /tmpmv:县否覆盖&quot;tmp/cangls&quot;？y#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动 【例 2】强制移动。之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。 如果我们确认需要覆盖已经存在的同名文件，则可以使用 “-f” 选项进行强制移动，这就不再需要用户手工确认了。例如： 123456[root@localhost ~]# touch cangls#重新建立文件[root@localhost ~]# mv -f cangls /tmp#就算 /tmp/ 目录下已经存在同名的文件，由于&quot;-f&quot;选项的作用，所以会强制覆盖【例 3】不覆盖移动。既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 &quot;-n&quot; 选项的帮助了。例如： 12345678[root@localhost ~]# ls /tmp/tmp/bols /tmp/cangls#在/tmp/目录下已经存在bols、cangls文件了[root@localhost ~]# mv -vn bols cangls lmls /tmp/、&quot;lmls&quot;-&gt;&quot;/tmp/lmls&quot;#再向 /tmp/ 目录中移动同名文件，如果使用了 &quot;-n&quot; 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动（&quot;-v&quot; 选项用于显示移动过程）【例 4】改名。如果源文件和目标文件在同一目录中，那就是改名。例如： 12[root@localhost ~]# mv bols lmls#把 bols 改名为 lmls 目录也可以按照同样的方法改名。 【例 5】显示移动过程。如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 “-v” 选项来查看详细的移动信息。例如： [root@localhost ~]# touch test1.txt test2.txt test3.txt#建立三个测试文件 12345[root@localhost ~]# mv -v *.txt /tmp&quot;test1.txt&quot; -&gt; &quot;/tmp/test1.txt&quot;&quot;test2.txt&quot; -&gt; &quot;/tmp/test2.txt&quot;&quot;test3.txt&quot; -&gt; &quot;/tmp/test3.txt&quot;#加入&quot;-v&quot;选项，可以看到有哪些文件进行了移动 Linux命令行自动补全功能文件名（或者目录名）是执行 Linux 命令中最常见的参数，例如前面介绍的 cd、mkdir、cp 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名（目录名）特别长的时候。 考虑到这种情况，Shell（Bash）提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。 举个例子，在 &#x2F;etc 目录下，执行如下命令： 12[root@localhost ~]# cd /etc[root@localhost etc]# cd fs &lt;-- 按一次 Tab 键 当按下 Tab 键时，你会发现 Shell 自动将 “fs” 补全成了 “fatab”，这是因为当前 &#x2F;etc 目录中只有 fstab 是以 “fs” 开头，因此 Shell 可以确定这里想要输入的文件名称为 fstab。 那么，如果当前目录中含有多个以指定字符（或字符串）开头的目录或文件，Shell 还可以成功辨认吗？答案是否定的，但它会以列表的形式给出所有以指定字符或字符串开头的文件或目录，供用户选择。 例如，还是在 &#x2F;etc 目录下，执行如下命令： 123[root@localhost etc]# cd b &lt;-- 连续按两次 Tab 键bash_completion.d/ blkid/ bonobo-activation/bashrc bluetooth 可以看到，当按一次 Tab 键时，Shell 没有任何反映，原因就是当前目录下以 “b” 为开头的文件或目录有多个（2 个以上），仅凭一个字符 “b” 无法精准判断出具体指的是哪个文件。而当再一次按下 Tab 键时，Shell 会列表的形式显示给用户当前目录下所有以 “b” 开头的文件或目录。 事实上，Shell 提供的命令行补全功能不仅适用于补全文件名，也同样适用于所有 Linux 命令。举个例子，当输入 ca 并连续按下 2 次 Tab 键时，Shell 会罗列出所有以 “ca” 开头的 Linux 命令，如下所示： 12345[root@localhost etc]# ca &lt;--连续按两次 Tab 键cacertdir_rehash cache_restore capsh catchsegvcache_check cal captoinfocache_dump caller casecache_repair canberra-gtk-play cat 另外，Shell 还有一套被称作通配符的转用符号（如表 1 所示），这些通配符可以搜索并匹配文件名的一部分，从而大大简化了文件名的输入。 符号 作用 * 匹配任意数量的字符。 ? 匹配任意一个字符。 [] 匹配括号内的任意一个字符，甚至 [] 中还可以包含用 -（短横线）连接的字符或数字，表示一定范围内的字符或数字。 为了学习这些通配符的用法，首先需要建立一个空目录（如 test），并在该目录中创建一些文件（供测试用），执行命令如下： 123456[root@localhost etc]# makdir test[root@localhost etc]# cd test[root@localhost test]# touch apple banana grape grapefruit watermelon[root@localhost test]# lsapple banana grape grapefruit watermelon在此基础上，继续执行如下命令： 12345678[root@localhost test]# ls a* &lt;--匹配所有以 a 字符开头的文件名apple[root@localhost test]# ls g*t &lt;--匹配所有以 g 字符开头，以 t 字符结尾的文件名grapefruit[root@localhost test]# ls *e* &lt;--匹配所有包含 e 字符的文件名apple grape grapefruit watermelon[root@localhost test]# ls *n* &lt;--匹配所有包含 n 字符的文件名banana watermelon 结合以上实例，因为 * 可以匹配任何数量的字符，因此可以一一实现实例中标注的功能。 接下来，列举一下使用 ? 匹配文件名的示例： 1234[root@localhost test]# ls ????eapple grape[root@localhost test]# ls g???e*grape grapefruit 因为 1 个 ? 只能匹配 1 个任意字符，因此该示例中第一个例子表示的是匹配任意包含 5 个字符但以 e 结尾的文件（apple 和 grape），第二例子表示匹配任何以 g 开头且第 5 个字符为 e 的文件（grape 和 grapefruit）。 最后，列举一些使用括号 [] 匹配文件名的示例： 1234[root@localhost test]# ls [abw]*apple banana watermelon[root@localhost test]# ls [agw]*[ne]apple grape watermelon 此示例中，第一个例子表示匹配任何以 a、b 或 w 开头的文件；第二个例子中表示匹配任何以 a、g、w 开头，以 n 或 e 结尾的文件名。 不仅如此，[] 中还可以通过 -（短横线）表示一定范围内的任意字符（或数字），例如： 12[root@localhost test]# ls [a-g]*apple banana grape grapefruit 其中，[a-g]* 表示匹配以字母 a 到 g 之间任何一个字母开头的文件名。 什么是环境变量，Linux环境变量及作用变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。 值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。 我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下： 1234567[root@localhost ~]# envORBIT_SOCKETDIR=/tmp/orbit-rootHOSTNAME=livecd.centosGIO_LAUNCHED_DESKTOP_FILE_PID=2065TERM=xtermSHELL=/bin/bash...... Linux 系统能够正常运行并且为用户提供服务，需要数百个环境变量来协同工作，但是，我们没有必要逐一学习每个变量，这里给大家列举了 10 个非常重要的环境变量，如表 1 所示。 环境变量名称 作用 HOME 用户的主目录（也称家目录） SHELL 用户使用的 Shell 解释器名称 PATH 定义命令行解释器搜索用户执行命令的路径 EDITOR 用户默认的文本解释器 RANDOM 生成一个随机数字 LANG 系统语言、语系名称 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 PS1 Bash解释器的提示符 MAIL 邮件保存路径 Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。 例如，使用下述命令来查看 HOME 变量在不同用户身份下都有哪些值： 12345[root@localhost ~]# echo $HOME/root[root@localhost ~]# su - user1 &lt;--切换到 user1 用户身份[user1@localhost ~]$ echo $HOME/home/user1 这里的 su 命令可以临时切换用户身份，此命令的具体用法会在后续章节做详细介绍。 其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 WORKDIR 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下： 12345[root@localhost ~]# mkdir /home/work1[root@localhost ~]# WORKDIR=/home/work1[root@localhost ~]# cd $WORKDIR[root@localhost work1]# pwd/home/work1 但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 export 命令将其提升为全局环境变量，这样其他用户就可以使用它了： 12345678910[root@localhost work1]# su user1 &lt;-- 切换到 user1，发现无法使用 WORKDIR 自定义变量[user1@localhost ~]$ cd $WORKDIR[user1@localhost ~]$ echo $WORKDIR[user1@localhost ~]$ exit &lt;--退出user1身份[root@localhost work1]# export WORKDIR[root@localhost work1]# su user1[user1@localhost ~]$ cd $WORKDIR[user1@localhost work1]$ pwd/home/work1 Linux PATH环境变量及作用在讲解 PATH 环境变量之前，首先介绍一下 which 命令，它用于查找某个命令所在的绝对路径。例如： 1234567[root@localhost ~]# which rm/bin/rm[root@localhost ~]# which rmdir/bin/rmdir[root@localhost ~]# which lsalias ls=&#x27;ls --color=auto&#x27; /bin/ls 注意，ls 是一个相对特殊的命令，它使用 alias 命令做了别名，也就是说，我们常用的 ls 实际上执行的是 ls –color&#x3D;auto。 通过使用 which 命令，可以查找各个外部命令（和 Shell 内置命令相对）所在的绝对路径。学到这里，读者是否有这样一个疑问，为什么前面在使用 rm、rmdir、ls 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置（绝对路径）呢？其实，这是 PATH 环境变量在起作用。 首先，执行如下命令： 12[root@localhost ~]# echo $PATH/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin 这里的 echo 命令用来输出 PATH 环境变量的值（这里的 $ 是 PATH 的前缀符号），PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。 如果在 PATH 包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。 从执行结果中可以看到，&#x2F;bin 目录已经包含在 PATH 环境变量中，因此在使用类似 rm、rmdir、ls等命令时，即便直接使用其命令名，Linux 也可以找到该命令。 为了印证以上观点，下面举个反例，如果我们将 ls 命令移动到 &#x2F;root 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 ls 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 No such file or directory，示例命令如下： 123[root@localhost ~]# mv /bin/ls /root[root@localhost ~]# lsbash: /bin/ls: No such file or directory 此时，如果仍想使用 ls 命令，有 2 种方法，一种是直接将 &#x2F;root 添加到 PATH 环境变量中，例如： 123456[root@localhost ~]# PATH=$PATH:/root[root@localhost ~]# echo $PATH/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root[root@localhost ~]# lsDesktop Downloads Music post-install Public VideosDocuments ls Pictures post-install.org Templates 注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$PATH 就恢复成了默认值。 另一种方法是以绝对路径的方式使用此命令，例如： 123[root@localhost ~]# /root/lsDesktop Downloads Music post-install Public VideosDocuments ls Pictures post-install.org Templates 为了不影响系统的正常使用，强烈建议大家将移动后的 ls 文件还原，命令如下： 1[root@localhost ~]# mv /root/ls /bin Linux打包（归档）和压缩打包（归档）和压缩（包含两者的区别）归档，也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。 通常，归档总是会和系统（数据）备份联系在一起，不过，有关数据备份的内容，留到后续章节讲，本章仅学习归档命令的基本使用。 和归档文件类似，压缩文件也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，压缩文件采用了不同的存储方式，使其所占用的磁盘空间比集合中所有文件大小的总和要小。 压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。比如说，在压缩文件中，有不止一处出现了 “网络”，那么，在压缩文件时，这个词就会用一个代码表示并写入词典文件，这样就可以实现缩小文件体积的目的。 由于计算机处理的信息是以二进制的形式表示的，因此，压缩软件就是把二进制信息中相同的字符串以特殊字符标记，只要通过合理的数学计算，文件的体积就能够被大大压缩。把一个或者多个文件用压缩软件进行压缩，形成一个文件压缩包，既可以节省存储空间，有方便在网络上传送。 如果你能够理解文件压缩的基本原理，那么很容易就能想到，对文件进行压缩，很可能损坏文件中的内容，因此，压缩又可以分为有损压缩和无损压缩。无损压缩很好理解，指的是压缩数据必须准确无误；有损压缩指的是即便丢失个别的数据，对文件也不会造成太大的影响。有损压缩广泛应用于动画、声音和图像文件中，典型代表就是影碟文件格式 mpeg、音乐文件格式 mp3 以及图像文件格式 jpg。 采用压缩工具对文件进行压缩，生成的文件称为压缩包，该文件的体积通常只有原文件的一半甚至更小。需要注意的是，压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原，此过程又称解压缩。 Linux 下，常用归档命令有 2 个，分别是 tar 和 dd（相对而言，tar 的使用更为广泛）；常用的压缩命令有很多，比如 gzip、zip、bzip2 等。这些命令的详细用法，后续文件会做一一介绍。 注意，tar 命令也可以作为压缩命令，也很常用。 Linux tar打包命令详解Linux 系统中，最常用的归档（打包）命令就是 tar，该命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。 使用 tar 命令归档的包通常称为 tar 包（tar 包文件都是以“.tar”结尾的）。 tar命令做打包操作当 tar 命令用于打包操作时，该命令的基本格式为： 1[root@localhost ~]#tar [选项] 源文件或目录 此命令常用的选项及各自的含义如表 1 所示。 选项 含义 -c 将多个文件或目录进行打包。 -A 追加 tar 文件到归档文件。 -f 包名 指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名； -v 显示打包文件过程； 需要注意的是，在使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。 下面给大家举几个例子，一起看看如何使用 tar 命令打包文件和目录。 【例 1】打包文件和目录。 12[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg#把anacondehks.cfg打包为 anacondehks.cfg.tar文件 选项 “-cvf” 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 “.tar” 作为扩展名。打包目录也是如此： 123456789101112[root@localhost ~]# ll -d test/drwxr-xr-x 2 root root 4096 6月 17 21:09 test/#test是我们之前的测试目录[root@localhost ~]# tar -cvf test.tar test/test/test/test3test/test2test/test1#把目录打包为test.tar文件tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg /tmp/#把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包 【例 2】打包并压缩目录。首先声明一点，压缩命令不能直接压缩目录，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩。例如： 12345678[root@localhost ~]#ll -d test test.tardrwxr-xr-x 2 root root 4096 6月 17 21:09 test-rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar#我们之前已经把test目录打包成test.tar文件[root@localhost ~]# gzip test.tar[root@localhost ~]# ll test.tar.gz-rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz#gzip命令会把test.tar压缩成test.tar.gz tar命令做解打包操作当 tar 命令用于对 tar 包做解打包操作时，该命令的基本格式如下： 1[root@localhost ~]#tar [选项] 压缩包 当用于解打包时，常用的选项与含义如表 2 所示。 选项 含义 -x 对 tar 包做解打包操作。 -f 指定要解压的 tar 包的包名。 -t 只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。 -C 目录 指定解打包位置。 -v 显示解打包的具体过程。 其实解打包和打包相比，只是把打包选项 “-cvf” 更换为 “-xvf”。我们来试试： 12[root@localhost ~]# tar -xvf anaconda-ks.cfg. tar#解打包到当前目录下 如果使用 “-xvf” 选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 “-C(大写)” 选项。例如： 12[root@localhost ~]# tar -xvf test.tar -C /tmp#把文件包test.tar解打包到/tmp/目录下 如果只想查看文件包中有哪些文件，则可以把解打包选项 “-x” 更换为测试选项 “-t”。例如： 123456[root@localhost ~]# tar -tvf test.tardrwxr-xr-x root/root 0 2016-06-17 21:09 test/-rw-r-r- root/root 0 2016-06-17 17:51 test/test3-rw-r-r- root/root 0 2016-06-17 17:51 test/test2-rw-r-r- root/root 0 2016-06-17 17:51 test/test1#会用长格式显示test.tar文件包中文件的详细信息 tar命令做打包压缩（解压缩解打包）操作你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成 “.tar” 格式，再压缩成 “.tar.gz” 或 “.tar.bz2” 格式。其实 tar 命令是可以同时打包压缩的，前面的讲解之所打包和压缩分开，是为了让大家了解在 Linux 中打包和压缩的不同。 当 tar 命令同时做打包压缩的操作时，其基本格式如下： 1[root@localhost ~]#tar [选项] 压缩包 源文件或目录 此处常用的选项有以下 2 个，分别是： -z：压缩和解压缩 “.tar.gz” 格式； -j：压缩和解压缩 “.tar.bz2”格式。 【例 1】压缩与解压缩 “.tar.gz”格式。 1234567[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/#把/temp/目录直接打包压缩为&quot;.tar.gz&quot;格式，通过&quot;-z&quot;来识别格式，&quot;-cvf&quot;和打包选项一致解压缩也只是在解打包选项 &quot;-xvf&quot; 前面加了一个 &quot;-z&quot; 选项。[root@localhost ~]# tar -zxvf tmp.tar.gz#解压缩与解打包&quot;.tar.gz&quot;格式 前面讲的选项 “-C” 用于指定解压位置、”-t” 用于查看压缩包内容，在这里同样适用。 【例 2】压缩与解压缩 “.tar.bz2” 格式。和”.tar.gz”格式唯一的不同就是”-zcvf”选项换成了 “-jcvf”，如下所示： 1234[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/#打包压缩为&quot;.tar.bz2&quot;格式，注意压缩包文件名[root@localhost ~]# tar -jxvf tmp.tar.bz2#解压缩与解打包&quot;.tar.bz2&quot;格式 把文件直接压缩成”.tar.gz”和”.tar.bz2”格式，才是 Linux 中最常用的压缩方式，这是大家一定要掌握的压缩和解压缩方法。 tar 命令最初被用来在磁带上创建备份，现在可以在任何设备上创建备份。利用 tar 命令可以把一大堆的文件和目录打包成一个文件，这对于备份文件或是将几个文件组合成为一个文件进行网络传输是非常有用的。 Linux zip命令：压缩文件或目录我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式， 本节要讲的 zip 命令，类似于 Windows 系统中的 winzip 压缩程序，其基本格式如下： 1[root@localhost ~]#zip [选项] 压缩包名 源文件或源目录列表 注意，zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用。 该命令常用的几个选项及各自的含义如表 1 所示。 选项 含义 -r 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。 -m 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。 -v 显示详细的压缩过程信息。 -q 在压缩的时候不显示命令的执行过程。 -压缩级别 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。 -u 更新压缩文件，即往压缩文件中添加新文件。 下面给大家举几个例子。 【例 1】zip 命令的基本使用。 123456[root@localhost ~]# zip ana.zip anaconda-ks.cfgadding: anaconda-ks.cfg (deflated 37%)#压缩[root@localhost ~]# ll ana.zip-rw-r--r-- 1 root root 935 6月 1716:00 ana.zip#压缩文件生成 不仅如此，所有的压缩命令都可以同时压缩多个文件，例如： 1234567[root@localhost ~]# zip test.zip install.log install.log.syslogadding: install.log (deflated 72%)adding: install.log.syslog (deflated 85%)#同时压缩多个文件到test.zip压缩包中[root@localhost ~]#ll test.zip-rw-r--r-- 1 root root 8368 6月 1716:03 test.zip#压缩文件生成 【例 2】使用 zip 命令压缩目录，需要使用“-r”选项，例如： 12345678[root@localhost ~]# mkdir dir1#建立测试目录[root@localhost ~]# zip -r dir1.zip dir1adding: dir1/(stored 0%)#压缩目录[root@localhost ~]# ls -dl dir1.zip-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip#压缩文件生成 Linux unzip命令：解压zip文件unzip 命令可以查看和解压缩 zip 文件。该命令的基本格式如下： 1[root@localhost ~]# unzip [选项] 压缩包名 此命令常用的选项以及各自的含义如表 1 所示。 选项 含义 -d 目录名 将压缩文件解压到指定目录下。 -n 解压时并不覆盖已经存在的文件。 -o 解压时覆盖已经存在的文件，并且无需用户确认。 -v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。 -t 测试压缩文件有无损坏，但并不解压。 -x 文件列表 解压文件，但不包含文件列表中指定的文件。 【例 1】不论是文件压缩包，还是目录压缩包，都可以直接解压缩，例如： 1234[root@localhost ~]# unzip dir1.zipArchive: dir1.zipcreating: dirl/#解压缩 【例 2】使用 -d 选项手动指定解压缩位置，例如： 1234[root@localhost ~]# unzip -d /tmp/ ana.zipArchive: ana.zipinflating: /tmp/anaconda-ks.cfg#把压缩包解压到指定位置 Linux gzip命令：压缩文件或目录gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为“.gz”。 再强调一下，gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。 gzip 命令的基本格式如下： 1[root@localhost ~]# gzip [选项] 源文件 命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件。该命令常用的选项及含义如表 1 所示。 选项 含义 -c 将压缩数据输出到标准输出中，并保留源文件。 -d 对压缩文件进行解压缩。 -r 递归压缩指定目录下以及子目录下的所有文件。 -v 对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。 -l 对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。 -数字 用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。 【例 1】基本压缩。gzip 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可。我们来试试： 12345[root@localhost ~]# gzip install.log#压缩instal.log 文件[root@localhost ~]# lsanaconda-ks.cfg install.log.gz install.log.syslog#压缩文件生成，但是源文件也消失了 【例 2】保留源文件压缩。在使用 gzip 命令压缩文件时，源文件会消失，从而生成压缩文件。这时有些人会有强迫症，就逼问笔者：能不能在压缩文件的时候，不让源文件消失？好吧，也是可以的，不过很别扭。 12345[root@localhost ~]# gzip -c anaconda-ks.cfg &gt;anaconda-ks.cfg.gz#使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件[root@localhost ~]# lsanaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog#可以看到压缩文件和源文件都存在 【例 3】 压缩目录。我们可能会想当然地认为 gzip 命令可以压缩目录。 我们来试试： 123456789101112[root@localhost ~]# mkdir test[root@localhost ~]# touch test/test1[root@localhost ~]# touch test/test2[root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件[root@localhost ~]# gzip -r test/#压缩目录，并没有报错[root@localhost ~]# lsanaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test#但是查看发现test目录依然存在，并没有变为压缩文件[root@localhost ~]# ls test/testl .gz test2.gz test3.gz#原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩 在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。 Linux gunzip命令：解压缩文件或目录gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz）。 对于解压被 gzip 压缩过的文件，还可以使用 gzip 自己，即 gzip -d 压缩包。 gunzip 命令的基本格式为： 1[root@localhost ~]# gunzip [选项] 文件 该命令常用的选项及含义如表 1 所示。 选项 含义 -r 递归处理，解压缩指定目录下以及子目录下的所有文件。 -c 把解压缩后的文件输出到标准输出设备。 -f 强制解压缩文件，不理会文件是否已存在等情况。 -l 列出压缩文件内容。 -v 显示命令执行过程。 -t 测试压缩文件是否正常，但不对其做解压缩操作。 【例 1】直接解压缩文件。 [root@localhost ~]# gunzip install.log.gz 当然，”gunzip -r”依然只会解压缩目录下的文件，而不会解打包。要想解压缩”.gz”格式，还可以使用 “gzip -d”命令，例如： 1[root@localhost ~]# gzip -d anaconda-ks.cfg.gz 【例 2】要解压缩目录下的内容，则需使用 “-r” 选项，例如： [root@localhost ~]# gunzip -r test&#x2F; 注意，如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容。例如： 1[root@localhost ~]# zcat anaconda-ks.cfg.gz Linux bzip2命令：压缩文件（.bz2格式）bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件。当执行压缩任务完成后，会生成一个以“.bz2”为后缀的压缩包。 “.bz2”格式是 Linux 的另一种压缩格式，从理论上来讲，”.bz2”格式的算法更先进、压缩比更好；而 “.gz”格式相对来讲的时间更快。 bzip2 命令的基本格式如下： 1[root@localhost ~]# bzip2 [选项] 源文件 源文件指的要压缩或解压缩的文件，该命令常用的选项及各自的含义如表 1 所示。 选项 含义 -d 执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。 -k bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。 -f bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。 -t 测试压缩包文件的完整性。 -v 压缩或解压缩文件时，显示详细信息。 -数字 这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。 【例 1】直接压缩文件。 [root@localhost ~]# bzip2 anaconda-ks.cfg#压缩成”.bz2”格式 此压缩命令会在压缩的同时删除源文件。 【例 2】压缩的同时保留源文件。 12345[root@localhost ~]# bzip2 -k install.log.syslog#压缩[root@localhost ~]# lsanaconda-ks.cfg.bz2 install.loginstalLlogsyslog install.logsyslogbz2#压缩文件和源文件都存在 Linux bunzip2命令：bz2格式的解压缩命令要解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令。 bunzip2 命令的使用和 gunzip 命令大致相同，bunzip2 命令只能用于解压文件，即便解压目录，也是解压该目录以及所含子目录下的所有文件。 bunzip2 命令的基本格式为： [root@localhost ~]# bunzip2 [选项] 源文件 此命令常用的选项以及各自的含义，如表 1 所示。 选项 含义 -k 解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。 -f 解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。 -v 显示命令执行过程。 -L 列出压缩文件内容。 先试试使用 gunzip2 命令来进行解压缩，例如： 1[root@localhost ~]# bunzip2 anaconda-ks.cfg.bz2 “.bz2” 格式也可以使用 “bzip2 -d 压缩包” 命令来进行解压缩，例如： 1[root@localhost ~]# bzip2 -d install.log.syslog.bz2 和 “.gz” 格式一样，”.bz2” 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat。例如： 1[root@localhost ~]# bzcat install.log.syslog.bz2 Vim文本编辑器Vim 是一个基于文本界面的编辑工具，使用简单且功能强大。更重要的是，Vim 是所有 Linux 发行版本默认的文本编辑器。 很多人习惯将 Vim 称为 Vi，其实 Vim 是 Vi 的增强版（在 Vi 的基础上增加了正则表达式的查找、多窗口的编辑等功能），使用 Vim 进行程序开发会更加方便。 Linux Vim三种工作模式（命令模式、输入模式和编辑模式）使用 Vim 编辑文件时，存在 3 种工作模式，分别是命令模式、输入模式和编辑模式，这 3 种工作模式可随意切换，如图 1 所示。 Vim的命令模式使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键（上、下、左、右键）或 k、j、h、i 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。 Vim的输入模式在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。 使 Vim 进行输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令（各指令的具体功能如表 3 所示），当编辑文件完成后按 Esc 键即可返回命令模式。 快捷键 功能描述 i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动 I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令 o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本 O 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本 a 在当前光标所在位置之后插入随后输入的文本 A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令 Vim 的编辑模式编辑模式用于对文件中的指定内容执行保存、查找或替换等操作。 使 Vim 切换到编辑模式的方法是在命令模式状态下按“：”键，此时 Vim 窗口的左下方出现一个“：”符号，这是就可以输入相关指令进行操作了。 指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可。 对于新手来说，经常不知道自己处于什么模式。不论是自己忘了，还是不小心切换了模式，都可以按一次 Esc 键返回命令模式。如果你多按几次 Esc 键后听到”嘀————“的声音，则代表你已经处于命令模式了。 Linux Vim基本操作（文件的打开和编辑）Vim 打开文件使用 Vim 打开文件很简单，例如在命令行模式下打开一个自己编写的文件 &#x2F;test&#x2F;vi.test，打开方法如下： 1[root@itxdl ~]# vim /test/vi.test 刚打开文件时 Vim 处于命令模式，此时文件的下方会显示文件的一些信息，包括文件的总行数和字符数，以及当前光标所在的位置等，此时可以使用插入命令进入输入模式对文件进行编辑 除此之外，我们还可以利用下表中打开文件的命令格式，针对特定情形使用适当的打开方式，可以大大提高我们的效率。 Vi 使用的选项 说 明 vim filename 打开或新建一个文件，并将光标置于第一行的首部 vim -r filename 恢复上次 vim 打开时崩溃的文件 vim -R filename 把指定的文件以只读方式放入 Vim 编辑器中 vim + filename 打开文件，并将光标置于最后一行的首部 vi +n filename 打开文件，并将光标置于第 n 行的首部 vi +&#x2F;pattern filename 打幵文件，并将光标置于第一个与 pattern 匹配的位置 vi -c command filename 在对文件进行编辑前，先执行指定的命令 使用 Vim 进行编辑同样，Vim 提供了大量的编辑快捷键，主要可分为以下几类。 Vim 插入文本从命令模式进入输入模式进行编辑，可以按下 I、i、O、o、A、a 等键来完成，使用不同的键，光标所处的位置不同，如表 3 所示。 快捷键 功能描述 i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动 I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令 o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本 O（大写） 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本 a 在当前光标所在位置之后插入随后输入的文本 A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行 a 命令 Vim 查找文本 快捷键 功能描述 &#x2F;abc 从光标所在位置向前查找字符串 abc &#x2F;^abc 查找以 abc 为行首的行 &#x2F;abc$ 查找以 abc 为行尾的行 ?abc 从光标所在为主向后查找字符串 abc n 向同一方向重复上次的查找指令 N 向相反方向重复上次的查找指定 如果在文件中并没有找到所要查找的字符串，则在文件底部会出现 “Pattern not found” 提示 在查找过程中需要注意的是，要查找的字符串是严格区分大小写的，如查找 “shenchao” 和 “ShenChao” 会得到不同的结果。 如果想忽略大小写，则输入命令 “:set ic”；调整回来输入”:set noic”。 如果在字符串中出现特殊符号，则需要加上转义字符 “&quot;。常见的特殊符号有 \\、*、?、$ 等。如果出现这些字符，例如，要查找字符串 “10$”，则需要在命令模式中输入 “&#x2F;10$“。 Vim 替换文本 快捷键 功能描述 r 替换光标所在位置的字符 R 从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束 :s&#x2F;a1&#x2F;a2&#x2F;g 将当前光标所在行中的所有 a1 用 a2 替换 :n1,n2s&#x2F;a1&#x2F;a2&#x2F;g 将文件中 n1 到 n2 行中所有 a1 都用 a2 替换 :g&#x2F;a1&#x2F;a2&#x2F;g 将文件中所有的 a1 都用 a2 替换 例如，要将某文件中所有的 “root” 替换为 “liudehua”，则有两种输入命令，分别为： 123:1, $s/root/liudehua/g或:%s/root/liudehua/g 上述命令是在编辑模式下操作的，表示的是从第一行到最后一行，即全文查找 “root”，然后替换成 “liudehua”。 如果刚才的命令变成 :10,20 s/root/liudehua/g，则只替换从第 10 行到第 20 行的 “root”。 Vim删除文本 快捷键 功能描述 x 删除光标所在位置的字符 dd 删除光标所在行 ndd 删除当前行（包括此行）后 n 行文本 dG 删除光标所在行一直到文件末尾的所有内容 D 删除光标位置到行尾的内容 :a1,a2d 函数从 a1 行到 a2 行的文本内容 注意，被删除的内容并没有真正删除，都放在了剪贴板中。将光标移动到指定位置处，按下 “p” 键，就可以将刚才删除的内容又粘贴到此处。 Vim复制和粘贴文本 快捷键 功能描述 p 将剪贴板中的内容粘贴到光标后 P（大写） 将剪贴板中的内容粘贴到光标前 y 复制已选中的文本到剪贴板 yy 将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行 yw 将光标位置的单词复制到剪贴板 Vim其他常用快捷键某些情况下，可能需要把两行进行连接。比如说，下面的文件中有两行文本，现在需要将其合并成一行（实际上就是将两行间的换行符去掉）。可以直接在命令模式中按下 “J” 键，按下前后如图 10 所示。 图 10 按下 “J” 键前后 如果不小心误删除了文件内容，则可以通过 “u” 键来撤销刚才执行的命令。如果要撤销刚才的多次操作，可以多按几次 “u” 键。 Vim 保存退出文本Vim 的保存和退出是在编辑模式中进行的，其常用命令如下表所示。 命令 功能描述 :wq 保存并退出 Vim 编辑器 :wq! 保存并强制退出 Vim 编辑器 :q 不保存就退出 Vim 编辑器 :q! 不保存，且强制退出 Vim 编辑器 :w 保存但是不退出 Vim 编辑器 :w! 强制保存文本 :w filename 另存到 filename 文件 x！ 保存文本，并退出 Vim 编辑器，更通用的一个 vim 命令 ZZ 直接退出 Vim 编辑器 需要注意的是，”w!” 和 “wq!” 等类似的指令，通常用于对文件没有写权限的时候（显示 readonly），但如果你是文件的所有者或者 root 用户，就可以强制执行。 Vim移动光标快捷键汇总Vim 文本编辑器中，最简单的移动光标的方式是使用方向键，但这种方式的效率太低，更高效的方式使用快捷键。 Vim 移动光标常用的快捷键及其功能如下面各表所示，需要注意的是，表中所有的快捷键都在命令模式（默认状态）下直接使用。 Vim快捷方向键 快捷键 功能描述 h 光标向左移动一位 j 光标向下移动一行（以回车为换行符），也就是光标向下移动 k 光标向上移动一行（也就是向上移动） l 光标向右移动一位 最初使用，大家可能觉得比较别扭，但熟能生巧，使用此方式移动光标同样能够提高编辑速度。 Vim光标以单词为单位移动某些情形下，可能需要光标迅速移动至一行中的某个位置，将光标以单词为单位进行移动就会很方便。 快捷键 功能描述 w 或 W 光标移动至下一个单词的单词首 b 或 B 光标移动至上一个单词的单词首 e 或 E 光标移动至下一个单词的单词尾 nw 或 nW n 为数字，表示光标向右移动 n 个单词 nb 或 nB n 为数字，表示光标向左移动 n 个单词 Vim光标移动至行首或行尾 快捷键 功能描述 0 或 ^ 光标移动至当前行的行首 $ 光标移动至当前行的行尾 n$ 光标移动至当前行只有 n 行的行尾，n为数字 Vim光标移动至指定字符一行中，如果需要将光标移动到当前行的某个特点字符，则可以使用表 4 中的快捷键。 快捷键 功能描述 fx 光标移动至当前行中下一个 x 字符处 Fx 光标移动至当前行中下一个 x 字符处 Vim光标移动到指定行 快捷键 功能描述 gg 光标移动到文件开头 G 光标移动至文件末尾 nG 光标移动到第 n 行，n 为数字 :n 编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首 Vim光标移动到匹配的括号处程序员在编辑程序时，经常会为将光标移动到与一个 “(“ 匹配的 “)” （对于 [] 和 {} 也是一样的）处而感到头疼。Vim 里面提供了一个非常方便地査找匹配括号的命令，这就是 “%”。 比如，在 &#x2F;etc&#x2F;init.d&#x2F;sshd 脚本文件中（最好还是复制后练习，小心驶得万年船），想迅速地将光标定位到与第 49 行的 “{“ 相对应的 “}” 处，则可以将光标先定位在 “{“ 处，然后再使用 “％” 命令，使之定位在 “}” 处，如图 6 所示。 图 6 使用”％”命令定位括号 Linux Vim撤销和恢复撤销快捷键使用 Vim 编辑文件内容时，经常会有如下 2 种需求： 对文件内容做了修改之后，却发现整个修改过程是错误或者没有必要的，想将文件恢复到修改之前的样子。 将文件内容恢复之后，经过仔细考虑，又感觉还是刚才修改过的内容更好，想撤销之前做的恢复操作。 基于这 2 种需求，Vim 编辑器提供了撤销和恢复撤销的命令，如表 1 所示。 快捷键 功能 u（小写） undo 的第 1 个字母，功能是撤销最近一次对文本做的修改操作。 Ctrl+R Redo 的第 1 个字母，功能是恢复最近一次所做的撤销操作。 U（大写） 第一次会撤销对一行文本（光标所在行）做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。 注意，以上这 3 种命令都必须在 Vim 编辑器处于命令模式时才能使用。 下面通过一个例子来演示以上 3 个命令的具体用法。首先，我们新建一个 demo.txt 文件并打开，键入一行内容，例如： 1www.forever.cn.mw 然后按“Esc”键，使 Vim 由输入模式转为命令模式，并使用 yy 命令将这一行文本复制到剪贴板中，如此我们就可以在文本任意位置通过键入 p（或大写的 P）命令将复制的内容粘贴到光标所在的位置。 假设我们将光标调整到第一行最后一个字符处，连续按两次 p 命令（粘贴 2 次），则此时文本中的内容变为： 123www.forever.cn.mwwww.forever.cn.mwwww.forever.cn.mw 在此基础上，通过 u（小写）命令就可以使文本内容恢复到上一次做粘贴操作之前的样子，其中“上一次”的含义是，恢复操作是可以叠加的，即按一次就会在现有基础上做一次恢复操作。 比如，继续操作 demo.txt 文件，按一次 u，会发现其文本内容变为： 12www.forever.cn.mwwww.forever.cn.mw 再按一次 u，文本内容继续恢复为： 1www.forever.cn.mw 同样，恢复撤销的操作和撤销操作是相对应的，通过按 Ctrl+R 组合键，可以撤销之前所做的一次恢复操作。例如，继续操作 demo.txt 文件，按一次 Ctrl+R，会发现其文本内容恢复为： 12www.forever.cn.mwwww.forever.cn.mw 再按一次 Ctrl+R，文本内容又恢复为： 123www.forever.cn.mwwww.forever.cn.mwwww.forever.cn.mw U（大写）的功能和之前的 2 个命令不同，它的作用是撤销或恢复撤销对光标所在行文本所做的全部操作。比如，我们对 demo.txt 文件内容做如下修改： 123www.forever.cn.mwwww.forever.cn.mwwww.forever.cn.mw新增内容 可以看到，这里对第三行文本做了 2 处修改。在此基础上，如果在命令模式下键入 U（大写），可以看到，之前对第 3 行所做的 2 处修改，全部被恢复了： 123www.forever.cn.mwwww.forever.cn.mwwww.forever.cn.mw 如果此时再键入 U（大写），则又会恢复之前对第 3 行文本做过的全部操作： 123www.forever.cn.mwwww.forever.cn.mwwww.forever.cn.mw新增内容 Linux Vim可视化模式及其用法相信大家都使用过带图形界面的操作系统中的文字编辑器，用户可以使用鼠标来选择要操作的文本，非常方便。在 Vim 编辑器中也有类似的功能，但不是通过鼠标，而是通过键盘来选择要操作的文本。 在 Vim 中，如果想选中目标文本，就需要调整 Vim 进入可视化模式，如表 1 所示，通过在 Vim 命令模式下键入不同的键，可以进入不同的可视化模式。 命令 功能 v（小写） 又称字符可视化模式，此模式下目标文本的选择是以字符为单位的，也就是说，该模式下要一个字符一个字符的选中要操作的文本。 V（大写） 又称行可视化模式，此模式化目标文本的选择是以行为单位的，也就是说，该模式化可以一行一行的选中要操作的文本。 Ctrl+v（组合键） 又称块可视化模式，该模式下可以选中文本中的一个矩形区域作为目标文本，以按下 Ctrl+v 位置作为矩形的一角，光标移动的终点位置作为它的对角。 以字符可视化模式为例，Vim 成功进入该模式的标志是窗口底部出现 –VISUAL– 标志 相应地，进入行可视化模式的标志是标记处显示 –VISUAL LINE–；进入块可视化模式的标志是图 2 标记处显示 –VISUAL BLOCK–。 需要注意的是，当选中文本并做完相应操作（例如选中文件并按 p 键将其复制到剪贴板中）后，Vim 会自动从可视化模式转换为命令模式。当然，也可以再次按 v（或者 V、Ctrl+v）手动退出可视化模式。 另外值得一提的是，之前所学的在 Vim 命令模式下编辑文本的很多命令，在可视化模式下仍然可以使用。表 3 中罗列出了常用的几个可以在可视化模式下使用的命令。 命令 功能 d 删除选中的部分文本。 D 删除选中部分所在的行，和 d 不同之处在于，即使选中文本中有些字符所在的行没有都选中，删除时也会一并删除。 y 将选中部分复制到剪贴板中。 p（小写） 将剪贴板中的内容粘贴到光标之后。 P（大写） 将剪贴板中的内容粘贴到光标之前。 u（小写） 将选中部分中的大写字符全部改为小写字符。 U（大写） 将选中部分中的小写字符全部改为大写字符。 &gt; 将选中部分右移（缩进）一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。 &lt; 将选中部分左移一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。 Vim 多窗口编辑vim提供多窗口编辑的功能，可以简化复合的编辑任务。vim的多窗口并不是说在终端上启动多个vim实例。 启动多窗口编辑viｍ的多窗口是动态的，可以开始编辑时就打开多窗口，也可以工作时随时增加新窗口，或者删除一个窗口。$ vim -o file1 file2 打开一个编辑会话，显示为水平分割成两半的窗口，一个文件占用一个窗口。$ vim -O file1 file2 和上面相同，不过是垂直分割两半的窗口 如果画面分割后不足以容纳下所有窗口，那么第一个文件会占用大部分窗口，余下的窗口则载入缓冲区，暂时不能看到，但仍可以取用。 -o后面加一个数字n，是预分配窗口的形式打开： $ vim -o5 file1 file2 将分配5个相同的窗口，有3个是闲置的 vim的多窗口编辑：split 新建一个窗口，将当前窗口分割成两半，他们显示的是相同缓冲区的内容（同一个文件）。这样就可以在两个窗口中浏览相同的文件了。 ：vsplit 创建全新的垂直分割的窗口，同样是显示和当前窗口同一个文件内容。效果如下： 当多个窗口编辑同一个文件时，在任意一个窗口进行编辑（例如删除一行），那么所有相同文件的窗口上都会同时反应效果，因为他们共享同一个文件缓冲区。 如果想编辑或浏览另一个文件，而又不想失去在当前文件中的编辑位置，就用新文件的参数传给：split命令：split otherfile 分割窗口的选项：[n] split(vsplit) [++opt] [+cmd] [file] 命令中：n 为vim指定在新窗口中显示的行数，且新窗口的大小刚好容纳该行数，新窗口位于画面顶端opt 传递vim选项信息给新的窗口会话（请注意，它的前面必须加上两个加号）cmd 传入欲在新窗口中执行的命令（请注意，它的前面必须加上一个加号）file 指定在新窗口中编辑的文件 ：sview filename 以只读的方式水平分割打开一个新窗口：sfind [++opt] [+cmd] [file] 和split的运作方式相似，但在path中寻找filename，如果vim未找到文件则不显示 在窗口间游走在gvim或vim中，在窗口中移动其实非常简单，因为gvim已默认支持鼠标点击来换编辑窗口，而vim中，则可以打开mouse选项，：set mouse &#x3D; a 为命令、输入、导航都激活鼠标的使用 我们知道vim的特色就是可以脱离鼠标而工作，所以可以使用vim提供的全套导航命令，在会话中快速而准确的移动编辑窗口。 按住Ctrl + W，然后再加上h, j, k, l，分别表示向左、下、上、右移动窗口Ctrl + w + h：向左移动窗口Ctrl + w + j： 向下移动窗口Ctrl + w + j： 向上移动窗口Ctrl + w + l： 向右移动窗口 Ctrl + w + w：这个命令会在所有窗口中循环移动Ctrl + w + t：移动到最左上角的窗口Ctrl + w + b：移动到最右下角的窗口Ctrl + w + p：移动到前一个访问的窗口 移动窗口vim中有两种移动窗口方式，一种只是简单地在屏幕上切换窗口，尺寸维持不变；另一种则是改变窗口的实际布局，还会调整尺寸，以填充它移动的位置。 移动窗口本身（轮换或交换） Ctrl + w + r：向右或向下方交换窗口，而Ctrl + w + R则和它方向相反。 光标会随着窗口而移动 Ctrl + w + x：交换同列或同行的窗口的位置。vim默认交换当前窗口的与它下一个窗口的位置，如果下方没有窗口，则试着与上一个窗口交换位置。亦可在此命令前加上数量，与制定的窗口交换位置。 移动窗口并改变其布局 注：下面的第三个字母都是大写，按玩Ctrl + w之后，按shif + 相应的字母。后面用^代替CtrlCtrl + w + K ：移动当前窗口至屏幕顶端，并占用全部宽度^WJ： 移动窗口至屏幕底端，并占用全部宽度^WH：移动窗口至屏幕左端，并占用全部高度^WL：移动窗口至屏幕右端，并占用全部高度 ^WT ：移动窗口至屏新的现有分页 调整窗口尺寸 改变当前窗口的尺寸，同时当然也会影响到其他窗口。在gvim和vim中，可以用鼠标点击窗口的顶部白色条并窗口直接调整尺寸。 也可以直接用命令，调整尺寸命令也是以Ctrl + W开头：Ctrl + W + &#x3D; ：让所有窗口调整至相同尺寸（平均划分）Ctrl + W + -：将当前窗口的高度减少一行，也可在ex命令中，：resize -4明确指定减少的尺寸Ctrl + W + +：将当前窗口的高度增加一行。同样在ex命令中，：resize +n 明确指定增加尺寸 Ctrl + W + &lt; ：将当前窗口的宽度减少Ctrl + W + &gt; ：将当前窗口的宽度增加 Ctrl + W + |：将当前窗口的宽度调到最大，也可他哦你通过ex命令：vertical resize n明确指定改变宽度 分页编辑除了使多窗口编辑外，vim还允许创建多个分页（tab），每个分页各有独自的行为，类似于浏览器firefox或chrome的分页浏览功能。 我们可以在vim或gvim中使用分页，但在gvim会更好用。最终要的命令：tabnew filename 打开新分页并编辑新文件（可选的）。如果未指定文件，则只打开新分页，并附上空的缓冲区。：tabclose 关闭当前分页 ：tabonly 关闭其他所有的分页。如果其他分页中有修改过的文件，则不会移除该分页，除非设置了autowrite选项。此时，所有修改过的文件都在分页关闭前写入磁盘。 游走分页可以直接点鼠标来移动到另一个分页，也可以用命令 Ctrl + PageDown：移动到下一个分页 Ctrl + PageUp：移动到上一个分页 关闭与离开窗口有4种关闭窗口的方式，分别是：离开（quit）、关闭（close）、隐藏（hide）、关闭其他窗口 ^代表Ctrl键^Wq，离开当前窗口^Wc，关闭当前的窗口^Wo，关闭当前窗口以外的所有窗口 Linux Vim批量注释和自定义注释快捷键使用 Vim 编辑 Shell 脚本，在进行调试时，需要进行多行的注释，每次都要先切换到输入模式，在行首输入注释符”#”再退回命令模式，非常麻烦。 连续行的注释其实可以用替换命令来完成。换句话说，在指定范围行加”#”注释，可以使用 “:起始行，终止行 s&#x2F;^&#x2F;#&#x2F;g”，例如： 1:1,10s/^/#/g 表示在第 1~10 行行首加”#”注释。”^”意为行首；”g”表示执行替换时不询问确认。如果希望每行交互询问是否执行，则可将 “g” 改为 “c”。 取消连续行注释，则可以使用 “:起始行，终止行s&#x2F;^#&#x2F;&#x2F;g”，例如： 1:1,10s/^#//g 意为将行首的”#”替换为空，即删除。 当然，使用语言不同，注释符号或想替换的内容不同，都可以采用此方法，灵活运用即可。 添加”&#x2F;&#x2F;“注释要稍微麻烦一些，命令格式为 “:起始行，终止行 s&#x2F;^&#x2F;//&#x2F;g”。例如： 1:1,5s/^/\\/\\//g 表示在第 1~5 行行首加”&#x2F;&#x2F;“注释，因为 “&#x2F;“ 前面需要加转义字符 “&quot;，所以写出来比较奇特。 以上方法可以解决连续行的注释问题，如果是非连续的多行就不灵了，这时我们可以定义快捷键简化操作。格式如下： 1:map 快捷键 执行命令 如定义快捷键 “Ctrl+P” 为在行首添加 “#” 注释，可以执行 “:map^P l#&lt;Esc&gt;”。其中 “^P” 为定义快捷键 “Ctrl+P”。注意：必须同时按 “Ctrl+V+P” 快捷键生成 “^P” 方可有效，或先按 “Ctrl+V” 再按 “Ctrl+P” 也可以，直接输入 “^P” 是无效的。 “l#&lt;Esc&gt;” 就是此快捷键要触发的动作，”l” 为在光标所在行行首插入，”#” 为要输入的字符，”&lt;Esc&gt;” 表示退回命令模式。”&lt;Esc&gt;” 要逐个字符输入，不可直接按键盘上的 Esc 键。 设置成功后，直接在任意需要注释的行上按 “Ctrl+P” 快捷键，就会自动在行首加上 “#” 注释。取消此快捷键定义，输入 “:unmap^P” 即可。 我们可以延伸一下，如果想取消文件行首的快捷键，则可以设置 “:map^B 0x”，快捷键为 “Ctrl+B”, “0” 表示跳到行首，”x” 表示删除光标所在处字符。 再如，有时我们写完脚本等文件，需要在末尾注释中加入自己的邮箱，则可以直接定义每次按快捷键 “Ctrl+E” 实现插入邮箱，定义方法为 “:map^E &#x61;&#x31;&#x32;&#x33;&#x34;&#53;&#64;&#x71;&#x71;&#46;&#99;&#111;&#x6d;&lt;Esc&gt;”。其中 “a” 表示在当前字符后插入，”&#x31;&#x32;&#51;&#x34;&#x35;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;“ 为插入的邮箱，”&lt;Esc&gt;” 表示插入后返回命令模式。 所以，通过定义快捷键，我们可以把前面讲到的命令组合起来使用。 将快捷键对应的命令保存在 .vimrc 文件中，即可在每次使用 Vim 时自动调用，非常方便。 要在 Vim 中显示行号，请使用 :set number 命令显示绝对行号，使用 :set relativenumber 显示相对行号。如果同时启用了绝对行号和相对行号，则 Vim 会切换到混合行号模式。 Vim配置文件（.vimrc）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&quot; 使用vim的modeline来设置当前文件的textwidth,&quot; 避免输入超过78个字符时自动换行&quot; 使用:verbose set textwidth?命令可以看到vim默认&quot; 为vim配置脚本设置了textwidth为78,当输入超过78个字符&quot; 并按下空格键时会自动换行.将textwidth设成0关闭该功能&quot;&quot; vim: tw=0 :&quot; 去掉有关vi一致性模式,避免操作习惯上的局限.set nocompatible&quot; 让Backspace键可以往前删除字符.&quot; Debian系统自带的vim版本会加载一个debian.vim文件,&quot; 默认已经设置这一项,&quot; 可以正常使用Backspace键.如果使用自己编译的vim版本,&quot; 并自行配置.vimrc文件,可能就没有设置这一项,导致&quot; Backspace键用不了,或者时灵时不灵.所以主动配置.set backspace=indent,eol,start&quot; 1=启动显示状态行, 2=总是显示状态行.&quot; 设置总是显示状态行,方便看到当前文件名.set laststatus=2&quot; 设置ruler会在右下角显示光标所在的行号和列号,&quot; 不方便查看.改成设置状态栏显示内容&quot;&quot; set ruler&quot; 设置状态行显示的内容. %F: 显示当前文件的完整路径.&quot; %r: 如果readonly,会显示[RO]&quot; %B: 显示光标下字符的编码值,十六进制.&quot; %l:光标所在的行号. %v:光标所在的虚拟列号.&quot; %P: 显示当前内容在整个文件中的百分比.&quot; %H和%M是strftime()函数的参数,获取时间.set statusline=%F%r\\ [HEX=%B][%l,%v,%P]\\ %&#123;strftime(\\&quot;%H:%M\\&quot;)&#125; &quot; 显示还没有输入完整的命令.例如yy命令,输入第一个y会在右下角显示y.set showcmd&quot; 使用Tab键补全时,在状态栏显示匹配的列表,&quot; 方便查看都有哪些命令符合补全条件.set wildmenu&quot; 显示行号set number&quot; 高亮显示匹配的括号set showmatch&quot; 高亮显示所有搜索到的内容.后面用map映射&quot; 快捷键来方便关闭当前搜索的高亮.set hlsearch&quot; 光标立刻跳转到搜索到内容set incsearch&quot; 搜索到最后匹配的位置后,再次搜索不回到第一个匹配处set nowrapscan&quot; 去掉输入错误时的提示声音set noeb&quot; 默认按下Esc后,需要等待1秒才生效,&quot; 设置Esc超时时间为100ms,尽快生效set ttimeoutset ttimeoutlen=100&quot; 设置文件编码,主要是避免中文乱码.&quot; 先注释,后续遇到中文乱码再打开&quot;&quot; set fileencodings=utf-8,cp936,big5,latin1&quot; FIXME 在MS-DOS控制台打开vim时,控制台使用鼠标&quot; 右键来复制粘贴,设置全鼠标模式,鼠标右键被映射为&quot; visual mode,不能用来复制粘贴,不方便.但是如果不&quot; 设置鼠标模式,会无法使用鼠标滚轮来滚动界面.经过验证,&quot; 发现可以设成普通模式mouse=n来使用鼠标滚轮,也能使用&quot; 鼠标右键复制粘贴. mouse=c/mouse=i模式都不能用鼠标&quot; 滚轮. Linux下还是要设成 mouse=aset mouse=n&quot; FIXME 在MS-DOS控制台打开vim,光标很小,不方便看到光标&quot; 在哪里.下面设置cursorline,高亮光标所在的行.&quot; cursorlineopt=number只高亮行号部分,不影响正文内容&quot; 的显示. 在其他容易看到光标的终端上可以去掉这两个设置.set cursorlineset cursorlineopt=number&quot; 开启语法高亮syntax enable&quot; 检测文件类型,并载入文件类型插件,&quot; 为特定文件类型载入相关缩进文件filetype plugin indent on&quot; 设置自动补全的选项. longest表示只自动补全最大匹配的部分,&quot; 剩余部分通过CTRL-P/CTRL-N来选择匹配项进行补全. menu表示&quot; 弹出可补全的内容列表.如果有多个匹配,longest选项不会自动选中&quot; 并完整补全,要多按一次CTRL-P,比较麻烦,不做设置,保持默认设置,&quot; vim默认没有设置longest.&quot;&quot; set completeopt=longest,menu&quot; 自动缩进.这个导致从外面拷贝多行以空格开头的内容时,&quot; 会有多的缩进,先不设置.&quot;&quot; set autoindent&quot; 设置C风格的自动缩进.设置filetype indent on后,就会根据文件&quot; 类型自动缩进.按照vim用户手册&#x27;30.3 Automatic indenting&#x27;的&quot; 说明,可以不再单独设置cindent.&quot;&quot; set cindent&quot; 自动缩进时,缩进长度为4set shiftwidth=4&quot; 输入Tab字符时,自动替换成空格set expandtab&quot; 设置softtabstop有一个好处是可以用Backspace键来一次&quot; 删除4个空格. softtabstop的值为负数,会使用shiftwidth&quot; 的值,两者保持一致,方便统一缩进.set softtabstop=-1&quot; 设置颜色主题,适用于黑色背景.colorscheme slate&quot; 创建一个新的 MyTabSpace 组,并设置它的颜色highlight MyTabSpace ctermfg=darkgrey&quot; 指定tab字符和空格的颜色组为MyTabSpace,不同字符串&quot; 之间用|隔开,要使用\\|转义.match MyTabSpace /\\t\\| /&quot; 针对特定类型的代码文件,设置显示Tab键和行尾空格以便在&quot; 查看代码时注意到它们.&quot; TODO 后续查看代码如果体验不好再改成用map映射快捷键&quot; 开关list来动态切换显示.autocmd FileType c,cpp,java,xml setlocal list | set listchars=tab:&gt;~,trail:.&quot; 配置 gtags 插件,用于在函数之间跳转,方便查看源代码.&quot; 参考 gtags-cscopde.vim 的注释,添加下面语句来&quot; 使用 &#x27;:tag&#x27; 和 &#x27;&lt;C-]&gt;&#x27;set cscopetag&quot; 设置 cscopetag 后,由于gtags-cscopde默认没有启动,&quot; 还需要进行下面的设置.结合这两个设置, gtags 就可以&quot; 使用Ctrl-]键来跳转到函数定义处.let GtagsCscope_Auto_Load = 1&quot; 配置 GtagsCscope_Auto_Load = 1 后,在没有GTAGS文件&quot; 的目录下使用vim,会提示 Gtags-cscope: GTAGS not found.&quot; Press ENTER or type command to continue&quot; 需要按回车才会打开文件.如果要去掉这个报错,需要设置GtagsCscope_Quiet = 1let g:GtagsCscope_Quiet = 1&quot; 设置只有一个匹配结果时,不显示quickfix窗口let g:Gtags_Close_When_Single = 1&quot; 配置 quickfix 相关命令的快捷键. 可以用:map命令&quot; 查看vim已有的快捷键映射.nnoremap &lt;F2&gt; :cclose&lt;CR&gt;nnoremap &lt;F3&gt; :cn&lt;CR&gt;nnoremap &lt;F4&gt; :cp&lt;CR&gt;&quot; vim 用 map 命令来映射快捷键,它前面可以加一些前缀来对应&quot; 不同的场景.下面 map 前面的 nore 表示非递归. nore 前面&quot; 的n表示只在普通模式下生效.即,基于下面的配置,在插入模式下,&quot; 按F6没有这个映射效果.插入模式对应i. 下面配置cscope查找&quot; 文件命令的快捷键为F6,由于需要手动输入文件名,不要加&lt;CR&gt;nnoremap &lt;F6&gt; :cs find f&lt;Space&gt;&quot; 如果要去掉高亮显示搜索到的内容,需要再次搜索一些不存在的字符串,&quot; 比较麻烦.可以在vim的命令行中执行nohlsearch命令去掉当前高亮.&quot; 下面的 nohlsearch 以 : 开头表示在命令行执行.nnoremap &lt;F9&gt; :nohlsearch&lt;CR&gt;&quot; 插入模式下也用F9来去掉搜索高亮.下面的&lt;C-o&gt;表示CTRL-O.&quot; CTRL-O键可以在插入模式执行一次命令inoremap &lt;F9&gt; &lt;C-o&gt;:nohlsearch&lt;CR&gt; Vim中执行Linux命令的几种方式Vim 编辑器不仅提供了大量的命令来方便和加快我们的文件编辑工作，在此编辑器中，我们还可以直接使用 Linux 命令来进一步提高文件编辑的效率，这就是 Vim 编辑器的所谓过滤功能。 由于 Vim 编辑器中支持直接执行 Linux 命令，从而可以方便快捷地对文件完成以下操作： 将一个命令的输出结果存入正在编辑的文件； 将正在编辑的文件中的一些数据作为某个指定 Linux 命令的输入。 下面，通过一个简单的例子，来演示如何在 Vim 编辑器中执行 Linux 命令。 首先，我们新建一个 demo.txt 文件，并手动输入如下内容，并将光标移动至下一行开头： 1www.forever.cn.mw 在此基础上，按 Esc 令 Vim 返回到命令模式，再按下!!，这时在窗口的左下角会出现:.!的提示信息，这就表明我们可以输入 Linux 命令了。例如，我们输入 date 命令 注意，窗口左下角的:.!表示操作文本的范围，其中 . 表示从光标所在行开始，! 表示后续会执行 Linux 命令，整体表示命令的执行结果将插入到光标所在行的位置，因此，如果光标所在位置处有数据，就会被命令的执行结果直接覆盖掉。 确认光标位置无误后，按 Enter（回车）键，这时会发现系统当前的日期和时间写到了 demo.txt 文件中第 2 行的位置： 12www.forever.cn.mwTue Nov 12 07:20:49 PST 2021 在此基础上，再向该文件中手动输入以下数据： 12345www.forever.cn.mwTue Nov 12 07:20:49 PST 20211 文本13 文本32 文本2 输出完成之后，将光标调整至第 3 行第 1 个字符的位置，然后按 Esc 使 Vim 进行命令模式，并按下!&#125;组合键，你会看到窗口的左下角出现:.,$!的提示信息 其中 . 表示光标所在的当前行，$ 表示文件最后一行，因此和之前不同，这次选取的是文件中第 3 行及之后的所有内容。 在此基础上，我们使用 sort 命令对选中文本按照第 1 列进行降序排序，执行命令如下： 1:.,$!sort -nr -k1 按 Enter（回车）键，可以看到，demo.txt 文件中的内容变成： 12345www.forever.cn.mwTue Nov 12 07:20:49 PST 20211 文本12 文本23 文本3 由此，通过将所选文件作为 sort 命令的输入，实现了对该部分文本的降序排序操作。 除此之外，表 3 罗列出了常用的几种 Vim 和 Linux 命令搭配使用的方式 格式 功能 :!命令 直接运行一个 Linux 命令，运行完毕之后，即可返回到 Vim 中。 :w!命令 将 Vim 中所有的文本内容作为指定命令的输入。但命令的执行结果不会写入到当前文件中。 :r!命令 将命令执行的结果写入到当前 Vim 中，例如 :!ls 表示将 ls 的执行结果输入到 Vim 中。 :nr!命令 其中 n 为数字，表示将命令的执行结果写入到 Vim 第 n 行的位置。例如，:3r!date 表示将 date 命令的执行结果写入到第 3 行文本处。 :n,m!命令 其中 n 表示起始行号，m为结束行号，功能是将 Vim 中指定的部分文本作为某个命令的输入，同时将命令的输出也插入到当前指定的位置。 :n,m w!命令 其中 n 表示起始行号，m为结束行号，其功能是 Vim 中指定的部分文本作为某个命令的输入，但命令的执行结果不会写入到文件中。 !!date 向 Vim 中插入当前时间。 Linux文本处理（Linux三剑客grep、sed和awk）Linux cat命令：连接文件并打印输出到标准输出设备cat 命令可以用来显示文本文件的内容（类似于 DOS 下的 type 命令），也可以把几个文件内容附加到另一个文件中，即连接合并文件。 关于此命令，有人认为写 cat 命令的人是因为喜欢猫，因此给此命令起名为“cat”，其实不然，cat 是 concatenate（连接、连续）的简写。 cat 命令的基本格式如下： 123[root@localhost ~]# cat [选项] 文件名或者[root@localhost ~]# cat 文件1 文件2 &gt; 文件3 这两种格式中，前者用于显示文件的内容，常用选项及各自的含义如表 1 所示；而后者用于连接合并文件。 选项 含义 -A 相当于 -vET 选项的整合，用于列出所有隐藏符号； -E 列出每行结尾的回车符 $； -n 对输出的所有行进行编号； -b 同 -n 不同，此选项表示只对非空行进行编号。 -T 把 Tab 键 ^I 显示出来； -V 列出特殊字符； -s 当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。 注意，cat 命令用于查看文件内容时，不论文件内容有多少，都会一次性显示。如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用PgUp+上箭头组合键向上翻页，但是这种翻页是有极限的，如果文件足够长，那么还是无法看全文件的内容。 因此，cat 命令适合查看不太大的文件。当然，在 Linux 中是可以使用其他的命令或方法来查看大文件的，我们以后再来学习。 【例 1】cat 命令本身非常简单，我们可以直接查看文件的内容。例如： 123456789[root@localhost ~]# cat anaconda-ks.cfg# Kickstart file automatically generated by anaconda.#version=DEVELinstallcdromlang zh一CN.UTF-8…省略部分内容... 而如果使用 “-n” 选项，则会显示行号。例如: 12345678[root@localhost ~]# cat -n anaconda-ks.cfg1 # Kickstart file automatically generated by anaconda.234 #version=DEVEL5 install6 cdrom…省略部分内容... 如果使用 “-A” 选项，则相当于使用了 “-vET” 选项，可以查看文本中的所有隐藏符号，包括回车符（$）、Tab 键（^I）等。例如： 12345678[root@localhost ~]# cat -A anaconda-ks.cfg# Kickstart file automatically generated by anaconda.$$$#version=DEVEL$install$cdrom$…省略部分内容… 【例 2】将文件 file1.txt 和 file2.txt 的内容合并后输出到文件 file3.txt 中。 12345678910111213[root@localhost base]# lsfile1.txt file2.txt[root@localhost base]# cat file1.txtwww.forever.cn.mw(file1.txt)[root@localhost base]# cat file2.txtis great(file2.txt)[root@localhost base]# cat file1.txt file2.txt &gt; file3.txt[root@localhost base]# more file3.txt#more 命令可查看文件中的内容www.forever.cn.mw(file1.txt)is great(file2.txt)[root@localhost base]# lsfile1.txt file2.txt file3.txt Linux more命令：分屏显示文件内容在讲解 cat 命令时，我们留下了一个疑问，即当使用 cat 命令查看文件内容时，如果文件过大，以至使用PgUp+上箭头组合键向上翻页也无法看全文件中的内容，该怎么办呢？这就需要使用 more 命令。 more 命令可以分页显示文本文件的内容，使用者可以逐页阅读文件中内容，此命令的基本格式如下： 1[root@localhost ~]# more [选项] 文件名 more 命令比较简单，一般不用什么选项，对于表 1 中所列的选项，读者只需看到认识即可。 选项 含义 -f 计算行数时，以实际的行数，而不是自动换行过后的行数。 -p 不以卷动的方式显示每一页，而是先清除屏幕后再显示内容。 -c 跟 -p 选项相似，不同的是先显示内容再清除其他旧资料。 -s 当遇到有连续两行以上的空白行时，就替换为一行的空白行。 -u 不显示下引号（根据环境变量 TERM 指定的终端而有所不同）。 +n 从第 n 行开始显示文件内容，n 代表数字。 -n 一次显示的行数，n 代表数字。 more 命令的执行会打开一个交互界面，因此读者有必要了解一些交互命令，常用的交互命令如表 2 所示。 交互指令 功能 h 或 ？ 显示 more 命令交互命令帮助。 q 或 Q 退出 more。 v 在当前行启动一个编辑器。 :f 显示当前文件的文件名和行号。 !&lt;命令&gt; 或 :!&lt;命令&gt; 在子Shell中执行指定命令。 回车键 向下移动一行。 空格键 向下移动一页。 Ctrl+l 刷新屏幕。 &#x3D; 显示当前行的行号。 ‘ 转到上一次搜索开始的地方。 Ctrf+f 向下滚动一页。 . 重复上次输入的命令。 &#x2F; 字符串 搜索指定的字符串。 d 向下移动半页。 b 向上移动一页。 【例 1】用分页的方式显示 anaconda-ks.cfg 文件的内容。 12345678[root@localhost ~]# more anaconda-ks.cfg# Kickstart file automatically generated by anaconda.#version=DEVELinstallcdrom…省略部分内容…--More--(69%)#在这里执行交互命令即可 【例 2】显示文件 anaconda-ks.cfg 的内容，每 10 行显示一屏，同时清楚屏幕，使用以下命令： 12[root@localhost ~]# more -c -10 anaconda-ks.cfg#省略输出内容。 Linux head命令：显示文件开头的内容head 命令可以显示指定文件前若干行的文件内容，其基本格式如下： 1[root@localhost ~]# head [选项] 文件名 该命令常用选项以及各自的含义，如表 1 所示。 选项 含义 -n K 这里的 K 表示行数，该选项用来显示文件前 K 行的内容；如果使用 “-K” 作为参数，则表示除了文件最后 K 行外，显示剩余的全部内容。 -c K 这里的 K 表示字节数，该选项用来显示文件前 K 个字节的内容；如果使用 “-K”，则表示除了文件最后 K 字节的内容，显示剩余全部内容。 -v 显示文件名； 注意，如不设置显示的具体行数，则默认显示 10 行的文本数据。 【例 1】基本用法。 12345[root@localhost ~]# head anaconda-ks.cfghead 命令默认显示文件的开头 10 行内容。如果想显示指定的行数，则只需使用 &quot;-n&quot; 选项即可，例如：[root@localhost ~]# head -n 20 anaconda-ks.cfg这是显示文件的开头 20 行内容，也可以直接写 &quot;-行数&quot;，例如：[root@localhost ~]# head -20 anaconda-ks.cfg Linux less命令：查看文件内容less 命令的作用和 more 十分类似，都用来浏览文本文件中的内容，不同之处在于，使用 more 命令浏览文件内容时，只能不断向后翻看，而使用 less 命令浏览，既可以向后翻看，也可以向前翻看。 不仅如此，为了方面用户浏览文本内容，less 命令还提供了以下几个功能： 使用光标键可以在文本文件中前后（左后）滚屏； 用行号或百分比作为书签浏览文件； 提供更加友好的检索、高亮显示等操作； 兼容常用的字处理程序（如 Vim、Emacs）的键盘操作； 阅读到文件结束时，less 命令不会退出； 屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。 less 命令的基本格式如下： 1[root@localhost ~]# less [选项] 文件名 此命令可用的选项以及各自的含义如表 1 所示。 选项 选项含义 -N 显示每行的行号。 -S 行过长时将超出部分舍弃。 -e 当文件显示结束后，自动离开。 -g 只标志最后搜索到的关键同。 -Q 不使用警告音。 -i 忽略搜索时的大小写。 -m 显示类似 more 命令的百分比。 -f 强迫打开特殊文件，比如外围设备代号、目录和二进制文件。 -s 显示连续空行为一行。 -b &lt;缓冲区大小&gt; 设置缓冲区的大小。 -o &lt;文件名&gt; 将 less 输出的内容保存到指定文件中。 -x &lt;数字&gt; 将【Tab】键显示为规定的数字空格。 在使用 less 命令查看文件内容的过程中，和 more 命令一样，也会进入交互界面，因此需要读者掌握一些常用的交互指令，如表 2 所示。 交互指令 功能 &#x2F;字符串 向下搜索“字符串”的功能。 ?字符串 向上搜索“字符串”的功能。 n 重复*前一个搜索（与 &#x2F; 成 ? 有关）。 N 反向重复前一个搜索（与 &#x2F; 或 ? 有关）。 b 向上移动一页。 d 向下移动半页。 h 或 H 显示帮助界面。 q 或 Q 退出 less 命令。 y 向上移动一行。 空格键 向下移动一页。 回车键 向下移动一行。 【PgDn】键 向下移动一页。 【PgUp】键 向上移动一页。 Ctrl+f 向下移动一页。 Ctrl+b 向上移动一页。 Ctrl+d 向下移动一页。 Ctrl+u 向上移动半页。 j 向下移动一行。 k 向上移动一行。 G 移动至最后一行。 g 移动到第一行。 ZZ 退出 less 命令。 v 使用配置的编辑器编辑当前文件。 [ 移动到本文档的上一个节点。 ] 移动到本文档的下一个节点。 p 移动到同级的上一个节点。 u 向上移动半页。 【例 1】使用 less 命令查看 &#x2F;boot&#x2F;grub&#x2F;grub.cfg 文件中的内容。 1234567891011121314151617181920212223[root@localhost ~]# less /boot/grub/grub.cfg##DO NOT EDIT THIS FILE##It is automatically generated by grub-mkconfig using templates from /etc/grub.d and settings from /etc/default/grub#### BEGIN /etc/grub.d/00_header ###if [ -s $prefix/grubenv ]; then set have_grubenv=true load_envfiset default=&quot;0&quot;if [ &quot;$ &#123;prev_saved_entry&#125;&quot; ]; then set saved_entry=&quot;$&#123;prev_saved_entry&#125;&quot; save_env saved_entry set prev_saved_entry= save_env prev_saved_entry set boot_once=truefifunction savedefault &#123; if [ -z &quot;$&#123;boot_once&#125;&quot; ]; then: 可以看到，less 在屏幕底部显示一个冒号（：），等待用户输入命令，比如说，用户想向下翻一页，可以按空格键；如果想向上翻一页，可以按 b 键。 Linux tail命令：显示文件结尾的内容tail 命令和 head 命令正好相反，它用来查看文件末尾的数据，其基本格式如下： 1[root@localhost ~]# tail [选项] 文件名 此命令常用的选项及含义如表 1 所示。 选项 含义 -n K 这里的 K 指的是行数，该选项表示输出最后 K 行，在此基础上，如果使用 -n +K，则表示从文件的第 K 行开始输出。 -c K 这里的 K 指的是字节数，该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 -c +K 则表示从文件第 K 个字节开始输出。 -f 输出文件变化后新增加的数据。 【例 1】查看 &#x2F;etc&#x2F;passwd 文件最后 3 行的数据内容。 123456789[root@localhost ~]# tail -n 3 /etc/passwdsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinoprofile:x:16:16:Special user account to be used by OProfile:/var/lib/oprofile:/sbin/nologintcpdump:x:72:72::/:/sbin/nologin除此之外，还可以采用如下这种形式：[root@localhost ~]# tail -3 /etc/passwdsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinoprofile:x:16:16:Special user account to be used by OProfile:/var/lib/oprofile:/sbin/nologintcpdump:x:72:72::/:/sbin/nologin 可以看到，使用 tail -n 3 /etc/passwd 命令和 tail -3 /etc/passwd 的效果是一样的。 【例 2】查看 &#x2F;etc&#x2F;passwd 文件末尾 100 个字节的数据内容。 12[root@localhost ~]# tail -c 100 /etc/passwdcpdump:x:72:72::/:/sbin/nologin 【例 3】 监听文件的新増内容。tail 命令有一种比较有趣的用法，可以使用 “-f” 选项来监听文件的新増内容，例如： 123456789101112[root@localhost ~]#tail -f anaconda-ks.cfg@server-platform@server-policypaxoddjobsgpiocertmongerpam_krb5krb5-workstationperl-DBD-SQLite%end#光标不会退出文件，而会一直监听在文件的结尾处 这条命令会显示文件的最后 10 行内容，而且光标不会退出命令，每隔一秒会检查一下文件是否增加新的内容，如果增加就追加到原来的输出结果后面并显示。因此，这时如果向文件中追加一些数据（需要开启一个新终端）： 123[root@localhost ~]# echo 2222222222 &gt;&gt; anaconda-ks.cfg[root@localhost ~]# echo 3333333333 &gt;&gt; anaconda-ks.cfg#在新终端中通过echo命令向文件中追加数据 那么，在原始的正在监听的终端中，会看到如下信息： 123456789101112[root@localhost ~]# tail -f anaconda-ks.cfg @server-platforin@server-policypaxoddjobsgpiocertmongerpam_krb5krb5-workstationperl-DBD-SQLite%end222222222233333333333#在文件的结尾处监听到了新増数据 如果想终止输出，按【Ctrl+c】键中断 tail 命令即可。 Linux重定向用法详解Linux 中的数据流谈到 Linux 的重定向，就不得不提以下这3种数据流： 输入信息会从 stdin 中读取（标准输入，通常是键盘或鼠标）。 输出信息会被输出到 stdout （标准输出，一个文本文件或者数据流）。 错误信息会被输出到 stderr。 了解了这些数据流的存在，在你使用 Shell 时，你就可以更好地控制数据的流向了。 在 Linux 系统中，标准输入，标准输出以及标准错误都作为文件存在。你可以在 /dev 目录下看到它们： 12$ ls /dev/std*/dev/stderr /dev/stdin /dev/stdout 重定向输出在 Linux 系统中，使用 &gt; 字符表示重定向输出。例如，将 ls 命令的输出重定向到一个文件中： 1$ ls &gt; list.txt 执行以上命令后，屏幕上并不会显示 ls 命令的输出信息，因为输出信息已经被重定向至 list.txt 文件中了。 除此之外，重定向还有许多用途，它还可以用于复制文件的内容，而且不限于复制文本文件，二进制文件也可以复制： 1$ cat image.png &gt; picture.png 如果你想要将一个文件的内容复制到另一个文件的末尾，你只需将 &gt; 字符换成 &gt;&gt; 字符串即可，像这样： 1$ cat lxlinux &gt;&gt; alvi 重定向输入与重定向输出相反，重定向输入使用的是 &lt; 字符。 输入重定向可以将输入信息重定向至命令中作为参数使用。该功能可能比较少用，但是，当命令需要一个参数列表时，而这些参数都存在一个文件中，然后你想快速地将它们从文件中复制粘贴到终端，这时这个功能就能派上用场了。 例如，package.list 里记录了你需要安装的包的列表，而你想要快速地安装所有的包，只需执行以下这一条命令，就能一次性安装 package.list 里的所有包： 1$ sudo dnf install $(&lt;package.list) 输入重定向的常见用法是 Here-document (简称 Here-doc) 以及 Here-string 。 Here-doc 将输入的文本块重定向至标准输入流，直至遇到特殊的文件结束标记符为止（文件结束标记符可以是任意的唯一的字符串，但大部分人都默认使用 EOF）。 你可以尝试在终端输入以下命令（直到第二个 EOF 字符串结束）： 1234$ cat &lt;&lt; EOF&gt; alvin&gt; lxlinux.net&gt; EOF 预期的输出应该是这样的： 12alvinlxlinux.net Here-doc 是 Bash 脚本编写者们将多行文本转储到文件或屏幕上的常用技巧。 Here-string 与 Here-doc 相似，但是它只有一个字符串，或者几个被引号括起来的字符串： 1234$ cat &lt;&lt;&lt; alvinalvin$ cat &lt;&lt;&lt; &quot;alvin lxlinux.net&quot;alvin lxlinux.net 重定向错误信息错误信息默认会进入叫 stderr 的流，使用 2&gt; 可以对其进行重定向。例如，将错误信息重定向到名为 output.log 的文件中： 1$ ls /nope 2&gt; output.log 重定向数据至 &#x2F;dev&#x2F;null就像标准输入、标准输出以及标准错误一样，在 Linux 文件系统中，空，也存在一个文件与之对应，它叫做 null ，放在 /dev 目录下。为了方便读，人们经常省略斜杠，直接把他读作 dev null 。 /dev/null 并不保存数据，被写入 /dev/null 的数据最终都会丢失，就像被丢进虚空中一样。因此，你可以使用重定向将不需要的数据输送到 /dev/null 。例如，find 命令的输出往往很冗长，而且在搜索文件时还经常会报告权限冲突的错误，像这样： 123456$ find ~ -type f/home/seth/actual.filefind: `/home/seth/foggy&#x27;: Permission deniedfind: `/home/seth/groggy&#x27;: Permission deniedfind: `/home/seth/soggy&#x27;: Permission denied/home/seth/zzz.file 这时，你就可以将错误信息重定向到 /dev/null ，以过滤掉不必要的信息，像这样: 123$ find ~ -type f 2&gt; /dev/null/home/seth/actual.file/home/seth/zzz.file Linux grep命令详解：查找文件内容很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用 grep 命令。 grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。 grep命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。 正则表达式是描述一组字符串的一个模式，正则表达式的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，grep 命令支持如表 1 所示的这几种正则表达式的元字符（也就是通配符）。 通配符 功能 c* 将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。 . 将匹配任何一个字符，且只能是一个字符。 [xyz] 匹配方括号中的任意一个字符。 [^xyz] 匹配除方括号中字符外的所有字符。 ^ 锁定行的开头。 $ 锁定行的结尾。 需要注意的是，在基本正则表达式中，如通配符 *、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \\，如 *、+、{、|、( 和 )。 grep 命令是用来在每一个文件或中（或特定输出上）搜索特定的模式，当使用 grep 时，包含指定字符模式的每一行内容，都会被打印（显示）到屏幕上，但是使用 grep 命令并不改变文件中的内容。 grep 命令的基本格式如下： 1[root@localhost ~]# grep [选项] 模式 文件名 这里的模式，要么是字符（串），要么是正则表达式。而此命令常用的选项以及各自的含义如表 2 所示。 选项 含义 -c 仅列出文件中包含模式的行数。 -i 忽略模式中的字母大小写。 -l 列出带有匹配行的文件名。 -n 在每一行的最前面列出行号。 -v 列出没有匹配模式的行。 -w 把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。 注意，如果是搜索多个文件，grep 命令的搜索结果只显示文件中发现匹配模式的文件名；而如果搜索单个文件，grep 命令的结果将显示每一个包含匹配模式的行。 【例 1】假设有一份 emp.data 员工清单，现在要搜索此文件，找出职位为 CLERK 的所有员工，则执行命令如下： 12[root@localhost ~]# grep CLERK emp.data#忽略输出内容 而在此基础上，如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下： 12[root@localhost ~]# grep -c CLERK emp.data#忽略输出内容 【例 2】搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下： 12[root@localhost ~]# grep ^78 emp.data#忽略输出内容 grep 命令的功能非常强大，通过利用它的不同选项以及变化万千的正则表达式，可以获取任何我们所需要的信息。 Linux sed命令完全攻略我们知道，Vim 采用的是交互式文本编辑模式，你可以用键盘命令来交互性地插入、删除或替换数据中的文本。但本节要讲的 sed 命令不同，它采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。 sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下： 每次仅读取一行内容； 根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据； 将执行结果输出。 当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。 sed 命令的基本格式如下： 1[root@localhost ~]# sed [选项] [脚本命令] 文件名 该命令常用的选项及含义，如表 1 所示。 选项 含义 -e 脚本命令 该选项会将其后跟的脚本命令添加到已有的命令中。 -f 脚本命令文件 该选项会将其后文件中的脚本命令添加到已有的命令中。 -n 默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。 -i 此选项会直接修改源文件，要慎用。 成功使用 sed 命令的关键在于掌握各式各样的脚本命令及格式，它能帮你定制编辑文件的规则。 sed脚本命令sed s 替换脚本命令此命令的基本格式为： 1[address]s/pattern/replacement/flags 其中，address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。 关于指定具体操作行（address）的用法，这里先不做解释，文章后续会对其做详细介绍。 此命令中常用的 flags 标记如表 2 所示。 flags 标记 功能 n 1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记； g 对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A； p 会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。 w file 将缓冲区中的内容写到指定的 file 文件中； &amp; 用正则表达式匹配的内容进行替换； 匹配第 n 个子串，该子串之前在 pattern 中用 () 指定。 \\ 转义（转义替换部分包含：&amp;、\\ 等）。 比如，可以指定 sed 用新文本替换第几处模式匹配的地方： 123[root@localhost ~]# sed &#x27;s/test/trial/2&#x27; data4.txtThis is a test of the trial script.This is the second test of the trial script. 可以看到，使用数字 2 作为标记的结果就是，sed 编辑器只替换每行中第 2 次出现的匹配模式。 如果要用新文件替换所有匹配的字符串，可以使用 g 标记： 123[root@localhost ~]# sed &#x27;s/test/trial/g&#x27; data4.txtThis is a trial of the trial script.This is the second trial of the trial script. 我们知道，-n 选项会禁止 sed 输出，但 p 标记会输出修改过的行，将二者匹配使用的效果就是只输出被替换命令修改过的行，例如： 12345[root@localhost ~]# cat data5.txtThis is a test line.This is a different line.[root@localhost ~]# sed -n &#x27;s/test/trial/p&#x27; data5.txtThis is a trial line. w 标记会将匹配后的结果保存到指定文件中，比如： 12345[root@localhost ~]# sed &#x27;s/test/trial/w test.txt&#x27; data5.txtThis is a trial line.This is a different line.[root@localhost ~]#cat test.txtThis is a trial line. 在使用 s 脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义，例如： 1[root@localhost ~]# sed &#x27;s/\\/bin\\/bash/\\/bin\\/csh/&#x27; /etc/passwd sed d 替换脚本命令此命令的基本格式为： 1[address]d 如果需要删除文本中的特定行，可以用 d 脚本命令，它会删除指定行中的所有内容。但使用该命令时要特别小心，如果你忘记指定具体行的话，文件中的所有内容都会被删除，举个例子： 1234567[root@localhost ~]# cat data1.txtThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy dog[root@localhost ~]# sed &#x27;d&#x27; data1.txt#什么也不输出，证明成了空文件 当和指定地址一起使用时，删除命令显然能发挥出大的功用。可以从数据流中删除特定的文本行。 address 的具体写法后续会做详细介绍，这里只给大家举几个简单的例子： 通过行号指定，比如删除 data6.txt 文件内容中的第 3 行： 123456789[root@localhost ~]# cat data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.[root@localhost ~]# sed &#x27;3d&#x27; data6.txtThis is line number 1.This is line number 2.This is line number 4. 或者通过特定行区间指定，比如删除 data6.txt 文件内容中的第 2、3行： 123[root@localhost ~]# sed &#x27;2,3d&#x27; data6.txtThis is line number 1.This is line number 4. 也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心，你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，sed 会删除两个指定行之间的所有行（包括指定的行），例如： 123[root@localhost ~]#sed &#x27;/1/,/3/d&#x27; data6.txt#删除第 1~3 行的文本数据This is line number 4. 或者通过特殊的文件结尾字符，比如删除 data6.txt 文件内容中第 3 行开始的所有的内容： 123[root@localhost ~]# sed &#x27;3,$d&#x27; data6.txtThis is line number 1.This is line number 2. 在此强调，在默认情况下 sed 并不会修改原始文件，这里被删除的行只是从 sed 的输出中消失了，原始文件没做任何改变。 sed a 和 i 脚本命令a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行，这里之所以要同时介绍这 2 个脚本命令，因为它们的基本格式完全相同，如下所示： 1[address]a（或 i）\\新文本内容 下面分别就这 2 个命令，给读者举几个例子。比如说，将一个新行插入到数据流第三行前，执行命令如下： 1234567[root@localhost ~]# sed &#x27;3i\\&gt; This is an inserted line.&#x27; data6.txtThis is line number 1.This is line number 2.This is an inserted line.This is line number 3.This is line number 4. 再比如说，将一个新行附加到数据流中第三行后，执行命令如下： 1234567[root@localhost ~]# sed &#x27;3a\\&gt; This is an appended line.&#x27; data6.txtThis is line number 1.This is line number 2.This is line number 3.This is an appended line.This is line number 4. 如果你想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可，例如： 123456789[root@localhost ~]# sed &#x27;1i\\&gt; This is one line of new text.\\&gt; This is another line of new text.&#x27; data6.txtThis is one line of new text.This is another line of new text.This is line number 1.This is line number 2.This is line number 3.This is line number 4. 可以看到，指定的两行都会被添加到数据流中。 sed c 替换脚本命令c 命令表示将指定行中的所有内容，替换成该选项后面的字符串。该命令的基本格式为： 1[address]c\\用于替换的新文本 举个例子： 123456[root@localhost ~]# sed &#x27;3c\\&gt; This is a changed line of text.&#x27; data6.txtThis is line number 1.This is line number 2.This is a changed line of text.This is line number 4. 在这个例子中，sed 编辑器会修改第三行中的文本，其实，下面的写法也可以实现此目的： 123456[root@localhost ~]# sed &#x27;/number 3/c\\&gt; This is a changed line of text.&#x27; data6.txtThis is line number 1.This is line number 2.This is a changed line of text.This is line number 4. sed y 转换脚本命令y 转换命令是唯一可以处理单个字符的 sed 脚本命令，其基本格式如下： 1[address]y/inchars/outchars/ 转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。 举个简单例子： 12345678[root@localhost ~]# sed &#x27;y/123/789/&#x27; data8.txtThis is line number 7.This is line number 8.This is line number 9.This is line number 4.This is line number 7 again.This is yet another line.This is the last line in the file. 可以看到，inchars 模式中指定字符的每个实例都会被替换成 outchars 模式中相同位置的那个字符。 转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置，再打个比方： 12[root@localhost ~]# echo &quot;This 1 is a test of 1 try.&quot; | sed &#x27;y/123/456/&#x27;This 4 is a test of 4 try. sed 转换了在文本行中匹配到的字符 1 的两个实例，我们无法限定只转换在特定地方出现的字符。 sed p 打印脚本命令p 命令表示搜索符号条件的行，并输出该行的内容，此命令的基本格式为： 1[address]p p 命令常见的用法是打印包含匹配文本模式的行，例如： 1234567[root@localhost ~]# cat data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.[root@localhost ~]# sed -n &#x27;/number 3/p&#x27; data6.txtThis is line number 3. 可以看到，用 -n 选项和 p 命令配合使用，我们可以禁止输出其他行，只打印包含匹配文本模式的行。 如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示： 123456[root@localhost ~]# sed -n &#x27;/3/&#123;&gt; p&gt; s/line/test/p&gt; &#125;&#x27; data6.txtThis is line number 3.This is test number 3. sed 命令会查找包含数字 3 的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。 sed w 脚本命令w 命令用来将文本中指定行的内容写入文件中，此命令的基本格式如下： 1[address]w filename 这里的 filename 表示文件名，可以使用相对路径或绝对路径，但不管是哪种，运行 sed 命令的用户都必须有文件的写权限。 下面的例子是将数据流中的前两行打印到一个文本文件中： 12345678[root@localhost ~]# sed &#x27;1,2w test.txt&#x27; data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.[root@localhost ~]# cat test.txtThis is line number 1.This is line number 2. 当然，如果不想让行直接输出，可以用 -n 选项，再举个例子： 123456789[root@localhost ~]# cat data11.txtBlum, R BrowncoatMcGuiness, A AllianceBresnahan, C BrowncoatHarken, C Alliance[root@localhost ~]# sed -n &#x27;/Browncoat/w Browncoats.txt&#x27; data11.txtcat Browncoats.txtBlum, R BrowncoatBresnahan, C Browncoat 可以看到，通过使用 w 脚本命令，sed 可以实现将包含文本模式的数据行写入目标文件。 sed r 脚本命令r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，该命令的基本格式为： [address]r filename sed 命令会将 filename 文件中的内容插入到 address 指定行的后面，比如说： 12345678910[root@localhost ~]# cat data12.txtThis is an added line.This is the second added line.[root@localhost ~]# sed &#x27;3r data12.txt&#x27; data6.txtThis is line number 1.This is line number 2.This is line number 3.This is an added line.This is the second added line.This is line number 4. 如果你想将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符，例如： 1234567[root@localhost ~]# sed &#x27;$r data12.txt&#x27; data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.This is an added line.This is the second added line. sed q 退出脚本命令q 命令的作用是使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理。 比如： 123[root@localhost ~]# sed &#x27;2q&#x27; test.txtThis is line number 1.This is line number 2. 可以看到，sed 命令在打印输出第 2 行之后，就停止了，是 q 命令造成的，再比如： 12[root@localhost ~]# sed &#x27;/number 1/&#123; s/number 1/number 0/;q; &#125;&#x27; test.txtThis is line number 0. 使用 q 命令之后，sed 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出。 sed 脚本命令的寻址方式前面在介绍各个脚本命令时，我们一直忽略了对 address 部分的介绍。对各个脚本命令来说，address 用来表明该脚本命令作用到文本中的具体行。 默认情况下，sed 命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须写明 address 部分，表示的方法有以下 2 种： 以数字形式指定行区间； 用文本模式指定具体行区间。 以上两种形式都可以使用如下这 2 种格式，分别是： 12345[address]脚本命令或者address &#123; 多个脚本命令&#125; 以上两种形式在前面例子中都有具体实例，因此这里不再做过多赘述。 以数字形式指定行区间当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。sed 会将文本流中的第一行编号为 1，然后继续按顺序为接下来的行分配行号。 在脚本命令中，指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里举一个 sed 命令作用到指定行号的例子： 12345[root@localhost ~]#sed &#x27;2s/dog/cat/&#x27; data1.txtThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy catThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy dog 可以看到，sed 只修改地址指定的第二行的文本。下面的例子中使用了行地址区间： 12345[root@localhost ~]# sed &#x27;2,3s/dog/cat/&#x27; data1.txtThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy catThe quick brown fox jumps over the lazy catThe quick brown fox jumps over the lazy dog 在此基础上，如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——美元符（$）： 12345[root@localhost ~]# sed &#x27;2,$s/dog/cat/&#x27; data1.txtThe quick brown fox jumps over the lazy dogThe quick brown fox jumps over the lazy catThe quick brown fox jumps over the lazy catThe quick brown fox jumps over the lazy cat 用文本模式指定行区间sed 允许指定文本模式来过滤出命令要作用的行，格式如下： 1/pattern/command 注意，必须用正斜线将要指定的 pattern 封起来，sed 会将该命令作用到包含指定文本模式的行上。 举个例子，如果你想只修改用户 demo 的默认 shell，可以使用 sed 命令，执行命令如下： 1234567[root@localhost ~]# grep demo /etc/passwddemo:x:502:502::/home/Samantha:/bin/bash[root@localhost ~]# sed &#x27;/demo/s/bash/csh/&#x27; /etc/passwdroot:x:0:0:root:/root:/bin/bash...demo:x:502:502::/home/demo:/bin/csh... 虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限，因此，sed 允许在文本模式使用正则表达式指明作用的具体行。正则表达式允许创建高级文本模式匹配表达式来匹配各种数据。这些表达式结合了一系列通配符、特殊字符以及固定文本字符来生成能够匹配几乎任何形式文本的简练模式。 关于正则表达式，本节不做过多介绍，有兴趣的读者可阅读《正则表达式入门教程》一文，这里仅给读者提供一个简单示例： 12345678910111213141516171819[root@localhost ~]# cat test.txt&lt;html&gt;&lt;title&gt;First Wed&lt;/title&gt;&lt;body&gt;h1Helloh1h2Helloh2h3Helloh3&lt;/body&gt;&lt;/html&gt;#使用正则表示式给所有第一个的h1、h2、h3添加&lt;&gt;，给第二个h1、h2、h3添加&lt;/&gt;[root@localhost ~]# cat sed.sh/h[0-9]/&#123; s//\\&lt;&amp;\\&gt;/1 s//\\&lt;\\/&amp;\\&gt;/2&#125;[root@localhost ~]# sed -f sed.sh test.txt&lt;h1&gt;Hello&lt;/h1&gt;&lt;h2&gt;Hello&lt;/h2&gt;&lt;h3&gt;Hello&lt;/h3&gt; Linux sed命令高级用法精讲sed 多行命令在学习 sed 命令的基础功能时，你可能注意到了一个局限，即所有的 sed 命令都只是针对单行数据执行操作，在 sed 命令读取缓冲区中的文本数据时，它会基于换行符的位置，将数据分成行，sed 会根据定义好的脚本命令一次处理一行数据。 但是，有时我们需要对跨多行的数据执行特定操作。比如说，在文本中查找一串字符串&quot;www.forever.cn.mw&quot;，它很有可能出现在两行中，每行各包含其中一部分。这时，如果用普通的 sed 编辑器命令来处理文本，就不可能发现这种被分开的情况。 幸运的是，sed 命令的设计人员已经考虑到了这种情况，并设计了对应的解决方案。sed 包含了三个可用来处理多行文本的特殊命令，分别是： Next 命令（N）：将数据流中的下一行加进来创建一个多行组来处理。 Delete（D）：删除多行组中的一行。 Print（P）：打印多行组中的一行。 注意，以上命令的缩写，都为大写。 N 多行操作命令N 命令会将下一行文本内容添加到缓冲区已有数据之后（之间用换行符分隔），从而使前后两个文本行同时位于缓冲区中，sed 命令会将这两行数据当成一行来处理。 下面这个例子演示的 N 命令的功能： 123456789[root@localhost ~]# cat data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.[root@localhost ~]# sed &#x27;/first/&#123; N ; s/ / / &#125;&#x27; data2.txtThis is the header line.This is the first data line. This is the second data line.This is the last line. 在这个例子中，sed 命令查找含有单词 first 的那行文本。找到该行后，它会用 N 命令将下一行合并到那行，然后用替换命令 s 将换行符替换成空格。结果是，文本文件中的两行在 sed 的输出中成了一行。 如果要在数据文件中查找一个可能会分散在两行中的文本短语，如何实现呢？这里给大家一个实例： 123456789[root@localhost ~]# cat data3.txtOn Tuesday, the Linux SystemAdministrator&#x27;s group meeting will be held.All System Administrators should attend.Thank you for your attendance.[root@localhost ~]# sed &#x27;N ; s/System Administrator/Desktop User/&#x27; data3.txtOn Tuesday, the Linux Desktop User&#x27;s group meeting will be held.All Desktop Users should attend.Thank you for your attendance. 用 N 命令将发现第一个单词的那行和下一行合并后，即使短语内出现了换行，你仍然可以找到它，这是因为，替换命令在 System 和 Administrator之间用了通配符（.）来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这可能不是你想要的。 要解决这个问题，可以在 sed 脚本中用两个替换命令，一个用来匹配短语出现在多行中的情况，一个用来匹配短语出现在单行中的情况，比如： 12345678[root@localhost ~]# sed &#x27;N&gt; s/System Administrator/Desktop User/&gt; s/System Administrator/Desktop User/&gt; &#x27; data3.txtOn Tuesday, the Linux DesktopUser&#x27;s group meeting will be held.All Desktop Users should attend.Thank you for your attendance. 第一个替换命令专门查找两个单词间的换行符，并将它放在了替换字符串中。这样就能在第一个替换命令专门在两个检索词之间寻找换行符，并将其纳入替换字符串。这样就允许在新文本的同样位置添加换行符了。 但这个脚本中仍有个小问题，即它总是在执行 sed 命令前将下一行文本读入到缓冲区中，当它到了后一行文本时，就没有下一行可读了，此时 N 命令会叫 sed 程序停止，这就导致，如果要匹配的文本正好在最后一行中，sed 命令将不会发现要匹配的数据。 解决这个 bug 的方法是，将单行命令放到 N 命令前面，将多行命令放到 N 命令后面，像这样： 123456789[root@localhost ~]# sed &#x27;&gt; s/System Administrator/Desktop User/&gt; N&gt; s/System Administrator/Desktop User/&gt; &#x27; data3.txtOn Tuesday, the Linux DesktopUser&#x27;s group meeting will be held.All Desktop Users should attend.Thank you for your attendance. 现在，查找单行中短语的替换命令在数据流的后一行也能正常工作，多行替换命令则会负责短语出现在数据流中间的情况。 D 多行删除命令sed 不仅提供了单行删除命令（d），也提供了多行删除命令 D，其作用是只删除缓冲区中的第一行，也就是说，D 命令将缓冲区中第一个换行符（包括换行符）之前的内容删除掉。 比如说： 1234567[root@localhost ~]# cat data4.txtOn Tuesday, the Linux SystemAdministrator&#x27;s group meeting will be held.All System Administrators should attend.[root@localhost ~]# sed &#x27;N ; /System Administrator/D&#x27; data4.txtAdministrator&#x27;s group meeting will be held.All System Administrators should attend. 文本的第二行被 N 命令加到了缓冲区，因此 sed 命令第一次匹配就是成功，而 D 命令会将缓冲区中第一个换行符之前（也就是第一行）的数据删除，所以，得到了如上所示的结果。 下面的例子中，它会删除数据流中出现在第一行前的空白行： 1234567891011[root@localhost ~]# cat data5.txtThis is the header line.This is a data line.This is the last line.[root@localhost ~]# sed &#x27;/^$/&#123;N ; /header/D&#125;&#x27; data5.txtThis is the header line.This is a data line.This is the last line. sed会查找空白行，然后用 N 命令来将下一文本行添加到缓冲区。此时如果缓冲区的内容中含有单词 header，则 D 命令会删除缓冲区中的第一行。 P 多行打印命令同 d 和 D 之间的区别一样，P（大写）命令和单行打印命令 p（小写）不同，对于具有多行数据的缓冲区来说，它只会打印缓冲区中的第一行，也就是首个换行符之前的所有内容。 12345678例如，test.txt 文件中的内容如下：[root@localhost ~]# cat test.txtaaabbbcccdddeeefff 表 1 中是对 test.txt 文件中的内容分别用 p 命令和 P 命令后，产生的输出信息的对比。 P（大写）命令 p（小写）命令 [root@localhost ~]# sed ‘&#x2F;.*&#x2F;N;P’ aaa aaa bbb ccc ccc ddd eee eee fff [root@localhost ~]# sed ‘&#x2F;.*&#x2F;N;p’ aaa bbb aaa bbb ccc ddd ccc ddd eee fff eee fff 第一个 sed 命令，每次都使用 N 将下一行内容追加到缓冲区内容的后面（用换行符间隔），也就是说，第一次时缓冲区中的内容为 aaa bbb，但 P（大写） 命令的作用的打印换行符之前的内容，也就是 aaa，之后则是 sed 在自动输出功能输出 aaa 和 bbb（sed 命令会自动将 输出为换行），依次类推，就输出了所看到的结果。 第二个 sed 命令，使用的是 p （小写）单行打印命令，它会将缓冲区中的所有内容全部打印出来（ 会自动输出为换行），因此，出现了看到的结果。 sed 保持空间前面我们一直说，sed 命令处理的是缓冲区中的内容，其实这里的缓冲区，应称为模式空间。值得一提的是，模式空间并不是 sed 命令保存文件的唯一空间。sed 还有另一块称为保持空间的缓冲区域，它可以用来临时存储一些数据。 表 2 列出了 5 条可用来操作保持空间的命令。 命令 功能 h 将模式空间中的内容复制到保持空间 H 将模式空间中的内容附加到保持空间 g 将保持空间中的内容复制到模式空间 G 将保持空间中的内容附加到模式空间 x 交换模式空间和保持空间中的内容 通常，在使用 h 或 H 命令将字符串移动到保持空间后，最终还要用 g、G 或 x 命令将保存的字符串移回模式空间。保持空间最直接的作用是，一旦我们将模式空间中所有的文件复制到保持空间中，就可以清空模式空间来加载其他要处理的文本内容。 由于有两个缓冲区域，下面的例子中演示了如何用 h 和 g 命令来将数据在 sed 缓冲区之间移动。 123456789[root@localhost ~]# cat data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.[root@localhost ~]# sed -n &#x27;/first/ &#123;h ; p ; n ; p ; g ; p &#125;&#x27; data2.txtThis is the first data line.This is the second data line.This is the first data line. 这个例子的运行过程是这样的： sed脚本命令用正则表达式过滤出含有单词first的行； 当含有单词 first 的行出现时，h 命令将该行放到保持空间； p 命令打印模式空间也就是第一个数据行的内容； n 命令提取数据流中的下一行（This is the second data line），并将它放到模式空间； p 命令打印模式空间的内容，现在是第二个数据行； g 命令将保持空间的内容（This is the first data line）放回模式空间，替换当前文本； p 命令打印模式空间的当前内容，现在变回第一个数据行了。 sed改变指定流程b 分支命令通常，sed 程序的执行过程会从第一个脚本命令开始，一直执行到最后一个脚本命令（D 命令是个例外，它会强制 sed 返回到脚本的顶部，而不读取新的行）。sed 提供了 b 分支命令来改变命令脚本的执行流程，其结果与结构化编程类似。 b 分支命令基本格式为： 1[address]b [label] 其中，address 参数决定了哪些行的数据会触发分支命令，label 参数定义了要跳转到的位置。 需要注意的是，如果没有加 label 参数，跳转命令会跳转到脚本的结尾，比如： 12345678910[root@localhost ~]# cat data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.[root@localhost ~]# sed &#x27;&#123;2,3b ; s/This is/Is this/ ; s/line./test?/&#125;&#x27; data2.txtIs this the header test?This is the first data line.This is the second data line.Is this the last test? 可以看到，因为 b 命令未指定 label 参数，因此数据流中的第2行和第3行并没有执行那两个替换命令。 如果我们不想直接跳到脚本的结尾，可以为 b 命令指定一个标签（也就是格式中的 label，最多为 7 个字符长度）。在使用此该标签时，要以冒号开始（比如 :label2），并将其放到要跳过的脚本命令之后。这样，当 sed 命令匹配并处理该行文本时，会跳过标签之前所有的脚本命令，但会执行标签之后的脚本命令。 比如说： 1234567[root@localhost ~]# sed &#x27;&#123;/first/b jump1 ; s/This is the/No jump on/&gt; :jump1&gt; s/This is the/Jump here on/&#125;&#x27; data2.txtNo jump on header lineJump here on first data lineNo jump on second data lineNo jump on last line 在这个例子中，如果文本行中出现了 first，程序的执行会直接跳到 jump1 标签之后的脚本行。如果分支命令的模式没有匹配，sed 会继续执行所有的脚本命令。 b 分支命令除了可以向后跳转，还可以向前跳转，例如： 1234567891011[root@localhost ~]# echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;&#123;&gt; :start&gt; s/,//1p&gt; /,/b start&gt; &#125;&#x27;This is, a, test, to, remove, commas.This is a, test, to, remove, commas.This is a test, to, remove, commas.This is a test to, remove, commas.This is a test to remove, commas.This is a test to remove commas. 在这个例子中，当缓冲区中的行内容中有逗号时，脚本命令就会一直循环执行，每次迭代都会删除文本中的第一个逗号，并打印字符串，直至内容中没有逗号。 t 测试命令类似于 b 分支命令，t 命令也可以用来改变 sed 脚本的执行流程。t 测试命令会根据 s 替换命令的结果，如果匹配并替换成功，则脚本的执行会跳转到指定的标签；反之，t 命令无效。 测试命令使用与分支命令相同的格式： 1[address]t [label] 跟分支命令一样，在没有指定标签的情况下，如果 s 命令替换成功，sed 会跳转到脚本的结尾（相当于不执行任何脚本命令）。例如： 123456789[root@localhost ~]# sed &#x27;&#123;&gt; s/first/matched/&gt; t&gt; s/This is the/No match on/&gt; &#125;&#x27; data2.txtNo match on header lineThis is the matched data lineNo match on second data lineNo match on last line 此例中，第一个替换命令会查找模式文本 first，如果匹配并替换成功，命令会直接跳过后面的替换命令；反之，如果第一个替换命令未能匹配成功，第二个替换命令就会被执行。 再举个例子： 1234567891011[root@localhost ~]# echo &quot;This, is, a, test, to, remove, commas. &quot; | sed -n &#x27;&#123;&gt; :start&gt; s/,//1p&gt; t start&gt; &#125;&#x27;This is, a, test, to, remove, commas.This is a, test, to, remove, commas.This is a test, to, remove, commas.This is a test to, remove, commas.This is a test to remove, commas.This is a test to remove commas. Linux awk命令详解除了使用 sed 命令，Linux 系统中还有一个功能更加强大的文本数据处理工具，就是 awk。它诞生于 20 世纪 70 年代末期，这也许是它影响了众多 Linux 用户的原因之一。 曾有人推测 awk 命令的名字来源于 awkward 这个单词。其实不然，此命令的设计者有 3 位，他们的姓分别是 Aho、Weingberger 和 Kernighan，awk 就取自这 3 为大师姓的首字母。 和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。 awk 命令的基本格式为： 1[root@localhost ~]# awk [选项] &#x27;脚本命令&#x27; 文件名 此命令常用的选项以及各自的含义，如表 1 所示。 选项 含义 -F fs 指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符。 -f file 从脚本文件中读取 awk 脚本指令，以取代直接在命令行中输入指令。 -v var&#x3D;val 在执行处理过程之前，设置一个变量 var，并给其设备初始值为 val。 awk 的强大之处在于脚本命令，它由 2 部分组成，分别为匹配规则和执行命令，如下所示： ‘匹配规则{执行命令}’ 这里的匹配规则，和 sed 命令中的 address 部分作用相同，用来指定脚本命令可以作用到文本内容中的具体行，可以使用字符串（比如 &#x2F;demo&#x2F;，表示查看含有 demo 字符串的行）或者正则表达式指定。另外需要注意的是，整个脚本命令是用单引号（’’）括起，而其中的执行命令部分需要用大括号（{}）括起来。 在 awk 程序执行时，如果没有指定执行命令，则默认会把匹配的行输出；如果不指定匹配规则，则默认匹配文本中所有的行。 举个简单的例子： 1[root@localhost ~]# awk &#x27;/^$/ &#123;print &quot;Blank line&quot;&#125;&#x27; test.txt 在此命令中，/^$/ 是一个正则表达式，功能是匹配文本中的空白行，同时可以看到，执行命令使用的是 print 命令，此命令经常会使用，它的作用很简单，就是将指定的文本进行输出。因此，整个命令的功能是，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank line。 awk 使用数据字段变量awk 的主要特性之一是其处理文本文件中数据的能力，它会自动给一行中的每个数据元素分配一个变量。 默认情况下，awk 会将如下变量分配给它在文本行中发现的数据字段： $0 代表整个文本行； $1 代表文本行中的第 1 个数据字段； $2 代表文本行中的第 2 个数据字段； $n 代表文本行中的第 n 个数据字段。 前面说过，在 awk 中，默认的字段分隔符是任意的空白字符（例如空格或制表符）。 在文本行中，每个数据字段都是通过字段分隔符划分的。awk 在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。 所以在下面的例子中，awk 程序读取文本文件，只显示第 1 个数据字段的值： 12345678[root@localhost ~]# cat data2.txtOne line of test text.Two lines of test text.Three lines of test text.[root@localhost ~]# awk &#x27;&#123;print $1&#125;&#x27; data2.txtOneTwoThree 该程序用 $1 字段变量来表示“仅显示每行文本的第 1 个数据字段”。当然，如果你要读取采用了其他字段分隔符的文件，可以用 -F 选项手动指定。 awk 脚本命令使用多个命令awk 允许将多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，例如： 12[root@localhost ~]# echo &quot;My name is Rich&quot; | awk &#x27;&#123;$4=&quot;Christine&quot;; print $0&#125;&#x27;My name is Christine 第一条命令会给字段变量 $4 赋值。第二条命令会打印整个数据字段。可以看到，awk 程序在输出中已经将原文本中的第四个数据字段替换成了新值。 除此之外，也可以一次一行地输入程序脚本命令，比如说： 12345[root@localhost ~]# awk &#x27;&#123;&gt; $4=&quot;Christine&quot;&gt; print $0&#125;&#x27;My name is RichMy name is Christine 在你用了表示起始的单引号后，bash shell 会使用 &gt; 来提示输入更多数据，我们可以每次在每行加一条命令，直到输入了结尾的单引号。 注意，此例中因为没有在命令行中指定文件名，awk 程序需要用户输入获得数据，因此当运行这个程序的时候，它会一直等着用户输入文本，此时如果要退出程序，只需按下 Ctrl+D 组合键即可。 awk从文件中读取程序跟 sed 一样，awk 允许将脚本命令存储到文件中，然后再在命令行中引用，比如： 123456789101112[root@localhost ~]# cat awk.sh&#123;print $1 &quot;&#x27;s home directory is &quot; $6&#125;[root@localhost ~]# awk -F: -f awk.sh /etc/passwdroot&#x27;s home directory is /rootbin&#x27;s home directory is /bindaemon&#x27;s home directory is /sbinadm&#x27;s home directory is /var/admlp&#x27;s home directory is /var/spool/lpd...Christine&#x27;s home directory is /home/ChristineSamantha&#x27;s home directory is /home/SamanthaTimothy&#x27;s home directory is /home/Timothy awk.sh 脚本文件会使用 print 命令打印 &#x2F;etc&#x2F;passwd 文件的主目录数据字段（字段变量 $6），以及 userid 数据字段（字段变量 $1）。注意，在程序文件中，也可以指定多条命令，只要一条命令放一行即可，之间不需要用分号。 awk BEGIN关键字awk 中还可以指定脚本命令的运行时机。默认情况下，awk 会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用 BEGIN 关键字。 BEGIN 会强制 awk 在读取数据前执行该关键字后指定的脚本命令，例如： 12345678910[root@localhost ~]# cat data3.txtLine 1Line 2Line 3[root@localhost ~]# awk &#x27;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;&gt; &#123;print $0&#125;&#x27; data3.txtThe data3 File Contents:Line 1Line 2Line 3 可以看到，这里的脚本命令中分为 2 部分，BEGIN 部分的脚本指令会在 awk 命令处理数据前运行，而真正用来处理数据的是第二段脚本命令。 awk END关键字和 BEGIN 关键字相对应，END 关键字允许我们指定一些脚本命令，awk 会在读完数据后执行它们，例如： 12345678[root@localhost ~]# awk &#x27;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;&gt; &#123;print $0&#125;&gt; END &#123;print &quot;End of File&quot;&#125;&#x27; data3.txtThe data3 File Contents:Line 1Line 2Line 3End of File 可以看到，当 awk 程序打印完文件内容后，才会执行 END 中的脚本命令。 Linux系统软件安装Linux软件包Linux下的软件包众多，且几乎都是经 GPL 授权、免费开源（无偿公开源代码）的。这意味着如果你具备修改软件源代码的能力，只要你愿意，可以随意修改。 GPL，全称 General Public License，中文名称“通用性公开许可证”，简单理解 GPL 就是一个保护软件自由的一个协议，经 GPL 协议授权的软件必须开源 Linux下的软件包可细分为两种，分别是源码包和二进制包。 Linux源码包实际上，源码包就是一大堆源代码程序，是由程序员按照特定的格式和语法编写出来的。 我们都知道，计算机只能识别机器语言，也就是二进制语言，所以源码包的安装需要一名“翻译官”将“abcd”翻译成二进制语言，这名“翻译官”通常被称为编译器。 “编译”指的是从源代码到直接被计算机（或虚拟机）执行的目标代码的翻译过程，编译器的功能就是把源代码翻译为二进制代码，让计算机识别并运行 虽然源码包免费开源，但用户不会编程怎么办？一大堆源代码程序不会使用怎么办？源码包容易安装吗？等等这些都是使用源码包安装方式无法解答的问题。 另外，由于源码包的安装需要把源代码编译为二进制代码，因此安装时间较长。比如，大家应该都在 Windows下安装过 QQ，QQ 功能较多，程序相对较大（有 70 MB左右），但由于其并非是以源码包的形式发布，而是编译后才发布的，因此只需几分钟（经过简单的配置）即可安装成功。但如果我们以源码包安装的方式在 Linux 中安装一个 MySQL 数据库，即便此软件的压缩包仅有 23 MB左右，也需要 30 分钟左右的时间（根据硬件配置不同，略有差异）。 通过对比你会发现，源码包的编译是很费时间的，况且绝多大数用户并不熟悉程序语言，在安装过程中我们只能祈祷程序不要报错，否则初学者很难解决。 为了解决使用源码包安装方式的这些问题，Linux 软件包的安装出现了使用二进制包的安装方式。 Linux二进制包二进制包，也就是源码包经过成功编译之后产生的包。由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快（同 Windows下安装软件速度相当），且安装过程报错几率大大减小。 二进制包是 Linux 下默认的软件安装包，因此二进制包又被称为默认安装软件包。目前主要有以下 2 大主流的二进制包管理系统： RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等。 DPKG 包管理系统：由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。 RPM 包管理系统和 DPKG 管理系统的原理和形式大同小异，可以触类旁通。由于本教程使用的是 CentOS 6.x 版本，因此本节主要讲解 RPM 二进制包。 源码包 VS RPM二进制包源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理，Linux 中最常用的打包压缩格式为“tar.gz”，因此源码包又被称为 Tarball。 Tarball 是 Linux 系统的一款打包工具，可以对源码包进行打包压缩处理，人们习惯上将最终得到的打包压缩文件称为 Tarball 文件。 源码包需要我们自己去软件官方网站进行下载，包中通常包含以下内容： 源代码文件。 配置和检测程序（如 configure 或 config 等）。 软件安装说明和软件说明（如 INSTALL 或 README）。 总的来说，使用源码包安装软件具有以下几点好处： 开源。如果你有足够的能力，则可以修改源代码。 可以自由选择所需的功能。 因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也更高。 卸载方便。 但同时，使用源码包安装软件也有几点不足： 安装过程步骤较多，尤其是在安装较大的软件集合时（如 LAMP 环境搭建），容易出现拼写错误。 编译时间较长，所以安装时间比二进制安装要长。 因为软件是编译安装的，所以在安装过程中一旦报错，新手很难解决。 相比源码包，二进制包是在软件发布时已经进行过编译的软件包，所以安装速度比源码包快得多（和 Windows 下软件安装速度相当）。也正是因为已经进行通译，大家无法看到软件的源代码。 使用 RMP 包安装软件具有以下 2 点好处： 包管理系统简单，只通过几个命令就可以实现包的安装、升级、査询和卸载。 安装速度比源码包安装快得多。 与此同时，使用 RMP 包安装软件有如下不足： 经过编译，不能在看到源代码。 功能选择不如源码包灵活。 依赖性。有时我们会发现，在安装软件包 a 时需要先安装 b 和 c，而在安装 b 时需要先安装 d 和 e。这就需要先安装 d 和 e，再安装 b 和 c，最后才能安装 a。比如，我买了一个漂亮的灯具，打算安装在客厅里，可是在安装灯具之前，客厅需要有顶棚，并且顶棚需要刷好油漆。安装软件和装修及其类似，需要有一定的顺序，但是有时依赖性会非常强。 如何选择通过源码包和 RMP 二进制包的对比，在 Linux 进行软件安装时，我们应该使用哪种软件包呢？ 为了更好的区别两种软件包，这里举个例子。假设我们想做一套家具，源码包就像所有的家具完全由自己动手手工打造（手工编译），想要什么样的板材、油漆、颜色和样式都由自己决定（功能自定义，甚至可以修改源代码）。想想就觉得爽，完全不用被黑心的厂商所左右，而且不用担心质量问题（软件更适合自己的系统，效率更高，更加稳定）。但是，所花费的时间大大超过了买一套家具的时间（编译浪费时间），而且自己真的有做木工这个能力吗（需要对源代码非常了解）？就算请别人定制好的家具，再由自己组装，万一哪个部件不匹配（报错很难解决），怎么办？ 那么二进制包呢？也是我们需要一套家具，去商场买了一套（安装简单），家具都是现成的，不会有哪个部件不匹配，除非因为自身问题没有量好尺寸而导致放不下（报错很少）。但是我们完全不知道这套家具用的是什么材料、油漆是否合格，而且家具的样式不能随意选择（软件基本不能自定义功能）。 通过以上对源码包和二进制包的讲解，相信大家对两者的区别和特点有了更清楚的认识。 Linux RPM包统一命名规则RPM 二进制包的命名需遵守统一的命名规则，用户通过名称就可以直接获取这类包的版本、适用平台等信息。 RPM 二进制包命名的一般格式如下： 包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名 例如，RPM 包的名称是httpd-2.2.15-15.el6.centos.1.i686.rpm，其中： httped：软件包名。这里需要注意，httped 是包名，而 httpd-2.2.15-15.el6.centos.1.i686.rpm 通常称为包全名，包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名，一不小心就会弄错。 2.2.15：包的版本号，版本号的格式通常为主版本号.次版本号.修正号。 15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。 el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。 centos：表示此包适用于 CentOS 系统。 i686：表示此包使用的硬件平台，目前的 RPM 包支持的平台如表 1 所示： 平台名称 适用平台信息 i386 386 以上的计算机都可以安装 i586 686 以上的计算机都可以安装 i686 奔腾 II 以上的计算机都可以安装，目前所有的 CPU 是奔腾 II 以上的，所以这个软件版本居多 x86_64 64 位 CPU 可以安装 noarch 没有硬件限制 rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用 rpm 命令直接安装。此外，还有以 src.rpm 作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。 有读者可能会问，Linux 系统不靠扩展名分区文件类型，那为什么包全名中要包含 .rpm 扩展名呢？其实，这里的扩展名是为系统管理员准备的，如果我们不对 RPM 包标注扩展名，管理员很难知道这是一个 RPM 包，当然也就无法正确使用。 Linux RPM包安装、卸载和升级（rpm命令）本节讲解如何使用 rpm 命令对 RPM 二进制包进行安装、卸载和升级操作。 我们以安装 apache 程序为例。因为后续章节还会介绍使用源码包的方式安装 apache 程序，读者可以直观地感受到源码包和 RPM 包的区别。 RPM包默认安装路径通常情况下，RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到表 1 所示的目录中。 安装路径 含 义 &#x2F;etc&#x2F; 配置文件安装目录 &#x2F;usr&#x2F;bin&#x2F; 可执行的命令安装目录 &#x2F;usr&#x2F;lib&#x2F; 程序所使用的函数库保存位置 &#x2F;usr&#x2F;share&#x2F;doc&#x2F; 基本的软件使用手册保存位置 &#x2F;usr&#x2F;share&#x2F;man&#x2F; 帮助文件保存位置 RPM 包的默认安装路径是可以通过命令查询的。 除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别），得不偿失。 与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 &#x2F;usr&#x2F;local&#x2F; 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。 实际情况中，一台服务器几乎不会同时包含两个 apache 程序，管理员不好管理，还会占用过多的服务器磁盘空间。 RPM 包的安装安装 RPM 的命令格式为： 1[root@localhost ~]# rpm -ivh 包全名 注意一定是包全名。涉及到包全名的命令，一定要注意路径，可能软件包在光盘中，因此需提前做好设备的挂载工作。 此命令中各选项参数的含义为： -i：安装（install）; -v：显示更详细的信息（verbose）; -h：打印 #，显示安装进度（hash）; 例如，使用此命令安装 apache 软件包，如下所示： 12345678[root@localhost ~]# rpm -ivh \\/mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpmPreparing...####################[100%]1:httpd####################[100%] 注意，直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作。 此命令还可以一次性安装多个软件包，仅需将包全名用空格分开即可，如下所示： 1[root@localhost ~]# rpm -ivh a.rpm b.rpm c.rpm 如果还有其他安装要求（比如强制安装某软件而不管它是否有依赖性），可以通过以下选项进行调整： -nodeps：不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强制安装，则可以使用这个选项。注意，这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做。 -replacefiles：替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报”某个文件已经存在”的错误，从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。 -replacepkgs：替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。 -force：强制安装。不管是否已经安装，都重新安装。也就是 -replacefiles 和 -replacepkgs 的综合。 -test：测试安装。不会实际安装，只是检测一下依赖性。 -prefix：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。 apache 服务安装完成后，可以尝试启动： 1[root@localhost ~]# service 服务名 start|stop|restart|status 各参数含义： start：启动服务； stop：停止服务； restart：重启服务； status: 查看服务状态； 例如： 1[root@localhost ~]# service httpd start #启动apache服务 服务启动后，可以查看端口号 80 是否出现。命令如下： 12[root@localhost ~]# netstat -tlun | grep 80tcp 0 0 :::80:::* LISTEN 也可以在浏览器中输入 Linux 服务器的 IP 地址，访问这个 apache 服务器。目前在 apache 中没有建立任何网页，所以看到的只是测试页 RPM包的升级使用如下命令即可实现 RPM 包的升级： 1[root@localhost ~]# rpm -Uvh 包全名 -U（大写）选项的含义是：如果该软件没安装过则直接安装；若没安装则升级至最新版本。 1[root@localhost ~]# rpm -Fvh 包全名 -F（大写）选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。 RPM包的卸载RPM 软件包的卸载要考虑包之间的依赖性。例如，我们先安装的 httpd 软件包，后安装 httpd 的功能模块 mod_ssl 包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。 软件包卸载和拆除大楼是一样的，本来先盖的 2 楼，后盖的 3 楼，那么拆楼时一定要先拆除 3 楼。 如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误，例如： 123456789101112[root@localhost ~]# rpm -e httpderror: Failed dependencies:httpd-mmn = 20051115 is needed by (installed) mod_wsgi-3.2-1.el6.i686httpd-mmn = 20051115 is needed by (installed) php-5.3.3-3.el6_2.8.i686httpd-mmn = 20051115 is needed by (installed) mod_ssl-1:2.2.15-15.el6.centos.1.i686httpd-mmn = 20051115 is needed by (installed) mod_perl-2.0.4-10.el6.i686httpd = 2.2.15-15.el6.centos.1 is needed by (installed) httpd-manual-2.2.15-15.el6.centos.1 .noarchhttpd is needed by (installed) webalizer-2.21_02-3.3.el6.i686httpd is needed by (installed) mod_ssl-1:2.2.15-15.el6.centos.1.i686httpd=0:2.2.15-15.el6.centos.1 is needed by(installed)mod_ssl-1:2.2.15-15.el6.centos.1.i686 RPM 软件包的卸载很简单，使用如下命令即可： 1[root@localhost ~]# rpm -e 包名 -e 选项表示卸载，也就是 erase 的首字母。 RPM 软件包的卸载命令支持使用“-nocteps”选项，即可以不检测依赖性直接卸载，但此方式不推荐大家使用，因为此操作很可能导致其他软件也无法征程使用。 Linux rpm命令查询软件包（-q、-qa、-i、-p、-l、-f、-R）rpm 命令还可用来对 RPM 软件包做查询操作，具体包括： 查询软件包是否已安装； 查询系统中所有已安装的软件包； 查看软件包的详细信息； 查询软件包的文件列表； 查询某系统文件具体属于哪个 RPM 包。 使用 rpm 做查询命令的格式如下： 1[root@localhost ~]# rpm 选项 查询对象 下面教大家使用 rpm 命令一一实现以上查询操作。 rpm -q：查询软件包是否安装用 rpm 查询软件包是否安装的命令格式为： 1[root@localhost ~]# rpm -q 包名 -q 表示查询，是 query 的首字母。 例如，查看 Linux 系统中是否安装 apache，rpm 查询命令应写成： 12[root@localhost ~]# rpm -q httpdhttpd-2.2.15-15.el6.centos.1.i686 注意这里使用的是包名，而不是包全名。因为已安装的软件包只需给出包名，系统就可以成功识别（使用包全名反而无法识别）。 rpm -qa：查询系统中所有安装的软件包使用 rpm 查询 Linux 系统中所有已安装软件包的命令为： 123456789[root@localhost ~]# rpm -qalibsamplerate-0.1.7-2.1.el6.i686startup-notification-0.10-2.1.el6.i686gnome-themes-2.28.1-6.el6.noarchfontpackages-filesystem-1.41-1.1.el6.noarchgdm-libs-2.30.4-33.el6_2.i686gstreamer-0.10.29-1.el6.i686redhat-lsb-graphics-4.0-3.el6.centos.i686…省略部分输出… 此外，这里还可以使用管道符查找出需要的内容，比如： 12345[root@localhost ~]# rpm -qa | grep httpdhttpd-devel-2.2.15-15.el6.centos.1.i686httpd-tools-2.2.15-15.el6.centos.1.i686httpd-manual-2.2.15-15.el6.centos.1.noarchhttpd-2.2.15-15.el6.centos.1.i686 相比rpm -q 包名命令，采用这种方式可以找到含有包名的所有软件包。 rpm -qi：查询软件包的详细信息通过 rpm 命令可以查询软件包的详细信息，命令格式如下： 1[root@localhost ~]# rpm -qi 包名 -i 选项表示查询软件信息，是 information 的首字母。 例如，想查看 apache 包的详细信息，可以使用如下命令： 123456789101112131415161718192021222324252627[root@localhost ~]# rpm -qi httpdName : httpd Relocations:(not relocatable)#包名Version : 2.2.15 Vendor:CentOS#版本和厂商Release : 15.el6.centos.1 Build Date: 2012年02月14日星期二 06时27分1秒#发行版本和建立时间Install Date: 2013年01月07日星期一19时22分43秒Build Host:c6b18n2.bsys.dev.centos.org#安装时间Group : System Environment/Daemons Source RPM:httpd-2.2.15-15.el6.centos.1.src.rpm#组和源RPM包文件名Size : 2896132 License: ASL 2.0#软件包大小和许可协议Signature :RSA/SHA1,2012年02月14日星期二 19时11分00秒，Key ID0946fca2c105b9de#数字签名Packager：CentOS BuildSystem &lt;http://bugs.centos.org&gt;URL : http://httpd.apache.org/#厂商网址Summary : Apache HTTP Server#软件包说明Description:The Apache HTTP Server is a powerful, efficient, and extensible web server.#描述 除此之外，还可以查询未安装软件包的详细信息，命令格式为： 1[root@localhost ~]# rpm -qip 包全名 -p 选项表示查询未安装的软件包，是 package 的首字母。 注意，这里用的是包全名，且未安装的软件包需使用“绝对路径+包全名”的方式才能确定包。 rpm -ql：命令查询软件包的文件列表通过前面的学习我们知道，rpm 软件包通常采用默认路径安装，各安装文件会分门别类安放在适当的目录文件下。使用 rpm 命令可以查询到已安装软件包中包含的所有文件及各自安装路径，命令格式为： 1[root@localhost ~]# rpm -ql 包名 -l 选项表示列出软件包所有文件的安装目录。 例如，查看 apache 软件包中所有文件以及各自的安装位置，可使用如下命令： 123456789[root@localhost ~]# rpm -ql httpd/etc/httpd/etc/httpd/conf/etc/httpd/conf.d/etc/httpd/conf.d/README/etc/httpd/conf.d/welcome.conf/etc/httpd/conf/httpd.conf/etc/httpd/conf/magic…省略部分输出… 同时，rpm 命令还可以查询未安装软件包中包含的所有文件以及打算安装的路径，命令格式如下： 1[root@localhost ~]# rpm -qlp 包全名 -p 选项表示查询未安装的软件包信息，是 package 的首字母。 注意，由于软件包还未安装，因此需要使用“绝对路径+包全名”的方式才能确定包。 比如，我们想查看 bing 软件包（未安装，绝对路径为：&#x2F;mnt&#x2F;cdrom&#x2F;Packages&#x2F;bind-9.8.2-0.10.rc1.el6.i686.rpm）中的所有文件及各自打算安装的位置，可以执行如下命令： 12345678[root@localhost ~]# rpm -qlp /mnt/cdrom/Packages/bind-9.8.2-0.10.rc1.el6.i686.rpm/etc/NetworkManager/dispatcher.d/13-named/etc/logrotate.d/named/etc/named/etc/named.conf/etc/named.iscdlv.key/etc/named.rfc1912.zones…省略部分输出… rpm -qf：命令查询系统文件属于哪个RPM包rpm -ql 命令是通过软件包查询所含文件的安装路径，rpm 还支持反向查询，即查询某系统文件所属哪个 RPM 软件包。其命令格式如下： 1[root@localhost ~]# rpm -qf 系统文件名 -f 选项的含义是查询系统文件所属哪个软件包，是 file 的首字母。 注意，只有使用 RPM 包安装的文件才能使用该命令，手动方式建立的文件无法使用此命令。 例如，查询 ls 命令所属的软件包，可以执行如下命令： 12[root@localhost ~]# rpm -qf /bin/lscoreutils-8.4-19.el6.i686 rpm -qR：查询软件包的依赖关系使用 rpm 命令安装 RPM 包，需考虑与其他 RPM 包的依赖关系。rpm -qR 命令就用来查询某已安装软件包依赖的其他包，该命令的格式为： [root@localhost ~]# rpm -qR 包名 -R（大写）选项的含义是查询软件包的依赖性，是 requires 的首字母。 例如，查询 apache 软件包的依赖性，可执行以下命令： 1234567891011[root@localhost ~]# rpm -qR httpd/bin/bash/bin/sh/etc/mime.types/usr/sbin/useraddapr-util-ldapchkconfigconfig(httpd) = 2.2.15-15.el6.centos.1httpd-tods = 2.2.15-15.el6.centos.1initscripts &gt;= 8.36…省略部分输出… 同样，在此命令的基础上增加 -p 选项，即可实现查找未安装软件包的依赖性。 例如，bind 软件包尚未安装（绝对路径为： &#x2F;mnt&#x2F;cdrom&#x2F;Packages&#x2F;bind-9.8.2-0.10.rc1.el6.i686.rpm），查看此软件包的依赖性可执行如下命令： 12345678910111213[root@localhost ~]# rpm -qRp /mnt/cdrom/Packages/bind-9.8.2-0.10.rc1.el6.i686.rpm/bin/bash/bin/shbind-libs = 32:9.8.2-0.10.rc1.el6chkconfigchkconfigconfig(bind) = 32:9.8.2-0.10.rc1.el6greplibbind9.so.80libc.so.6libc.so.6(GLIBC_2.0)libc.so.6(GLIBC_2.1)…省略部分输出… 注意，这里使用的也是“绝对路径+包全名”的方式。 Linux RPM包验证和数字证书（数字签名）执行 rpm -qa 命令可以看到，Linux 系统中装有大量的 RPM 包，且每个包都含有大量的安装文件。因此，为了能够及时发现文件误删、误修改文件数据、恶意篡改文件内容等问题，Linux 提供了以下两种监控（检测）方式： RPM 包校验：其实就是将已安装文件和 &#x2F;var&#x2F;lib&#x2F;rpm&#x2F; 目录下的数据库内容进行比较，确定文件内容是否被修改。 RPM 包数字证书校验：用来校验 RPM 包本身是否被修改。 Linux RPM 包校验RPM 包校验可用来判断已安装的软件包（或文件）是否被修改，此方式可使用的命令格式分为以下 3 种。 1[root@localhost ~]# rpm -Va -Va 选项表示校验系统中已安装的所有软件包。 1[root@localhost ~]# rpm -V 已安装的包名 -V 选项表示校验指定 RPM 包中的文件，是 verity 的首字母。 1[root@localhost ~]# rpm -Vf 系统文件名 -Vf 选项表示校验某个系统文件是否被修改。 例如我们校验 apache 软件包中所有的安装文件是否被修改，可执行如下命令： 1[root@localhost -]# rpm -V httpd 可以看到，执行后无任何提示信息，表明所有用 apache 软件包安装的文件均未改动过，还和从原软件包安装的文件一样。 接下来尝试对 apache 的配置文件 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 做适当修改，修改格式如下： 123456[root@localhost ~]#vim /etc/httpd/conf/httpd.conf...省略部分内容...Directorylndex index.html index.html.var index.php#这句话是定义apache可以识别的默认网页文件名。在后面加入了index.php#这句话大概有400行左右…省略部分内容... 由于我们还未学习如何配置 apache，为防止其崩溃，这里仅尝试修改 apache 的默认网页文件。按照以上格式对文件进行修改后保存退出，再次使用 rpm -V 命令对 apache 软件包进行验证： 12[root@localhost ~]# rpm -V httpdS.5....T. c /etc/httpd/conf/httpd.conf 可以看到，结果显示了文件被修改的信息。该信息可分为以下 3 部分： 最前面的 8 个字符（S.5….T）都属于验证信息，各字符的具体含义如下： S：文件大小是否改变。 M：文件的类型或文件的权限（rwx）是否改变。 5：文件MD5校验和是否改变（可以看成文件内容是否改变）。 D：设备的主从代码是否改变。 L：文件路径是否改变。 U：文件的属主（所有者）是否改变。 G：文件的属组是否改变。 T：文件的修改时间是否改变。 .：若相关项没发生改变，用 . 表示。 被修改文件类型，大致可分为以下几类： c：配置文件（configuration file）。 d：普通文档（documentation）。 g：”鬼”文件（ghost file），很少见，就是该文件不应该被这个 RPM 包包含。 l：授权文件（license file）。 r：描述文件（read me）。 被修改文件所在绝对路径（包含文件名）。 由此，S.5….T. c S.5….T. c &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 表达的完整含义是：配置文件 httpd.conf 的大小、内容、修改时间被人为修改过。 注意，并非所有对文件做修改的行为都是恶意的。通常情况下，对配置文件做修改是正常的，比如说配置 apache 就要修改其配置文件，而如果验证信息提示对二进制文件做了修改，这就需要小心，除非是自己故意修改的。 Linux RPM数字证书验证RPM 包校验方法只能用来校验已安装的 RPM 包及其安装文件，如果 RPM 包本身就被动过手脚，此方法将无法解决问题，需要使用 RPM 数字证书验证方法。 简单的理解，RPM 包校验其实就是将现有安装文件与最初使用 RPM 包安装时的初始文件进行对比，如果有改动则提示给用户，因此这种方式无法验证 RPM 包本身被修改的情况。 数字证书，又称数字签名，由软件开发商直接发布。Linux 系统安装数字证书后，若 RPM 包做了修改，此包携带的数字证书也会改变，将无法与系统成功匹配，软件无法安装。 可以将数字证书想象成自己的签名，是不能被模仿的（厂商的数字证书是唯一的），只有我认可的文件才会签名（只要是厂商发布的软件，都符合数字证书验证）；如果我的文件被人修改了，那么我的签名就会变得不同（如果软件改变，数字证书就会改变，从而通不过验证。当然，现实中人的手工签名不会直接改变，所以数字证书比手工签名还要可靠）。 使用数字证书验证 RPM 包的方法具有如下 2 个特点： 必须找到原厂的公钥文件，然后才能进行安装。 安装 RPM 包会提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。 数字证书默认会放到系统中/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6位置处，通过以下命令也可验证： #系统中的数字证书位置 12[root@localhost ~]# ll /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6-rw-r--r--.1 root root 1706 6 月 26 17:29 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 安装数字证书的命令如下： 12[root@localhost ~]# rpm --import /efc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6--import表示导入数字证书 数字证书安装完成后，可使用如下命令进行验证： 12[root@localhost ~]# rpm -qa|grep gpg-pubkeygpg-pubkey-c105b9de-4e0fd3a3 可以看到，数字证书已成功安装。在装有数字证书的系统上安装 RPM 包时，系统会自动验证包的数字证书，验证通过则可以安装，反之将无法安装（系统会报错）。 数字证书本身也是一个 RPM 包，因此可以用 rpm 命令查询数字证书的详细信息，也可以将其卸载。查询数字证书详细信息的命令如下： 12345678910111213[root@localhost ~]# rpm -qi gpg-pubkey-c105b9de-4e0fd3a3#查询数字证书包的详细信息Name : gpg-pubkeyRelocations: (not relocatable)Version : c105b9de Vendor: (none)Release : 4e0fd3a3 Build Date: 2012年11月12日 星期一 23时05分20秒Install Date: 2012年11月12日星期一23时05分20秒 Build Host: local hostGroup : Public KeysSource RPM: (none)Size : 0License: pubkey…省略部分输出…-----END PGP PUBLIC KEY BLOCK---- 卸载数字证书可以使用 -e 选项，命令如下： 1[root@localhost ~]# rpm -e gpg-pubkey-c105b9de-4ead3a3 虽然数字证书可以手动卸载，但不推荐大家将其卸载。 Linux提取RPM包文件(cpio命令)在讲解如何从 RPM 包中提取文件之前，先来系统学习一下 cpio 命令。 cpio 命令用于从归档包中存入和读取文件，换句话说，cpio 命令可以从归档包中提取文件（或目录），也可以将文件（或目录）复制到归档包中。 归档包，也可称为文件库，其实就是 cpio 或 tar 格式的文件，该文件中包含其他文件以及一些相关信息（文件名、访问权限等）。归档包既可以是磁盘中的文件，也可以是磁带或管道。 cpio 命令可以看做是备份或还原命令，因为它可以将数据（文件）备份到 cpio 归档库，也可以利用 cpio 文档库对数据进行恢复。 使用 cpio 命令备份或恢复数据，需注意以下几点： 使用 cpio 备份数据时如果使用的是绝对路径，那么还原数据时会自动恢复到绝对路径下；同理，如果备份数据使用的是相对路径，那么数据会还原到相对路径下。 cpio 命令无法自行指定备份（或还原）的文件，需要目标文件（或目录）的完整路径才能成功读取，因此此命令常与 find 命令配合使用。 cpio 命令恢复数据时不会自动覆盖同名文件，也不会创建目录（直接解压到当前文件夹）。 cpio 命令主要有以下 3 种基本模式： “-o” 模式：指的是 copy-out 模式，就是把数据备份到文件库中，命令格式如下： [root@localhost ~]# cpio -o[vcB] &gt; [文件丨设备] 各选项含义如下： -o：copy-out模式，备份； -v：显示备份过程； -c：使用较新的portable format存储方式； -B：设定输入&#x2F;输出块为 5120Bytes，而不是模式的 512Bytes； 比如，使用 cpio 备份数据的命令如下： 12345[root@localhost ~]#find /etc -print | cpio -ocvB &gt; /root/etc.cpio#利用find命令指定要备份/etc/目录，使用&gt;导出到etc.cpio文件[root@localhost ~]# II -h etc.cpio-rw--r--r--.1 root root 21M 6月5 12:29 etc.cpio#etc.cpio文件生成 “-i” 模式：指的是 copy-in 模式，就是把数据从文件库中恢复，命令格式如下： [root@localhost ~]# cpio -i[vcdu] &lt; [文件|设备] 各选项的含义为： -i：copy-in 模式，还原； -v：显示还原过程； -c：较新的 portable format 存储方式； -d：还原时自动新建目录； -u：自动使用较新的文件覆盖较旧的文件； 比如，使用 cpio 恢复之前备份的数据，命令如下： 123[root@localhost ~]# cpio -idvcu &lt; /root/etc.cpio#还原etc的备份#如果大家査看一下当前目录/root/，就会发现没有生成/etc/目录。这是因为备份时/etc/目录使用的是绝对路径，所以数据直接恢复到/etc/系统目录中，而没有生成在/root/etc/目录中 “-p” 模式：指的是复制模式，使用 -p 模式可以从某个目录读取所有文件，但并不将其备份到 cpio 库中，而是直接复制为其他文件。 例如，使用 -p 将 &#x2F;boot&#x2F; 复制到 &#x2F;test&#x2F;boot 目录中可以执行如下命令： 12345678910[root@localhost ~]# cd /tmp/#进入/tmp/目录[root@localhost tmp]#rm -rf*#删除/tmp/目录中的所有数据[root@localhost tmp]# mkdir test#建立备份目录[root@localhost tmp]# find /boot/ -print | cpio -p /tmp/test#备份/boot/目录到/tmp/test/目录中[root@localhost tmp]# ls test/boot#在/tmp/test/目录中备份出了/boot/目录 使用 cpio 命令提取 RPM 包中指定文件在服务器使用过程，如果系统文件被误修改或误删除，可以考虑使用 cpio 命令提取出原 RPM 包中所需的系统文件，从而修复被误操作的源文件。 RPM 包允许逐个提取包中文件，使用的命令格式如下： [root@localhost ~]# rpm2cpio 包全名|cpio -idv .文件绝对路径 该命令中，rpm2cpio 就是将 RPM 包转换为 cpio 格式的命令，通过 cpio 命令即可从 cpio 文件库中提取出指定文件。 举个例子，假设我们不小心把 &#x2F;bin&#x2F;ls 命令删除了，通常有以下 2 种方式修复： 将 coreutils-8.4-19.el6.i686 包（包含 ls 命令的 RPM 包）通过 -force 选项再安装一遍； 使用 cpio 命令从 coreutils-8.4-19.el6.i686 包中提取出 &#x2F;bin&#x2F;ls 文件，然后将其复制到相应位置； 这里我们选择第 2 种方式。有读者可能会问，如何知道 ls 命令隶属于那个 RPM 包呢？很简单，使用 rpm -qf 命令即可，如下所示： 123[root@localhost ~]# rpm -qf /bin/lscoreutils-8.4-19.el6.i686#查看ls文件属于哪个软件包 在此基础上，我们只需从此 RPM 包使用 cpio 命令提取出 ls 命令文件，然后将其复制到对应位置即可，实现命令如下： 12345678910111213[root@localhost ~]# mv /bin/ls /root/#把/bin/ls命令移动到/root/目录下，造成误删除的假象[root@localhost ~]# ls-bash: ls: command not found#这时执行ls命令，系统会报&quot;命令没有找到&quot;错误[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm|cpio -idv ./bin/ls#提取ls命令文件到当前目录下[root@localhost ~]# cp /root/bin/ls /bin/#把提取出来的ls命令文件复制到/bin/目录下[root@localhost ~]#lsanaconda-ks.cfg bin inittab install.log install.log.syslog ls#可以看到，ls命令又可以正常使用了 Linux SRPM源码包安装前面章节我们介绍了如何使用 RPM 包安装软件，本节学习使用另一种 RPM 包，即 SRPM 源码包安装软件。 SRPM 包，比 RPM 包多了一个“S”，是“Source”的首字母，所以 SRPM 可直译为“源代码形式的 RPM 包”。也就是说，SRPM 包中不再是经过编译的二进制文件，都是源代码文件。可以这样理解，SRPM 包是软件以源码形式发布后直接封装成 RPM 包的产物。 表 1 列出了 RPM 包与 SRPM 包的几点不同。 文件格式 文件名格式 直接安装与否 内含程序类型 可否修改参数并编译 RPM xxx.rpm 可 已编译 不可 SRPM xxx.src.rpm 不可 未编译的源代码 可 从表中可以看到，SRPM 包的命名与 RPM 包基本类似，唯一区别在于 SRPM 包多了“src”标志，即 SRPM 包采用“包名-版本号-发布次数-发行商-src.rpm”的方式进行命名，比如“MySQL-5.5.29-2.el6.src.rpm”。 此外，SRPM 包是未经编译的源码包，无法直接用来安装软件，需要经过以下 2 步： 将 SRPM 包编译成二进制的 RPM 包； 使用编译完成的 RPM 包安装软件； 前面章节已经介绍了如何使用 RPM 包安装软件，因此使用 SRPM 包安装软件的关键在于第一步，也就是如何将 SRPM 包编译为 RPM 包。 本节依然以安装 apache 为例，使用 SRPM 包安装软件（编译 SRPM 包）的方式有以下 2 种： 利用 rpmbuild 命令可以直接使用 SRPM 包安装软件，也可以先将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件； 利用 *.spec 文件可实现将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件； rpmbuild 命令的安装rpmbuild 命令也是一个程序，但是这个程序不会默认安装，所以要想使用 rpmbuild 命令就必须提前安装。这里我们使用 rpm 命令来安装 rpmbuild 命令，如下所示： 123456789[root@localhost~]#rpm -ivh /mnt/cdroin/Packages/rpm-build-4.8.0-27.el6.i686.rpmPreparing...###################[100%]1:rpm-build###################[100%]出现两个 100% 才证明 rpmbuild 安装成功。 rpmbuild命令安装SRPM包如果我们只想安装 SRPM 包，而不用修改源代码，那么直接使用 rpmbuild 命令即可。使用 rpmbuild 安装 SRPM 包的命令格式如下： 1[root@localhost ~]# rpmbuild [选项] 包全名 可使用如下 2 个选项： -rebuild：编译 SRPM 包生成 RPM 二进制包； -recompile：编译 SRPM 包，同时安装。 需要注意的是，SRPM 本质上仍属于 RPM 包，所以安装时仍需考虑包之间的依赖性，要先安装它的依赖包，才能正确安装。 这里我们选择使用 -rebuild 选项先将 SRPM 包编译成 RPM 二进制包，命令如下所示： 123456789101112131415161718192021222324[root@localhost ~]# rpmbuild -rebuild httpd-2.2.15-5.el6.src.rpmwarning: InstallSourcePackage at: psm.c:244: Header V3 RSA/SHA256 Signature, keyID fd431d51: NOKEYwarning: user mockbuild does not exist - using rootwarning: group mockbuild does not exist - using root#警告为mockbuild用户不存在，使用root代替。这里不是报错，不用紧张…省略部分输出…Wrote: /root/rpmbuild/RPMS/i386/ httpd-2.2.15-5.el6.i386.rpmWrote: /root/rpmbuild/RPMS/i386/httpd-devel-2.2.15-5.el6.i386.rpmWrote: /root/rpmbuild/RPMS/noarch/httpd-manual-2.2.15-5.el6.noarch.rpmWrote: /root/rpmbuild/RPMS/i386/httpd-tools-2.2.15-5.el6.i386.rpmWrote: /root/rpmbuild/RPMS/i386/ mod_ssl-2.2.15-5.el6.i386.rpm#写入RPM包的位置，只要看到，就说明编译成功Executing(%clean): /bin/sh -e/var/tmp/rpm-tmp.Wb8TKa+ umask 022+ cd/root/rpmbuild/BUILD+ cd httpd-2.2.15+ rm -rf /root/rpmbuild/BUILDROOT/httpd-2.2.15-5.el6.i386+ exit 0Executing(-clean): /bin/sh -e/var/tmp/rpm-tmp.3UBWql+ umask 022+ cd/root/rpmbuild/BUILD+ rm-rf httpd-2.2.15+ exit 0 exit 0 是编译成功的标志，此编译过程产生的临时文件会自动删除。SRPM 包编译完成后，会在当前目录生成 rpmbuild 目录，整个编译过程生成的文件（软件包）都存在这里。 12[root@localhost ~]# ls /root/rpmbuild/BUILD RPMS SOURCES SPECS SRPMS 通过 ls 命令可以看到，rpmbuild 目录下有几个子目录，其各自保存的文件类别如表 2 所示。 文件名 文件内容 BUILD 编译过程中产生的数据保存位置 RPMS 编译成功后，生成的 RPM 包保存位置 SOURCES 从 SRPM 包中解压出来的源码包（*.tar.gz）保存位置 SPECS 生成的设置文件的安装位置。第二种安装方法就是利用这个文件进行安装的 SRPMS 放置 SRPM 包的位置 可以看到，编译好的 RPM 包保存在 &#x2F;root&#x2F;rpmbuild&#x2F;RPMS&#x2F; 目录下，可以使用如下命令进行验证： 12345[root@localhost ~]#ll /root/rpmbuild/RPMS/i386/-rw--r--r-- 1 root root 3039035 11月19 06:30 httpd-2.2.15-5.el6.i386.rpm-rw--r--r-- 1 root root 154371 11月19 06:30 httpd-devel-2.2.15-5.el6.i386.rpm-rw--r--r-- 1 root root 124403 11月19 06:30 httpd-tools-2.2.15-5.el6.i386.rpm-rw--r--r-- 1 root root 383539 11月19 06:30 mod_ssl-2.2.15-5.el6.i386.rpm 如此，我们就得到可直接安装软件的 RPM 包。实际上，使用 rpmbuild命令编译 SRPM 包经历了以下 3 个过程： 先把 SRPM 包解开，得到源码包； 对源码包进行编译，生成二进制文件； 把二进制文件重新打包生成 RPM 包。 利用 *.spec 文件安装想利用 .spec 文件安装软件，需先将 SRPM 包解开。当然，我们可以使用 rpmbuild 命令解开 SRPM 包，但这里选择另一种方式，即使用 rpm -i 命令，如下所示： 1[root@localhost ~]# rpm -i httpd-2.2.15-5.el6.src.rpm -i 选项用于安装 rpm 包时表示安装，但对于 SRPM 包的安装来说，这里只会将 .src.rpm 包解开后将个文件放置在当前目录下的 rpmbuild 目录中，并不涉及安装操作。 通过此命令，也可以在当前目录下生成 rpmbuild 目录，但与表 2 不同，此 rpmbuild 目录中仅有 SOURCES 和 SPECS 两个子目录。其中，SOURCES 目录中放置的是源码，SPECS 目录中放置的是设置文件。 接下来使用 SPECS 目录中的设置文件生成 RPM 包，命令如下： 1[root@localhost ~]# rpmbuild -ba /root/rpmbuild/SPECS/httpd.spec 其中，-ba 选项的含义是编译，会同时生成 RPM 二进制包和 SRPM 源码包。这里还可以使用 -bb 选项用来仅生成 RPM 二进制包。 命令执行完成，会在 &#x2F;root&#x2F;rpmbuild&#x2F; 目录下生成 BUILD、RPMS、SOURCES、SPECS 和 SRPMS 目录，RPM 包放在 RPMS 目录中，SRPM 包生成在 SRPMS 目录中。 以上两种方式都可实现将 SRPM 包编译为 RPM 二进制包，剩下的工作就是使用 RPM 包安装软件，这部分内容已在前面章节中讲过，因此不再赘述。 Linux RPM包依赖性（含解决方案）RPM 软件包（包含 SRPM 包）的依赖性主要体现在 RPM 包安装与卸载的过程中。 例如，如果采用最基础的方式（基础服务器方式）安装 Linux 系统，则 gcc 这个软件是没有安装的，需要自己手工安装。当你使用 rpm 命令安装 gcc 软件的 RPM 包，就会发生依赖性错误，错误提示信息如下所示： 12345[root@localhost ~]# rpm -ivh /mnt/cdrom/Packages/ gcc-4.4.6-4.el6.i686.rpmerror: Failed dependencies: &lt;―依赖性错误cloog-ppi &gt;= 0.15 is needed by gcc-4.4.6-4.el6.i686cpp = 4.4.6-4.el6 is needed by gcc-4.4.6-4.el6.i686glibc-devel &gt;= 2.2.90-12 is needed by gcc-4.4.6-4.el6.i686 报错信息提示我们，如果要安装 gcc，需要先安装 cloog-ppl、cpp 和 glibc-devel 三个软件，这体现的就是 RPM 包的依赖性。 除此之外，报错信息中还会明确给出各个依赖软件的版本要求： “&gt;&#x3D;”：表示版本要大于或等于所显示版本； “&lt;&#x3D;”：表示版本要小于或等于所显示版本； “&#x3D;”：表示版本要等于所显示版本； Linux 系统中，RPM 包之间的依赖关系大致可分为以下 3 种： 树形依赖（A-B-C-D）：要想安装软件 A，必须先安装 B，而安装 B 需要先安装 C…….解决此类型依赖的方法是从后往前安装，即先安装 D，再安装 C，然后安装 B，最后安装软件 A。 环形依赖（A-B-C-D-A）：各个软件安装的依赖关系构成“环状”。解决此类型依赖的方法是用一条命令同时安装所有软件包，即使用 rpm -ivh 软件包A 软件包B ...。 模型依赖：软件包的安装需要借助其他软件包的某些文件（比如库文件），解决模块依赖最直接的方式是通过 http://www.rpmfind.net 网站找到包含此文件的软件包，安装即可。 以上 3 种 RPM 包的依赖关系，给出的解决方案都是手动安装，比较麻烦。在后续的章节中，我们将系统学习使用 yum 命令查询、安装、升级和卸载软件包的方法。 yum，全称”Yellow dog Updater,Modified”，CentOS 系统上的软件包管理器，它能够自动下载 RPM 包并安装，更重要的是，它可以自动处理软件包之间的依赖性关系，一次性安装所有依赖的软件包，无需一个个安装。 Linux yum是什么，yum源配置前面分别介绍了使用 SRPM 源码包和 RPM 二进制包安装软件，这两种方法都比较繁琐，需要手动解决包之间具有依赖性的问题，尤其是库文件依赖，需要自行去 http://www.rpmfind.net 网站上查找相关的 RPM 包。本节介绍一种可自动安装软件包（自动解决包之间依赖关系）的安装方式。 yum，全称“Yellow dog Updater, Modified”，是一个专门为了解决包的依赖关系而存在的软件包管理器。就好像 Windows 系统上可以通过 360 软件管家实现软件的一键安装、升级和卸载，Linux 系统也提供有这样的工具，就是 yum。 可以这么说，yum 是改进型的 RPM 软件管理器，它很好的解决了 RPM 所面临的软件包依赖问题。yum 在服务器端存有所有的 RPM 包，并将各个包之间的依赖关系记录在文件中，当管理员使用 yum 安装 RPM 包时，yum 会先从服务器端下载包的依赖性文件，通过分析此文件从服务器端一次性下载所有相关的 RPM 包并进行安装。 yum 软件可以用 rpm 命令安装，安装之前可以通过如下命令查看 yum 是否已安装： 123456[root@localhost ~]# rpm -qa | grep yumyum-metadata-parser-1.1.2-16.el6.i686yum-3.2.29-30.el6.centos.noarchyum-utils-1.1.30-14.el6.noarchyum-plugin-fastestmirror-1.1.30-14.el6.noarchyum-plugin-security-1.1.30-14.el6.noarch 可以看到，系统上已经安装了 yum。 使用 rpm 命令安装 yum 的具体方式可查看《Linux怎么安装yum》一节。 使用 yum 安装软件包之前，需指定好 yum 下载 RPM 包的位置，此位置称为 yum 源。换句话说，yum 源指的就是软件安装包的来源。 使用 yum 安装软件时至少需要一个 yum 源。yum 源既可以使用网络 yum 源，也可以将本地光盘作为 yum 源。接下来就给大家介绍这两种 yum 源的搭建方式。 网络 yum 源搭建一般情况下，只要你的主机网络正常，可以直接使用网络 yum 源，不需要对配置文件做任何修改，这里对 yum 源配置文件做一下简单介绍。 网络 yum 源配置文件位于 &#x2F;etc&#x2F;yum.repos.d&#x2F; 目录下，文件扩展名为”.repo”（只要扩展名为 “.repo” 的文件都是 yum 源的配置文件）。 12345[root@localhost ~]# ls /etc/yum.repos.d/CentOS-Base.repoCentOS-Media.repoCentOS-Debuginfo.repo.bakCentOS-Vault.repo 可以看到，该目录下有 4 个 yum 配置文件，通常情况下 CentOS-Base.repo 文件生效。我们可以尝试打开此文件，命令如下： 12345678[root@localhost yum.repos.d]# vim /etc/yum.repos.d/ CentOS-Base.repo[base]name=CentOS-$releasever - Basemirrorlist=http://mirrorlist.centos.org/? release= $releasever&amp;arch=$basearch&amp;repo=osbaseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6…省略部分输出… 此文件中含有 5 个 yum 源容器，这里只列出了 base 容器，其他容器和 base 容器类似。base 容器中各参数的含义分别为： [base]：容器名称，一定要放在[]中。 name：容器说明，可以自己随便写。 mirrorlist：镜像站点，这个可以注释掉。 baseurl：我们的 yum 源服务器的地址。默认是 CentOS 官方的 yum 源服务器，是可以使用的。如果你觉得慢，则可以改成你喜欢的 yum 源地址。 enabled：此容器是否生效，如果不写或写成 enabled 则表示此容器生效，写成 enable&#x3D;0 则表示此容器不生效。 gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。 gpgkey：数字证书的公钥文件保存位置。不用修改。 本地 yum 源在无法联网的情况下，yum 可以考虑用本地光盘（或安装映像文件）作为 yum 源。 Linux 系统安装映像文件中就含有常用的 RPM 包，我们可以使用压缩文件打开映像文件（iso文件），进入其 Packages 子目录，如图 1 所示： 图片安装映像文件的 Packages 子目录](assets&#x2F;Linux&#x2F;2-1Z32P9423J01.gif)图 1 安装映像文件的 Packages 子目录 可以看到，该子目录下含有几乎所有常用的 RPM 包，因此使用系统安装映像作为本地 yum 源没有任何问题。 在 &#x2F;etc&#x2F;yum.repos.d&#x2F; 目录下有一个 CentOS-Media.repo 文件，此文件就是以本地光盘作为 yum 源的模板文件，只需进行简单的修改即可，步骤如下： 放入 CentOS 安装光盘，并挂载光盘到指定位置。命令如下： 12345[root@localhost ~]# mkdir /mnt/cdrom#创建cdrom目录，作为光盘的挂载点[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/mount: block device/dev/srO is write-protected, mounting read-only#挂载光盘到/mnt/cdrom目录下 修改其他几个 yum 源配置文件的扩展名，让它们失效，因为只有扩展名是”*.repo”的文件才能作为 yum 源配置文件。当也可以删除其他几个 yum 源配置文件，但是如果删除了，当又想用网络作为 yum 源时，就没有了参考文件，所以最好还是修改扩展名。 命令如下： 1234[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# mv CentOS-Base, repo CentOS-Base.repo.bak[root@localhost yum.repos.d]#mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak[root@localhost yum.repos.d]# mv CentOS-Vault.repo CentOS-Vault.repo.bak 修改光盘 yum 源配置文件 CentOS-Media.repo，参照以下方修改： 123456789101112[root@localhost yum.repos.d]# vim CentOS-Media.repo[c6-media]name=CentOS-$releasever - Mediabaseurl=file:///mnt/cdrom#地址为你自己的光盘挂载地址#file:///media/cdrom/#file:///media/cdrecorder/#注释这两个的不存在地址gpgcheck=1enabled=1#把enabled=0改为enabled=1, 让这个yum源配置文件生效gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 如此，本地 yum 源就配置完成了。 Linux yum命令详解（查询、安装、升级和卸载软件包）yum查询命令使用 yum 对软件包执行查询操作，常用命令可分为以下几种： yum list：查询所有已安装和可安装的软件包。例如： 1234567891011121314[root@localhost yum.repos.d]# yum list#查询所有可用软件包列表Installed Packages#已经安装的软件包ConsdeKit.i686 0.4.1-3.el6@anaconda-CentOS-201207051201 J386/6.3ConsdeKit-libs.i686 0.4.1-3.el6 @anaconda-CentOS-201207051201 J386/6.3…省略部分输出…Available Packages#还可以安装的软件包389-ds-base.i686 1.2.10.2-15.el6 c6-media389-ds-base-devel.i686 1.2.10.2-15.el6 c6-media#软件名 版本 所在位置（光盘）…省略部分输出… yum list 包名：查询执行软件包的安装情况。例如： 123[root@localhost yum.repos.d]# yum list sambaAvailable Packages samba.i686 3.5.10-125.el6 c6-media#查询 samba 软件包的安装情况 yum search 关键字：从 yum 源服务器上查找与关键字相关的所有软件包。例如： 123456789[root@localhost yum.repos.d]# yum search samba#搜索服务器上所有和samba相关的软件包========================N/S Matched:samba =============================samba-client.i686：Samba client programssamba-common.i686：Files used by both Samba servers and clientssamba-doc.i686: Documentation for the Samba suite…省略部分输出…Name and summary matches only, use&quot;search all&quot; for everything. yum info 包名：查询执行软件包的详细信息。例如： 12345678910[root@localhost yum.repos.d]# yum info samba#查询samba软件包的信息Available Packages &lt;-没有安装Name : samba &lt;-包名Arch : i686 &lt;-适合的硬件平台Version : 3.5.10 &lt;―版本Release : 125.el6 &lt;—发布版本Size : 4.9M &lt;—大小Repo : c6-media &lt;-在光盘上…省略部分输出… yum安装命令yum 安装软件包的命令基本格式为： 1[root@localhost yum.repos.d]# yum -y install 包名 其中： install：表示安装软件包。 -y：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 yes； 例如使用此 yum 命令安装 gcc： 12[root@localhost yum jepos.d]#yum -y install gcc#使用yum自动安装gcc gcc 是 C 语言的编译器，鉴于该软件包涉及到的依赖包较多，建议使用 yum 命令安装。 yum 升级命令使用 yum 升级软件包，需确保 yum 源服务器中软件包的版本比本机安装的软件包版本高。 yum 升级软件包常用命令如下： yum -y update：升级所有软件包。不过考虑到服务器强调稳定性，因此该命令并不常用。 yum -y update 包名：升级特定的软件包。 yum 卸载命令使用 yum 卸载软件包时，会同时卸载所有与该包有依赖关系的其他软件包，即便有依赖包属于系统运行必备文件，也会被 yum 无情卸载，带来的直接后果就是使系统崩溃。 除非你能确定卸载此包以及它的所有依赖包不会对系统产生影响，否则不要使用 yum 卸载软件包。 yum 卸载命令的基本格式如下： 12[root@localhost yum.repos.d]# yum remove 包名#卸载指定的软件包 例如，使用 yum 卸载 samba 软件包的命令如下： 12[root@localhost yum.repos.d]# yum remove samba#卸载samba软件包 Linux yum管理软件组方法在安装 Linux 系统时，我们可以根据需要自定义安装软件包 选择“Customize now” Linux 列出的许多软件包组，例如编辑器、系统工具、开发工具等。 yum 命令除了可以对软件包进行查询、安装、升级和卸载外，还可完成对软件包组的查询、安装和卸载操作。 yum查询软件组包含的软件既然是软件包组，说明包含不只一个软件包，通过 yum 命令可以查询某软件包组中具体包含的软件包，命令格式如下： 12[root@localhost ~]#yum groupinfo 软件组名#查询软件组中包含的软件 例如，查询 Web Server 软件包组中包含的软件包，可使用如下命令： 12[root@localhost ~]#yum groupinfo &quot;Web Server&quot;#查询软件组&quot;Webserver&quot;中包含的软件 yum安装软件组使用 yum 安装软件包组的命令格式如下： 12[root@localhost ~]#yum groupinstall 软件组名#安装指定软件组，组名可以由grouplist查询出来 例如，安装 Web Server 软件包组可使用如下命令： 12[root@localhost ~]#yum groupinstall &quot;Web Server&quot;#安装网页服务软件组 yum命令卸载软件组yum 卸载软件包组的命令格式如下： 12[root@localhost ~]# yum groupremove 软件组名#卸载指定软件组 yum 软件包组管理命令更适合安装功能相对集中的软件包集合。例如，在初始安装 Linux 时没有安装图形界面，但后来发现需要图形界面的支持，这时可以手工安装图形界面软件组（X Window System 和 Desktop），就可以使用图形界面了。 Linux源码包安装和卸载教程（以apache为例）由于 Linux 操作系统开放源代码，因此在其上安装的软件大部分也都是开源软件，例如 Apache、Tomcat 和 PHP 等。开源软件基本都提供源码下载，可采用源码安装的方式安装软件。 注意，本节使用的源码包，指的是软件所有源代码的压缩包，其后缀名为 “.tar.gz” 或 “.tar.bz2”；而 SRPM 源码包本质上属于 RPM 包，也就是源码的RPM包，其文件后缀为 “.src.rpm”。虽然都叫源码包，但不是一码事。 软件的源代码，也就是软件的原始数据，任何人都可以通过源代码查看该软件的设计架构和实现方法，但软件源代码无法再计算机中直接运行安装，需要将源代码通过编译转换为计算机可以识别的机器语言，然后才可以安装。 Linux 系统中，绝大多数软件的源代码都是用 C 语言编写的，少部分用 C++（或其他语言）编写。因此要想安装源码包，必须安装 gcc 编译器（如果涉及 C++ 源码程序，还需要安装 gcc-c++）。 安装 gcc 之前，可先使用如下命令看看是否已经安装： [root@localhost ~]# rpm -q gccgcc-4.4.6-4.el6.i686 如果未安装，考虑到安装 gcc 所依赖的软件包太多，推荐大家使用 yum 安装 gcc。具体安装方式可阅读《Linux yum命令》一节。 除了安装编译器，还需要安装 make 编译命令。要知道，编译源码包可不像编译一个 hello.c 文件那样轻松，包中含大量的源码文件，且文件之间有着非常复杂的关联，直接决定着各文件编译的先后顺序，因此手动编译费时费力，而使用 make 命令可以完成对源码包的自动编译。 同样，在安装 make 命令之前，可使用如下命令查看其是否已经安装： [root@localhost yum. repos.d]# rpm -q makemake-3.81-20.el6.i686 如果未安装，可使用 yum -y install make 命令直接安装 make。 安装好了 gcc 编译器和 make 编译工具，接下来学习使用源码包安装软件。 Linux源码包安装软件本节仍然以安装 apache 为例，安装过程分为如下几步： 下载 apache 源码包。该软件的源码包可通过官方网站 http://httpd.apache.org/download.cgi#apache24 下载，得到的源码包格式为压缩包（ “.tar.gz” 或 “.tar.bz2” ）。 将各种文件分门别类保存在对应的目录中，应该成为合格 Linux 管理员约定俗成的习惯。Linux 系统中用于保存源代码的位置主要有 2 个，分别是 “&#x2F;usr&#x2F;src” 和 “&#x2F;usr&#x2F;local&#x2F;src”，其中 “&#x2F;usr&#x2F;src” 用来保存内核源代码，”&#x2F;usr&#x2F;local&#x2F;src” 用来保存用户下载的源代码。 将源码包进行解压缩，使用命令如下： 1[root@localhost ~]#tar -zxvf httpd-2.2.9.tar.gz|more 进入解压目录，执行如下命令： 123[root@localhost ~]# lsanaconda-ks.cfg httpd-2.2.9 httpd-2.2.9.tar.gz install.log install.log.syslog[root@localhost ~]# cd httpd-2.2.9 .&#x2F;configure 软件配置与检查。这一步主要完成以下 3 项任务： 检测系统环境是否符合安装要求。 定义需要的功能选项。通过 “.&#x2F;configure–prefix&#x3D;安装路径” 可以指定安装路径。注意，configure 不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用 “.&#x2F;configure” 方式执行（”.&#x2F;“ 代表在当前目录下）。 “.&#x2F;configure” 支持的功能选项较多，可执行 “.&#x2F;configure–help” 命令查询其支持的功能，例如： [root@localhost httpd-2.2.9]#.&#x2F;configure –help|more#查询apache支持的选项功能（不是必需步骤） 把系统环境的检测结果和定义好的功能选项写入 Makefile 文件，因为后续的编译和安装需要依赖这个文件的内容。 此步具体执行代码如下： 1234567[root@localhost httpd-2.2.9]# ./configure --prefix=/usr/local/apache2checking for chosen layout...Apachechecking for working mkdir -p…yeschecking build system type...i686-pc-linux-gnuchecking host system type...i686-pc-linux-gnuchecking target system typa...i686-pc-linux-gnu…省略部分输出… –prefix 选项的含义为指定安装目录。 此命令没有加载其他功能，只是指定安装目录。需要说明的是，”&#x2F;usr&#x2F;local&#x2F;apache2” 目录不需要手工建立，安装完成后会自动建立（这个目录是否生成也是检测软件是否正确安装的重要标志）。 make 编译。make 会调用 gcc 编译器，并读取 Makefile 文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被 Linux 识别的可执行文件，这些可执行文件保存在当前目录下。 执行的编译命令如下： [root@localhost httpd-2.2.9]# make 编程过程较为耗时，需要有足够的耐心。 正式开始安装软件，这里通常会写清程序的安装位置，如果没有，则建议读者把安装的执行过程保存下来，以备将来删除软件时使用。安装指令如下： [root@localhost httpd-2.2.9]# make install 整个过程不报错，即为安装成功。 安装源码包过程中，如果出现“error”（或“warning”）且安装过程停止，表示安装失败；反之，如果仅出现警告信息，但安装过程还在继续，这并不是安装失败，顶多使软件部分功能无法使用。 注意，如果在 “.&#x2F;configure” 或 “make” 编译中报错，则在重新执行命令前一定要执行 make clean 命令，它会清空 Makefile 文件或编译产生的 “.o” 头文件。 Linux源码包卸载通过源码包方式安装的各个软件，其安装文件独自保存在 &#x2F;usr&#x2F;local&#x2F; 目录下的各子目录中。例如，apache 所有的安装文件都保存在 &#x2F;usr&#x2F;local&#x2F;apache2 目录下。这就为源码包的卸载提供了便利。 源码包的卸载，只需要找到软件的安装位置，直接删除所在目录即可，不会遗留任何垃圾文件。需要读者注意的是，在删除软件之前，应先将软件停止服务。 以删除 apache 为例，只需关闭 apache 服务后执行如下命令即可： 1[root@localhost ~]# rm -rf /usr/local/apache2/ Linux源码包快速升级方法Linux 系统中更新用源码包安装的软件，除了卸载重装这种简单粗暴的方法外，还可以下载补丁文件更新源码包，用新的源码包重新编译安装软件。比较两种方式，后者更新软件的速度更快。 使用补丁文件更新源码包，省去了用 .&#x2F;configured 生成新的 Makefile 文件，还省去了大量的编译工作，因此效率更高。学完本节会对比有更深入的理解。 Linux补丁文件的生成和使用Linux 系统中可以使用 diff 命令对比出新旧软件的不同，并生成补丁文件。 diff 命令基本格式为： 12[root@localhost ~]# diff 选项 old new#比较old和new文件的不同 此命令中可使用如下几个选项： -a：将任何文档当作文本文档处理； -b：忽略空格造成的不同； -B：忽略空白行造成的不同； -I：忽略大小写造成的不同； -N：当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件； -r：当比较目录时，递归比较子目录； -u：使用同一输出格式； 从生成补丁文件，到使用其实现更新软件的目的，为了让读者清楚地了解整个过程的来龙去脉，下面我们自己创建两个文件（分别模拟旧软件和新软件），通过对比新旧文件生成补丁文件，最后利用补丁文件更新旧文件，具体步骤如下： 创建两个文件，执行如下命令： 123456789101112131415161718[root@localhost ~]# mkdir test#建立测试目录[root@localhost ~]# cd test#进入测试目录[root@localhost test]# vi old.txtourschoolislampbrother#文件old.txt，为了便于比较，将每行分开[root@localhost test]# vi new.txtourschoolislampbrotherinBeijing#文件new.txt 利用 diff 命令，比较两个文件（old.txt 和 new.txt）的不同，并生成补丁文件（txt.patch），执行代码如下： 123456789101112131415[root@localhost test]# diff -Naur /root/test/old.txt /root/test/new.txt &gt; txt. patch#比较两个文件的不同，同时生成txt.patch补丁文件[root@localhost test]#vi txt.patch#查看一下这个文件--/root/test/old.txt 2012-11-23 05:51:14.347954373 +0800#前一个文件+ + + /root/test/new.txt 2012-11-23 05:50:05.772988210 +0800#后一个文件@@-2, 3+2, 5@@schoolislampbrother+in+beijing#后一个文件比前一个文件多两行（用+表示） 利用补丁文件 txt.patch 更新 old.txt 旧文件，实现此步操作需利用 patch 命令，该命令基本格式如下： 12[root@localhost test]# patch -pn &lt; 补丁文件#按照补丁文件进行更新 -pn 选项中，n 为数字（例如 p1、p2、p3 等），pn 表示按照补丁文件中的路径，指定更新文件的位置。 这里对 -pn 选项的使用做一下额外说明。我们知道，补丁文件是要打入旧文件的，但是当前所在目录和补丁文件中记录的目录不一定是匹配的，需要 “-pn” 选项来同步两个目录。 例如，当前位于 “&#x2F;root&#x2F;test&#x2F;“ 目录下（要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为 “&#x2F;root&#x2F;test&#x2F;dd.txt”，如果写入 “-p1”（在补丁文件目录中取消一级目录），那么补丁文件会打入 “root&#x2F;test&#x2F;root&#x2F;test&#x2F;old.txt” 文件中，这显然是不对的；如果写入的是 “-p2”（在补丁文件目录中取消二级目录），补丁文件会打入 “&#x2F;root&#x2F;test&#x2F;test&#x2F;old.txt” 文件中，这显然也不对。如果写入的是 “-p3”（在补丁文件目录中取消三级目录），补丁文件会打入 “&#x2F;root&#x2F;test&#x2F;old.txt” 文件中，old.txt 文件就在这个目录下，所以应该用 “-p3” 选项。 如果当前所在目录是 “&#x2F;root&#x2F;“ 目录呢？因为补丁文件中记录的文件目录为 “&#x2F;root&#x2F;test&#x2F;old.txt”，所以这里就应该用 “-p2” 选项（代表取消两级目录），补丁打在当前目录下的 “test&#x2F;old.txt” 文件上。 因此，-pn 选项可以这样理解，即想要在补丁文件中所记录的目录中取消几个 “&#x2F;“，n 就是几。去掉目录的目的是和当前所在目录匹配。 现在更新 “old.txt” 文件，命令如下： 123456789101112[root@localhost test]# patch -p3 &lt; txt.patchpatching file old.txt#给old.txt文件打补丁[root@localhost test]# cat old.txt#查看一下dd.txt文件的内容ourschoolislampbrotherinBeijing#多出了in Beijing两行 可以看到，通过使用补丁文件 txt.patch 对旧文件进行更新，使得旧文件和新文件完全相同。 通过这个例子，大家要明白以下两点： 给旧文件打补丁依赖的不是新文件，而是补丁文件，所以即使新文件被删除也没有关系。 补丁文件中记录的目录和当前所在目录需要通过 “-pn” 选项实现同步，否则更新可能失败。 给apache打入补丁本节仍以 apache 为例，通过从官网上下载的补丁文件 “mod_proxy_ftp_CVE-2008-2939.diff”，更新 httpd-2.2.9 版本的 apache。 这里使用的补丁文件，修补了 apache 代理 FTP 站点时，模块空指针引用拒绝服务攻击的漏洞（了解即可，不用深究）。 具体更新步骤如下： 从 apache 官网上下载补丁文件； 复制补丁文件到 apache 源码包解压目录中，执行命令如下： 1[root@localhost ~]# cp mod_proxy_ftp_CVE-2008-2939.diff httpd-2.2.9 给旧 apache 打入补丁，具体执行命令如下： 12345678910[root@localhost ~]# cd httpd-2.2.9#进入apache源码目录[root@localhost httpd-2.2.9]# vi mod_proxy_ftp_CVE-2008-2939.diff#查看补丁文件--modules/proxy/mod_proxy_ftp.c (Revision 682869)+ + + modules/proxy/mod_proxy_ftp.c (Revision 682870)…省略部分输出…#查看一下补丁文件中记录的目录，以便一会儿和当前所在目录同步[root@localhost httpd-2.2.9]# patch - p0 &lt; mod_proxy_ftp_CVE-2008-2939.diff#打入补丁 为什么是 “-p0” 呢？因为当前在 “&#x2F;root&#x2F;httpd-2.2.9” 目录中，但补丁文件中记录的目录是 “modules&#x2F;proxy&#x2F;mod_proxy_ftp.c”，就在当前所在目录中，因此一个 “&#x2F;“ 都不需要去掉，所以是 “-p0”。 重新编译 apache 源码包，执行如下命令： [root@localhost httpd-2.2.9]# make 安装 apache，执行如下命令： 1[root@localhost httpd-2.2.9]# make install 打补丁更新软件的过程比安装软件少了 “.&#x2F;configure” 步骤，且编译时也只是编译变化的位置，编译速度更快。 注意，如果未安装过 httpd-2.2.9，就需要先打入补丁，再依次执行 “.&#x2F;configure”、”make”、“make install” 命令。 patch 命令不仅可以给就文件打入补丁，还可以执行反操作，即恢复用补丁文件修改过的源文件，例如： 1[root@localhost httpd-2.2.9]# patch -R &lt; modjDroxy_ftp_CVE-2008-2939.diff -R（大写）选项表示还原补丁。 Linux脚本程序包及安装方法（以webmin安装为例）脚本程序并不多见，所以在软件包分类中并没有把它列为一类。它更加类似于 Windows 下的程序安装，有一个可执行的安装程序，只要运行安装程序，然后进行简单的功能定制选择（比如指定安装目录等)，就可以安装成功，只不过是在字符界面完成的。 目前常见的脚本程序以各类硬件的驱动居多，我们需要学习一下这类软件的安装方式，以备将来不时之需。 我们来看看脚本程序如何安装和使用。安装一个叫作 Webmin 的工具软件，Webmin 是一个基于 Web 的系统管理界面，借助任何支持表格和表单的浏览器（和 File Manager 模块所需要的Java），你就可以设置用户账号、apache、DNS、文件共享等。 Webmin 包括一个简单的 Web 服务器和许多 CGI 程序，这些程序可以直接修改系统文件，比如 &#x2F;etc&#x2F;inetd.conf 和 &#x2F;etc&#x2F;passwd。Web 服务器和所有的 CGI 程序都是用 Perl 5 编写的，没有使用任何非标准 Perl 模块。也就是说，Webmin 是一个用 Perl 语言写的、可以通过浏览器管理 Linux 的软件。 webmin安装步骤首先下载 Webmin 软件，这里下载的是 webmin-1.610.tar.gz。 接下来解压缩软件，命令如下： 1[root@localhost ~]# tar -zxvf webmin-1.610.tar.gz 进入解压目录，命令如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@localhost ~]# cd webmin-1.610执行安装程序 setup.sh，并指定功能选项，命令如下：[root@localhost webmin-1.610]# ./setup.sh*************************** Welcome to the Webmin setup script,version 1.610 ***************************Webmin is a web-based interface that allows Unix-like operatingsystems and common Unix services to be easily administered.Installing Webmin in /root/webmin-1.610...**************************Webmin uses separate directories for configuration files and log files.Unless you want to run multiple versions of Webmin at the same timeyou can just accept the defaults.Config file directory [/etc/webmin]:#选择安装位置，默认安装在/etc/webmin目录下。如果安装到默认位置，则直接回车Log file directory [/var/webmin]:#日志文件保存位置，直接回车，选择默认位置**************************Webmin is written entirely in Perl.Please enter the full path to thePerl 5 interpreter on your system.Full path to peri (default /usr/bin/perl):#指定Perl语言的安装位置，直接回车，选择默认位置，Perl默认就安装这里Testing Perl...Perl seems to be installed ok**************************Operating system name: CentOS Linux Operating system version: 6.3**************************Webmin uses its own password protected web server to provide access to the administration programs.The setup script needs to know:-What port to run the web server on.There must not be another web server already using this port.-The login name required to access the web server.-The password required to access the web server.-If the Webserver should use SSL (if your system supports it).-Whether to start webmin at boot time.Web server port (default 10000):#指定Webmin监听的端口，直接回车，默认选定 10000Login name (default admin):admin #输入登录Webmin的用户名Login password:Password again:#输入登陆密码The Perl SSLeay library is not installed.SSL not available.#apache默认没有启动SSl功能，所以SSl没有被激活Start Webmin at boot time (y/n):y#是否在开机的同时启动Webmin…安装过程省略…Webmin has been installed and started successfully.Use your web browser to go tohttp://localhost:10000/and login with the name and password you entered previously.#安装完成 在浏览器地址栏中输入”http://192.168.2.199:10000/ “，然后输入用户名和密码，就可以登录到 Webmin 界面","tags":["Linux","CentOS"],"categories":["学习"]},{"title":"git基本使用","path":"/a531cc26/","content":"git查看修改1git diff顾名思义就是查看difference 查看历史当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。 回退版本好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： 果然被还原了。 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 回退之后还原之前的最新版本最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL—–&gt;改为指向add distributed，然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 关机恢复最新版本现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 撤销修改你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： 1git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： Git同样告诉我们，用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 还记得如何丢弃工作区的修改吗？ 12345$ git checkout -- readme.txt$ git statusOn branch masternothing to commit, working tree clean 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件先添加一个新文件test.txt到Git并且提交，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了，git status命令会立刻告诉你哪些文件被删除了， 现在你有两个选择， 一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 1234567$ git rm test.txtrm &#x27;test.txt&#x27;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 小提示：先手动删除文件，然后使用git rm 和git add效果是一样的。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 远程仓库添加远程仓库由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 在本地的learngit仓库下运行命令： 1$ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 删除远程库如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息： 123$ git remote -vorigin git@github.com:michaelliao/learn-git.git (fetch)origin git@github.com:michaelliao/learn-git.git (push) 然后，根据名字删除，比如删除origin： 1$ git remote rm origin 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆用命令git clone克隆一个本地库： 1$ git clone git@github.com:michaelliao/gitskills.git 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理创建与合并分支每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。首先，我们创建dev分支，然后切换到dev分支： 12$ git checkout -b devSwitched to a new branch &#x27;dev&#x27; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch dev$ git checkout devSwitched to branch &#x27;dev&#x27; 然后，用git branch命令查看当前分支： 123$ git branch* dev master 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：然后提交： 现在，dev分支的工作完成，我们就可以切换回master分支： 12$ git checkout masterSwitched to branch &#x27;master&#x27; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： 12345$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 12$ git branch -d devDeleted branch dev (was b17d20e). 删除后，查看branch，就只剩下master分支了： 12$ git branch* master switch我们注意到切换分支使用git checkout &lt;branch&gt;，而前面讲过的撤销修改则是git checkout -- &lt;file&gt;，同一个命令，有两种作用，确实有点令人迷惑。 实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支： 创建并切换到新的dev分支，可以使用： 1$ git switch -c dev 直接切换到已有的master分支，可以使用： 1$ git switch master 使用新的git switch命令，比git checkout要更容易理解。 小结Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git switch -c feature1Switched to a new branch &#x27;feature1&#x27; 修改readme.txt最后一行 在feature1分支上提交： 切换到master分支： 1234$ git switch masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 1 commit. (use &quot;git push&quot; to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： 提交： 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 123456789101112131415$ git statusOn branch masterYour branch is ahead of &#x27;origin/master&#x27; by 2 commits. (use &quot;git push&quot; to publish your local commits)You have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution)\tboth modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 再提交： 123$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567891011121314$ git log --graph --pretty=oneline --abbrev-commit* cf810e4 (HEAD -&gt; master) conflict fixed|\\ | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/ * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was 14096d0). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： 12$ git switch -c devSwitched to a new branch &#x27;dev&#x27; 修改readme.txt文件，并提交一个新的commit： 现在，我们切换回master： 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： 1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &#x27;recursive&#x27; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 1234567$ git log --graph --pretty=oneline --abbrev-commit* e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 123456789101112$ git statusOn branch devChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file: hello.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified: readme.txt 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 1234567$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 6 commits. (use &quot;git push&quot; to publish your local commits)$ git checkout -b issue-101Switched to a new branch &#x27;issue-101&#x27; 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： 1234$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： 123456789$ git switch masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 6 commits. (use &quot;git push&quot; to publish your local commits)$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &#x27;recursive&#x27; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ 123456$ git switch devSwitched to branch &#x27;dev&#x27;$ git statusOn branch devnothing to commit, working tree clean 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1234567891011121314$ git stash popOn branch devChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file: hello.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified: readme.txtDropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a) 再用git stash list查看，就看不到任何stash内容了： 1$ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。 那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？ 有木有更简单的方法？ 有！ 同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支： 123456$ git branch* dev master$ git cherry-pick 4c805e2[master 1d4b803] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： 12$ git switch -c feature-vulcanSwitched to a new branch &#x27;feature-vulcan&#x27; 5分钟后，开发完毕： 12345678910111213$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file: vulcan.py$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： 1$ git switch dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： 123$ git branch -d feature-vulcanerror: The branch &#x27;feature-vulcan&#x27; is not fully merged.If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。 现在我们强行删除： 12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e). 终于删除成功！ 小结开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 或者，用git remote -v显示更详细的信息： 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &#x27;learngit&#x27;...remote: Counting objects: 40, done.remote: Compressing objects: 100% (21/21), done.remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0Receiving objects: 100% (40/40), done.Resolving deltas: 100% (14/14), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 12$ git branch --set-upstream-to=origin/dev devBranch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;. 再pull： 1234$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 1234567891011$ git commit -m &quot;fix env conflict&quot;[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。 每次合并再push后，分支变成了这样： 12345678910111213141516171819$ git log --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch &#x27;dev&#x27;|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\\ \\ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\\ \\ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？ 其实是可以做到的！ Git有一种称为rebase的操作，有人把它翻译成“变基”。 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： 1234567891011$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello* e5e69f1 Merge branch &#x27;dev&#x27;|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env... 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： 123456789$ git push origin masterTo github.com:michaelliao/learngit.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： 123456789101112$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit d1be385..f005ed4 master -&gt; origin/master * [new tag] v1.0 -&gt; v1.0Auto-merging hello.pyMerge made by the &#x27;recursive&#x27; strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： 123456$ git statusOn branch masterYour branch is ahead of &#x27;origin/master&#x27; by 3 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： 123456789$ git log --graph --pretty=oneline --abbrev-commit* e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit|\\ | * f005ed4 (origin/master) set exit=1* | 582d922 add author* | 8875536 add comment|/ * d1be385 init hello... 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？ 有！ 什么问题？ 不好看！ 有没有解决方法？ 有！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： 123456789101112$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add commentUsing index info to reconstruct a base tree...M\thello.pyFalling back to patching base and 3-way merge...Auto-merging hello.pyApplying: add authorUsing index info to reconstruct a base tree...M\thello.pyFalling back to patching base and 3-way merge...Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master) add author* 3611cfe add comment* f005ed4 (origin/master) set exit=1* d1be385 init hello... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程： 123456789Mac:~/learngit michael$ git push origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.Total 6 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 1 local object.To github.com:michaelliao/learngit.git f005ed4..7e61ed4 master -&gt; master 再用git log看看效果： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master, origin/master) add author* 3611cfe add comment* f005ed4 set exit=1* d1be385 init hello... 远程分支的提交历史也是一条直线。 小结 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch &#x27;master&#x27; 然后，敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： 12345678910111213141516$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： 1$ git tag v0.9 f52c633 再用命令git tag查看标签： 123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 123456789$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:56:54 2018 +0800 add mergediff --git a/readme.txt b/readme.txt... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 用命令git show &lt;tagname&gt;可以看到说明文字： 123456789101112131415$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 小结 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 操作标签如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag &#x27;v0.1&#x27; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag &#x27;v0.9&#x27; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。","tags":["git"],"categories":["学习"]},{"title":"MyBatis","path":"/1bff3c65/","content":"MyBatisMyBatis是什么MyBatis 是一个开源、轻量级的数据持久化框架，是 JDBC 和 Hibernate 的替代方案。MyBatis 内部封装了 JDBC，简化了加载驱动、创建连接、创建 statement 等繁杂的过程，开发者只需要关注 SQL 语句本身。 数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中数据模型的统称。例如，文件的存储、数据的读取以及对数据表的增删改查等都是数据持久化操作。 MyBatis 支持定制化 SQL、存储过程以及高级映射，可以在实体类和 SQL 语句之间建立映射关系，是一种半自动化的 ORM 实现。其封装性低于 Hibernate，但性能优秀、小巧、简单易学、应用广泛。 ORM（Object Relational Mapping，对象关系映射）是一种数据持久化技术，它在对象模型和关系型数据库之间建立起对应关系，并且提供了一种机制，通过 JavaBean 对象去操作数据库表中的数据。 MyBatis 前身为 IBatis，2002 年由 Clinton Begin 发布。2010 年从 Apache 迁移到 Google，并改名为 MyBatis，2013 年又迁移到了 Github。 MyBatis 的主要思想是将程序中的大量 SQL 语句剥离出来，使用 XML 文件或注解的方式实现 SQL 的灵活配置，将 SQL 语句与程序代码分离，在不修改程序代码的情况下，直接在配置文件中修改 SQL 语句。 MyBatis 与其它持久性框架最大的不同是，MyBatis 强调使用 SQL，而其它框架（例如 Hibernate）通常使用自定义查询语言，即 HQL（Hibernate查询语言）或 EJB QL（Enterprise JavaBeans查询语言）。 优点 MyBatis 是免费且开源的。 与 JDBC 相比，减少了 50% 以上的代码量。 MyBatis 是最简单的持久化框架，小巧并且简单易学。 MyBatis 相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL 写在 XML 中，和程序逻辑代码分离，降低耦合度，便于同一管理和优化，提高了代码的可重用性。 提供 XML 标签，支持编写动态 SQL 语句。 提供映射标签，支持对象与数据库的 ORM 字段关系映射。 支持存储过程。MyBatis 以存储过程的形式封装 SQL，可以将业务逻辑保留在数据库之外，增强应用程序的可移植性、更易于部署和测试。 缺点 编写 SQL 语句工作量较大，对开发人员编写 SQL 语句的功底有一定要求。 SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 使用场景MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。适用于性能要求高，且需求变化较多的项目，如互联网项目。 拓展Mybatis-Plus（简称 MP）是 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，支持 Mybatis 所有原生的特性，为简化开发、提高效率而生。 MyBatis和Hibernate的区别Hibernate 和 MyBatis 都是目前业界中主流的对象关系映射（ORM）框架，它们的主要区别如下。 1）sql 优化方面 Hibernate 使用 HQL（Hibernate Query Language）语句，独立于数据库。不需要编写大量的 SQL，就可以完全映射，但会多消耗性能，且开发人员不能自主的进行 SQL 性能优化。提供了日志、缓存、级联（级联比 MyBatis 强大）等特性。 MyBatis 需要手动编写 SQL，所以灵活多变。支持动态 SQL、处理列表、动态生成表名、支持存储过程。工作量相对较大。 2）开发方面 MyBatis 是一个半自动映射的框架，因为 MyBatis 需要手动匹配 POJO 和 SQL 的映射关系。 Hibernate 是一个全表映射的框架，只需提供 POJO 和映射关系即可。 3）缓存机制比较Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置缓存。 MyBatis 的二级缓存配置在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且 Mybatis 可以在命名空间中共享相同的缓存配置和实例，通过 Cache-ref 来实现。 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。而 MyBatis 在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免 Cache 的盲目使用。否则脏数据的出现会给系统的正常运行带来很大的隐患。 4）Hibernate 优势 Hibernate 的 DAO 层开发比 MyBatis 简单，Mybatis 需要维护 SQL 和结果映射。 Hibernate 对对象的维护和缓存要比 MyBatis 好，对增删改查的对象的维护要方便。 Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库需要写不同 SQL。 Hibernate 有更好的二级缓存机制，可以使用第三方缓存。MyBatis 本身提供的缓存机制不佳。 5）Mybatis优势 MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段。 MyBatis 容易掌握，而 Hibernate 门槛较高。 6）应用场景MyBatis 适合需求多变的互联网项目，例如电商项目、金融类型、旅游类、售票类项目等。 Hibernate 适合需求明确、业务固定的项目，例如 OA 项目、ERP 项目和 CRM 项目等。 总结总的来说，MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。 对于性能要求不太苛刻的系统，比如管理系统、ERP 等推荐使用 Hibernate，而对于性能要求高、响应快、灵活的系统则推荐使用 MyBatis。 第一个MyBatis程序在创建 MyBatis 项目之前，首先创建 website 数据表，SQL 语句如下。 12345678910DROP TABLE IF EXISTS `website`;CREATE TABLE `website` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) COLLATE utf8_unicode_ci NOT NULL, `url` varchar(30) COLLATE utf8_unicode_ci DEFAULT &#x27;&#x27;, `age` tinyint(3) unsigned NOT NULL, `country` char(3) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#x27;&#x27;, `createtime` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建 MyBatis 程序的步骤为：下载jar包 -&gt; 部署jar包 -&gt; 编写MyBatis核心配置文件 -&gt; 创建实体类 -&gt; 创建DAO接口 -&gt; 创建SQL映射文件 -&gt; 编写测试类 1. 创建Web应用，部署jar包在 Eclipse 中创建 Web 项目 mybatisDemo，并将下载的 MyBatis 的核心 jar 包、依赖 jar 包以及 MySQL 数据库的驱动 jar 包复制到 &#x2F;WEB-INF&#x2F;lib 目录中。 2. 创建日志文件MyBatis 默认使用 log4j 输出日志信息，如果开发者需要查看控制台输出的 SQL 语句，可以在 classpath 路径下配置其日志文件。在 mybatisDemo 的 src 目录下创建 log4j.properties 文件，其内容如下： 12345678# Global logging configurationlog4j.rootLogger=ERROR,stdout# MyBatis logging configuration...log4j.logger.net.biancheng=DEBUG# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 3. 创建持久化类在 src 目录下创建一个名为 net.biancheng.po 的包，在该包中创建持久化类 Website。注意，在类中声明的属性与数据表 website 的字段一致。 Website 类代码如下。 123456789101112131415package net.biancheng.po;import java.util.Date;public class Website &#123; private int id; private String name; private String url; private int age; private String country; private Date createtime; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;id&quot; + id + &quot;name&quot; + name + &quot;url&quot; + url + &quot;age&quot; + age + &quot;country&quot; + country + &quot;createtime&quot; + createtime; &#125;&#125; 4. 创建映射文件在 src 目录下创建 net.biancheng.mapper 包，在该包下创建映射文件 WebsiteMapper.xml。 WebsiteMapper.xml 文件内容如下。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;net.biancheng.mapper.WebsiteMapper&quot;&gt; &lt;!-- 添加一个网站 --&gt; &lt;insert id=&quot;addWebsite&quot; parameterType=&quot;net.biancheng.po.Website&quot;&gt; insert into website (name,url,age,country) values(#&#123;name&#125;,#&#123;url&#125;,#&#123;age&#125;,#&#123;country&#125;) &lt;/insert&gt; &lt;!-- 查询所有网站信息 --&gt; &lt;select id=&quot;selectAllWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; select * from website &lt;/select&gt;&lt;/mapper&gt; 上述代码中，&lt;mapper&gt; 元素是配置文件的根元素，它包含了 namespace 属性，该属性值通常设置为“包名+SQL映射文件名”，用于指定唯一的命名空间。 子元素 &lt;select&gt;、&lt;insert&gt; 中的信息用于执行查询、添加操作。在定义的 SQL 语句中，“#{}”表示一个占位符，相当于“?”，而“#{name}”表示该占位符待接收参数的名称为 name。 5. 创建配置文件MyBatis 核心配置文件主要用于配置数据库连接和 MyBatis 运行时所需的各种特性，包含了设置和影响 MyBatis 行为的属性。 在 src 目录下创建 MyBatis 的核心配置文件 mybatis-config.xml，在该文件中配置了数据库环境和映射文件的位置，具体内容如下： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot; /&gt; &lt;/settings&gt; &lt;!-- 配置mybatis运行环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用JDBC的事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- MySQL数据库驱动 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!-- 连接数据库的URL --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将mapper文件加入到配置文件中 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;net/biancheng/mapper/WebsiteMapper.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 上述映射文件和配置文件都不需要读者完全手动编写，都可以从 MyBatis 使用手册中复制，然后做简单修改。 为了方便管理以后各框架集成所需的配置文件，可以在项目工程下新建 Source Folder 类型的 resources 目录，并在此目录下添加 MyBatis 的核心配置文件，默认文件名为 “ configuration.xml”。但需要注意的是，为了方便在框架集成时更好地区分各个配置文件，我们一般将此文件名命名“mybatis-config.xml”，该文件用于配置数据库连接信息和 MyBatis 的参数。 6. 创建测试类在 src 目录下创建一个名为 net.biancheng.test 的包，在该包中创建 MyBatisTest 测试类。在测试类中首先使用输入流读取配置文件，然后根据配置信息构建 SqlSessionFactory 对象。 接下来通过 SqlSessionFactory 对象创建 SqlSession 对象，并使用 SqlSession 对象的方法执行数据库操作。 MyBatisTest 测试类的代码如下： 123456789101112131415161718192021222324252627282930313233343536package net.biancheng.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import net.biancheng.po.Website;public class Test &#123; public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建SqlSessionFactory SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); // SqlSession执行文件中定义的SQL，并返回映射结果 // 添加网站 Website website = new Website(); website.setName(&quot;编程帮&quot;); website.setUrl(&quot;https://www.biancheng.net/&quot;); website.setAge(21); website.setCountry(&quot;CN&quot;); ss.insert(&quot;net.biancheng.mapper.WebsiteMapper.addWebsite&quot;, website); // 查询所有网站 List&lt;Website&gt; listWeb = ss.selectList(&quot;net.biancheng.mapper.WebsiteMapper.selectAllWebsite&quot;); for (Website site : listWeb) &#123; System.out.println(site); &#125; // 提交事务 ss.commit(); // 关闭 SqlSession ss.close(); &#125;&#125; 运行 MyBatis核心对象MyBatis 有三个基本要素： 核心接口和类 MyBatis核心配置文件（mybatis-config.xml） SQL映射文件（mapper.xml） 下面首先介绍 MyBatis 的核心接口和类，如下所示。 每个 MyBatis 应用程序都以一个 SqlSessionFactory 对象的实例为核心。 首先获取 SqlSessionFactoryBuilder 对象，可以根据 XML 配置文件或者 Configuration 类的实例构建该对象。 然后获取 SqlSessionFactory 对象，该对象实例可以通过 SqlSessionFactoryBuilder 对象来获取。 有了 SqlSessionFactory 对象之后，就可以进而获取 SqlSession 实例。SqlSession 对象中完全包含以数据库为背景的所有执行 SQL 操作的方法，用该实例可以直接执行已映射的 SQL 语句。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder 会根据配置信息或者代码生成 SqlSessionFactory，并且提供了多个 build() 方法重载，如图。 通过源码分析，可以发现以上方法都是在调用同一签名方法，即： build(Reader reader, String environment, Properties properties) 由于参数 environment 和 properties 都可以为 null，去除重复的方法，真正的重载方法其实只有如下三种： build(InputStream inputStream, String environment, Properties properties) build(Reader reader, String environment, Properties properties) build(Configuration config) 通过上述分析，发现配置信息可以以三种形式提供给 SqlSessionFactoryBuilder 的 build() 方法，分别是 InputStream（字节流）、Reader（字符流）、Configuration（类）。 由于字节流和字符流都属于读取配置文件的方式，所以就很容易想到构建一个 SqlSessionFactory 有两种方式，即：读取 XML 配置文件和编写代码。一般习惯为采取 XML 配置文件的方式来构造 SqlSessionFactory，这样一方面可以避免硬编码，另一方面方便日后配置人员修改，避免重复编译代码。 SqlSessionFactoryBuilder的生命周期和作用域SqlSessionFactoryBuilder 的最大特点就是用过即丢。创建 SqlSessionFactory 对象之后，这个类就不存在了，因此 SqlSessionFactoryBuilder 的最佳范围就是存在于方法体内，也就是局部变量。 SqlSessionFactorySqlSessionFactory 是工厂接口而不是现实类，他的任务就是创建 SqlSession。 所有的 MyBatis 应用都以 SqlSessionFactory 实例为中心，SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 对象来获取。有了它以后，顾名思义，就可以通过 SqlSession 提供的 openSession() 方法来获取 SqlSession 实例。源码如下。 1234567891011public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; SqlSessionFactory的生命周期和作用域SqlSessionFactory 对象一旦创建，就会在整个应用程序过程中始终存在。没有理由去销毁或再创建它，并且在应用程序运行中也不建议多次创建 SqlSessionFactory。因此 SqlSessionFactory 的最佳作用域是 Application，即随着应用程序的生命周期一直存在。这种“存在于整个应用运行期间，并且只存在一个对象实例”的模式就是所谓的单例模式（指在运行期间有且仅有一个实例）。 SqlSessionSqlSession 是用于执行持久化操作的对象，类似于 JDBC 中的 Connection。它提供了面向数据库执行 SQL 命令所需的所有方法，可以通过 SqlSession 实例直接运行已映射的 SQL 语句。 123456void clearCache();Configuration getConfiguration();void rollback(boolean force);void commit(boolean force);int delete(String statement, Object parameter);... SqlSession 的用途主要有两种。 获取映射器。让映射器通过命名空间和方法名称找到对应的 SQL，并发送给数据库，执行后返回结果。 直接通过“命名空间（namespace）+SQL id”的方式执行 SQL，不需要获取映射器。这是 iBatis 版本留下的方式。例如《第一个MyBatis程序》一节的示例就是这种方式执行的 SQL 语句。 SqlSession生命周期和作用域SqlSession 对应一次数据库会话。由于数据库会话不是永久的，因此 SqlSession 的生命周期也不是永久的，每次访问数据库时都需要创建 SqlSession 对象。 需要注意的是：每个线程都有自己的 SqlSession 实例，SqlSession 实例不能被共享，也不是线程安全的。因此 SqlSession 的作用域范围是 request 作用域或方法体作用域内。 MyBatis配置文件（mybatis-config.xml）MyBatis 配置文件的结构如下。 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- 配置 --&gt; &lt;properties /&gt;&lt;!-- 属性 --&gt; &lt;settings /&gt;&lt;!-- 设置 --&gt; &lt;typeAliases /&gt;&lt;!-- 类型命名 --&gt; &lt;typeHandlers /&gt;&lt;!-- 类型处理器 --&gt; &lt;objectFactory /&gt;&lt;!-- 对象工厂 --&gt; &lt;plugins /&gt;&lt;!-- 插件 --&gt; &lt;environments&gt;&lt;!-- 配置环境 --&gt; &lt;environment&gt;&lt;!-- 环境变量 --&gt; &lt;transactionManager /&gt;&lt;!-- 事务管理器 --&gt; &lt;dataSource /&gt;&lt;!-- 数据源 --&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;databaseIdProvider /&gt;&lt;!-- 数据库厂商标识 --&gt; &lt;mappers /&gt;&lt;!-- 映射器 --&gt;&lt;/configuration&gt; mybatis-config.xml 文件中的元素节点是有一定顺序的，节点位置必须按以上位置排序，否则会编译错误。 configuration 元素是整个 XML 配置文件的根节点，其角色就相当于是 MyBatis 的总管，MyBatis 所有的配置信息都会存放在它里面。 properties标签properties 标签可以通过 resource 属性指定外部 properties 文件（database.properties），也可以通过 properties 子元素配置。 1. 指定文件使用 properties 指定外部文件，代码如下。 1&lt;properties resource=&quot;mybatisDemo/resources/database.properties&quot;/&gt; database.properties 用于描述数据库连接的相关配置，例如数据库驱动、连接数据库的 url、数据库用户名、数据库密码等。 2. properties子元素配置通过 properties 子元素 property 配置 username 和 password 变量，然后在 environments 节点中引用这些变量，代码如下。 1234&lt;properties&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; 在 environments 节点中引用 username 和 password 变量。 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 也可以不使用 properties 标签，直接将属性值写在 value 中。 settings标签settings 标签用于配置 MyBatis 的运行时行为，它能深刻的影响 MyBatis 的底层运行，一般不需要大量配置，大部分情况下使用其默认值即可。 settings 的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了。settings 配置项说明如下表所示（表中高亮字体的配置项为常用配置项）。 配置项 作用 配置选项 默认值 &#x3D;&#x3D;cacheEnabled&#x3D;&#x3D; 该配置影响所有映射器中配置缓存的全局开关 true|false true &#x3D;&#x3D;lazyLoadingEnabled&#x3D;&#x3D; 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态 true|false false &#x3D;&#x3D;aggressiveLazyLoading&#x3D;&#x3D; 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载 true|false 版本3.4.1 （不包含） 之前默认值为 true，之后为 false multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要兼容驱动） true|false true useColumnLabel 使用列标签代替列名。不同的驱动会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果 true|false true useGeneratedKeys 允许JDBC 支持自动生成主键，需要驱动兼容。如果设置为 true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby） true|false false &#x3D;&#x3D;autoMappingBehavior&#x3D;&#x3D; 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射。 PARTIAL 表示只会自动映射，没有定义嵌套结果集和映射结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套） NONE、PARTIAL、FULL PARTIAL autoMappingUnkno wnColumnBehavior 指定自动映射当中未知列（或未知属性类型）时的行为。 默认是不处理，只有当日志级别达到 WARN 级别或者以下，才会显示相关日志，如果处理失败会抛出 SqlSessionException 异常 NONE、WARNING、FAILING NONE &#x3D;&#x3D;defaultExecutorType&#x3D;&#x3D; 配置默认的执行器。SIMPLE 是普通的执行器；REUSE 会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新 SIMPLE、REUSE、BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 任何正整数 Not Set (null) defaultFetchSize 设置数据库驱动程序默认返回的条数限制，此参数可以重新设置 任何正整数 Not Set (null) safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许，设置 false true|false false safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许，设置false true|false true &#x3D;&#x3D;mapUnderscoreToCamelCase&#x3D;&#x3D; 是否开启自动驼峰命名规则映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 true|false false localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速联复嵌套査询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlScssion 的不同调用将不会共享数据 SESSION|STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER NULL、VARCHAR、OTHER OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载 — equals、clone、hashCode、toString defaultScriptingLanguage 指定动态 SQL 生成的默认语言 — org.apache.ibatis .script.ing.xmltags .XMLDynamicLanguageDriver callSettersOnNulls 指定当结果集中值为 null 时，是否调用映射对象的 setter（map 对象时为 put）方法，这对于 Map.kcySet() 依赖或 null 值初始化时是有用的。注意，基本类型（int、boolean 等）不能设置成 null true|false false logPrefix 指定 MyBatis 增加到日志名称的前缀 任何字符串 Not set loglmpl 指定 MyBatis 所用日志的具体实现，未指定时将自动査找 SLF4J|LOG4J|LOG4J2|JDK_LOGGING |COMMONS_LOGGING |ST DOUT_LOGGING|NO_LOGGING Not set proxyFactory 指定 MyBatis 创建具有延迟加栽能力的对象所用到的代理工具 CGLIB|JAVASSIST JAVASSIST （MyBatis 版本为 3.3 及以上的） vfsImpl 指定 VFS 的实现类 提供 VFS 类的全限定名，如果存在多个，可以使用逗号分隔 Not set useActualParamName 允许用方法参数中声明的实际名称引用参数。要使用此功能，项目必须被编译为 Java 8 参数的选择。（从版本 3.4.1 开始可以使用） true|false true 下面给出一个全量的配置样例，如下所示。 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; typeAliases标签为了不在任何地方都指定类的全限定名，我们可以使用 typeAliases 标签定义一个别名。 例如，在 net.bianchengbang.po 包中有一个 Student 类，则该类的全限定名称为 net.bianchengbang.po.Student。使用 typeAliases 标签定义别名，这样就不用每次都书写类的全限定名称了，代码如下。 123&lt;typeAliases&gt; &lt;typeAlias alias = &quot;Student&quot; type = &quot;net.bianchengbang.po.Student&quot;/&gt;&lt;/typeAliases&gt; 如果需要对同一个包下的多个类定义别名，则可以定义为： 123&lt;typeAliases&gt; &lt;package name=&quot;net.biancheng.po&quot;/&gt;&lt;/typeAliases&gt; 这样 MyBatis 将扫描 net.biancheng.po 包里面的类，将其第一个字母变为小写作为其别名，例如 Student 别名为 student，User 别名为 user。 typeHandlers标签typeHandlers 主要将获取的值合理地转化为 Java 类型。在 typeHandler 中，分为 jdbcType 和 javaType，其中 jdbcType 用于定义数据库类型，而 javaType 用于定义 Java 类型，typeHandler 的作用就是承担 jdbcType 和 javaType 之间的相互转换。 MyBatis 支持自定义处理类型，在自定义处理类型时，需要实现 org.apache.ibatis.type.TypeHandler 接口或继承 org.apache.ibatis.type.BaseTypeHandle 类。详细可参考官网：http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers environments标签在 environments 标签中，可以配置 MyBatis 的多套运行环境，将 SQL 映射到多个不同的数据库上。 environment 是 environments 的子标签，用来配置 MyBatis 的一套运行环境，需指定运行环境 ID、事务管理、数据源配置等相关信息。 我们可以通过配置多个 environment 标签来连接多个数据库，需要注意的是必须指定其中一个为默认运行环境（通过default指定）。 environment 标签提供了两个子标签，即 transactionManager 和 dataSource。 transactionManager标签MyBatis 支持两个事务管理器，即 JDBC 和 MANAGED。 如果使用 JDBC 类型的事务管理器，则应用程序服务器负责事务管理操作，例如提交、回滚等。如果使用 MANAGED 类型的事务管理器，则应用程序服务器负责管理连接生命周期。 dataSource标签用于配置数据库的连接属性，例如要连接的数据库的驱动程序名称、URL、用户名和密码等。 dataSource 中的 type 属性用于指定数据源类型，有以下 3 种类型。 1）UNPOOLEDUNPOOLED 没有数据库连接池，效率低下。MyBatis 需要打开和关闭每个数据库操作的连接，它有点慢，通常应用于简单的应用程序。 2）POOLED对于 POOLED 数据源类型，MyBatis 将维护一个数据库连接池。并且对于每个数据库的操作，MyBatis 都会使用连接池中的连接，并在操作完成后将它们返回到池中。减少了创建新连接所需的初始连接和身份验证时间。 3）JNDI对于 JNDI 的数据源类型，MyBatis 将从 JNDI 数据源中获取连接。 dataSource 标签示例代码如下： 123456789&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- MySQL数据库驱动 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!-- 连接数据库的URL --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;&lt;/dataSource&gt; mappers标签mappers 标签用于指定 MyBatis SQL 映射文件的路径。 mapper 是 mappers 的子标签，mapper 中的 resource 属性用于指定 SQL 映射文件的路径（类资源路径） 例如，SQL 映射文件的名称是 Student.xml，它位于名为 net.biancheng.mapper 的包中，那么您可以这样配置： 123&lt;mappers&gt; &lt;mapper resource=&quot;net/biancheng/mapper/Student.xml&quot;/&gt;&lt;/mappers&gt; MyBatis Mapper（映射器）映射器是 MyBatis 中最重要的文件，文件中包含一组 SQL 语句（例如查询、添加、删除、修改），这些语句称为映射语句或映射 SQL 语句。 映射器由 Java 接口和 XML 文件（或注解）共同组成，它的作用如下。 定义参数类型 配置缓存 提供 SQL 语句和动态 SQL 定义查询结果和 POJO 的映射关系 映射器有以下两种实现方式。 通过 XML 文件方式实现，比如我们在 mybatis-config.xml 文件中描述的 XML 文件，用来生成 mapper。 通过注解的方式实现，使用 Configuration 对象注册 Mapper 接口。 如果 SQL 语句存在动态 SQL 或者比较复杂，使用注解写在 Java 文件里可读性差，且增加了维护的成本。所以一般建议使用 XML 文件配置的方式，避免重复编写 SQL 语句。 XML实现映射器XML 定义映射器分为两个部分：接口和XML。下面先定义接口 WebsiteMapper 123456package net.biancheng.mapper;import java.util.List;import net.biancheng.po.Website;public interface WebsiteMapper &#123; public List&lt;Website&gt; selectAllWebsite();&#125; WebsiteMapper.xml 代码如下。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;net.biancheng.mapper.WebsiteMapper&quot;&gt; &lt;!-- 查询所有网站信息 --&gt; &lt;select id=&quot;selectAllWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; select * from website &lt;/select&gt;&lt;/mapper&gt; 下面对上述 XML 文件进行讲解。 namespace 用来定义命名空间，该命名空间和定义接口的全限定名一致。 &lt;select&gt; 元素表明这是一条查询语句，属性 id 用来标识这条 SQL。resultType 表示返回的是一个 Website 类型的值。 在 MyBatis 配置文件中添加以下代码。 1&lt;mapper resource=&quot;net/biancheng/mapper/WebsiteMapper.xml&quot; /&gt; 该语句用来引入 XML 文件，MyBatis 会读取 WebsiteMapper.xml 文件，生成映射器。 下面进行测试，用 SqlSession 来获取 Mapper，Test 类代码如下。 1234567891011121314public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); WebsiteMapper websiteMapper = ss.getMapper(WebsiteMapper.class); List&lt;Website&gt; websitelist = websiteMapper.selectAllWebsite(); for (Website site : websitelist) &#123; System.out.println(site); &#125; ss.commit(); ss.close(); &#125;&#125; 运行 注解实现映射器使用注解的方式实现映射器，只需要在接口中使用 Java 注解，注入 SQL 即可。如下所示。 12345678package net.biancheng.mapper;import java.util.List;import org.apache.ibatis.annotations.Select;import net.biancheng.po.Website;public interface WebsiteMapper2 &#123; @Select(value = &quot;select * from website&quot;) public List&lt;Website&gt; selectAllWebsite();&#125; 这里我们使用了 @Select 注解，并且注入了和 XML 中相同的 select 语句。 如果使用注解和 XML 文件两种方式同时定义，那么 XML 方式将覆盖掉注解方式。 虽然这里注解的方式看起来比 XML 简单，但是现实中我们遇到的 SQL 会比该例子复杂得多。如果 SQL 语句中有多个表的关联、多个查询条件、级联、条件分支等，显然这条 SQL 就会复杂的多，所以并不建议读者使用这种方式。比如下面这条 SQL。 12345678910select * from t_user uleft join t_user_role ur on u.id = ur.user_idleft join t_role r on ur.role_id = r.idleft join t_user_info ui on u.id = ui.user_idleft join t_female_health fh on u.id = fh.user_idleft join t_male_health mh on u.id = mh.user_idwhere u.user_name like concat(&#x27;%&#x27;, $&#123;userName&#125;,&#x27;%&#x27;)and r.role_name like concat(&#x27;%&#x27;, $&#123;roleName&#125;,&#x27;%&#x27;)and u.sex = 1and ui.head_image is not null; 如果把以上 SQL 放到 @Select 注解中，无疑会大大降低代码的可读性。如果同时还要考虑使用动态 SQL 或需要加入其他的逻辑，这样就使得这个注解更加复杂了，不利于日后的维护和修改。 此外，XML 可以相互引入，而注解是不可以的，所以在一些比较复杂的场景下，使用 XML 方式会更加灵活和方便。因此大部分的企业都以 XML 为主，本教程也会保持一致，以 XML 方式来创建映射器。当然在一些简单的表和应用中使用注解方式也会比较简单。 这个接口可以在 XML 中定义，将在 mybatis-config.xml 中配置 XML 的语句修改为以下语句即可。 1&lt;mapper resource=&quot;com/mybatis/mapper/WebsiteMapper2&quot; /&gt; 也可以使用 configuration 对象注册这个接口，比如： 1configuration.addMapper(WebsiteMapper2.class); MyBatis 映射器的主要元素下面介绍在映射器中可以定义哪些元素，以及它们的作用。 元素名称 描述 备注 mapper 映射文件的根节点，只有 namescape 一个属性 namescape 作用如下：用于区分不同的 mapper，全局唯一绑定DAO接口，即面向接口编程。当 namescape 绑定某一接口后，可以不用写该接口的实现类，MyBatis 会通过接口的完整限定名查找到对应的 mapper 配置来执行 SQL 语句。因此 namescape 的命名必须要跟接口同名。 select 查询语句，最常用、最复杂的元素之一 可以自定义参数，返回结果集等 insert 插入语句 执行后返回一个整数，代表插入的条数 update 更新语句 执行后返回一个整数，代表更新的条数 delete 删除语句 执行后返回一个整数，代表删除的条数 parameterMap 定义参数映射关系 即将被删除的元素，不建议使用 sql 允许定义一部分的 SQL，然后在各个地方引用它 例如，一张表列名，我们可以一次定义，在多个 SQL 语句中使用 resultMap 用来描述数据库结果集与对象的对应关系，它是最复杂、最强大的元素 提供映射规则 cache 配置给定命名空间的缓存 - cache-ref 其它命名空间缓存配置的引用 - 后面文章中会详细介绍以上元素。 拓展关于 MyBatis 的 SQL 映射文件中的 mapper 元素的 namescape 属性有如下要求。 namescape 的命名必须跟某个 DAO 接口同名，同属于 DAO 层，因此代码结构上，映射文件与该接口应放置在同一 package 下（如 net.biancheng.dao.website），并且习惯上是以 Mapper 结尾（如 WebsiteMapper.java、WebsiteMapper.xml）。 不同的 mapper 文件中子元素的 id 可以相同，MyBatis 通过 namescape 和子元素的 id 联合区分。接口中的方法与映射文件中的 SQL 语句 id 应一 一对应。 MyBatis执行SQL的两种方式MyBatis 有两种执行 SQL 语句的方式，如下： 通过 SqlSession 发送 SQL 通过 SqlSession 获取 Mapper 接口，通过 Mapper 接口发送 SQL SqlSession发送SQL有映射器之后就可以通过 SqlSession 发送 SQL 了。我们以 getWebsite 这条 SQL 为例看看如何发送 SQL。 1Website website = (Website)sqlSession.selectOne(&quot;net.biancheng.mapper.WebsiteMapper.getWebsite&quot;,1); MyBatis 常用的查询方法有 2 种，分别为 selectOne 和 selectList。 1）selectOneselectOne 方法表示使用查询并且只返回一个对象，必须指定查询条件。只能查询 0 或 1 条记录，大于 1 条记录则运行错误。常用格式如下（也有其它重载方法，根据需要选择）。 1sqlSession.selectOne(String arg0, Object arg1) 2）selectListselectList 方法表示使用查询并且返回一个列表。可以查询 0 或 N 条记录。常用格式如下。 1sqlSession.selectOne(String arg0) 也可指定参数： 1sqlSession.selectList(String arg0, Object arg1) 以上语法格式中，String 对象由一个命名空间加 SQL id 组合而成，它完全定位了一条 SQL，这样 MyBatis 就会找到对应的 SQL。Object 对象为需要传递的参数，也就是查询条件。 selectOne 实现的 selectList 都可以实现，即 list 中只有一个对象。但 selectList 能实现的，selectOne 不一定能实现。 如果 MyBatis 中只有一个 id 为 getWbsite 的 SQL，那么也可以简写为： 1Website website = (Website )sqlSession.selectOne(&quot;getWbsite&quot;,1); 这是 MyBatis 前身 iBatis 所留下的方式。 Mapper接口发送 SQLSqlSession 还可以获取 Mapper 接口，通过 Mapper 接口发送 SQL，如下所示。 12WebsiteMapper websiteMapper = sqlSession.getMapper(WebsiteMapper.class);Website website = websiteMapper.getWebsite(1); 通过 SqlSession 的 getMapper 方法获取一个 Mapper 接口，然后就可以调用它的方法了。因为 XML 文件或者接口注解定义的 SQL 都可以通过“类的全限定名+方法名”查找，所以 MyBatis 会启用对应的 SQL 运行，并返回结果。 区别上面分别讲解了 MyBatis 两种发送 SQL 的方式，一种用 SqlSession 直接发送，另外一种通过 SqlSession 获取 Mapper 接口再发送。笔者建议采用 Mapper 接口发送 SQL 的方式，理由如下： 使用 Mapper 接口编程可以消除 SqlSession 带来的功能性代码，提高可读性，而 SqlSession 发送 SQL，需要一个 SQL id 去匹配 SQL，比较晦涩难懂。 使用 Mapper 接口，类似 websiteMapper.getWebsite(1) 则是完全面向对象的语言，更能体现业务的逻辑。 使用 websiteMapper.getWebsite(1) 方式，IDE 会提示错误和校验，而使用 sqlSession.selectOne(“getWebsite”,1L) 语法，只有在运行中才能知道是否会产生错误。 目前使用 Mapper 接口编程已成为主流，尤其在 Spring 中运用 MyBatis 时，Mapper 接口的使用就更为简单，所以本教程使用 Mapper 接口的方式讨论 MyBatis。 MyBatis select标签select 示例语句如下。 123&lt;select id=&quot;selectAllWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot; parameterType=&quot;string&quot;&gt; SELECT id,NAME,url FROM website WHERE NAME LIKE CONCAT (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)&lt;/select&gt; 以上是一个 id 为 selectAllWebsite 的映射语句，参数类型为 string，返回结果类型为 Website。 执行 SQL 语句时可以定义参数，参数可以是一个简单的参数类型，例如 int、float、String；也可以是一个复杂的参数类型，例如 JavaBean、Map 等。MyBatis 提供了强大的映射规则，执行 SQL 后，MyBatis 会将结果集自动映射到 JavaBean 中。 为了使数据库的查询结果和返回值类型中的属性能够自动匹配，通常会对 MySQL 数据库和 JavaBean 采用同一套命名规则，即 Java 命名驼峰规则，这样就不需要再做映射了（数据库表字段名和属性名不一致时需要手动映射）。 参数的传递使用#&#123;参数名&#125;，相当于告诉 MyBatis 生成 PreparedStatement 参数。对于 JDBC，该参数会被标识为“?”。以上 SQL 语句可以使用 JDBC 实现，实现代码如下。 123String sql = &quot;SELECT id,NAME,url FROM website WHERE NAME LIKE CONCAT (&#x27;%&#x27;,?,&#x27;%&#x27;)&quot;;PreparedStatement ps = conn.prepareStatement(sql);ps.setString(1,userName); select标签常用属性下面介绍 select 标签中常用的属性。 属性名称 描 述 备注 id 它和 Mapper 的命名空间组合起来使用，是唯一标识符，供 MyBatis 调用 如果命名空间+id不唯一，那么 MyBatis 抛出异常 parameterType 表示传入 SQL 语句传入参数类型的全限定名或别名。它是一个可选属性，MyBatis 能推断出具体传入语句的参数 支持基本数据类型和 JavaBean、Map 等复杂数据类型 resultType SQL 语句执行后返回的类型（全限定名或者别名）。如果是集合类型，返回的是集合元素的类型，返回时可以使用 resultType 或 resultMap 之一 - resultMap 它是映射集的引用，与 &lt;resultMap&gt; 元素一起使用，返回时可以使用 resultType 或 resultMap 之一 是 MyBatis 最复杂的元素，可以配置映射规则、级联、typeHandler 等 flushCache 用于设置在调用 SQL 语句后是否要求 MyBatis 清空之前查询的本地缓存和二级缓存 默认值为 false，如果设置为 true，则任何时候只要 SQL 语句被调用都将清空本地缓存和二级缓存 useCache 启动二级缓存的开关，默认值为 true，表示将査询结果存入二级缓存中 - timeout 用于设置超时参数，单位是秒（s），超时将抛出异常 - fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的 JDBC 驱动所设置的条数 statementType 告诉 MyBatis 使用哪个 JDBC 的 Statement 工作，取值为 STATEMENT（Statement）、 PREPARED（PreparedStatement）、CALLABLE（CallableStatement） - resultSetType 这是针对 JDBC 的 ResultSet 接口而言，其值可设置为 FORWARD_ONLY（只允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新）、SCROLLJNSENSITIVE（双向滚动，及时更新） - 传递多个参数现在需要根据 id 和 name 来模糊查询网站信息，显然这涉及到了两个参数。给映射器传递多个参数分为以下三种方法。 使用Map传递参数 使用注解传递参数 使用JavaBean传递参数 1. 使用Map传递参数使用 MyBatis 提供的 Map 接口作为参数实现，如下所示。 123456&lt;!-- 根据name和url模糊查询网站信息 --&gt;&lt;select id=&quot;selectWebsiteByMap&quot; resultType=&quot;net.biancheng.po.Website&quot; parameterType=&quot;map&quot;&gt; SELECT id,NAME,url FROM website WHERE name LIKE CONCAT (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) AND url LIKE CONCAT (&#x27;%&#x27;,#&#123;url&#125;,&#x27;%&#x27;)&lt;/select&gt; 在 WebsiteMapper 接口中，方法如下。 1public List&lt;Website&gt; selectWebsiteByMap(Map&lt;String, String&gt; params); 测试代码如下。 1234Map&lt;String,String&gt; paramsMap = new HashMap&lt;String,String&gt;();paramsMap.put(&quot;name&quot;,&quot;编程&quot;);paramsMap.put(&quot;url&quot;,&quot;biancheng&quot;);websiteMapper.selectWebsiteByMap(paramsMap); 使用 Map 传递参数虽然简单易用，但是由于这样设置参数需要键值对应，业务关联性不强，开发人员需要深入到程序中看代码，造成可读性下降。 2. 使用注解传递参数使用 MyBatis 的注解 @Param() 传递参数，如下所示。 123456&lt;!-- 根据name和url模糊查询网站信息 --&gt;&lt;select id=&quot;selectWebsiteByAn&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT id,NAME,url FROM website WHERE name LIKE CONCAT (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) AND url LIKE CONCAT (&#x27;%&#x27;,#&#123;url&#125;,&#x27;%&#x27;)&lt;/select&gt; WebsiteMapper 接口中方法如下。 1public List&lt;Website&gt; selectWebsiteByAn(@Param(&quot;name&quot;) String name, @Param(&quot;url&quot;) String url); 当我们把参数传递给后台时，MyBatis 通过 @Param 提供的名称就会知道 #{name} 代表 name 参数，提高了参数可读性。但是如果这条 SQL 拥有 10 个参数的查询，就会造成可读性下降，增强了代码复杂性。 3. 使用JavaBean传递参数在参数过多的情况下，MyBatis 允许组织一个 JavaBean，通过简单的 setter 和 getter 方法设置参数，提高可读性。如下所示。 123456&lt;!-- 根据name和url模糊查询网站信息 --&gt;&lt;select id=&quot;selectWebsiteByAn&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT id,NAME,url FROM website WHERE name LIKE CONCAT (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) AND url LIKE CONCAT (&#x27;%&#x27;,#&#123;url&#125;,&#x27;%&#x27;)&lt;/select&gt; WebsiteMapper 接口中方法如下。 1public List&lt;Website&gt; selectWebsiteByAn(Website website); 这就是通过 JavaBean 传递多个参数的方式。 区别以上 3 种方式的区别如下。 使用 Map 传递参数会导致业务可读性的丧失，继而导致后续扩展和维护的困难，所以在实际应用中我们应该果断废弃该方式。 使用 @Param 注解传递参数会受到参数个数的影响。当 n≤5 时，它是最佳的传参方式，因为它更加直观；当 n&gt;5 时，多个参数将给调用带来困难。 当参数个数大于 5 个时，建议使用 JavaBean 方式。 MyBatis insert标签MyBatis insert 标签用来定义插入语句，执行插入操作。当 MyBatis 执行完一条插入语句后，就会返回其影响数据库的行数。 1.修改 WebsiteMapper.xml，增加插入语句，代码如下。 12345&lt;!-- 增加网站信息 --&gt;&lt;insert id=&quot;addWebsite&quot; parameterType=&quot;string&quot;&gt; insert into website(name) values(#&#123;name&#125;)&lt;/insert&gt; 2.在 WebsiteMapper 接口中定义一个 add() 方法，代码如下。 1public int addWebsite(String name); 参数为 Sting 类型的字符串；返回值为 int 类型，即执行 SQL 后，插入记录的行数。 3.测试代码如下。 1234//插入 name 为编程帮4 的记录String name = &quot;编程帮4&quot;;int i = websiteMapper.addWebsite(name);System.out.println(&quot;共插入了 &quot; + i + &quot; 条记录&quot;); 4.执行测试代码，控制台输出如下。 1共插入了 1 条记录 insert 标签常用属性insert 标签中常用的属性如下表。 属性名称 描述 备注 id 它和 Mapper 的命名空间组合起来使用，是唯一标识符，供 MyBatis 调用 如果命名空间+ id 不唯一，那么 MyBatis 抛出异常 parameterType 传入 SQL 语句的参数类型的全限定名或别名，它是一个可选属性。 支持基本数据类型和 JavaBean、Map 等复杂数据类型 keyProperty 该属性的作用是将插入操作的返回值赋给 PO 类的某个属性，通常为主键对应的属性。如果是联合主键，可以将多个值用逗号隔开。 - useGeneratedKeys 该属性用来设置，是否使用 JDBC 提供的 getGenereatedKeys() 方法，获取数据库内部产生的主键并赋值到 keyProperty 属性设置的请求对象的属性中，例如 MySQL、SQL Server 等自动递增的字段，其默认值为 false。 该属性值设置为 true 后，会将数据库生成的主键回填到请求对象中，以供其他业务使用。 flushCache 该属性用于设置执行该操作后，是否会清空二级缓存和本地缓存，默认值为 true。 - timeout 该属性用于设置执行该操作的最大时限，如果超时，就抛异常。 - databaseId 取值范围 oracle、mysql 等，表示数据库厂家；元素内部可通过 来为特定数据库指定不同的 sql 语句。 MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 keyColumn 该属性用于设置第几列是主键，当主键列不是表中的第 1 列时，就需要设置该属性。如果是联合主键，可以将多个值用逗号隔开。 - 注意：insert 标签中没有 resultType 属性，只有查询操作才需要对返回结果类型进行相应的指定。 传递多个参数在上面的示例中，我们在插入语句中只使用了一个 String 类型的参数，而在实际的开发过程中，我们的插入语句往往需要使用多个参数，Mybatis 为我们提供以下 3 种方式，来实现给映射器传递多个参数： 使用 Map 传递参数 使用注解传递参数 使用 JavaBean 传递参数 使用 Map 传递参数我们可以将参数封装到一个 Map 对象中，然后传递给 MyBatis 的映射器，示例如下。 1.在 WebsiteMapper 接口中，定义一个 addWebsiteByMap() 方法，并使用 Map 传递参数，方法如下。 1int addWebsiteByMap(Map&lt;String, String&gt; params); 2.在 WebsiteMapper.xml 中，使用 insert 标签定义一条插入语句，并接收通过 Map 传递的参数，配置如下。 1234&lt;!--接收 Map 参数--&gt;&lt;insert id=&quot;addWebsiteByMap&quot; parameterType=&quot;map&quot;&gt; insert into Website (name, url) values (#&#123;name&#125;, #&#123;url&#125;)&lt;/insert&gt; 3.测试代码如下。 12345Map&lt;String, String&gt; params = new HashMap&lt;&gt;();params.put(&quot;name&quot;, &quot;编程帮&quot;);params.put(&quot;url&quot;, &quot;https://www.biancheng.net/&quot;);int i = websiteMapper.addWebsiteByMap(params);System.out.println(&quot;通过 Map 成功向数据库中添加了 &quot; + i + &quot; 条记录&quot;); 4.执行测试代码，控制台输出如下。 1通过 Map 成功向数据库中添加了 1 条记录 使用注解传递参数我们还可以使用 MyBatis 提供的 @Param 注解给注解器传递参数，示例代码如下。 1.在 WebsiteMapper 接口中，定义一个 addWebsiteByParam() 方法，并使用 @Param 注解传递参数，方法如下 1int addWebsiteByParam(@Param(&quot;name&quot;) String name, @Param(&quot;url&quot;) String url); 2.在 WebsiteMapper.xml 中使用 insert 标签定义一条插入语句，并接收通过 @Param 注解传递的参数，配置如下。 1234&lt;!--接收 @Param 注解传递的参数--&gt;&lt;insert id=&quot;addWebsiteByParam&quot;&gt; insert into Website (name, url) values (#&#123;name&#125;, #&#123;url&#125;)&lt;/insert&gt; 3.测试代码如下。 1int i = websiteMapper.addWebsiteByParam(&quot;bianchengbang&quot;, &quot;www.biancheng.net&quot;);System.out.println(&quot;通过 @Param 注解成功向数据库中添加了 &quot; + i + &quot; 条记录&quot;); 4.执行测试代码，控制台输出如下。 1通过 @Param 注解成功向数据库中添加了 1 条记录 使用 JavaBean 传递参数在参数过多的情况下，我们可以将参数通过 setter 方法封装到 JavaBean（实体类）对象中 ，传递给映射器。 1.在 WebsiteMapper 接口中,定义一个 addWebsiteByJavaBean() 方法，并使用 JavaBean 传递参数，方法如下。 1int addWebsiteByJavaBean(Website website); 2.在 WebsiteMapper.xml 中使用 insert 标签定义一条插入语句，并接收通过 JavaBean 传递的参数，配置如下。 1234&lt;!--接收通过 JavaBean 传递的参数--&gt;&lt;insert id=&quot;addWebsiteByJavaBean&quot; parameterType=&quot;net.biancheng.www.po.Website&quot;&gt; insert into Website (name, url) values (#&#123;name&#125;, #&#123;url&#125;)&lt;/insert&gt; 3.测试代码如下。 1234567//创建 JavaBean 对象Website website = new Website();//通过 setter 方法将参数封装website.setName(&quot;编程帮 JavaBean&quot;);website.setUrl(&quot;www.biancheng.net&quot;);int i = websiteMapper.addWebsiteByJavaBean(website);System.out.println(&quot;通过 JavaBean 成功向数据库中添加了 &quot; + i + &quot; 条记录&quot;); 4.执行测试代码，控制台输出如下。 1通过 JavaBean 成功向数据库中添加了 1 条记录 区别以上 3 种方式的区别如下： 使用 Map 传递参数会导致业务可读性的丧失，继而导致后续扩展和维护的困难，所以在实际应用中我们应该果断废弃该方式。 使用 @Param 注解传递参数会受到参数个数的影响。当 n≤5 时，它是最佳的传参方式，因为它更加直观；当 n&gt;5 时，多个参数将给调用带来困难。 当参数个数大于 5 个时，建议使用 JavaBean 方式。 主键（自动递增）回填我们知道，MySQL、SQL Server 等数据库表可以采用自动递增的字段作为其主键，当向这样的数据库表插入数据时，即使不指定自增主键的值，数据库也会根据自增规则自动生成主键并插入到表中。 一些特殊情况下，我们可能需要将这个刚刚生成的主键回填到请求对象（原本不包含主键信息的请求对象）中，供其他业务使用。此时，我们就可以通过在 insert 标签中添加 keyProperty 和 useGeneratedKeys 属性，来实现该功能。 下面我们通过一个示例，来演示主键（自动递增）回填功能。 1.为 WebsiteMapper.xml 中 id 为 addWebsite 的 insert 标签添加 keyProperty 和 useGeneratedKeys 属性，具体代码如下： 1234&lt;!--添加一个网站信息，成功后将主键值返回填给id(po的属性)--&gt;&lt;insert id=&quot;addWebsite&quot; parameterType=&quot;net.biancheng.po.Website&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into Website (name,url) values(#&#123;name&#125;,#&#123;url&#125;)&lt;/insert&gt; 2.测试代码如下： 12345678910// 添加一个网站信息Website addsite = new Website();//插入的对象中不包含主键 id addsite.setName(&quot;编程帮&quot;);addsite.setUrl(&quot;https://www.biancheng.net/&quot;);//执行插入int num = websiteMapper.addWebsite(addsite);System.out.println(&quot;添加了 &quot; + num + &quot; 条记录&quot;);//获取回填的主键System.out.println(&quot;添加记录的主键是:&quot; + addsite.getId()); 3.执行测试代码，控制台输出如下。 12添加了 1 条记录添加记录的主键是:3 自定义主键如果在实际项目中，若数据库不支持主键自动递增（例如 Oracle），或者取消了主键自动递增的规则，我们可以使用 MyBatis 的 &lt;selectKey&gt; 标签自定义生成主键，具体配置代码如下。 12345678&lt;!-- 添加一个网站，#&#123;name&#125;为 net.biancheng.po.Website 的属性值 --&gt;&lt;insert id=&quot;insertWebsite&quot; parameterType=&quot;net.biancheng.po.Website&quot;&gt; &lt;!-- 先使用selectKey标签定义主键，然后再定义SQL语句 --&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;Integer&quot; order=&quot;BEFORE&quot;&gt; select if(max(id) is null,1,max(id)+1) as newId from Website &lt;/selectKey&gt; insert into Website (id,name,url) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;url&#125;)&lt;/insert&gt; &lt;selectKey&gt; 标签中属性说明如下： keyProperty：用于指定主键值对应的 PO 类的属性。 order：该属性取值可以为 BEFORE 或 AFTER。BEFORE 表示先执行 标签内的语句，再执行插入语句；AFTER 表示先执行插入语句再执行 标签内的语句。 MyBatis update标签MyBatis update 标签用于定义更新语句，执行更新操作。当 MyBatis 执行完一条更新语句后，会返回一个整数，表示受影响的数据库记录的行数。 下面我们通过一个示例演示 update 标签的用法。 1.在 WebsiteMapper.xml 中添加以下更新语句，代码如下。 1234&lt;!--update 标签--&gt;&lt;update id=&quot;updateWebsite&quot; parameterType=&quot;string&quot;&gt; update website set name = #&#123;name&#125;&lt;/update&gt; 2.在 WebsiteMapper 接口中增加一个 updateWebsite() 方法，代码如下。 1int updateWebsite(String name); 参数为 String 类型的字符串；返回值为 int 类型，表示执行 sql 语句后受影响的记录的行数。 3.测试代码如下。 12int i = websiteMapper.updateWebsite(&quot;C语言中文网&quot;);System.out.println(&quot;共更新了 &quot; + i + &quot; 条记录&quot;); 4.执行测试代码，控制台输出如下。 1共更新了 9 条记录 通过控制台输出可知，该更新语句执行后，共影响了 9 条数据库记录。 update 标签常用属性update 标签常用属性如下表。 属性名称 描述 备注 id 它和 Mapper 的命名空间组合起来使用，是唯一标识符，供 MyBatis 调用 如果命名空间+ id 不唯一，那么 MyBatis 抛出异常 parameterType 传入 SQL 语句的参数类型的全限定名或别名，它是一个可选属性。 支持基本数据类型和 JavaBean、Map 等复杂数据类型 flushCache 该属性用于设置执行该操作后，是否会清空二级缓存和本地缓存，默认值为 true。 - timeout 该属性用于设置 SQL 执行的超时时间，如果超时，就抛异常。 - statementType 执行 SQL 时使用的 statement 类型, 默认为 PREPARED，可选值：STATEMENT，PREPARED 和 CALLABLE。 - 注意：update 标签中没有 resultType 属性，只有查询操作才需要对返回结果类型进行相应的指定。 MyBatis delete标签MyBatis delete 标签用于定义 delete 语句，执行删除操作。当 MyBatis 执行完一条更新语句后，会返回一个整数，表示受影响的数据库记录的行数。 下面我们通过一个示例演示 delete 标签的用法。 1.在 WebsiteMapper.xml 中使用 delete 标签添加一条 delete 语句，代码如下。 123&lt;delete id=&quot;deleteWebsite&quot; parameterType=&quot;string&quot;&gt; delete from website where name = #&#123;name&#125;&lt;/delete&gt; 2.在 WebsiteMapper 接口中增加一个 deleteWebsite() 方法，代码如下。 1int deleteWebsite(String name); 参数为 String 类型的字符串；返回值为 int 类型，表示执行 sql 语句后，被删除记录的行数。 3.测试代码如下。 1234//删除 name 为编程帮3 的记录String name = &quot;编程帮3&quot;;int i = websiteMapper.deleteWebsite(name);System.out.println(&quot;共删除了 &quot; + i + &quot; 条记录&quot;); 4.执行测试代码，控制台输出如下。 1共删除了 3 条记录 delete 标签常用属性delete 标签常用属性如下表。 属性名称 描述 备注 id 它和 Mapper 的命名空间组合起来使用，是唯一标识符，供 MyBatis 调用 如果命名空间+ id 不唯一，那么 MyBatis 抛出异常 parameterType 传入 SQL 语句的参数类型的全限定名或别名，它是一个可选属性。 支持基本数据类型和 JavaBean、Map 等复杂数据类型 flushCache 该属性用于设置执行该操作后，是否会清空二级缓存和本地缓存，默认值为 true。 - timeout 该属性用于设置 SQL 执行的超时时间，如果超时，就抛异常。 - statementType 执行 SQL 时使用的 statement 类型, 默认为 PREPARED，可选值：STATEMENT，PREPARED 和 CALLABLE。 - 注意：delete 标签中没有 resultType 属性，只有查询操作才需要对返回结果类型进行相应的指定。 MyBatis resultMap元素resultMap 是 MyBatis 中最复杂的元素，主要用于解决实体类属性名与数据库表中字段名不一致的情况，可以将查询结果映射成实体对象。下面我们先从最简单的功能开始介绍。 现有的 MyBatis 版本只支持 resultMap 查询，不支持更新或者保存，更不必说级联的更新、删除和修改。 resultMap元素的构成resultMap 元素还可以包含以下子元素，代码如下。 12345678910111213&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt; &lt;constructor&gt;&lt;!-- 类再实例化时用来注入结果到构造方法 --&gt; &lt;idArg/&gt;&lt;!-- ID参数，结果为ID --&gt; &lt;arg/&gt;&lt;!-- 注入到构造方法的一个普通结果 --&gt; &lt;/constructor&gt; &lt;id/&gt;&lt;!-- 用于表示哪个列是主键 --&gt; &lt;result/&gt;&lt;!-- 注入到字段或JavaBean属性的普通结果 --&gt; &lt;association property=&quot;&quot;/&gt;&lt;!-- 用于一对一关联 --&gt; &lt;collection property=&quot;&quot;/&gt;&lt;!-- 用于一对多、多对多关联 --&gt; &lt;discriminator javaType=&quot;&quot;&gt;&lt;!-- 使用结果值来决定使用哪个结果映射 --&gt; &lt;case value=&quot;&quot;/&gt;&lt;!-- 基于某些值的结果映射 --&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 其中： &lt;resultMap&gt; 元素的 type 属性表示需要的 POJO，id 属性是 resultMap 的唯一标识。 子元素 &lt;constructor&gt; 用于配置构造方法。当一个 POJO 没有无参数构造方法时使用。 子元素 &lt;id&gt; 用于表示哪个列是主键。允许多个主键，多个主键称为联合主键。 子元素 &lt;result&gt; 用于表示 POJO 和 SQL 列名的映射关系。 子元素 &lt;association&gt;、&lt;collection&gt; 和 &lt;discriminator&gt; 用在级联的情况下。关于级联的问题比较复杂 id 和 result 元素都有以下属性。 元素 说明 property 映射到列结果的字段或属性。如果 POJO 的属性和 SQL 列名（column元素）是相同的，那么 MyBatis 就会映射到 POJO 上 column 对应 SQL 列 javaType 配置 Java 类型。可以是特定的类完全限定名或 MyBatis 上下文的别名 jdbcType 配置数据库类型。这是 JDBC 类型，MyBatis 已经为我们做了限定，基本支持所有常用数据库类型 typeHandler 类型处理器。允许你用特定的处理器来覆盖 MyBatis 默认的处理器。需要指定 jdbcType 和 javaType 相互转化的规则 一条 SQL 查询语句执行后会返回结果集，结果集有两种存储方式，即使用 Map 存储和使用 POJO 存储。 使用Map存储结果集任何 select 语句都可以使用 Map 存储，代码如下。 1234&lt;!-- 查询所有网站信息存到Map中 --&gt;&lt;select id=&quot;selectAllWebsite&quot; resultType=&quot;map&quot;&gt; select * from website&lt;/select&gt; 在 WebsiteMapper 接口中添加以下方法。 1public List&lt;Map&lt;String,Object&gt;&gt; selectAllWebsite(); Map 的 key 是 select 语句查询的字段名（必须完全一样），而 Map 的 value 是查询返回结果中字段对应的值，一条记录映射到一个 Map 对象中。 使用 Map 存储结果集很方便，但可读性稍差，所以一般推荐使用 POJO 的方式。 使用POJO存储结果集因为 MyBatis 提供了自动映射，所以使用 POJO 存储结果集是最常用的方式。但有时候需要更加复杂的映射或级联，这时就需要使用 select 元素的 resultMap 属性配置映射集合。 修改 Website 类，代码如下。 12345678910111213141516package net.biancheng.po;import java.util.Date;public class Website &#123; private int id; private String uname; private String url; private int age; private String country; private Date createtime; /* setter和getter方法*/ @Override public String toString() &#123; return &quot;Website[id=&quot; + id + &quot;,uname=&quot; + uname + &quot;,url=&quot; + url + &quot;,age=&quot; + age + &quot;,country=&quot; + country + &quot;,createtime=&quot; + createtime + &quot;]&quot;; &#125;&#125; WebsiteMapper.xml 代码如下。 1234567&lt;!--使用自定义结果集类型 --&gt;&lt;resultMap type=&quot;net.biancheng.po.Website&quot; id=&quot;myResult&quot;&gt; &lt;!-- property 是 net.biancheng.po.Website 类中的属性 --&gt; &lt;!-- column是查询结果的列名，可以来自不同的表 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;uname&quot; column=&quot;name&quot; /&gt;&lt;/resultMap&gt; resultMap 元素的属性 id 代表这个 resultMap 的标识，type 标识需要映射的 POJO。我们可以使用 MyBatis 定义好的类的别名或自定义类的全限定名。 这里使用 property 元素指定 Website 的属性名称 uname，column 表示数据库中 website 表的 SQL 列名 name，将 POJO 和 SQL 的查询结果一 一对应。 WebsiteMapper.xml 中 select 元素配置代码如下。 123&lt;select id=&quot;selectAllWebsite&quot; resultMap=&quot;myResult&quot;&gt; select id,name,url from website&lt;/select&gt; 可以发现 SQL 语句的列名和 myResult 中的 column 一一对应。 resultType和resultMap的区别MyBatis 的每一个查询映射的返回类型都是 resultMap，只是当我们提供的返回类型是 resultType 时，MyBatis 会自动把对应的值赋给 resultType 所指定对象的属性，而当我们提供的返回类型是 resultMap 时，MyBatis 会将数据库中的列数据复制到对象的相应属性上，可用于复制查询。 需要注意的是，resultMap 和 resultType 不能同时使用。 MyBatis注解（3种类型）1. SQL 语句映射1）@Insert：实现新增功能12@Insert(&quot;insert into user(id,name) values(#&#123;id&#125;,#&#123;name&#125;)&quot;)public int insert(User user); 2）@Select：实现查询功能12345678@Select(&quot;Select * from user&quot;)@Results(&#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;name&quot;, property = &quot;name&quot;), @Result(column = &quot;sex&quot;, property = &quot;sex&quot;), @Result(column = &quot;age&quot;, property = &quot;age&quot;)&#125;)List&lt;User&gt; queryAllUser(); 3）@SelectKey：插入后，获取id的值以 MySQL 为例，MySQL 在插入一条数据后，使用 select last_insert_id() 可以获取到自增 id 的值。 123@Insert(&quot;insert into user(id,name) values(#&#123;id&#125;,#&#123;name&#125;)&quot;)@SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;, resultType = int,before = false)public int insert(User user); @SelectKey 各个属性含义如下。 statement：表示要运行的 SQL 语句； keyProperty：可选项，表示将查询结果赋值给代码中的哪个对象； keyColumn：可选项，表示将查询结果赋值给数据表中的哪一列； resultType：指定 SQL 语句的返回值； before：默认值为 true，在执行插入语句之前，执行 select last_insert_id()。值为 flase，则在执行插入语句之后，执行 select last_insert_id()。 4）@Insert：实现插入功能12@Insert(&quot;insert into user(name,sex,age) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;&quot;)int saveUser(User user); 5）@Update：实现更新功能12@Update(&quot;update user set name= #&#123;name&#125;,sex = #&#123;sex&#125;,age =#&#123;age&#125; where id = #&#123;id&#125;&quot;)void updateUserById(User user); 6）@Delete：实现删除功能12@Delete(&quot;delete from user where id =#&#123;id&#125;&quot;)void deleteById(Integer id); 7）@Param：映射多个参数@Param 用于在 Mapper 接口中映射多个参数。 12int saveUser(@Param(value=&quot;user&quot;) User user,@Param(&quot;name&quot;) String name,@Param(&quot;age&quot;) Int age); @Param 中的 value 属性可省略，用于指定参数的别名。 2. 结果集映射@Result、@Results、@ResultMap 是结果集映射的三大注解。 声明结果集映射关系代码： 1234567@Select(&#123;&quot;select id, name, class_id from student&quot;&#125;)@Results(id=&quot;studentMap&quot;, value=&#123; @Result(column=&quot;id&quot;, property=&quot;id&quot;, jdbcType=JdbcType.INTEGER, id=true), @Result(column=&quot;name&quot;, property=&quot;name&quot;, jdbcType=JdbcType.VARCHAR), @Result(column=&quot;class_id &quot;, property=&quot;classId&quot;, jdbcType=JdbcType.INTEGER)&#125;)List&lt;Student&gt; selectAll(); 下面为 @Results 各个属性的含义。 id：表示当前结果集声明的唯一标识； value：表示结果集映射关系； @Result：代表一个字段的映射关系。其中，column 指定数据库字段的名称，property 指定实体类属性的名称，jdbcType 数据库字段类型，id 为 true 表示主键，默认 false。 可使用 @ResultMap 来引用映射结果集，其中 value 可省略。 123@Select(&#123;&quot;select id, name, class_id from student where id = #&#123;id&#125;&quot;&#125;)@ResultMap(value=&quot;studentMap&quot;)Student selectById(Integer id); 这样不需要每次声明结果集映射时都复制冗余代码，简化开发，提高了代码的复用性。 3. 关系映射1）@one：用于一对一关系映射12345678@Select(&quot;select * from student&quot;) @Results(&#123; @Result(id=true,property=&quot;id&quot;,column=&quot;id&quot;), @Result(property=&quot;name&quot;,column=&quot;name&quot;), @Result(property=&quot;age&quot;,column=&quot;age&quot;), @Result(property=&quot;address&quot;,column=&quot;address_id&quot;,one=@One(select=&quot;net.biancheng.mapper.AddressMapper.getAddress&quot;)) &#125;) public List&lt;Student&gt; getAllStudents(); 2）@many：用于一对多关系映射1234567@Select(&quot;select * from t_class where id=#&#123;id&#125;&quot;) @Results(&#123; @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;class_name&quot;,property=&quot;className&quot;), @Result(property=&quot;students&quot;, column=&quot;id&quot;, many=@Many(select=&quot;net.biancheng.mapper.StudentMapper.getStudentsByClassId&quot;)) &#125;) public Class getClass(int id); MyBatis关联（级联）查询级联关系是一个数据库实体的概念，有 3 种级联关系，分别是一对一级联、一对多级联以及多对多级联。例如，一个角色可以分配给多个用户，也可以只分配给一个用户。大部分场景下，我们都需要获取角色信息和用户信息，所以会经常遇见以下 SQL。 1234SELECT r.*,u.* FROM t_role rINNER JOIN t_user_role ur ON r.id = ur.idINNER JOIN t_user u ON ur.user_id = u.idWHERE r.id = #&#123;id&#125; 在级联中存在 3 种对应关系。 一对多的关系，如角色和用户的关系。通俗的理解就是，一家软件公司会存在许多软件工程师，公司和软件工程师就是一对多的关系。 一对一的关系。每个软件工程师都有一个编号（ID），这是他在公司的标识，它与工程师是一对一的关系。 多对多的关系，有些公司一个角色可以对应多个用户，但是一个用户可以兼任多个角色。通俗的说，一个人既可以是总经理，同时也是技术总监，而技术总监这个职位可以对应多个人，这就是多对多的关系。 实际应用中，由于多对多的关系比较复杂，会增加理解和关联的复杂度，所以应用较少。推荐的方法是，用一对多的关系把它分解为双向关系，以降低关系的复杂度，简化程序。 级联的优点是获取关联数据十分便捷。但是级联过多会增加系统的复杂度，同时降低系统的性能，此增彼减。所以记录超过 3 层时，就不要考虑使用级联了，因为这样会造成多个对象的关联，导致系统的耦合、负载和难以维护。 MyBatis一对一关联查询一对一级联关系在现实生活中是十分常见的，例如一个大学生只有一个学号，一个学号只属于一个学生。同样，人与身份证也是一对一的级联关系。 在 MyBatis 中，通过 &lt;resultMap&gt; 元素的子元素 &lt;association&gt; 处理一对一级联关系。示例代码如下。 123&lt;association property=&quot;studentCard&quot; column=&quot;cardId&quot; javaType=&quot;net.biancheng.po.StudentCard&quot; select=&quot;net.biancheng.mapper.StudentCardMapper.selectStuCardById&quot; /&gt; 在 &lt;association&gt; 元素中通常使用以下属性。 property：指定映射到实体类的对象属性。 column：指定表中对应的字段（即查询返回的列名）。 javaType：指定映射到实体对象属性的类型。 select：指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询。 一对一关联查询可采用以下两种方式： 单步查询，通过关联查询实现 分步查询，通过两次或多次查询，为一对一关系的实体 Bean 赋值 示例下面以学生和学号为例讲解一对一关联查询的处理过程。 1）创建数据表创建 student（学生）和 studentcard（学号）数据表，SQL 语句如下。 1234567891011121314151617181920CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `sex` tinyint(4) DEFAULT NULL, `cardId` int(20) DEFAULT NULL, PRIMARY KEY (`id`), KEY `cardId` (`cardId`), CONSTRAINT `student_ibfk_1` FOREIGN KEY (`cardId`) REFERENCES `studentcard` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;insert into `student`(`id`,`name`,`sex`,`cardId`) values (1,&#x27;C语言中文网&#x27;,0,1),(2,&#x27;编程帮&#x27;,0,2),(3,&#x27;赵小红&#x27;,1,3),(4,&#x27;李晓明&#x27;,0,4),(5,&#x27;李紫薇&#x27;,1,5),(6,&#x27;钱百百&#x27;,0,NULL);DROP TABLE IF EXISTS `studentcard`;CREATE TABLE `studentcard` ( `id` int(20) NOT NULL AUTO_INCREMENT, `studentId` int(20) DEFAULT NULL, `startDate` date DEFAULT NULL, `endDate` date DEFAULT NULL, PRIMARY KEY (`id`), KEY `studentId` (`studentId`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;insert into `studentcard`(`id`,`studentId`,`startDate`,`endDate`) values (1,20200311,&#x27;2021-03-01&#x27;,&#x27;2021-03-11&#x27;),(2,20200314,&#x27;2021-03-01&#x27;,&#x27;2021-03-11&#x27;),(3,20200709,&#x27;2021-03-01&#x27;,&#x27;2021-03-11&#x27;),(4,20200508,&#x27;2021-03-01&#x27;,&#x27;2021-03-11&#x27;),(5,20207820,&#x27;2021-03-01&#x27;,&#x27;2021-03-11&#x27;); 2）创建持久化类在 myBatisDemo 应用的 net.biancheng.po 包下创建数据表对应的持久化类 Student 和 StudentCard。 Student 的代码如下： 123456789101112package net.biancheng.po;public class Student &#123; private int id; private String name; private int sex; private StudentCard studentCard; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, sex=&quot; + sex + &quot;, studentCard=&quot; + studentCard + &quot;]&quot;; &#125;&#125; StudentCard 的代码如下： 12345678910111213package net.biancheng.po;import java.util.Date;public class StudentCard &#123; private int id; private int studentId; private Date startDate; private Date endDate; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;StudentCard [id=&quot; + id + &quot;, studentId=&quot; + studentId + &quot;]&quot;; &#125;&#125; 分步查询新建 StudentCardMapper 类，代码如下。 12345package net.biancheng.mapper;import net.biancheng.po.StudentCard;public interface StudentCardMapper &#123; public StudentCard selectStuCardById(int id);&#125; StudentCardMapper.xml 对应映射 SQL 语句代码如下。 123456&lt;mapper namespace=&quot;net.biancheng.mapper.StudentCardMapper&quot;&gt; &lt;select id=&quot;selectStuCardById&quot; resultType=&quot;net.biancheng.po.StudentCard&quot;&gt; SELECT * FROM studentCard WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; StudentMapper 类方法代码如下。 123456package net.biancheng.mapper;import net.biancheng.po.Student;public interface StudentMapper &#123; public Student selectStuById1(int id); public Student selectStuById2(int id);&#125; StudentMapper.xml 代码如下。 12345678910111213141516&lt;mapper namespace=&quot;net.biancheng.mapper.StudentMapper&quot;&gt; &lt;!-- 一对一根据id查询学生信息：级联查询的第一种方法（嵌套查询，执行两个SQL语句） --&gt; &lt;resultMap type=&quot;net.biancheng.po.Student&quot; id=&quot;cardAndStu1&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot; /&gt; &lt;!-- 一对一级联查询 --&gt; &lt;association property=&quot;studentCard&quot; column=&quot;cardId&quot; javaType=&quot;net.biancheng.po.StudentCard&quot; select=&quot;net.biancheng.mapper.StudentCardMapper.selectStuCardById&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectStuById1&quot; parameterType=&quot;Integer&quot; resultMap=&quot;cardAndStu1&quot;&gt; select * from student where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试代码如下。 123456789public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); Student stu = ss.getMapper(StudentMapper.class).selectStuById1(2); System.out.println(stu); &#125;&#125; 单步查询在 StudentMapper.xml 中添加以下代码。 1234567891011121314151617&lt;resultMap type=&quot;net.biancheng.po.Student&quot; id=&quot;cardAndStu2&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot; /&gt; &lt;!-- 一对一级联查询 --&gt; &lt;association property=&quot;studentCard&quot; javaType=&quot;net.biancheng.po.StudentCard&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;studentId&quot; column=&quot;studentId&quot; /&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectStuById2&quot; parameterType=&quot;Integer&quot; resultMap=&quot;cardAndStu2&quot;&gt; SELECT s.*,sc.studentId FROM student s,studentCard sc WHERE s.cardId = sc.id AND s.id=#&#123;id&#125;&lt;/select&gt; 在 StudentMapper 中添加以下方法。 1public Student selectStuById2(int id); MyBatis一对多关联查询在实际生活中也有许多一对多级联关系，例如一个用户可以有多个订单，而一个订单只属于一个用户。同样，国家和城市也属于一对多级联关系。 在 MyBatis 中，通过 &lt;resultMap&gt; 元素的子元素 &lt;collection&gt; 处理一对多级联关系，collection 可以将关联查询的多条记录映射到一个 list 集合属性中。示例代码如下。 123&lt;collection property=&quot;orderList&quot; ofType=&quot;net.biancheng.po.Order&quot; column=&quot;id&quot; select=&quot;net.biancheng.mapper.OrderMapper.selectOrderById&quot; /&gt; 在 &lt;collection&gt; 元素中通常使用以下属性。 property：指定映射到实体类的对象属性。 column：指定表中对应的字段（即查询返回的列名）。 ofType：指定映射到实体对象属性的类型。 select：指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询。 一对多关联查询可采用以下两种方式： 分步查询，通过两次或多次查询，为一对多关系的实体 Bean 赋值 单步查询，通过关联查询实现 示例下面以用户和订单为例讲解一对多关联查询（实现“根据 id 查询用户及其关联的订单信息”的功能）的处理过程。 1）创建数据表本实例需要两张数据表，一张是用户表 user，一张是订单表 order，这两张表具有一对多的级联关系。SQL 语句如下： 1234567891011121314151617CREATE TABLE `order` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ordernum` int(25) DEFAULT NULL, `userId` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `userId` (`userId`), CONSTRAINT `order_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `user` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;insert into `order`(`id`,`ordernum`,`userId`) values (1,20200107,1),(2,20200806,2),(3,20206702,3),(4,20200645,1),(5,20200711,2),(6,20200811,2),(7,20201422,3),(8,20201688,4);DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `pwd` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;insert into `user`(`id`,`name`,`pwd`) values (1,&#x27;编程帮&#x27;,&#x27;123&#x27;),(2,&#x27;C语言中文网&#x27;,&#x27;456&#x27;),(3,&#x27;赵小红&#x27;,&#x27;123&#x27;),(4,&#x27;李晓明&#x27;,&#x27;345&#x27;),(5,&#x27;杨小胤&#x27;,&#x27;123&#x27;),(6,&#x27;谷小乐&#x27;,&#x27;789&#x27;); 2）创建持久化类创建持久化类 User 和 Order，代码分别如下。 12345678910111213package net.biancheng.po;import java.util.List;public class User &#123; private int id; private String name; private String pwd; private List&lt;Order&gt; orderList; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, orderList=&quot; + orderList + &quot;]&quot;; &#125;&#125; Order 类代码如下。 12345678910package net.biancheng.po;public class Order &#123; private int id; private int ordernum; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;Order [id=&quot; + id + &quot;, ordernum=&quot; + ordernum + &quot;]&quot;; &#125;&#125; 分步查询OrderMapper 类代码如下。 1public List&lt;Order&gt; selectOrderById(int id); OrderMapper.xml 中相应的映射 SQL 语句如下。 12345&lt;!-- 根据id查询订单信息 --&gt;&lt;select id=&quot;selectOrderById&quot; resultType=&quot;net.biancheng.po.Order&quot; parameterType=&quot;Integer&quot;&gt; SELECT * FROM `order` where userId=#&#123;id&#125;&lt;/select&gt; UserMapper 类代码如下。 1public User selectUserOrderById1(int id); UserMapper.xml 中相应的映射 SQL 语句如下。 1234567891011121314&lt;!-- 一对多 根据id查询用户及其关联的订单信息：级联查询的第一种方法（分步查询） --&gt;&lt;resultMap type=&quot;net.biancheng.po.User&quot; id=&quot;userAndOrder1&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;pwd&quot; column=&quot;pwd&quot; /&gt; &lt;!-- 一对多级联查询，ofType表示集合中的元素类型，将id传递给selectOrderById --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;net.biancheng.po.Order&quot; column=&quot;id&quot; select=&quot;net.biancheng.mapper.OrderMapper.selectOrderById&quot; /&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserOrderById1&quot; parameterType=&quot;Integer&quot; resultMap=&quot;userAndOrder1&quot;&gt; select * from user where id=#&#123;id&#125;&lt;/select&gt; 测试代码如下。 123456789public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); User us = ss.getMapper(UserMapper.class).selectUserOrderById1(1); System.out.println(us); &#125;&#125; 单步查询该种方式实现一对多关联查询需要修改 Order 持久化类，因为 Order 中的 id 不能和 User 中的 id 重复。 12345678910package net.biancheng.po;public class Order &#123; private int oId; private int ordernum; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;Order [id=&quot; + oId+ &quot;, ordernum=&quot; + ordernum + &quot;]&quot;; &#125;&#125; UserMapper 类代码如下。 1public User selectUserOrderById2(int id); UserMapper.xml 中相关映射 SQL 语句如下。 123456789101112131415161718&lt;!-- 一对多 根据id查询用户及其关联的订单信息：级联查询的第二种方法（单步查询） --&gt;&lt;resultMap type=&quot;net.biancheng.po.User&quot; id=&quot;userAndOrder2&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;pwd&quot; column=&quot;pwd&quot; /&gt; &lt;!-- 一对多级联查询，ofType表示集合中的元素类型 --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;net.biancheng.po.Order&quot;&gt; &lt;id property=&quot;oId&quot; column=&quot;oId&quot; /&gt; &lt;result property=&quot;ordernum&quot; column=&quot;ordernum&quot; /&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserOrderById2&quot; parameterType=&quot;Integer&quot; resultMap=&quot;userAndOrder2&quot;&gt; SELECT u.*,o.id as oId,o.ordernum FROM `user` u,`order` o WHERE u.id=o.`userId` AND u.id=#&#123;id&#125;&lt;/select&gt; 测试代码修改调用方法，如下。 123456789public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); User us = ss.getMapper(UserMapper.class).selectUserOrderById2(1); System.out.println(us); &#125;&#125; MyBatis多对多关联查询实际应用中，由于多对多的关系比较复杂，会增加理解和关联的复杂度，所以应用较少。MyBatis 没有实现多对多级联，推荐通过两个一对多级联替换多对多级联，以降低关系的复杂度，简化程序。 例如，一个订单可以有多种商品，一种商品可以对应多个订单，订单与商品就是多对多的级联关系。可以使用一个中间表（订单记录表）将多对多级联转换成两个一对多的关系。 示例下面以订单和商品（实现“查询所有订单以及每个订单对应的商品信息”的功能）为例讲解多对多关联查询。 1. 创建数据表创建 order（订单），product（商品）和 order_details（订单和商品中间表），SQL 语句如下。 12345678910111213141516171819202122232425CREATE TABLE `order` ( `oid` int(11) NOT NULL AUTO_INCREMENT, `ordernum` int(25) DEFAULT NULL, `userId` int(11) DEFAULT NULL, PRIMARY KEY (`oid`), KEY `userId` (`userId`), CONSTRAINT `order_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `user` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;insert into `order`(`oid`,`ordernum`,`userId`) values (1,20200107,1),(2,20200806,2),(3,20206702,3),(4,20200645,1),(5,20200711,2),(6,20200811,2),(7,20201422,3),(8,20201688,4),(9,NULL,5);DROP TABLE IF EXISTS `orders_detail`;CREATE TABLE `orders_detail` ( `id` int(11) NOT NULL AUTO_INCREMENT, `orderId` int(11) DEFAULT NULL, `productId` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;insert into `orders_detail`(`id`,`orderId`,`productId`) values (1,1,1),(2,1,2),(3,1,3),(4,2,3),(5,2,1),(6,3,2);DROP TABLE IF EXISTS `product`;CREATE TABLE `product` ( `pid` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(25) DEFAULT NULL, `price` double DEFAULT NULL, PRIMARY KEY (`pid`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;insert into `product`(`pid`,`name`,`price`) values (1,&#x27;Java教程&#x27;,128),(2,&#x27;C语言教程&#x27;,138),(3,&#x27;Python教程&#x27;,132.35); 2. 创建持久化类Order 类代码如下。 123456789101112package net.biancheng.po;import java.util.List;public class Order &#123; private int oid; private int ordernum; private List&lt;Product&gt; products; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;Order [id=&quot; + oid + &quot;, ordernum=&quot; + ordernum + &quot;, products=&quot; + products + &quot;]&quot;; &#125;&#125; Product 类方法如下。 1234567891011121314package net.biancheng.po;import java.util.List;public class Product &#123; private int pid; private String name; private Double price; // 多对多中的一个一对多 private List&lt;Order&gt; orders; /*省略setter和getter方法*/ @Override public String toString() &#123; return &quot;Product [id=&quot; + pid + &quot;, name=&quot; + name + &quot;, price=&quot; + price + &quot;]&quot;; &#125;&#125; 3. 创建接口和映射文件OrderMapper 接口代码如下。 123456package net.biancheng.mapper;import java.util.List;import net.biancheng.po.Order;public interface OrderMapper &#123; public List&lt;Order&gt; selectAllOrdersAndProducts();&#125; OrderMapper.xml 代码如下。 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;net.biancheng.mapper.OrderMapper&quot;&gt; &lt;resultMap type=&quot;net.biancheng.po.Order&quot; id=&quot;orderMap&quot;&gt; &lt;id property=&quot;oid&quot; column=&quot;oid&quot; /&gt; &lt;result property=&quot;ordernum&quot; column=&quot;ordernum&quot; /&gt; &lt;collection property=&quot;products&quot; ofType=&quot;net.biancheng.po.Product&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;pid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;price&quot; column=&quot;price&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectAllOrdersAndProducts&quot; parameterType=&quot;Integer&quot; resultMap=&quot;orderMap&quot;&gt; SELECT o.oid,o.`ordernum`,p.`pid`,p.`name`,p.`price` FROM `order` o INNER JOIN orders_detail od ON o.oid=od.`orderId` INNER JOIN product p ON p.pid = od.`productId` &lt;/select&gt;&lt;/mapper&gt; 4. 创建测试类测试类代码如下。 123456789101112131415161718192021package net.biancheng.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import net.biancheng.mapper.OrderMapper;import net.biancheng.po.Order;public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); List&lt;Order&gt; orderList = ss.getMapper(OrderMapper.class).selectAllOrdersAndProducts(); for (Order or : orderList) &#123; System.out.println(or); &#125; &#125;&#125; MyBatis动态SQL动态 SQL 是 MyBatis 的强大特性之一。在 JDBC 或其它类似的框架中，开发人员通常需要手动拼接 SQL 语句。根据不同的条件拼接 SQL 语句是一件极其痛苦的工作。例如，拼接时要确保添加了必要的空格，还要注意去掉列表最后一个列名的逗号。而动态 SQL 恰好解决了这一问题，可以根据场景动态的构建查询。 动态 SQL 只有几个基本元素，与 JSTL 或 XML 文本处理器相似，十分简单明了，大量的判断都可以在 MyBatis 的映射 XML 文件里配置，以达到许多需要大量代码才能实现的功能。 动态 SQL 大大减少了编写代码的工作量，更体现了 MyBatis 的灵活性、高度可配置性和可维护性。 MyBatis 也可以在注解中配置 SQL，但是由于注解功能受限，且对于复杂的 SQL 语句来说可读性差，所以使用较少。本教程不对它们进行介绍。 MyBatis 的动态 SQL 包括以下几种元素，如下表所示。 元素 作用 备注 if 判断语句 单条件分支判断 choose（when、otherwise） 相当于 Java 中的 switch case 语句 多条件分支判断 trim、where 辅助元素 用于处理一些SQL拼装问题 foreach 循环语句 在in语句等列举条件常用 bind 辅助元素 拼接参数 MyBatis if标签：条件判断if 语句使用方法简单，常常与 test 属性联合使用。语法如下。 123&lt;if test=&quot;判断条件&quot;&gt; SQL语句&lt;/if&gt; 当判断条件为 true 时，才会执行所包含的 SQL 语句。 最常见的场景是在 if 语句中包含 where 子句，例如。 123456&lt;select id=&quot;selectAllWebsite&quot; resultMap=&quot;myResult&quot;&gt; select id,name,url from website &lt;if test=&quot;name != null&quot;&gt; where name like #&#123;name&#125; &lt;/if&gt;&lt;/select&gt; 以上代表表示根据网站名称去查找相应的网站信息，但是网站名称是一个可填可不填的条件，不填写的时候不作为查询条件。 可多个 if 语句同时使用。以下语句表示为可以按照网站名称（name）或者网址（url）进行模糊查询。如果您不输入名称或网址，则返回所有的网站记录。但是，如果你传递了任意一个参数，它就会返回与给定参数相匹配的记录。 123456789&lt;select id=&quot;selectAllWebsite&quot; resultMap=&quot;myResult&quot;&gt; select id,name,url from website where 1=1 &lt;if test=&quot;name != null&quot;&gt; AND name like #&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;url!= null&quot;&gt; AND url like #&#123;url&#125; &lt;/if&gt;&lt;/select&gt; MyBatis choose、when和otherwise标签MyBatis 中动态语句 choose-when-otherwise 类似于 Java 中的 switch-case-default 语句。由于 MyBatis 并没有为 if 提供对应的 else 标签，如果想要达到&lt;if&gt;…&lt;else&gt;…&lt;&#x2F;else&gt; &lt;&#x2F;if&gt; 的效果，可以借助&lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt; 来实现。 动态语句 choose-when-otherwise 语法如下。 1234567891011121314&lt;choose&gt; &lt;when test=&quot;判断条件1&quot;&gt; SQL语句1 &lt;/when &gt; &lt;when test=&quot;判断条件2&quot;&gt; SQL语句2 &lt;/when &gt; &lt;when test=&quot;判断条件3&quot;&gt; SQL语句3 &lt;/when &gt; &lt;otherwise&gt; SQL语句4 &lt;/otherwise&gt;&lt;/choose&gt; choose 标签按顺序判断其内部 when 标签中的判断条件是否成立，如果有一个成立，则执行相应的 SQL 语句，choose 执行结束；如果都不成立，则执行 otherwise 中的 SQL 语句。这类似于 Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。 示例以下示例要求： 当网站名称不为空时，只用网站名称作为条件进行模糊查询； 当网站名称为空，而网址不为空时，则用网址作为条件进行模糊查询； 当网站名称和网址都为空时，则要求网站年龄不为空。 下面使用 choose-when-otherwise 标签实现 WebsiteMapper.xml 代码如下。 12345678910111213141516171819&lt;mapper namespace=&quot;net.biancheng.mapper.WebsiteMapper&quot;&gt; &lt;select id=&quot;selectWebsite&quot; parameterType=&quot;net.biancheng.po.Website&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT id,name,url,age,country FROM website WHERE 1=1 &lt;choose&gt; &lt;when test=&quot;name != null and name !=&#x27;&#x27;&quot;&gt; AND name LIKE CONCAT(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &lt;/when&gt; &lt;when test=&quot;url != null and url !=&#x27;&#x27;&quot;&gt; AND url LIKE CONCAT(&#x27;%&#x27;,#&#123;url&#125;,&#x27;%&#x27;) &lt;/when&gt; &lt;otherwise&gt; AND age is not null &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt;&lt;/mapper&gt; WebsiteMapper 类中方法如下。 1public List&lt;Website&gt; selectWebsite(Website website); 测试类代码如下。 123456789101112131415public class Test &#123; public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); Website site = new Website(); site.setname(&quot;编程&quot;); List&lt;Website&gt; siteList = ss.selectList(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsite&quot;, site); for (Website ws : siteList) &#123; System.out.println(ws); &#125; &#125;&#125; 这样 MyBatis 就会根据参数的设置进行判断来动态组装 SQL，以满足不同业务的要求。远比 Hibernate 和 JDBC 中大量判断 Java 代码要清晰和明确。 MyBatis where标签SQL 语句中加入了一个条件“1&#x3D;1”，如果没有加入这个条件，那么可能就会变成下面这样一条错误的语句。 1SELECT id,name,url,age,country FROM website AND name LIKE CONCAT(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) 显然以上语句会出现 SQL 语法异常，但加入“1&#x3D;1”这样的条件又非常奇怪，所以 MyBatis 提供了 where 标签。 where 标签主要用来简化 SQL 语句中的条件判断，可以自动处理 AND&#x2F;OR 条件，语法如下。 12345&lt;where&gt; &lt;if test=&quot;判断条件&quot;&gt; AND/OR ... &lt;/if&gt;&lt;/where&gt; if 语句中判断条件为 true 时，where 关键字才会加入到组装的 SQL 里面，否则就不加入。where 会检索语句，它会将 where 后的第一个 SQL 条件语句的 AND 或者 OR 关键词去掉。 示例要求：根据网站名称或网址对网站进行模糊查询。 WebsiteMapper.xml 代码如下。 1234567891011&lt;select id=&quot;selectWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; select id,name,url from website &lt;where&gt; &lt;if test=&quot;name != null&quot;&gt; AND name like #&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;url!= null&quot;&gt; AND url like #&#123;url&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; WebsiteMapper 类中方法如下。 1public List&lt;Website&gt; selectWebsite(Website website); 测试类代码如下。 123456789101112131415public class Test &#123; public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); Website site = new Website(); site.setname(&quot;编程&quot;); List&lt;Website&gt; siteList = ss.selectList(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsite&quot;, site); for (Website ws : siteList) &#123; System.out.println(ws); &#125; &#125;&#125; MyBatis set标签在 Mybatis 中，update 语句可以使用 set 标签动态更新列。set 标签可以为 SQL 语句动态的添加 set 关键字，剔除追加到条件末尾多余的逗号。 示例要求：根据 id 修改网站名称或网址。 WebsiteMapper.xml 代码如下。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;net.biancheng.mapper.WebsiteMapper&quot;&gt; &lt;select id=&quot;selectWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT * FROM website &lt;where&gt; &lt;if test=&quot;id!=null and id!=&#x27;&#x27;&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--使用set元素动态修改一个网站记录 --&gt; &lt;update id=&quot;updateWebsite&quot; parameterType=&quot;net.biancheng.po.Website&quot;&gt; UPDATE website &lt;set&gt; &lt;if test=&quot;name!=null&quot;&gt;name=#&#123;name&#125;&lt;/if&gt; &lt;if test=&quot;url!=null&quot;&gt;url=#&#123;url&#125;&lt;/if&gt; &lt;/set&gt; WHERE id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; WebsiteMapper 类中方法如下。 123456789package net.biancheng.mapper;import java.util.List;import org.apache.ibatis.annotations.Param;import net.biancheng.po.Website;public interface WebsiteMapper &#123; public List&lt;Website&gt; selectWebsite(Website site); public int updateWebsite(Website site);&#125; 测试类代码如下。 12345678910111213141516171819202122232425262728293031323334package net.biancheng.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import net.biancheng.mapper.WebsiteMapper;import net.biancheng.po.Website;public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); Website site = new Website(); site.setId(1); site.setUrl(&quot;www.biancheng.net&quot;); // 执行update语句前 List&lt;Website&gt; siteList = ss.getMapper(WebsiteMapper.class).selectWebsite(site); for (Website st : siteList) &#123; System.out.println(st); &#125; int num = ss.getMapper(WebsiteMapper.class).updateWebsite(site); System.out.println(&quot;影响数据库行数&quot; + num); // 执行update语句后 List&lt;Website&gt; siteList2 = ss.getMapper(WebsiteMapper.class).selectWebsite(site); for (Website st : siteList2) &#123; System.out.println(st); &#125; ss.commit(); ss.close(); &#125;&#125; MyBatis trim标签在 MyBatis 中除了使用 if+where 实现多条件查询，还有一个更为灵活的元素 trim 能够替代之前的做法。 trim 一般用于去除 SQL 语句中多余的 AND 关键字、逗号，或者给 SQL 语句前拼接 where、set 等后缀，可用于选择性插入、更新、删除或者条件查询等操作。trim 语法格式如下。 123&lt;trim prefix=&quot;前缀&quot; suffix=&quot;后缀&quot; prefixOverrides=&quot;忽略前缀字符&quot; suffixOverrides=&quot;忽略后缀字符&quot;&gt; SQL语句&lt;/trim&gt; trim 中属性说明如下。 属性 描述 prefix 给SQL语句拼接的前缀，为 trim 包含的内容加上前缀 suffix 给SQL语句拼接的后缀，为 trim 包含的内容加上后缀 prefixOverrides 去除 SQL 语句前面的关键字或字符，该关键字或者字符由 prefixOverrides 属性指定。 suffixOverrides 去除 SQL 语句后面的关键字或者字符，该关键字或者字符由 suffixOverrides 属性指定。 示例下面我们利用 trim 实现与 where 元素相同的效果。 要求：根据网站名称或网址对网站进行模糊查询。 WebsiteMapper.xml 代码如下。 123456789101112&lt;select id=&quot;selectWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT id,name,url,age,country FROM website &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;name != null and name !=&#x27;&#x27;&quot;&gt; AND name LIKE CONCAT (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;url!= null&quot;&gt; AND url like concat (&#x27;%&#x27;,#&#123;url&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; WebsiteMapper 类中方法如下。 1public List&lt;Website&gt; selectWebsite(Website website); 测试类代码如下。 12345678910111213141516public class Test &#123; public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); Website site = new Website(); site.setname(&quot;编程&quot;); site.setUrl(&quot;http&quot;); List&lt;Website&gt; siteList = ss.selectList(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsite&quot;, site); for (Website ws : siteList) &#123; System.out.println(ws); &#125; &#125;&#125; MyBatis foreach标签对于一些 SQL 语句中含有 in 条件，需要迭代条件集合来生成的情况，可以使用 foreach 来实现 SQL 条件的迭代。 Mybatis foreach 标签用于循环语句，它很好的支持了数据和 List、set 接口的集合，并对此提供遍历的功能。语法格式如下。 123&lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list|array|map key&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; 参数值&lt;/foreach&gt; foreach 标签主要有以下属性，说明如下。 item：表示集合中每一个元素进行迭代时的别名。 index：指定一个名字，表示在迭代过程中每次迭代到的位置。 open：表示该语句以什么开始（既然是 in 条件语句，所以必然以(开始）。 separator：表示在每次进行迭代之间以什么符号作为分隔符（既然是 in 条件语句，所以必然以,作为分隔符）。 close：表示该语句以什么结束（既然是 in 条件语句，所以必然以)开始）。 使用 foreach 标签时，最关键、最容易出错的是 collection 属性，该属性是必选的，但在不同情况下该属性的值是不一样的，主要有以下 3 种情况： 如果传入的是单参数且参数类型是一个 List，collection 属性值为 list。 如果传入的是单参数且参数类型是一个 array 数组，collection 的属性值为 array。 如果传入的参数是多个，需要把它们封装成一个 Map，当然单参数也可以封装成 Map。Map 的 key 是参数名，collection 属性值是传入的 List 或 array 对象在自己封装的 Map 中的 key。 示例WebsiteMapper.xml 中代码如下。 12345678910&lt;select id=&quot;selectWebsite&quot; parameterType=&quot;net.biancheng.po.Website&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT id,name,url,age,country FROM website WHERE age in &lt;foreach item=&quot;age&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;age&#125; &lt;/foreach&gt;&lt;/select&gt; WebsiteMapper 类中相应方法如下。 1public List&lt;Website&gt; selectWebsite(List&lt;Integer&gt; ageList); 测试代码如下。 12345678910111213141516public class Test &#123; public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); List&lt;Integer&gt; ageList = new ArrayList&lt;Integer&gt;(); ageList.add(10); ageList.add(12); List&lt;Website&gt; siteList = ss.selectList(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsite&quot;, ageList); for (Website ws : siteList) &#123; System.out.println(ws); &#125; &#125;&#125; MyBatis bind标签每个数据库的拼接函数或连接符号都不同，例如 MySQL 的 concat 函数、Oracle 的连接符号“||”等。这样 SQL 映射文件就需要根据不同的数据库提供不同的实现，显然比较麻烦，且不利于代码的移植。幸运的是，MyBatis 提供了 bind 标签来解决这一问题。 bind 标签可以通过 OGNL 表达式自定义一个上下文变量。 比如，按照网站名称进行模糊查询，SQL 映射文件如下。 123456&lt;select id=&quot;selectWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27;+_parameter+&#x27;%&#x27;&quot; /&gt; SELECT id,name,url,age,country FROM website WHERE name like #&#123;pattern&#125;&lt;/select&gt; bind 元素属性如下。 value：对应传入实体类的某个字段，可以进行字符串拼接等特殊处理。 name：给对应参数取的别名。 以上代码中的“_parameter”代表传递进来的参数，它和通配符连接后，赋给了 pattern，然后就可以在 select 语句中使用这个变量进行模糊查询，不管是 MySQL 数据库还是 Oracle 数据库都可以使用这样的语句，提高了可移植性。 大部分情况下需要传递多个参数，下面为传递多个参数时 bind 的用法示例。 示例WebsiteMapper 类中方法代码如下。 1public List&lt;Website&gt; selectWebsite(Website site); SQL 映射文件代码如下。 12345678&lt;select id=&quot;selectWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; &lt;bind name=&quot;pattern_name&quot; value=&quot;&#x27;%&#x27;+name+&#x27;%&#x27;&quot; /&gt; &lt;bind name=&quot;pattern_url&quot; value=&quot;&#x27;%&#x27;+url+&#x27;%&#x27;&quot; /&gt; SELECT id,name,url,age,country FROM website WHERE name like #&#123;pattern_name&#125; AND url like #&#123;pattern_url&#125;&lt;/select&gt; 测试代码如下。 12345678910111213141516public class Test &#123; public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); Website site = new Website(); site.setname(&quot;编程&quot;); site.setUrl(&quot;http&quot;); List&lt;Website&gt; siteList = ss.selectList(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsite&quot;, site); for (Website ws : siteList) &#123; System.out.println(ws); &#125; &#125;&#125; MyBatis分页功能MyBatis 的分页功能是基于内存的分页，即先查询出所有记录，再按起始位置和页面容量取出结果。 本节我们为查询网站记录增加分页功能，要求结果列表按照 id 升序排列。 WebsiteMapper 中方法如下。 1234567/*** @param site* @param currentPageNo 起始位置* @param pageSize 页面容量* @return*/public List&lt;Website&gt; selectWebsite(@Param(&quot;site&quot;) Website site, @Param(&quot;from&quot;) Integer currentPageNo, @Param(&quot;pageSize&quot;) Integer pageSize); 相比原来的 selectWebsite 方法，增加了两个参数，起始位置（from）和页面容量（pageSize），用于实现分页查询。 修改 WebsiteMapper.xml 的查询语句，增加 limit 关键字，SQL 映射代码如下。 12345678910111213&lt;select id=&quot;selectWebsite&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT id,name,url,age,country FROM website &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;site.name != null and site.name !=&#x27;&#x27;&quot;&gt; AND name LIKE CONCAT (&#x27;%&#x27;,#&#123;site.name&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;site.url!= null and site.url !=&#x27;&#x27;&quot;&gt; AND url LIKE CONCAT (&#x27;%&#x27;,#&#123;site.url&#125;,&#x27;%&#x27;) &lt;/if&gt; ORDER BY id limit #&#123;from&#125;,#&#123;pageSize&#125; &lt;/trim&gt;&lt;/select&gt; 测试类代码如下。 123456789101112131415161718public static void main(String[] args) throws IOException &#123; // 读取配置文件mybatis-config.xml InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); // 通过SqlSessionFactory创建SqlSession SqlSession ss = ssf.openSession(); Website site = new Website(); // site.setname(&quot;编程&quot;); site.setUrl(&quot;http&quot;); Integer pageSize = 3; Integer currentPageNo = 0; List&lt;Website&gt; siteList = new ArrayList&lt;Website&gt;(); siteList = ss.getMapper(WebsiteMapper.class).selectWebsite(site, currentPageNo, pageSize); for (Website ws : siteList) &#123; System.out.println(ws); &#125;&#125; 上述代码中，根据传入的起始位置（currentPageNo&#x3D;0）和页面容量（pageSize&#x3D;3）进行相应分页，查看第一页的数据列表，运行测试方法，输出正确的分页列表。 注意：MyBatis 实现分页查询属于 DAO 层操作，由于 DAO 层不牵涉任何业务实现，所以实现分页的方法中第一个参数为 limit 的起始位置（下标从 0 开始），而不是用户输入的真正页码（页码从1开始）。页码如何转换为 limit 的起始位置下标，即：起始位置下标&#x3D;（页码-1）*页面容量，那么这个转换操作必然不能在 DAO 层实现，需要在业务层实现。所以我们在测试类中传入的参数为下标，而不是页码。 MyBatis缓存（一级缓存和二级缓存）缓存可以将数据保存在内存中，是互联网系统常常用到的。目前流行的缓存服务器有 MongoDB、Redis、Ehcache 等。缓存是在计算机内存上保存的数据，读取时无需再从磁盘读入，因此具备快速读取和使用的特点。 和大多数持久化框架一样，MyBatis 提供了一级缓存和二级缓存的支持。默认情况下，MyBatis 只开启一级缓存。 一级缓存一级缓存是基于 PerpetualCache（MyBatis自带）的 HashMap 本地缓存，作用范围为 session 域内。当 session flush（刷新）或者 close（关闭）之后，该 session 中所有的 cache（缓存）就会被清空。 在参数和 SQL 完全一样的情况下，我们使用同一个 SqlSession 对象调用同一个 mapper 的方法，往往只执行一次 SQL。因为使用 SqlSession 第一次查询后，MyBatis 会将其放在缓存中，再次查询时，如果没有刷新，并且缓存没有超时的情况下，SqlSession 会取出当前缓存的数据，而不会再次发送 SQL 到数据库。 由于 SqlSession 是相互隔离的，所以如果你使用不同的 SqlSession 对象，即使调用相同的 Mapper、参数和方法，MyBatis 还是会再次发送 SQL 到数据库执行，返回结果。 示例在 WebsiteMapper 类中添加 selectWebsiteById 方法，代码如下。 1public Website selectWebsiteById(int id); WebsiteMapper.xml 中添加相应的映射 SQL 语句，代码如下。 12345&lt;select id=&quot;selectWebsiteById&quot; resultType=&quot;net.biancheng.po.Website&quot;&gt; SELECT * FROM website WHERE id=#&#123;id&#125;&lt;/select&gt; 测试代码如下。 12345678910111213141516171819202122232425262728package net.biancheng.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import net.biancheng.po.Website;public class Test &#123; public static Logger logger = Logger.getLogger(Test.class); public static void main(String[] args) throws IOException &#123; InputStream config = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); // 根据配置文件构建 SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config); SqlSession ss = ssf.openSession(); Website site = ss.selectOne(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsiteById&quot;, 1); logger.debug(&quot;使用同一个sqlsession再执行一次&quot;); Website site2 = ss.selectOne(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsiteById&quot;, 1); // 请注意，当我们使用二级缓存的时候，sqlSession调用了 commit方法后才会生效 ss.commit(); logger.debug(&quot;现在创建一个新的SqlSeesion对象在执行一次&quot;); SqlSession ss2 = ssf.openSession(); Website site3 = ss2.selectOne(&quot;net.biancheng.mapper.WebsiteMapper.selectWebsiteById&quot;, 1); // 请注意，当我们使用二级缓存的时候，sqlSession调用了 commit方法后才会生效 ss2.commit(); &#125;&#125; 运行结果如下。 12345678DEBUG [main] - ==&gt; Preparing: SELECT * FROM website WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - 使用同一个sqlsession再执行一次DEBUG [main] - 现在创建一个新的SqlSeesion对象在执行一次DEBUG [main] - ==&gt; Preparing: SELECT * FROM website WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1 从运行结果可以看出，第一个 SqlSession 实际只发生过一次查询，而第二次查询就从缓存中取出了，也就是 SqlSession 层面的一级缓存。为了克服这个问题，我们往往需要配置二级缓存，使得缓存在 SqlSessionFactory 层面上能够提供给各个 SqlSession 对象共享。 二级缓存二级缓存是全局缓存，作用域超出 session 范围之外，可以被所有 SqlSession 共享。 一级缓存缓存的是 SQL 语句，二级缓存缓存的是结果对象。 二级缓存的配置1）MyBatis 的全局缓存配置需要在 mybatis-config.xml 的 settings 元素中设置，代码如下。 123&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;&lt;/settings&gt; 2）在 mapper 文件（如 WebMapper.xml）中设置缓存，默认不开启缓存。需要注意的是，二级缓存的作用域是针对 mapper 的 namescape 而言，即只有再次在 namescape 内（net.biancheng.WebsiteMapper）的查询才能共享这个缓存，代码如下。 123456789&lt;mapper namescape=&quot;net.biancheng.WebsiteMapper&quot;&gt; &lt;!-- cache配置 --&gt; &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot; /&gt; ...&lt;/mapper&gt; 以上属性说明如下。 属性 说明 eviction 代表的是缓存回收策略，目前 MyBatis 提供以下策略。LRU：使用较少，移除最长时间不用的对象；FIFO：先进先出，按对象进入缓存的顺序来移除它们；SOFT：软引用，移除基于垃圾回收器状态和软引用规则的对象；WEAK：弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval 刷新间隔时间，单位为毫秒，这里配置的是 100 秒刷新，如果省略该配置，那么只有当 SQL 被执行的时候才会刷新缓存。 size 引用数目，正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是 1024 个对象。 readOnly 只读，默认值为 false，意味着缓存数据只能读取而不能修改，这样设置的好处是可以快速读取缓存，缺点是没有办法修改缓存。 3）在 mapper 文件配置支持 cache 后，如果需要对个别查询进行调整，可以单独设置 cache，代码如下。 12&lt;select id=&quot;getWebsiteList&quot; resultType=&quot;net.biancheng.po.Website&quot; usecache=&quot;true&quot;&gt; ...&lt;/select&gt; 对于 MyBatis 缓存仅作了解即可，因为面对一定规模的数据量，内置的 Cache 方式就派不上用场了，并且对查询结果集做缓存并不是 MyBatis 所擅长的，它专心做的应该是 SQL 映射。对于缓存，采用 OSCache、Memcached 等专门的缓存服务器来做更为合理。 MyBatis逆向工程Mybatis 提供了一个逆向工程工具，该工具可以根据数据表自动生成针对单表的 po 类、mapper 映射文件和 mapper 接口。大大缩减了开发时间，可以让开发人员将更多的精力放在繁杂的业务逻辑上。 之所以强调单表两个字，是因为 MyBatis 逆向工程生成的 Mapper 中的操作都是针对单表的。在大型项目中，很少有复杂的多表关联查询，所以该工具作用还是很大的。 1. 下载jar包jar包下载链接：https://github.com/mybatis/generator/releases。本节下载版本为 mybatis-generator-core-1.4.0。 maven 项目在 pom.xml 文件中添加以下代码。 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 2. 创建数据表创建 user、student、studentCard 和 website 数据表，SQL 语句如下。 123456789101112131415161718192021222324252627282930313233343536DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, `sex` tinyint(4) DEFAULT NULL, `cardId` int(20) DEFAULT NULL, PRIMARY KEY (`id`), KEY `cardId` (`cardId`), CONSTRAINT `student_ibfk_1` FOREIGN KEY (`cardId`) REFERENCES `studentcard` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `studentcard`;CREATE TABLE `studentcard` ( `id` int(20) NOT NULL AUTO_INCREMENT, `studentId` int(20) DEFAULT NULL, `startDate` date DEFAULT NULL, `endDate` date DEFAULT NULL, PRIMARY KEY (`id`), KEY `studentId` (`studentId`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `pwd` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `website`;CREATE TABLE `website` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) COLLATE utf8_unicode_ci NOT NULL, `url` varchar(30) COLLATE utf8_unicode_ci DEFAULT &#x27;&#x27;, `age` tinyint(3) unsigned NOT NULL, `country` char(3) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#x27;&#x27;, `createtime` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 3. 创建项目创建 NXProject 项目，导入所需 jar 包。 新建资源文件夹 config，在 config 文件夹下创建 genertorConfig.xml 文件，用于配置及指定数据库及表等。 注意：可以在已有的项目中进行逆向生成，也可以创建一个新项目。建议创建新项目，避免出现意外影响已有的项目。 genertorConfig.xml 配置文件代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!-- Mysql数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/test&quot; userId=&quot;root&quot; password=&quot;root&quot; /&gt; &lt;!-- 默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时 把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject：生成POJO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;net.biancheng.pojo&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject：mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;net.biancheng.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetProject：mapper接口生成的的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;net.biancheng.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据表 --&gt; &lt;table tableName=&quot;website&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;student&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;studentcard&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 创建 GeneratorSqlmap 类执行生成代码。 1234567891011121314151617181920212223242526272829package net.biancheng;import java.io.File;import java.util.*;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class GeneratorSqlmap &#123; public void generator() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; // 指定配置文件 File configFile = new File(&quot;./config/generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; // 执行main方法以生成代码 public static void main(String[] args) &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 项目结构如下图所示。 执行 GeneratorSqlmap 后刷新项目，项目结构如下。 可以看到在 pojo 包中，有一部分是名字为 XxxExample 的类。类中包含以下 3 个成员变量，如下。 123protected String orderByClause;protected boolean distinct;protected List&lt;Criteria&gt; oredCriteria; 以上变量说明如下： distinct 字段用于指定 DISTINCT 查询。 orderByClause 字段用于指定 ORDER BY 条件，这个条件没有构造方法，直接通过传递字符串值指定。 oredCriteria 字段用于自定义查询条件。","tags":["Java","数据库","MyBatis","SQL"],"categories":["学习"]},{"title":"spring+springmvc+springboot","path":"/fa9fbfbe/","content":"commons.logging-1.2.jar ClassPathXmlApplicationContext 1234567891011121314&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--spring将加载spring目录下的applicationContext.xml文件--&gt; &lt;param-value&gt; classpath:spring/applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; Spring 官方提供了 3 种方法实现初始化回调和销毁回调： 实现 InitializingBean 和 DisposableBean 接口； 在 XML 中配置 init-method 和 destory-method； 使用 @PostConstruct 和 @PreDestory 注解。 1234567&lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot;&gt; &lt;constructor-arg ref=&quot;man&quot; type=&quot;net.biancheng.Man&quot;/&gt; &lt;/bean&gt; 1234567&lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot;&gt; &lt;property name=&quot;man&quot; ref=&quot;man&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;bianchengbang&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot; /&gt; &lt;/bean&gt; 1）@Component2）@Repository3）@Service4）@Controller5）@Autowired6）@Resource7）@Qualifier12&lt;!--使用context命名空间，通知spring扫描指定目录，进行注解的解析 --&gt;&lt;context:component-scan base-package=&quot;net.biancheng&quot; /&gt; 123456789101112&lt;aop:config&gt; &lt;aop:aspect id=&quot;log&quot; ref=&quot;logging&quot;&gt; &lt;aop:pointcut id=&quot;selectAll&quot; expression=&quot;execution(* net.biancheng.*.*(..))&quot; /&gt; &lt;aop:before pointcut-ref=&quot;selectAll&quot; method=&quot;beforeAdvice&quot; /&gt; &lt;aop:after pointcut-ref=&quot;selectAll&quot; method=&quot;afterAdvice&quot; /&gt; &lt;aop:after-returning pointcut-ref=&quot;selectAll&quot; returning=&quot;retVal&quot; method=&quot;afterReturningAdvice&quot; /&gt; &lt;aop:after-throwing pointcut-ref=&quot;selectAll&quot; throwing=&quot;ex&quot; method=&quot;afterThrowingAdvice&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 123456789启用 @AspectJ 注解有以下两种方法：1）使用@Configuration和@EnableAspectJAutoProxy注解@Configuration@EnableAspectJAutoProxypublic class Appconfig &#123;&#125;2）基于XML配置在 XML 文件中添加以下内容启用 @AspectJ。&lt;aop:aspectj-autoproxy&gt; 123456789101112131415161718192021222324252627&lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--数据库驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--连接数据库的url --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/test&quot; /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--默认必须使用数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;userdao&quot; class=&quot;net.biancheng.UserDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt; &lt;/bean&gt; 1234567891011121314151617&lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; readOnly = &quot;false&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt; &lt;aop:config&gt; &lt;!-- 切入点，execution 定义的表达式表示net.biencheng包下的所有类所有方法都应用该是事务 --&gt; &lt;aop:pointcut id=&quot;createOperation&quot; expression=&quot;execution(* net.biancheng.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;createOperation&quot; /&gt; &lt;/aop:config&gt; 1）在 Spring 容器中注册驱动，代码如下所示：1234&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;!-- 注册事务管理驱动 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 123456789101112131415&lt;!-- 部署 DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt; &lt;!--不能省略--&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 1234567&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt; &lt;!--可以省略--&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 1234&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;fm_&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;&lt;/bean&gt; 12&lt;!-- 使用扫描机制扫描控制器类，控制器类都在net.biancheng.controller包及其子包下 --&gt;&lt;context:component-scan base-package=&quot;net.biancheng.controller&quot; /&gt; RequestMapping注解1. value 属性符匹配，如 @RequestMapping(value&#x3D;”toUser&#x2F;*”) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问。 2. path属性path 属性支持通配符匹配，如 @RequestMapping(path&#x3D;”toUser&#x2F;*”) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问。 3. name属性name属性相当于方法的注释，使方法更易理解。如 @RequestMapping(value &#x3D; “toUser”,name &#x3D; “获取用户信息”)。 4. method属性@RequestMapping(value &#x3D; “toUser”,method &#x3D; RequestMethod.GET) 5. params属性1@RequestMapping(value = &quot;toUser&quot;,params = &quot;type&quot;) 表示请求中必须包含 type 参数时才能执行该请求。即 http://localhost:8080/toUser?type=xxx 能够正常访问 toUser() 方法，而 http://localhost:8080/toUser 则不能正常访问 toUser() 方法。 6. header属性@RequestMapping(value &#x3D; “toUser”,headers &#x3D; “Referer&#x3D;http://www.xxx.com“) 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“http://www.xxx.com”时，才能执行该请求。 7. consumers属性consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如：application&#x2F;json、text&#x2F;html。如@RequestMapping(value &#x3D; “toUser”,consumes &#x3D; “application&#x2F;json”)。 8.produces属性@RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json,charset&#x3D;utf-8”)，表示返回 utf-8 编码。 2）请求处理方法常见的返回类型请求处理方法可以返回如下类型的对象： ModelAndView Model 包含模型属性的 Map View 代表逻辑视图名的 String void 其它任意Java类型 1234567891011&lt;context:component-scan base-package=&quot;net.biancheng&quot; /&gt;&lt;mvc:annotation-driven /&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!--后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 12345678910111213141516171819202122232425262728&lt;mvc:annotation-driven&gt;&lt;!--配置@ResponseBody由fastjson解析 --&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot; /&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;mvc:default-servlet-handler /&gt;&lt;bean id=&quot;fastJsonpResponseBodyAdvice&quot; class=&quot;com.alibaba.fastjson.support.spring.FastJsonpResponseBodyAdvice&quot;&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;callback&lt;/value&gt; &lt;value&gt;jsonp&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- annotation-driven用于简化开发的配置，注解DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter --&gt;&lt;!-- 使用resources过滤掉不需要dispatcherservlet的资源（即静态资源，例如css、js、html、images）。 在使用resources时必须使用annotation-driven，否则resources元素会阻止任意控制器被调用 --&gt;&lt;!-- 允许js目录下的所有文件可见 --&gt;&lt;mvc:resources location=&quot;/&quot; mapping=&quot;/**&quot; /&gt; 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javaScript&quot;&gt; function testJson() &#123; var name = $(&quot;#name&quot;).val(); var password = $(&quot;#password&quot;).val(); var age = $(&quot;#age&quot;).val(); $.ajax(&#123; //请求路径 url : &quot;$&#123;pageContext.request.contextPath&#125;/testJson&quot;, //请求类型 type : &quot;post&quot;, //data表示发送的数据 data : JSON.stringify(&#123; name : name, password : password, age : age &#125;), //定义发送请求的数据格式为JSON字符串 contentType : &quot;application/json;charset=utf-8&quot;, //定义回调响应的数据格式为JSON字符串，该属性可以省略 dataType : &quot;json&quot;, //成功响应的结果 success : function(data) &#123; if (data != null) &#123; alert(&quot;输入的用户名：&quot; + data.name + &quot;，密码：&quot; + data.password + &quot;， 年龄：&quot; + data.age); &#125; &#125; &#125;); &#125;&lt;/script&gt; 12345678910111213141516171819&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!-- 配置一个全局拦截器，拦截所有请求 --&gt; &lt;bean class=&quot;net.biancheng.interceptor.TestInterceptor&quot; /&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器作用的路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;!-- 配置不需要拦截作用的路径 --&gt; &lt;mvc:exclude-mapping path=&quot;&quot; /&gt; &lt;!-- 定义&lt;mvc:interceptor&gt;元素中，表示匹配指定路径的请求才进行拦截 --&gt; &lt;bean class=&quot;net.biancheng.interceptor.Interceptor1&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器作用的路径 --&gt; &lt;mvc:mapping path=&quot;/gotoTest&quot; /&gt; &lt;!-- 定义在&lt;mvc:interceptor&gt;元素中，表示匹配指定路径的请求才进行拦截 --&gt; &lt;bean class=&quot;net.biancheng.interceptor.Interceptor2&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; Spring MVC 有以下 3 种处理异常的方式： 使用 Spring MVC 提供的简单异常处理器 SimpleMappingExceptionResolver。 实现 Spring 的异常处理接口 HandlerExceptionResolver，自定义自己的异常处理器。 使用 @ExceptionHandler 注解实现异常处理 123456789101112public class MyExceptionHandler implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) &#123; Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;(); // 根据不同错误转向不同页面（统一处理），即异常与View的对应关系 if (arg3 instanceof ArithmeticException) &#123; return new ModelAndView(&quot;error&quot;, model); &#125; return new ModelAndView(&quot;error-2&quot;, model); &#125;&#125; 在 springmvc-servlet.xml 文件中添加以下代码。 12&lt;!--托管MyExceptionHandler--&gt;&lt;bean class=&quot;net.biancheng.exception.MyExceptionHandler&quot;/&gt; 12345678910111213&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 定义默认的异常处理页面，当该异常类型注册时使用 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;&gt;&lt;/property&gt; &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常页名作为值 --&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;!-- 在这里还可以继续扩展对不同异常类型的处理 --&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; GET：表示获取资源 POST：表示新建资源 PUT：表示更新资源 DELETE：表示删除资源 由于 HTTP 不支持 PUT 和 DELETE 请求，所以需要将 DELETE 和 PUT 请求转换成 POST 请求，在 web.xml 中配置过滤器 HiddenHttpMethodFilter。 123456789&lt;!-- HiddenHttpMethodFilter过滤器可以将POST请求转化为put请求和delete请求! --&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 123456&lt;!-- 发送PUT和DELETE请求时，需要添加一个隐藏域 --&gt; &lt;h4&gt;发送PUT请求&lt;/h4&gt; &lt;form action=&quot; user/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;PUT&quot; /&gt; &lt;/form&gt; MultipartResolver接口MultpartiResolver 接口有以下两个实现类： StandardServletMultipartResolver：使用了 Servlet 3.0 标准的上传方式。 CommonsMultipartResolver：使用了 Apache 的 commons-fileupload 来完成具体的上传操作。 commons-io-2.4.jar 和 commons-fileupload-1.2.2.jar 123456&lt;!-- 配置MultipartResolver，用于上传文件，使用spring的CommonsMultipartResolver --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;&lt;/bean&gt; 表单的 enctype 属性指定的是表单数据的编码方式，该属性有以下 3 个值。 application&#x2F;x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的 value 属性值。 multipart&#x2F;form-data：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里。 text&#x2F;plain：该编码方式只有当表单的 action 属性为“mailto：”URL 的形式时才使用，主要适用于直接通过表单发送邮件的方式。 12345678910111213141516171819202122@RequestMapping(&quot;/multifile&quot;)public String multiFileUpload(@ModelAttribute MultiFileDomain multiFileDomain, HttpServletRequest request) &#123; String realpath = request.getServletContext().getRealPath(&quot;uploadfiles&quot;); File targetDir = new File(realpath); if (!targetDir.exists()) &#123; targetDir.mkdirs(); &#125; List&lt;MultipartFile&gt; files = multiFileDomain.getMyfile(); System.out.println(&quot;files&quot;+files); for (int i = 0; i &lt; files.size(); i++) &#123; MultipartFile file = files.get(i); String fileName = file.getOriginalFilename(); File targetFile = new File(realpath, fileName); // 上传 try &#123; file.transferTo(targetFile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return &quot;showMulti&quot;;&#125; 设置报头的示例如下： 12response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;);response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+filename); 12server: port: 8081 YAML 的语法如下： 使用缩进表示层级关系。 缩进时不允许使用 Tab 键，只允许使用空格。 缩进的空格数不重要，但同级元素必须左侧对齐。 大小写敏感。 12345678spring: profiles: dev datasource: url: jdbc:mysql://127.0.01/banchengbang_springboot username: root password: root driver-class-name: com.mysql.jdbc.Driver 1234website: name: bianchengbang url: www.biancheng.netwebsite: &#123;name: bianchengbang,url: www.biancheng.net&#125; 12345pets: -dog -cat -pigpets: [dog,cat,pig] 123456789101112person: name: zhangsan age: 30 pets: -dog -cat -pig car: name: QQ child: name: zhangxiaosan age: 2 12345---website: name: bianchengbang url: www.biancheng.net--- SpringBoot 提供了以下 2 种方式进行配置绑定： 使用 @ConfigurationProperties 注解 使用 @Value 注解 @ConfigurationProperties12345@Component@ConfigurationProperties(prefix = &quot;person&quot;) @Value(&quot;$&#123;person.lastName&#125;&quot;) private String lastName; @PropertySource123person.properties 的配置如下。person.last-name=李四person.age=12 123@PropertySource(value = &quot;classpath:person.properties&quot;)//指向对应的配置文件@Component@ConfigurationProperties(prefix = &quot;person&quot;) @ImportResource 导入 Spring 配置文件1234//将 beans.xml 加载到项目中@ImportResource(locations = &#123;&quot;classpath:/beans.xml&quot;&#125;)@SpringBootApplicationpublic class HelloworldApplication&#123;&#125; 多 Profile 文件方式123456application-&#123;profile&#125;.properties/yml#默认端口号server.port=8080#激活指定的profilespring.profiles.active=prod 123456789101112131415#默认配置server: port: 8080#切换配置spring: profiles: active: dev #激活开发环境配置---#开发环境server: port: 8081spring: config: activate: on-profile: dev 123mvn clean packagejava -jar helloworld-0.0.1-SNAPSHOT.jar --spring.profiles.active=devjava -Dspring.profiles.active=prod -jar helloworld-0.0.1-SNAPSHOT.jar 默认配置文件 file:.&#x2F;config&#x2F; file:.&#x2F;config&#x2F;*&#x2F; file:.&#x2F; classpath:&#x2F;config&#x2F; classpath:&#x2F; 注：file: 指当前项目根目录；classpath: 指当前项目的类路径，即 resources 目录。 12345#项目更目录下#上下文路径为 /abcserver: servlet: context-path: /abc 除了默认配置文件，Spring Boot 还可以加载一些位于项目外部的配置文件。我们可以通过如下 2 个参数，指定外部配置文件的路径： spring.config.location spring.config.additional-location 12345java -jar &#123;JAR&#125; --spring.config.location=&#123;外部配置文件全路径&#125;java -jar springbootdemo-0.0.1-SNAPSHOT.jar --spring.config.location=D:\\myConfig\\my-application.ymljava -jar &#123;JAR&#125; --spring.config.additional-location=&#123;外部配置文件全路径&#125;java -jar springbootdemo-0.0.1-SNAPSHOT.jar --spring.config.additional-location=D:\\myConfig\\my-application.yml Spring Boot 配置优先级以下是常用的 Spring Boot 配置形式及其加载顺序（优先级由高到低）： 命令行参数 来自 java:comp&#x2F;env 的 JNDI 属性 Java 系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource 配置的 random.* 属性值 配置文件（YAML 文件、Properties 文件） @Configuration 注解类上的 @PropertySource 指定的配置文件 通过 SpringApplication.setDefaultProperties 指定的默认属性 12java -jar &#123;Jar文件名&#125; --&#123;参数1&#125;=&#123;参数值1&#125; --&#123;参数2&#125;=&#123;参数值2&#125;java -jar springbootdemo-0.0.1-SNAPSHOT.jar --server.port=8081 --server.servlet.context-path=/bcb 这些配置文件得优先级顺序，遵循以下规则： 先加载 JAR 包外的配置文件，再加载 JAR 包内的配置文件； 先加载 config 目录内的配置文件，再加载 config 目录外的配置文件； 先加载 config 子目录下的配置文件，再加载 config 目录下的配置文件； 先加载 appliction-{profile}.properties&#x2F;yml，再加载 application.properties&#x2F;yml； 先加载 .properties 文件，再加载 .yml 文件。 Spring Factories 机制1234org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition SpringFactoriesLoader 有（loadFactories()与loadFactoryNames()方法）–&gt;META-INF&#x2F;spring.factories loadFactoryNames() 中调用loadSpringFactories()方法能够读取该项目中所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件的配置内容，并以 Map 集合的形式返回 @SpringBootApplication 注解@SpringBootConfiguration 和 @EnableAutoConfiguration和@ComponentScan注解 @EnableAutoConfiguration 注解@Import 注解通过 AutoConfigurationImportSelector类（选择器）给容器中导入自动配置组件 AutoConfigurationImportSelector 类实现了 DeferredImportSelector 接口，还包含一个静态内部类 AutoConfigurationGroup，它实现了 DeferredImportSelector 接口的内部接口 Group（Spring 5 新增）。 AutoConfigurationImportSelector 内各方法执行顺序如下。 getImportGroup() 方法 process() 方法 selectImports() 方法 2. process() 方法该方法通过调用 getAutoConfigurationEntry() 方法读取 spring.factories 文件中的内容，获得自动配置类的集合 getAutoConfigurationEntry() 方法通过调用 getCandidateConfigurations() 方法来获取自动配置类的完全限定名，并在经过排除、过滤等处理后，将其缓存到成员变量中 在 getCandidateConfigurations() 方法中，根据 Spring Factories 机制调用 SpringFactoriesLoader 的 loadFactoryNames() 方法，根据 EnableAutoConfiguration.class （自动配置接口）获取其实现类（自动配置类）的类名的集合 AutoConfigurationImportSelector.AutoConfigurationGroup#selectImports() 会将 process() 方法处理后得到的自动配置类，进行过滤、排除，最后将所有自动配置类添加到容器中。 如下表。 注解 生效条件 @ConditionalOnBean 容器中存在指定的 Bean 时生效 @ConditionalOnMissingBean 容器中不存在指定的 Bean 时生效 @ConditionalOnClass 存在指定的类时生效 @ConditionalOnMissingClass 不存在指定的类时生效 @ConditionalOnResource 类路径下存在指定的资源文件时生效 @ConditionalOnWebApplication 当前应用是 web 应用时生效 @ConditionalOnNotWebApplication 当前应用不是 web 应用生效 Spring Boot 选用 SLF4J + Logback 的组合来搭建日志系统。 123Logger logger = LoggerFactory.getLogger(this.class);//调用 sl4j 的 info() 方法，而非调用 logback 的方法logger.info(&quot;Hello World&quot;); SLF4J+Log4j : slf4j-log4j12.jar SLF4J+JUL : slf4j-jdk14.jar 优先级依次升高 : trace-&gt;debug-&gt;info-&gt;warn-&gt;error 12345678910#日志级别logging.level.net.biancheng.www=trace#使用相对路径的方式设置日志输出的位置（项目根目录目录\\my-log\\mylog\\spring.log）#logging.file.path=my-log/myLog#绝对路径方式将日志文件输出到 【项目所在磁盘根目录\\springboot\\logging\\my\\spring.log】logging.file.path=/spring-boot/logging#控制台日志输出格式logging.pattern.console=%d&#123;yyyy-MM-dd hh:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#日志文件输出格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === - %msg%n 扩展 Spring MVC1234567891011//实现 WebMvcConfigurer 接口可以来扩展 SpringMVC 的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //当访问 “/” 或 “/index.html” 时，都直接跳转到登陆页面 registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); &#125;&#125; Spring Boot 通过配置类 ErrorMvcAutoConfiguration 对异常处理提供了自动配置，该配置类向容器中注入了以下 4 个组件。 ErrorPageCustomizer：该组件会在在系统发生异常后，默认将请求转发到“&#x2F;error”上。 BasicErrorController：处理默认的“&#x2F;error”请求。 DefaultErrorViewResolver：默认的错误视图解析器，将异常信息解析到相应的错误视图上。 DefaultErrorAttributes：用于页面上共享异常信息。 ErrorMvcAutoConfiguration 向容器中注入了一个名为 ErrorPageCustomizer 的组件，它主要用于定制错误页面的响应规则。 registerErrorPages() 错误控制器组件 BasicErrorController 我们可以通过以下 3 种方式定制 Spring Boot 错误页面： 自定义 error.html 自定义动态错误页面 自定义静态错误页面 自定义动态错误页面（精确匹配）&gt;自定义静态错误页面（精确匹配）&gt;自定义动态错误页面（模糊匹配）&gt;自定义静态错误页面（模糊匹配）&gt;自定义 error.html。 被 @ControllerAdvice 注解的类可以用来实现全局异常处理，这是 Spring MVC 中提供的功能，在 Spring Boot 中可以直接使用。 1234567891011121314@ControllerAdvicepublic class MyExceptionHandler &#123; @ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //向 request 对象传入错误状态码 request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); //根据当前处理的异常，自定义的错误数据 map.put(&quot;code&quot;, &quot;user.notexist&quot;); map.put(&quot;message&quot;, e.getMessage()); //将自定的错误数据传入 request 域中 request.setAttribute(&quot;ext&quot;,map); return &quot;forward:/error&quot;; &#125;","tags":["Java","Spring","SpringMVC","SpingBoot"],"categories":["学习"]},{"title":"SpringBoot","path":"/6f2612a2/","content":"SpringBootSpring Boot是什么Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。 Spring Boot 集成了大量常用的第三方库配置，Spring Boot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。 Spring Boot 提供了大量开箱即用（out-of-the-box）的依赖模块，例如 spring-boot-starter-redis、spring-boot-starter-data-mongodb 和 spring-boot-starter-data-elasticsearch 等。这些依赖模块为 Spring Boot 应用提供了大量的自动配置，使得 Spring Boot 应用只需要非常少量的配置甚至零配置，便可以运行起来，让开发人员从 Spring 的“配置地狱”中解放出来，有更多的精力专注于业务逻辑的开发。 Spring Boot 的特点Spring Boot 具有以下特点： 1. 独立运行的 Spring 项目Spring Boot 可以以 jar 包的形式独立运行，Spring Boot 项目只需通过命令“ java–jar xx.jar” 即可运行。 2. 内嵌 Servlet 容器Spring Boot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty 或者 Undertow 等），应用无需打成 WAR 包 。 3. 提供 starter 简化 Maven 配置Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。 4. 提供了大量的自动配置Spring Boot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。 5. 自带应用监控Spring Boot 可以对正在运行的项目提供监控。 6. 无代码生成和 xml 配置Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。 Spring Boot starter入门传统的 Spring 项目想要运行，不仅需要导入各种依赖，还要对各种 XML 配置文件进行配置，十分繁琐，但 Spring Boot 项目在创建完成后，即使不编写任何代码，不进行任何配置也能够直接运行，这都要归功于 Spring Boot 的 starter 机制。本节我们将对 stater 进行介绍。 starterSpring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的 starter（启动器），starter 中整合了该场景下各种可能用到的依赖，用户只需要在 Maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启动相应的默认配置。starter 提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些 starter 都遵循着约定成俗的默认配置，并允许用户调整这些配置，即遵循“约定大于配置”的原则。 并不是所有的 starter 都是由 Spring Boot 官方提供的，也有部分 starter 是第三方技术厂商提供的，例如 druid-spring-boot-starter 和 mybatis-spring-boot-starter 等等。当然也存在个别第三方技术，Spring Boot 官方没提供 starter，第三方技术厂商也没有提供 starter。 以 spring-boot-starter-web 为例，它能够为提供 Web 开发场景所需要的几乎所有依赖，因此在使用 Spring Boot 开发 Web 项目时，只需要引入该 Starter 即可，而不需要额外导入 Web 服务器和其他的 Web 依赖。 在 pom.xml 中引入 spring-boot-starter-web，示例代码如下。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--SpringBoot父项目依赖管理--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; .... &lt;dependencies&gt; &lt;!--导入 spring-boot-starter-web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt; ...&lt;/project&gt; 在该项目中执行以下 mvn 命令查看器依赖树。 1mvn dependency:tree 我们可以看到 Spring Boot 导入了 springframework、logging、jackson 以及 Tomcat 等依赖，而这些正是我们在开发 Web 项目时所需要的。 版本信息是由 spring-boot-starter-parent（版本仲裁中心） 统一控制的。 spring-boot-starter-parentspring-boot-starter-parent 是所有 Spring Boot 项目的父级依赖，它被称为 Spring Boot 的版本仲裁中心，可以对项目内的部分常用依赖进行统一管理。 1234567&lt;!--SpringBoot父项目依赖管理--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; Spring Boot 项目可以通过继承 spring-boot-starter-parent 来获得一些合理的默认配置，它主要提供了以下特性： 默认 JDK 版本（Java 8） 默认字符集（UTF-8） 依赖管理功能 资源过滤 默认插件配置 识别 application.properties 和 application.yml 类型的配置文件 查看 spring-boot-starter- parent 的底层代码，可以发现其有一个父级依赖 spring-boot-dependencies。 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt;&lt;/parent&gt; spring-boot-dependencies 的底层代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; .... &lt;properties&gt; &lt;activemq.version&gt;5.16.1&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.88&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.15.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.18.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; .... &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-amqp&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-blueprint&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;build-helper-maven-plugin.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;flyway.version&#125;&lt;/version&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 以上配置中，部分元素说明如下： dependencyManagement ：负责管理依赖； pluginManagement：负责管理插件； properties：负责定义依赖或插件的版本号。 spring-boot-dependencies 通过 dependencyManagement 、pluginManagement 和 properties 等元素对一些常用技术框架的依赖或插件进行了统一版本管理，例如 Activemq、Spring、Tomcat 等。 YAML教程（快速入门版）Spring Boot 提供了大量的自动配置，极大地简化了spring 应用的开发过程，当用户创建了一个 Spring Boot 项目后，即使不进行任何配置，该项目也能顺利的运行起来。当然，用户也可以根据自身的需要使用配置文件修改 Spring Boot 的默认设置。 SpringBoot 默认使用以下 2 种全局的配置文件，其文件名是固定的。 application.properties application.yml 其中，application.yml 是一种使用 YAML 语言编写的文件，它与 application.properties 一样，可以在 Spring Boot 启动时被自动读取，修改 Spring Boot 自动配置的默认值。 YAML 简介YAML 全称 YAML Ain’t Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。 想要使用 YAML 作为属性配置文件（以 .yml 或 .yaml 结尾），需要将 SnakeYAML 库添加到 classpath 下，Spring Boot 中的 spring-boot-starter-web 或 spring-boot-starter 都对 SnakeYAML 库做了集成， 只要项目中引用了这两个 Starter 中的任何一个，Spring Boot 会自动添加 SnakeYAML 库到 classpath 下。 12server: port: 8081 YAML 语法YAML 的语法如下： 使用缩进表示层级关系。 缩进时不允许使用 Tab 键，只允许使用空格。 缩进的空格数不重要，但同级元素必须左侧对齐。 大小写敏感。 1234567spring: profiles: dev datasource: url: jdbc:mysql://127.0.01/banchengbang_springboot username: root password: root driver-class-name: com.mysql.jdbc.Driver YAML 常用写法YAML 支持以下三种数据结构： 对象：键值对的集合 数组：一组按次序排列的值 字面量：单个的、不可拆分的值 YAML 字面量写法字面量是指单个的，不可拆分的值，例如：数字、字符串、布尔值、以及日期等。 在 YAML 中，使用“key:[空格]value”的形式表示一对键值对（空格不能省略），如 url: www.biancheng.net。 字面量直接写在键值对的“value”中即可，且默认情况下字符串是不需要使用单引号或双引号的。 1name: bianchengbang 若字符串使用单引号，则会转义特殊字符。 1name: zhangsan lisi 输出结果为： 1zhangsan lisi 若字符串使用双引号，则不会转义特殊字符，特殊字符会输出为其本身想表达的含义 1name: zhangsan lisi 输出结果为： 12zhangsan lisi YAML 对象写法在 YAML 中，对象可能包含多个属性，每一个属性都是一对键值对。YAML 为对象提供了 2 种写法： 普通写法，使用缩进表示对象与属性的层级关系。 123website: name: bianchengbang url: www.biancheng.net 行内写法： 1website: &#123;name: bianchengbang,url: www.biancheng.net&#125; YAML 数组写法YAML 使用“-”表示数组中的元素，普通写法如下： 1234pets: -dog -cat -pig 行内写法： 1pets: [dog,cat,pig] 复合结构以上三种数据结构可以任意组合使用，以实现不同的用户需求，例如： 123456789101112person: name: zhangsan age: 30 pets: -dog -cat -pig car: name: QQ child: name: zhangxiaosan age: 2 YAML 组织结构一个 YAML 文件可以由一个或多个文档组成，文档之间使用“—”作为分隔符，且个文档相互独立，互不干扰。如果 YAML 文件只包含一个文档，则“—”分隔符可以省略。 123456789101112131415---website: name: bianchengbang url: www.biancheng.net---website: &#123;name: bianchengbang,url: www.biancheng.net&#125;pets: -dog -cat -pig---pets: [dog,cat,pig]name: &quot;zhangsan lisi&quot;---name: &#x27;zhangsan lisi&#x27; Spring Boot配置绑定所谓“配置绑定”就是把配置文件中的值与 JavaBean 中对应的属性进行绑定。通常，我们会把一些配置信息（例如，数据库配置）放在配置文件中，然后通过 Java 代码去读取该配置文件，并且把配置文件中指定的配置封装到 JavaBean（实体类） 中。 SpringBoot 提供了以下 2 种方式进行配置绑定： 使用 @ConfigurationProperties 注解 使用 @Value 注解 @ConfigurationProperties通过 Spring Boot 提供的 @ConfigurationProperties 注解，可以将全局配置文件中的配置数据绑定到 JavaBean 中。下面我们以 Spring Boot 项目 helloworld 为例，演示如何通过 @ConfigurationProperties 注解进行配置绑定。 1.在 helloworld 的全局配置文件 application.yml 中添加以下自定义属性。 123456789101112person: lastName: 张三 age: 18 boss: false birth: 1990/12/12 maps: &#123; k1: v1,k2: 12 &#125; lists: ‐ lisi ‐ zhaoliu dog: name: 迪迪 age: 5 2.在 helloworld 项目中创建一个名为 Person 的实体类，并将配置文件中的属性映射到这个实体类上，代码如下。 123456789101112131415161718/*** 将配置文件中配置的每一个属性的值，映射到这个组件中* @ConfigurationProperties：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；* prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；*/@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; ...&#125; 注意： 只有在容器中的组件，才会拥有 SpringBoot 提供的强大功能。如果我们想要使用 @ConfigurationProperties 注解进行配置绑定，那么首先就要保证该对 JavaBean 对象在 IoC 容器中，所以需要用到 @Component 注解来添加组件到容器中。 JavaBean 上使用了注解 @ConfigurationProperties(prefix &#x3D; “person”) ，它表示将这个 JavaBean 中的所有属性与配置文件中以“person”为前缀的配置进行绑定。 2.创建一个名为 Dog 的 JavaBean，代码如下。 12345public class Dog &#123; private String name; private String age; ...&#125; 3.修改 HelloController 的代码，在浏览器中展示配置文件中各个属性值，代码如下。 12345678910@Controllerpublic class HelloController &#123; @Autowired private Person person; @ResponseBody @RequestMapping(&quot;/hello&quot;) public Person hello() &#123; return person; &#125;&#125; 4.重启项目，使用浏览器访问 “http://localhost:8081/hello” @Value当我们只需要读取配置文件中的某一个配置时，可以通过 @Value 注解获取。 1.以 Spring Boot 项目 helloworld 为例，修改实体类 Person 中的代码，使用 @Value 注解进行配置绑定，代码如下。 123456789101112131415@Componentpublic class Person &#123; @Value(&quot;$&#123;person.lastName&#125;&quot;) private String lastName; @Value(&quot;$&#123;person.age&#125;&quot;) private Integer age; @Value(&quot;$&#123;person.boss&#125;&quot;) private Boolean boss; @Value(&quot;$&#123;person.birth&#125;&quot;) private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; ...&#125; 重启项目，使用浏览器访问 “http://localhost:8081/hello” @Value 与 @ConfigurationProperties 对比@Value 和 @ConfigurationProperties 注解都能读取配置文件中的属性值并绑定到 JavaBean 中，但两者存在以下不同。 1. 使用位置不同 @ConfigurationProperties：标注在 JavaBean 的类名上； @Value：标注在 JavaBean 的属性上。 2. 功能不同 @ConfigurationProperties：用于批量绑定配置文件中的配置； @Value：只能一个一个的指定需要绑定的配置。 3. 松散绑定支持不同@ConfigurationProperties：支持松散绑定（松散语法），例如实体类 Person 中有一个属性为 lastName，那么配置文件中的属性名支持以下写法： person.firstName person.first-name person.first_name PERSON_FIRST_NAME @Vaule：不支持松散绑定。 4. SpEL 支持不同 @ConfigurationProperties：不支持 SpEL 表达式; @Value：支持 SpEL 表达式。 5. 复杂类型封装 @ConfigurationProperties：支持所有类型数据的封装，例如 Map、List、Set、以及对象等； @Value：只支持基本数据类型的封装，例如字符串、布尔值、整数等类型。 6. 应用场景不同@Value 和 @ConfigurationProperties 两个注解之间，并没有明显的优劣之分，它们只是适合的应用场景不同而已。 若只是获取配置文件中的某项值，则推荐使用 @Value 注解； 若专门编写了一个 JavaBean 来和配置文件进行映射，则建议使用 @ConfigurationProperties 注解。 我们在选用时，根据实际应用场景选择合适的注解能达到事半功倍的效果。 @PropertySource如果将所有的配置都集中到 application.properties 或 application.yml 中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 Spring Boot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。 1.以 helloworld 为例，将与 person 相关的自定义配置移动到 src&#x2F;main&#x2F;resources 下的 person.properties 中（注意，必须把 application.properties 或 application.yml 中的相关配置删除）。 person.properties 的配置如下。 123456789person.last-name=李四person.age=12person.birth=2000/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=dogperson.dog.age=2 2.在 Person 使用 @PropertySource 注解指向 person.properties，代码如下。 12345678910111213@PropertySource(value = &quot;classpath:person.properties&quot;)//指向对应的配置文件@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; ...&#125; 3.重启项目，使用浏览器访问 “http://localhost:8081/hello” Spring Boot导入Spring配置Spring Boot 为了我们提供了以下 2 种方式来导入 Spring 配置： 使用 @ImportResource 注解加载 Spring 配置文件 使用全注解方式加载 Spring 配置 @ImportResource 导入 Spring 配置文件在主启动类上使用 @ImportResource 注解可以导入一个或多个 Spring 配置文件，并使其中的内容生效。 1.以 helloworld 为例，创建一个名为 PersonService 的接口，代码如下。 123public interface PersonService &#123; public Person getPersonInfo();&#125; 2.创建一个名为 PersonServiceImpl 的类，并实现 PersonService 接口，代码如下。 12345678public class PersonServiceImpl implements PersonService &#123; @Autowired private Person person; @Override public Person getPersonInfo() &#123; return person; &#125;&#125; 3.在该项目的 resources 下添加一个名为 beans.xml 的 Spring 配置文件，配置代码如下。 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;personService&quot; class=&quot;net.biancheng.www.service.impl.PersonServiceImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 4.修改该项目的单元测试类 HelloworldApplicationTests ，校验 IOC 容器是否已经 personService，代码如下。 12345678910111213141516171819202122@SpringBootTestclass HelloworldApplicationTests &#123; @Autowired Person person; //IOC 容器 @Autowired ApplicationContext ioc; @Test public void testHelloService() &#123; //校验 IOC 容器中是否包含组件 personService boolean b = ioc.containsBean(&quot;personService&quot;); if (b) &#123; System.out.println(&quot;personService 已经添加到 IOC 容器中&quot;); &#125; else &#123; System.out.println(&quot;personService 没添加到 IOC 容器中&quot;); &#125; &#125; @Test void contextLoads() &#123; System.out.println(person); &#125;&#125; 6.运行单元测试代码，结果如下图。 7.在主启动程序类上使用 @ImportResource 注解，将 Spring 配置文件 beans.xml 加载到项目中，代码如下。 12345678//将 beans.xml 加载到项目中@ImportResource(locations = &#123;&quot;classpath:/beans.xml&quot;&#125;)@SpringBootApplicationpublic class HelloworldApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloworldApplication.class, args); &#125;&#125; 8.再次执行测试代码，结果如下图。 1](https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203120956139.png) 全注解方式加载 Spring 配置Spring Boot 推荐我们使用全注解的方式加载 Spring 配置，其实现方式如下： 使用 @Configuration 注解定义配置类，替换 Spring 的配置文件； 配置类内部可以包含有一个或多个被 @Bean 注解的方法，这些方法会被 AnnotationConfigApplicationContext 或 AnnotationConfigWebApplicationContext 类扫描，构建 bean 定义（相当于 Spring 配置文件中的&lt;bean&gt;&lt;/bean&gt;标签），方法的返回值会以组件的形式添加到容器中，组件的 id 就是方法名。 以 helloworld 为例，删除主启动类的 @ImportResource 注解，添加一个名为 MyAppConfig 的配置类，代码如下。 1234567891011121314151617/*** @Configuration 注解用于定义一个配置类，相当于 Spring 的配置文件* 配置类中包含一个或多个被 @Bean 注解的方法，该方法相当于 Spring 配置文件中的 &lt;bean&gt; 标签定义的组件。*/@Configurationpublic class MyAppConfig &#123; /** * 与 &lt;bean id=&quot;personService&quot; class=&quot;PersonServiceImpl&quot;&gt;&lt;/bean&gt; 等价 * 该方法返回值以组件的形式添加到容器中 * 方法名是组件 id（相当于 &lt;bean&gt; 标签的属性 id) */ @Bean public PersonService personService() &#123; System.out.println(&quot;在容器中添加了一个组件:peronService&quot;); return new PersonServiceImpl(); &#125;&#125; 执行测试代码。 Spring Boot Profile（多环境配置）在实际的项目开发中，一个项目通常会存在多个环境，例如，开发环境、测试环境和生产环境等。不同环境的配置也不尽相同，例如开发环境使用的是开发数据库，测试环境使用的是测试数据库，而生产环境使用的是线上的正式数据库。 Profile 为在不同环境下使用不同的配置提供了支持，我们可以通过激活、指定参数等方式快速切换环境。 多 Profile 文件方式Spring Boot 的配置文件共有两种形式：.properties 文件和 .yml 文件，不管哪种形式，它们都能通过文件名的命名形式区分出不同的环境的配置，文件命名格式为： 1application-&#123;profile&#125;.properties/yml 其中，{profile} 一般为各个环境的名称或简称，例如 dev、test 和 prod 等等。 properties 配置在 helloworld 的 src&#x2F;main&#x2F;resources 下添加 4 个配置文件： application.properties：主配置文件 application-dev.properties：开发环境配置文件 application-test.properties：测试环境配置文件 application-prod.properties：生产环境配置文件 在 applcation.properties 文件中，指定默认服务器端口号为 8080，并通过以下配置激活生产环境（prod）的 profile。 1234#默认端口号server.port=8080#激活指定的profilespring.profiles.active=prod 在 application-dev.properties 中，指定开发环境端口号为 8081，配置如下 12# 开发环境server.port=8081 在 application-test.properties 中，指定测试环境端口号为 8082，配置如下。 12# 测试环境server.port=8082 在 application-prod.properties 中，指定生产环境端口号为 8083，配置如下。 12# 生产环境server.port=8083 yml 配置与 properties 文件类似，我们也可以添加 4 个配置文件： application.yml：默认配置 application-dev.yml：开发环境配置 application-test.yml：测试环境配置 application-prod.yml：生产环境配置 在 applcation.yml 文件中指定默认服务端口号为 8080，并通过以下配置来激活开发环境的 profile。 1234567#默认配置server: port: 8080\t#切换配置\tspring: profiles: active: dev #激活开发环境配置 在 application-dev.yml 中指定开发环境端口号为 8081，配置如下。 123#开发环境server: port: 8081 在 application-test.yml 中指定测试环境端口号为 8082，配置如下。 123#测试环境server: port: 8082 在 application-prod.yml 中指定生产环境端口号为 8083，配置如下。 123#生产环境server: port: 8083 多 Profile 文档块模式在 YAML 配置文件中，可以使用“—”把配置文件分割成了多个文档块，因此我们可以在不同的文档块中针对不同的环境进行不同的配置，并在第一个文档块内对配置进行切换。 以 helloworld 项目为例，修改 application.yml ，配置多个文档块，并在第一文档快内激活测试环境的 Profile，代码如下。 12345678910111213141516171819202122232425262728293031#默认配置server: port: 8080#切换配置spring: profiles: active: test---#开发环境server: port: 8081spring: config: activate: on-profile: dev---#测试环境server: port: 8082spring: config: activate: on-profile: test---#生产环境server: port: 8083spring: config: activate: on-profile: prod 激活 Profile除了可以在配置文件中激活指定 Profile，Spring Boot 还为我们提供了另外 2 种激活 Profile 的方式： 命令行激活 虚拟机参数激活 命令行激活我们可以将 Spring Boot 项目打包成 JAR 文件，并在通过命令行运行时，配置命令行参数，激活指定的 Profile。 我们还以 helloworld 为例，执行以下 mvn 命令将项目打包。 1mvn clean package 项目打包完成，打开命令行窗口，跳转到 JAR 文件所在目录，执行以下命令，启动该项目，并激活开发环境（dev）的 Profile。 1java -jar helloworld-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev 以上命令中，–spring.profiles.active&#x3D;dev 为激活开发环境（dev）Profile 的命令行参数。 虚拟机参数激活我们还可以在 Spring Boot 项目运行时，指定虚拟机参数来激活指定的 Profile。 以 helloworld 为例，将该项目打包成 JAR 文件后，打开命令行窗口跳转到 JAR 所在目录，执行以下命令，激活生产环境（prod）Profile。 1java -Dspring.profiles.active=prod -jar helloworld-0.0.1-SNAPSHOT.jar 以上命令中，-Dspring.profiles.active&#x3D;prod 为激活生产环境（prod）Profile 的虚拟机参数。 Spring Boot默认配置文件默认配置文件Spring Boot 项目中可以存在多个 application.properties 或 apllication.yml。 Spring Boot 启动时会扫描以下 5 个位置的 application.properties 或 apllication.yml 文件，并将它们作为 Spring boot 的默认配置文件。 file:./config/ file:./config/*/ file:./ classpath:/config/ classpath:/ 注：file: 指当前项目根目录；classpath: 指当前项目的类路径，即 resources 目录。 以上所有位置的配置文件都会被加载，且它们优先级依次降低，序号越小优先级越高。其次，位于相同位置的 application.properties 的优先级高于 application.yml。 所有位置的文件都会被加载，高优先级配置会覆盖低优先级配置，形成互补配置，即： 存在相同的配置内容时，高优先级的内容会覆盖低优先级的内容； 存在不同的配置内容时，高优先级和低优先级的配置内容取并集。 示例创建一个名为 springbootdemo 的 Spring Boot 项目，并在当前项目根目录下、类路径下的 config 目录下、以及类路径下分别创建一个配置文件 application.yml，该项目结构如下图。 项目根路径下配置文件 application.yml 配置如下。 12345#项目更目录下#上下文路径为 /abcserver: servlet: context-path: /abc 项目类路径下 config 目录下配置文件 application.yml 配置如下。 1234567#类路径下的 config 目录下#端口号为8084#上下文路径为 /helloWorldserver: port: 8084 servlet: context-path: /helloworld 项目类路径下的 application.yml 配置如下。 123#默认配置server: port: 8080 创建一个名为 MyController 的类，代码如下。 123456789@RestControllerpublic class MyController &#123; @ResponseBody @RequestMapping(&quot;/test&quot;) public String hello() &#123; return &quot;hello Spring Boot!&quot;; &#125;&#125; 根据 Spring Boot 默认配置文件优先级进行分析： 该项目中存在多个默认配置文件，其中根目录下 &#x2F;config 目录下的配置文件优先级最高，因此项目的上下文路径为 “&#x2F;abc”； 类路径（classpath）下 config 目录下的配置文件优先级高于类路径下的配置文件，因此该项目的端口号为 “8084”； 以上所有配置项形成互补，所以访问路径为“http://localhost:8084/abc”。 根据服务器端口和上下文路径，使用浏览器访问 http://localhost:8084/abc/test Spring Boot外部配置文件除了默认配置文件，Spring Boot 还可以加载一些位于项目外部的配置文件。我们可以通过如下 2 个参数，指定外部配置文件的路径： spring.config.location spring.config.additional-location spring.config.location我们可以先将 Spring Boot 项目打包成 JAR 文件，然后在命令行启动命令中，使用命令行参数 –spring.config.location，指定外部配置文件的路径。 1java -jar &#123;JAR&#125; --spring.config.location=&#123;外部配置文件全路径&#125; 需要注意的是，使用该参数指定配置文件后，会使项目默认配置文件（application.properties 或 application.yml ）失效，Spring Boot 将只加载指定的外部配置文件。 示例 11.在本地目录 D:\\myConfig 下，创建一个配置文件 my-application.yml，配置如下。 123#指定配置文件server: port: 8088 2.执行以下 mvn 命令，将 springbootdemo 项目打包成 JAR。 1mvn clean package 3.打开命令行窗口，跳转到 JAR 文件所在目录，执行以下命令，其中 –spring.config.location 用于指定配置文件的新位置。 1java -jar springbootdemo-0.0.1-SNAPSHOT.jar --spring.config.location=D:\\myConfig\\my-application.yml 从控制台输出可以看出： 服务器端口号从“8084”被修改为“8088”，表示外部配置文件已生效； 上下文路径则从“&#x2F;abc”被修改为默认值（‘ ’），表示项目内部的默认配置文件已失效。 4.使用浏览器访问 “http://localhost:8088/test” spring.config.additional-location我们还可以在 Spring Boot 启动时，使用命令行参数 –spring.config.additional-location 来加载外部配置文件。 1java -jar &#123;JAR&#125; --spring.config.additional-location=&#123;外部配置文件全路径&#125; 但与 –spring.config.location 不同，–spring.config.additional-location 不会使项目默认的配置文件失效，使用该命令行参数添加的外部配置文件会与项目默认的配置文件共同生效，形成互补配置，且其优先级是最高的，比所有默认配置文件的优先级都高。 示例 21.将 springbootdemo 打包为 JAR 文件，打开命令行窗口，跳转到该项目 JAR 所在目录下，执行以下命令启动该项目。 1java -jar springbootdemo-0.0.1-SNAPSHOT.jar --spring.config.additional-location=D:\\myConfig\\my-application.yml 注意：Maven 对项目进行打包时，位于项目根目录下的配置文件是无法被打包进项目的 JAR 包的，因此位于根目录下的默认配置文件无法在 JAR 中生效，即该项目将只加载指定的外部配置文件和项目类路径（classpath）下的默认配置文件，它们的加载优先级顺序为： spring.config.additional-location 指定的外部配置文件 my-application.yml classpath:&#x2F;config&#x2F;application.yml classpath:&#x2F;application.yml 根据配置文件优先级分析可知： 以上三个配置文件中 my-application.yml 的优先级最高，因此该项目的服务器端口号为 “8088”； 只有 classpath:&#x2F;config&#x2F;application.yml 中配置了上下文路径（context-path），因此该项目的上下文路径为 “&#x2F;helloworld”； 基于以上配置分析，得出该项目访问路径为“http://localhost:8088/helloWorld”。 2.使用浏览器访问 “http://localhost:8088/helloworld/test”。 通过上面的示例，我们看到将 Spring Boot 项目打包后，然后在命令行启动命令中添加 spring.config.additional-location 参数指定外部配置文件，会导致项目根目录下的配置文件无法被加载，我们可以通过以下 3 种方式解决这个问题。 在 IDEA 的运行配置（Run&#x2F;Debug Configuration）中，添加虚拟机参数 -Dspring.config.additional-location&#x3D;D:\\myConfig\\my-application.yml，指定外部配置文件； 在 IDEA 的运行配置（Run&#x2F;Debug Configuration）中，添加程序运行参数 –spring.config.additional-location&#x3D;D:\\myConfig\\my-application.yml，指定外部配置文件； 在主启动类中调用 System.setProperty（）方法添加系统属性 spring.config.additional-location，指定外部配置文件。 Spring Boot配置加载顺序Spring Boot 不仅可以通过配置文件进行配置，还可以通过环境变量、命令行参数等多种形式进行配置。这些配置都可以让开发人员在不修改任何代码的前提下，直接将一套 Spring Boot 应用程序在不同的环境中运行。 Spring Boot 配置优先级以下是常用的 Spring Boot 配置形式及其加载顺序（优先级由高到低）： 命令行参数 来自 java:comp&#x2F;env 的 JNDI 属性 Java 系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource 配置的 random.* 属性值 配置文件（YAML 文件、Properties 文件） @Configuration 注解类上的 @PropertySource 指定的配置文件 通过 SpringApplication.setDefaultProperties 指定的默认属性 以上所有形式的配置都会被加载，当存在相同配置内容时，高优先级的配置会覆盖低优先级的配置；存在不同的配置内容时，高优先级和低优先级的配置内容取并集，共同生效，形成互补配置。 命令行参数Spring Boot 中的所有配置，都可以通过命令行参数进行指定，其配置形式如下。 1java -jar &#123;Jar文件名&#125; --&#123;参数1&#125;=&#123;参数值1&#125; --&#123;参数2&#125;=&#123;参数值2&#125; 示例 11.在 springbootdemo 项目启动时，使用以下命令。 1java -jar springbootdemo-0.0.1-SNAPSHOT.jar --server.port=8081 --server.servlet.context-path=/bcb 命令行参数说明如下： –server.port：指定服务器端口号； –server.servlet.context-path：指定上下文路径（项目的访问路径）。 配置文件Spring Boot 启动时，会自动加载 JAR 包内部及 JAR 包所在目录指定位置的配置文件（Properties 文件、YAML 文件），下图中展示了 Spring Boot 自动加载的配置文件的位置及其加载顺序，同一位置下，Properties 文件优先级高于 YAML 文件。 1 说明如下： &#x2F;myBoot：表示 JAR 包所在目录，目录名称自定义； &#x2F;childDir：表示 JAR 包所在目录下 config 目录的子目录，目录名自定义； JAR：表示 Spring Boot 项目打包生成的 JAR； 其余带有“&#x2F;”标识的目录的目录名称均不能修改。 红色数字：表示该配置文件的优先级，数字越小优先级越高。 这些配置文件得优先级顺序，遵循以下规则： 先加载 JAR 包外的配置文件，再加载 JAR 包内的配置文件； 先加载 config 目录内的配置文件，再加载 config 目录外的配置文件； 先加载 config 子目录下的配置文件，再加载 config 目录下的配置文件； 先加载 appliction-{profile}.properties&#x2F;yml，再加载 application.properties&#x2F;yml； 先加载 .properties 文件，再加载 .yml 文件。 示例 21.创建一个名为 mybootdemo 的 Spring Boot 项目，并在 src&#x2F;main&#x2F;resoources 下创建以下 4 个配置文件。 application.yml：默认配置 application-dev.yml：开发环境配置 application-test.yml：测试环境配置 application-prod.yml：生产环境配置 1）在 applcation.yml 文件中，指定默认服务端口号（port）为 “8080”，上下文路径（context-path）为“&#x2F;mybootdemo”，并激活开发环境（dev）的 profile。 1234567server: port: 8080 #端口号 servlet: context-path: /mybootdemo #上下文路径或项目访问路径spring: profiles: active: dev #激活开发环境配置 2）在 application-dev.yml 中，指定开发环境端口号为 “8081”，上下文路径为“&#x2F;in-dev”，配置如下。 12345678server: port: 8081 #开发环境端口号 8081 servlet: context-path: /in-dev #开发环境上下文路径为 in-devspring: config: activate: on-profile: dev #开发环境 3）在 application-test.yml 中，指定测试环境端口号为 “8082”，上下文路径为“&#x2F;in-test”，配置如下。 123456789#测试环境配置server: port: 8082 #测试环境端口 8082 servlet: context-path: /in-test #测试环境上下文路径 /in-testspring: config: activate: on-profile: test 4）在 application-prod.yml 中，指定生产环境端口号为 “8083”，上下文路径为“&#x2F;in-prod”，配置如下。 123456789#生产环境配置server: port: 8083 #端口号 servlet: context-path: /in-prod #上下文路径spring: config: activate: on-profile: prod 2.执行以下 mvn 命令，将 mybootdemo 打包成 JAR，并将该 JAR 包移动到本次磁盘的某个目录下（例如 mySpringBoot 目录）。 1mvn clean package 3.在 JAR 包所在目录下创建 application.yml ，并设置上下文路径为“&#x2F;out-default”，并激活生产环境（prod）Profile。 12345678#JAR 包外默认配置server: servlet: context-path: /out-default#切换配置spring: profiles: active: prod #激活开发环境配置 4.打开命令行窗口，跳转到 mySpringBoot 目录下，执行以下命令启动 Spring Boot。 1java -jar mybootdemo-0.0.1-SNAPSHOT.jar 启动结果如下图。 示例分析： Spring Boot 在启动时会加载全部的 5 个配置文件，其中位于 JAR 包外的 application.yml 优先级最高； 在 JAR 包外的 application.yml 中，配置激活了生产环境（prod）Profile，即 JAR 包内部的 application-prod.yml 生效。此时，该项目中的配置文件优先级顺序为：JAR 包外 application.yml &gt; JAR 包内 application-prod.yml &gt;JAR 包内其他配置文件; application-prod.yml 的配置内容会覆盖 JAR 包内所有其他配置文件的配置内容，即端口号（port）为“8083”，上下文路径（context-path）为“&#x2F;in-prod”; JAR 包内的 application-prod.yml 中的上下文路径会被 JAR 包外的 application.yml 覆盖为“&#x2F;out-default”; JAR 包内的 application-prod.yml 与 JAR 包外的 application.yml，形成互补配置，即，端口号为“8083”，上下文路径为“&#x2F;out-default”。 Spring Boot自动配置原理Spring Boot 默认使用 application.properties 或 application.yml 作为其全局配置文件，我们可以在该配置文件中对各种自动配置属性（server.port、logging.level.* 、spring.config.active.no-profile 等等）进行修改，并使之生效 Spring Factories 机制Spring Boot 的自动配置是基于 Spring Factories 机制实现的。 Spring Factories 机制是 Spring Boot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。Spring Boot 会自动扫描所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件，并读取其中的内容，进行实例化，这种机制也是 Spring Boot Starter 的基础。 什么是SPI？SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。 类图中，接口对应定义的抽象SPI接口；实现方实现SPI接口；调用方依赖SPI接口。SPI接口的定义在调用方，在概念上更依赖调用方；组织上位于调用方所在的包中；实现位于独立的包中。当接口属于实现方的情况，实现方提供了接口和实现，这个用法很常见，属于API调用。我们可以引用接口来达到调用某实现类的功能。 spring.factoriesspring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key&#x3D;vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开，例如： 1234org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition 注意：文件中配置的内容过长，为了阅读方便而手动换行时，为了防止内容丢失可以使用“\\”。 Spring Factories 实现原理spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF&#x2F;spring.factories 文件，并获取指定接口的配置。在 SpringFactoriesLoader 类中定义了两个对外的方法，如下表。 返回值 方法 描述 &lt;T&gt; List&lt;T&gt; loadFactories(Class factoryType, @Nullable ClassLoader classLoader) 静态方法； 根据接口获取其实现类的实例； 该方法返回的是实现类对象列表。 List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) 公共静态方法； 根据接口l获取其实现类的名称； 该方法返回的是实现类的类名的列表 以上两个方法的关键都是从指定的 ClassLoader 中获取 spring.factories 文件，并解析得到类名列表，具体代码如下。 loadFactories() 方法能够获取指定接口的实现类对象，具体代码如下。 12345678910111213141516171819202122public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader) &#123; Assert.notNull(factoryType, &quot;&#x27;factoryType&#x27; must not be null&quot;); ClassLoader classLoaderToUse = classLoader; if (classLoader == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; // 调用loadFactoryNames获取接口的实现类 List&lt;String&gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Loaded [&quot; + factoryType.getName() + &quot;] names: &quot; + factoryImplementationNames); &#125; // 遍历 factoryNames 数组，创建实现类的对象 List&lt;T&gt; result = new ArrayList(factoryImplementationNames.size()); Iterator var5 = factoryImplementationNames.iterator(); //排序 while(var5.hasNext()) &#123; String factoryImplementationName = (String)var5.next(); result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse)); &#125; AnnotationAwareOrderComparator.sort(result); return result;&#125; loadFactoryNames() 方法能够根据接口获取其实现类类名的集合，具体代码如下。 123456789public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123; ClassLoader classLoaderToUse = classLoader; if (classLoader == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; String factoryTypeName = factoryType.getName(); //获取自动配置类 return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());&#125; loadSpringFactories() 方法能够读取该项目中所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件的配置内容，并以 Map 集合的形式返回，具体代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123; Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; HashMap result = new HashMap(); try &#123; //扫描所有 Jar 包类路径下的 META-INF/spring.factories 文件 Enumeration urls = classLoader.getResources(&quot;META-INF/spring.factories&quot;); while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); //将扫描到的 META-INF/spring.factories 文件中内容包装成 properties 对象 Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next(); //提取 properties 对象中的 key 值 String factoryTypeName = ((String)entry.getKey()).trim(); //提取 proper 对象中的 value 值（多个类的完全限定名使用逗号连接的字符串） // 使用逗号为分隔符转换为数组，数组内每个元素都是配置类的完全限定名 String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); String[] var10 = factoryImplementationNames; int var11 = factoryImplementationNames.length; //遍历配置类数组，并将数组转换为 list 集合 for(int var12 = 0; var12 &lt; var11; ++var12) &#123; String factoryImplementationName = var10[var12]; ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; &#123; return new ArrayList(); &#125;)).add(factoryImplementationName.trim()); &#125; &#125; &#125; //将 propertise 对象的 key 与由配置类组成的 List 集合一一对应存入名为 result 的 Map 中 result.replaceAll((factoryType, implementations) -&gt; &#123; return (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); &#125;); cache.put(classLoader, result); //返回 result return result; &#125; catch (IOException var14) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var14); &#125; &#125;&#125; 自动配置的加载Spring Boot 自动化配置也是基于 Spring Factories 机制实现的，在 spring-boot-autoconfigure-xxx.jar 类路径下的 META-INF&#x2F;spring.factories 中设置了 Spring Boot 自动配置的内容 ，如下。 123456789101112131415# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration... 以上配置中，value 取值是由多个 xxxAutoConfiguration （使用逗号分隔）组成，每个 xxxAutoConfiguration 都是一个自动配置类。Spring Boot 启动时，会利用 Spring-Factories 机制，将这些 xxxAutoConfiguration 实例化并作为组件加入到容器中，以实现 Spring Boot 的自动配置。 @SpringBootApplication 注解所有 Spring Boot 项目的主启动程序类上都使用了一个 @SpringBootApplication 注解，该注解是 Spring Boot 中最重要的注解之一 ，也是 Spring Boot 实现自动化配置的关键。 @SpringBootApplication 是一个组合元注解，其主要包含两个注解：@SpringBootConfiguration 和 @EnableAutoConfiguration，其中 @EnableAutoConfiguration 注解是 SpringBoot 自动化配置的核心所在。 @EnableAutoConfiguration 注解@EnableAutoConfiguration 注解用于开启 Spring Boot 的自动配置功能， 它使用 Spring 框架提供的 @Import 注解通过 AutoConfigurationImportSelector类（选择器）给容器中导入自动配置组件。 Spring+SpringMVC+SpringBoot+MyBatis%5C1546332K5-1.png) AutoConfigurationImportSelector 类AutoConfigurationImportSelector 类实现了 DeferredImportSelector 接口，AutoConfigurationImportSelector 中还包含一个静态内部类 AutoConfigurationGroup，它实现了 DeferredImportSelector 接口的内部接口 Group（Spring 5 新增）。 AutoConfigurationImportSelector 类中包含 3 个方法，如下表。 返回值 方法声明 描述 内部类方法 内部类 Class&lt;? extends Group&gt; getImportGroup() 该方法获取实现了 Group 接口的类，并实例化 否 void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) 该方法用于引入自动配置的集合 是 AutoConfigurationGroup Iterable selectImports() 遍历自动配置类集合（Entry 类型的集合），并逐个解析集合中的配置类 是 AutoConfigurationGroup AutoConfigurationImportSelector 内各方法执行顺序如下。 getImportGroup() 方法 process() 方法 selectImports() 方法 下面我们将分别对以上 3 个方法及其调用过程进行介绍。 1. getImportGroup() 方法AutoConfigurationImportSelector 类中 getImportGroup() 方法主要用于获取实现了 DeferredImportSelector.Group 接口的类，代码如下。 1234public Class&lt;? extends Group&gt; getImportGroup() &#123; //获取实现了 DeferredImportSelector.Gorup 接口的 AutoConfigurationImportSelector.AutoConfigurationGroup 类 return AutoConfigurationImportSelector.AutoConfigurationGroup.class; &#125; 2. process() 方法静态内部类 AutoConfigurationGroup 中的核心方法是 process()，该方法通过调用 getAutoConfigurationEntry() 方法读取 spring.factories 文件中的内容，获得自动配置类的集合，代码如下 。 12345678910111213141516public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123; Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; &#123; return String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName()); &#125;); //拿到 META-INF/spring.factories中的EnableAutoConfiguration，并做排除、过滤处理 //AutoConfigurationEntry里有需要引入配置类和排除掉的配置类，最终只要返回需要配置的配置类 AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata); //加入缓存,List&lt;AutoConfigurationEntry&gt;类型 this.autoConfigurationEntries.add(autoConfigurationEntry); Iterator var4 = autoConfigurationEntry.getConfigurations().iterator(); while(var4.hasNext()) &#123; String importClassName = (String)var4.next(); //加入缓存，Map&lt;String, AnnotationMetadata&gt;类型 this.entries.putIfAbsent(importClassName, annotationMetadata); &#125;&#125; getAutoConfigurationEntry() 方法通过调用 getCandidateConfigurations() 方法来获取自动配置类的完全限定名，并在经过排除、过滤等处理后，将其缓存到成员变量中，具体代码如下。 1234567891011121314151617181920212223protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; else &#123; //获取注解元数据中的属性设置 AnnotationAttributes attributes = this.getAttributes(annotationMetadata); //获取自动配置类 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); //删除list 集合中重复的配置类 configurations = this.removeDuplicates(configurations); //获取飘出导入的配置类 Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes); //检查是否还存在排除配置类 this.checkExcludedClasses(configurations, exclusions); //删除排除的配置类 configurations.removeAll(exclusions); //获取过滤器，过滤配置类 configurations = this.getConfigurationClassFilter().filter(configurations); //出发自动化配置导入事件 this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions); &#125;&#125; 在 getCandidateConfigurations() 方法中，根据 Spring Factories 机制调用 SpringFactoriesLoader 的 loadFactoryNames() 方法，根据 EnableAutoConfiguration.class （自动配置接口）获取其实现类（自动配置类）的类名的集合，如下图。 Spring+SpringMVC+SpringBoot+MyBatis%5C1546334106-2.png) 3. process() 方法以上所有方法执行完成后，AutoConfigurationImportSelector.AutoConfigurationGroup#selectImports() 会将 process() 方法处理后得到的自动配置类，进行过滤、排除，最后将所有自动配置类添加到容器中。 123456789101112131415161718public Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports() &#123; if (this.autoConfigurationEntries.isEmpty()) &#123; return Collections.emptyList(); &#125; else &#123; //获取所有需要排除的配置类 Set&lt;String&gt; allExclusions = (Set)this.autoConfigurationEntries.stream(). map(AutoConfigurationImportSelector.AutoConfigurationEntry::getExclusions).flatMap(Collection::stream).collect(Collectors.toSet()); //获取所有经过自动化配置过滤器的配置类 Set&lt;String&gt; processedConfigurations = (Set)this.autoConfigurationEntries.stream().map(AutoConfigurationImportSelector. AutoConfigurationEntry::getConfigurations).flatMap(Collection::stream).collect(Collectors.toCollection(LinkedHashSet::new)); //排除过滤后配置类中需要排除的类 processedConfigurations.removeAll(allExclusions); return (Iterable)this.sortAutoConfigurations(processedConfigurations, this.getAutoConfigurationMetadata()).stream().map((importClassName) -&gt; &#123; return new DeferredImportSelector.Group.Entry((AnnotationMetadata)this.entries.get(importClassName), importClassName); &#125;).collect(Collectors.toList()); &#125;&#125; 自动配置的生效和修改spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 Spring Boot 中以 @Conditional 派生注解的形式体现，如下表。 注解 生效条件 @ConditionalOnJava 应用使用指定的 Java 版本时生效 @ConditionalOnBean 容器中存在指定的 Bean 时生效 @ConditionalOnMissingBean 容器中不存在指定的 Bean 时生效 @ConditionalOnExpression 满足指定的 SpEL 表达式时生效 @ConditionalOnClass 存在指定的类时生效 @ConditionalOnMissingClass 不存在指定的类时生效 @ConditionalOnSingleCandidate 容器中只存在一个指定的 Bean 或这个 Bean 为首选 Bean 时生效 @ConditionalOnProperty 系统中指定属性存在指定的值时生效 @ConditionalOnResource 类路径下存在指定的资源文件时生效 @ConditionalOnWebApplication 当前应用是 web 应用时生效 @ConditionalOnNotWebApplication 当前应用不是 web 应用生效 下面我们以 ServletWebServerFactoryAutoConfiguration 为例，介绍 Spring Boot 自动配置是如何生效的。 ServletWebServerFactoryAutoConfigurationServletWebServerFactoryAutoConfiguration 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Configuration( //表示这是一个配置类，与 xml 配置文件等价，也可以给容器中添加组件 proxyBeanMethods = false)@AutoConfigureOrder(-2147483648)@ConditionalOnClass(&#123;ServletRequest.class&#125;)//判断当前项目有没有 ServletRequest 这个类@ConditionalOnWebApplication(// 判断当前应用是否是 web 应用，如果是，当前配置类生效 type = Type.SERVLET)@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)//启动指定类的属性配置（ConfigurationProperties）功能；将配置文件中对应的值和 ServerProperties 绑定起来；并把 ServerProperties 加入到ioc容器中@Import(&#123;ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, EmbeddedTomcat.class, EmbeddedJetty.class, EmbeddedUndertow.class&#125;)public class ServletWebServerFactoryAutoConfiguration &#123; public ServletWebServerFactoryAutoConfiguration() &#123; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties, ObjectProvider&lt;WebListenerRegistrar&gt; webListenerRegistrars) &#123; return new ServletWebServerFactoryCustomizer(serverProperties, (List) webListenerRegistrars.orderedStream().collect(Collectors.toList())); &#125; @Bean @ConditionalOnClass( name = &#123;&quot;org.apache.catalina.startup.Tomcat&quot;&#125; ) public TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer(ServerProperties serverProperties) &#123; return new TomcatServletWebServerFactoryCustomizer(serverProperties); &#125; @Bean @ConditionalOnMissingFilterBean(&#123;ForwardedHeaderFilter.class&#125;) @ConditionalOnProperty( value = &#123;&quot;server.forward-headers-strategy&quot;&#125;, havingValue = &quot;framework&quot; ) public FilterRegistrationBean&lt;ForwardedHeaderFilter&gt; forwardedHeaderFilter() &#123; ForwardedHeaderFilter filter = new ForwardedHeaderFilter(); FilterRegistrationBean&lt;ForwardedHeaderFilter&gt; registration = new FilterRegistrationBean(filter, new ServletRegistrationBean[0]); registration.setDispatcherTypes(DispatcherType.REQUEST, new DispatcherType[]&#123;DispatcherType.ASYNC, DispatcherType.ERROR&#125;); registration.setOrder(-2147483648); return registration; &#125; public static class BeanPostProcessorsRegistrar implements ImportBeanDefinitionRegistrar, BeanFactoryAware &#123; private ConfigurableListableBeanFactory beanFactory; public BeanPostProcessorsRegistrar() &#123; &#125; public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; if (beanFactory instanceof ConfigurableListableBeanFactory) &#123; this.beanFactory = (ConfigurableListableBeanFactory) beanFactory; &#125; &#125; public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; if (this.beanFactory != null) &#123; this.registerSyntheticBeanIfMissing(registry, &quot;webServerFactoryCustomizerBeanPostProcessor&quot;, WebServerFactoryCustomizerBeanPostProcessor.class, WebServerFactoryCustomizerBeanPostProcessor::new); this.registerSyntheticBeanIfMissing(registry, &quot;errorPageRegistrarBeanPostProcessor&quot;, ErrorPageRegistrarBeanPostProcessor.class, ErrorPageRegistrarBeanPostProcessor::new); &#125; &#125; private &lt;T&gt; void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, String name, Class&lt;T&gt; beanClass, Supplier&lt;T&gt; instanceSupplier) &#123; if (ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(beanClass, true, false))) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass, instanceSupplier); beanDefinition.setSynthetic(true); registry.registerBeanDefinition(name, beanDefinition); &#125; &#125; &#125;&#125; 该类使用了以下注解： @Configuration：用于定义一个配置类，可用于替换 Spring 中的 xml 配置文件； @Bean：被 @Configuration 注解的类内部，可以包含有一个或多个被 @Bean 注解的方法，用于构建一个 Bean，并添加到 Spring 容器中；该注解与 spring 配置文件中 &lt;bean&gt; 等价，方法名与 &lt;bean&gt; 的 id 或 name 属性等价，方法返回值与 class 属性等价； 除了 @Configuration 和 @Bean 注解外，该类还使用 5 个 @Conditional 衍生注解： @ConditionalOnClass({ServletRequest.class})：判断当前项目是否存在 ServletRequest 这个类，若存在，则该配置类生效。 @ConditionalOnWebApplication(type &#x3D; Type.SERVLET)：判断当前应用是否是 Web 应用，如果是的话，当前配置类生效。 @ConditionalOnClass(name &#x3D; {“org.apache.catalina.startup.Tomcat”})：判断是否存在 Tomcat 类，若存在则该方法生效。 @ConditionalOnMissingFilterBean({ForwardedHeaderFilter.class})：判断容器中是否有 ForwardedHeaderFilter 这个过滤器，若不存在则该方法生效。 @ConditionalOnProperty(value &#x3D; {“server.forward-headers-strategy”},havingValue &#x3D; “framework”)：判断配置文件中是否存在 server.forward-headers-strategy &#x3D; framework，若不存在则该方法生效。 ServerPropertiesServletWebServerFactoryAutoConfiguration 类还使用了一个 @EnableConfigurationProperties 注解，通过该注解导入了一个 ServerProperties 类，其部分源码如下。 ServletWebServerFactoryAutoConfiguration 类还使用了一个 @EnableConfigurationProperties 注解，通过该注解导入了一个 ServerProperties 类，其部分源码如下。 123456789101112131415161718192021222324252627282930313233343536@ConfigurationProperties( prefix = &quot;server&quot;, ignoreUnknownFields = true)public class ServerProperties &#123; private Integer port; private InetAddress address; @NestedConfigurationProperty private final ErrorProperties error = new ErrorProperties(); private ServerProperties.ForwardHeadersStrategy forwardHeadersStrategy; private String serverHeader; private DataSize maxHttpHeaderSize = DataSize.ofKilobytes(8L); private Shutdown shutdown; @NestedConfigurationProperty private Ssl ssl; @NestedConfigurationProperty private final Compression compression; @NestedConfigurationProperty private final Http2 http2; private final ServerProperties.Servlet servlet; private final ServerProperties.Tomcat tomcat; private final ServerProperties.Jetty jetty; private final ServerProperties.Netty netty; private final ServerProperties.Undertow undertow; public ServerProperties() &#123; this.shutdown = Shutdown.IMMEDIATE; this.compression = new Compression(); this.http2 = new Http2(); this.servlet = new ServerProperties.Servlet(); this.tomcat = new ServerProperties.Tomcat(); this.jetty = new ServerProperties.Jetty(); this.netty = new ServerProperties.Netty(); this.undertow = new ServerProperties.Undertow(); &#125; ....&#125; 我们看到，ServletWebServerFactoryAutoConfiguration 使用了一个 @EnableConfigurationProperties 注解，而 ServerProperties 类上则使用了一个 @ConfigurationProperties 注解。这其实是 Spring Boot 自动配置机制中的通用用法。 Spring Boot 中为我们提供了大量的自动配置类 XxxAutoConfiguration 以及 XxxProperties，每个自动配置类 XxxAutoConfiguration 都使用了 @EnableConfigurationProperties 注解，而每个 XxxProperties 上都使用 @ConfigurationProperties 注解。 @ConfigurationProperties 注解的作用，是将这个类的所有属性与配置文件中相关的配置进行绑定，以便于获取或修改配置，但是 @ConfigurationProperties 功能是由容器提供的，被它注解的类必须是容器中的一个组件，否则该功能就无法使用。而 @EnableConfigurationProperties 注解的作用正是将指定的类以组件的形式注入到 IOC 容器中，并开启其 @ConfigurationProperties 功能。因此，**@ConfigurationProperties + @EnableConfigurationProperties 组合使用，便可以为 XxxProperties 类实现配置绑定功能。** 自动配置类 XxxAutoConfiguration 负责使用 XxxProperties 中属性进行自动配置，而 XxxProperties 则负责将自动配置属性与配置文件的相关配置进行绑定，以便于用户通过配置文件修改默认的自动配置。也就是说，真正“限制”我们可以在配置文件中配置哪些属性的类就是这些 XxxxProperties 类，它与配置文件中定义的 prefix 关键字开头的一组属性是唯一对应的。 注意：XxxAutoConfiguration 与 XxxProperties 并不是一一对应的，大多数情况都是多对多的关系，即一个 XxxAutoConfiguration 可以同时使用多个 XxxProperties 中的属性，一个 XxxProperties 类中属性也可以被多个 XxxAutoConfiguration 使用。 Spring Boot统一日志框架在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。在 Java 领域里存在着多种日志框架，如 JCL、SLF4J、Jboss-logging、jUL、log4j、log4j2、logback 等等。 日志框架的选择被分为两类：日志门面（日志抽象层）和日志实现，如下表。 日志分类 描述 举例 日志门面（日志抽象层） 为 Java 日志访问提供一套标准和规范的 API 框架，其主要意义在于提供接口。 JCL（Jakarta Commons Logging）、SLF4j（Simple Logging Facade for Java）、jboss-logging 日志实现 日志门面的具体的实现 Log4j、JUL（java.util.logging）、Log4j2、Logback 通常情况下，日志由一个日志门面与一个日志实现组合搭建而成，Spring Boot 选用 SLF4J + Logback 的组合来搭建日志系统。 SLF4J 是目前市面上最流行的日志门面，使用 Slf4j 可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性。 Logback 是 Slf4j 的原生实现框架，它与 Log4j 出自一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流。 SLF4J 的使用在项目开发中，记录日志时不应该直接调用日志实现层的方法，而应该调用日志门面（日志抽象层）的方法。 在使用 SLF4J 记录日志时，我们需要在应用中导入 SLF4J 及日志实现，并在记录日志时调用 SLF4J 的方法，例如： 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); //调用 sl4j 的 info() 方法，而非调用 logback 的方法 logger.info(&quot;Hello World&quot;); &#125;&#125; SLF4J 作为一款优秀的日志门面或者日志抽象层，它可以与各种日志实现框架组合使用，以达到记录日志的目的，如下图（参考自 SLF4J 官方）。 图片Spring+SpringMVC+SpringBoot+MyBatis%5C154Z31D9-0.png) 从 SLF4J 官方给出的方案可以看出： Logback 作为 Slf4j 的原生实现框架，当应用使用 SLF4J+Logback 的组合记录日志时，只需要引入 SLF4J 和 Logback 的 Jar 包即可； Log4j 虽然与 Logback 出自同一个人之手，但是 Log4j 出现要早于 SLF4J，因而 Log4j 没有直接实现 SLF4J，当应用使用 SLF4J+Log4j 的组合记录日志时，不但需要引入 SLF4J 和 Log4j 的 Jar 包，还必须引入它们之间的适配层（Adaptation layer）slf4j-log4j12.jar，该适配层可谓“上有老下有小”，它既要实现 SLF4J 的方法，还有调用 Log4j 的方法，以达到承上启下的作用； 当应用使用 SLF4J+JUL 记录日志时，与 SLF4J+Log4j 一样，不但需要引入 SLF4J 和 JUL 的对应的 Jar 包，还要引入适配层 slf4j-jdk14.jar。 这里我们需要注意一点，每一个日志的实现框架都有自己的配置文件。使用 slf4j 记录日志时，配置文件应该使用日志实现框架（例如 logback、log4j 和 JUL 等等）自己本身的配置文件。 统一日志框架（通用）通常一个完整的应用下会依赖于多种不同的框架，而且它们记录日志使用的日志框架也不尽相同，例如，Spring Boot（slf4j+logback），Spring（commons-logging）、Hibernate（jboss-logging）等等。那么如何统一日志框架的使用呢？ 对此，SLF4J 官方也给出了相应的解决方案，如下图。 从上图中可以看出，统一日志框架一共需要以下 3 步 ： 排除应用中的原来的日志框架； 引入替换包替换被排除的日志框架； 导入 SLF4J 实现。 SLF4J 官方给出的统一日志框架的方案是“狸猫换太子”，即使用一个替换包来替换原来的日志框架，例如 log4j-over-slf4j 替换 Log4j（Commons Logging API）、jul-to-slf4j.jar 替换 JUL（java.util.logging API）等等。 替换包内包含被替换的日志框架中的所有类，这样就可以保证应用不会报错，但替换包内部实际使用的是 SLF4J API，以达到统一日主框架的目的。 统一日志框架（Spring Boot）我们在使用 Spring Boot 时，同样可能用到其他的框架，例如 Mybatis、Spring MVC、 Hibernate 等等，这些框架的底层都有自己的日志框架，此时我们也需要对日志框架进行统一。 我们知道，统一日志框架的使用一共分为 3 步，Spring Boot 作为一款优秀的开箱即用的框架，已经为用户完成了其中 2 步：引入替换包和导入 SLF4J 实现。 Spring Boot 的核心启动器 spring-boot-starter 引入了 spring-boot-starter-logging，使用 IDEA 查看其依赖关系，如下图。 从图 3 可知，spring-boot-starter-logging 的 Maven 依赖不但引入了 logback-classic （包含了日志框架 SLF4J 的实现），还引入了 log4j-to-slf4j（log4j 的替换包），jul-to-slf4j （JUL 的替换包），即 Spring Boot 已经为我们完成了统一日志框架的 3 个步骤中的 2 步。 SpringBoot 底层使用 slf4j+logback 的方式记录日志，当我们引入了依赖了其他日志框架的第三方框架（例如 Hibernate）时，只需要把这个框架所依赖的日志框架排除，即可实现日志框架的统一，示例代码如下。 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-console&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Spring Boot日志配置及输出默认配置Spring Boot 默认使用 SLF4J+Logback 记录日志，并提供了默认配置，即使我们不进行任何额外配，也可以使用 SLF4J+Logback 进行日志输出。 常见的日志配置包括日志级别、日志的输入出格式等内容。 日志级别日志的输出都是分级别的，当一条日志信息的级别大于或等于配置文件的级别时，就对这条日志进行记录。 常见的日志级别如下（优先级依次升高）。 序号 日志级别 说明 1 trace 追踪，指明程序运行轨迹。 2 debug 调试，实际应用中一般将其作为最低级别，而 trace 则很少使用。 3 info 输出重要的信息，使用较多。 4 warn 警告，使用较多。 5 error 错误信息，使用较多。 输出格式我们可以通过以下常用日志参数对日志的输出格式进行修改，如下表。 序号 输出格式 说明 1 %d{yyyy-MM-dd HH:mm:ss, SSS} 日志生产时间,输出到毫秒的时间 2 %-5level 输出日志级别，-5 表示左对齐并且固定输出 5 个字符，如果不足在右边补 0 3 %logger 或 %c logger 的名称 4 %thread 或 %t 输出当前线程名称 5 %p 日志输出格式 6 %message 或 %msg 或 %m 日志内容，即 logger.info(“message”) 7 %n 换行符 8 %class 或 %C 输出 Java 类名 9 %file 或 %F 输出文件名 10 %L 输出错误行号 11 %method 或 %M 输出方法名 12 %l 输出语句所在的行数, 包括类名、方法名、文件名、行数 13 hostName 本地机器名 14 hostAddress 本地 ip 地址 示例 1下面我们通过一个实例，来查看 Spring Boot 提供了哪些默认日志配置。 1.在 Spring Boot 中编写 Java 测试类，代码如下。 1234567891011121314151617@SpringBootTestclass SpringbootLoggingApplicationTests &#123; Logger logger = LoggerFactory.getLogger(getClass()); /** * 测试日志输出 * SLF4J 日志级别从小到大trace&gt;debug&gt;info&gt;warn&gt;error */ @Test void logTest() &#123; //日志级别 由低到高 logger.trace(&quot;trace 级别日志&quot;); logger.debug(&quot;debug 级别日志&quot;); logger.info(&quot;info 级别日志&quot;); logger.warn(&quot;warn 级别日志&quot;); logger.error(&quot;error 级别日志&quot;); &#125;&#125; 2.执行该测试，控制台输出如下图。 图片Spring+SpringMVC+SpringBoot+MyBatis%5C155029DM-0.png) 通过控制台输出结果可知，Spring Boot 日志默认级别为 info，日志输出内容默认包含以下元素： 时间日期 日志级别 进程 ID 分隔符：— 线程名：方括号括起来（可能会截断控制台输出） Logger 名称 日志内容 修改默认日志配置我们可以根据自身的需求，通过全局配置文件（application.properties&#x2F;yml）修改 Spring Boot 日志级别和显示格式等默认配置。在 application.properties 中，修改 Spring Boot 日志的默认配置，代码如下。 12345678910#日志级别logging.level.net.biancheng.www=trace#使用相对路径的方式设置日志输出的位置（项目根目录目录\\my-log\\mylog\\spring.log）#logging.file.path=my-log/myLog#绝对路径方式将日志文件输出到 【项目所在磁盘根目录\\springboot\\logging\\my\\spring.log】logging.file.path=/spring-boot/logging#控制台日志输出格式logging.pattern.console=%d&#123;yyyy-MM-dd hh:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#日志文件输出格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === - %msg%n 执行测试代码，执行结果如下。 图片Spring+SpringMVC+SpringBoot+MyBatis%5C155029E18-1.png) 控制台中日志的输出格式与 application.properties 中的 logging.pattern.console 配置一致。 查看本地日志文件 spring.log，该文件日志输出内容如下图。 本地日志文件中的日志输出格式与 application.properties 中 logging.pattern.file 配置一致。 自定义日志配置在 Spring Boot 的配置文件 application.porperties&#x2F;yml 中，可以对日志的一些默认配置进行修改，但这种方式只能修改个别的日志配置，想要修改更多的配置或者使用更高级的功能，则需要通过日志实现框架自己的配置文件进行配置。 Spring 官方提供了各个日志实现框架所需的配置文件，用户只要将指定的配置文件放置到项目的类路径下即可。 日志框架 配置文件 Logback logback-spring.xml、logback-spring.groovy、logback.xml、logback.groovy Log4j2 log4j2-spring.xml、log4j2.xml JUL (Java Util Logging) logging.properties 从上表可以看出，日志框架的配置文件基本上被分为 2 类： 普通日志配置文件，即不带 srping 标识的配置文件，例如 logback.xml； 带有 spring 表示的日志配置文件，例如 logback-spring.xml。 这两种日志配置文件在使用时大不相同，下面我们就对它们分别进行介绍。 普通日志配置文件我们将 logback.xml、log4j2.xml 等不带 spring 标识的普通日志配置文件，放在项目的类路径下后，这些配置文件会跳过 Spring Boot，直接被日志框架加载。通过这些配置文件，我们就可以达到自定义日志配置的目的。 示例1.将 logback.xml 加入到 Spring Boot 项目的类路径下（resources 目录下），该配置文件配置内容如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;/app/log&quot;/&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name=&quot;appName&quot; value=&quot;bianchengbang-spring-boot-logging&quot;&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread]**************** %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name=&quot;appLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式： --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %thread ] ------------------ [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出， false：表示只用当前logger的appender-ref，true： 表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;logger name=&quot;net.biancheng.www&quot; level=&quot;debug&quot;/&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;&lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;stdout&quot;/&gt; &lt;appender-ref ref=&quot;appLogAppender&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 2.启动该项目并启动测试程序。 带有 spring 标识的日志配置文件Spring Boot 推荐用户使用 logback-spring.xml、log4j2-spring.xml 等这种带有 spring 标识的配置文件。这种配置文件被放在项目类路径后，不会直接被日志框架加载，而是由 Spring Boot 对它们进行解析，这样就可以使用 Spring Boot 的高级功能 Profile，实现在不同的环境中使用不同的日志配置。 示例1.将 logback.xml 文件名修改为 logback-spring.xml，并将配置文件中日志输出格式的配置修改为使用 Profile 功能的配置。 2.配置内容修改前，日志输出格式配置如下。 123456789&lt;configuration scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; ...... &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread]**************** %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; ......&lt;/configuration&gt; 3.修改 logback-spring.xml 的配置内容，通过 Profile 功能实现在不同的环境中使用不同的日志输出格式，配置如下。 12345678910111213141516&lt;configuration scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; ...... &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;!--开发环境 日志输出格式--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--非开发环境 日志输出格式--&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; ......&lt;/configuration&gt; 4.在 Spring Boot 项目的 application.yml 中，激活开发环境（dev）的 Profile，配置内容如下。 12345678910111213141516171819202122232425262728293031#默认配置server: port: 8080#切换配置spring: profiles: active: dev---#开发环境server: port: 8081spring: config: activate: on-profile: dev---#测试环境server: port: 8082spring: config: activate: on-profile: test---#生产环境server: port: 8083spring: config: activate: on-profile: prod 5.启动 Spring Boot 并执行测试代码，控制台输出如下。 6.修改 appplication.yml 中的配置，激活测试环境（test）的 Profile，配置如下。 12345678910111213141516171819202122232425262728293031#默认配置server: port: 8080#切换配置spring: profiles: active: test---#开发环境server: port: 8081spring: config: activate: on-profile: dev---#测试环境server: port: 8082spring: config: activate: on-profile: test---#生产环境server: port: 8083spring: config: activate: on-profile: prod 7.重启 Spring Boot 并执行测试代码，控制台输出如下。 spring-boot-starter-web（Web启动器）Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。 Spring Boot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 Spring MVC 提供了大量自动配置，可以适用于大多数 Web 开发场景。 Spring Boot Web 快速开发Spring Boot 为 Spring MVC 提供了自动配置，并在 Spring MVC 默认功能的基础上添加了以下特性： 引入了 ContentNegotiatingViewResolver 和 BeanNameViewResolver（视图解析器） 对包括 WebJars 在内的静态资源的支持 自动注册 Converter、GenericConverter 和 Formatter （转换器和格式化器） 对 HttpMessageConverters 的支持（Spring MVC 中用于转换 HTTP 请求和响应的消息转换器） 自动注册 MessageCodesResolver（用于定义错误代码生成规则） 支持对静态首页（index.html）的访问 自动使用 ConfigurableWebBindingInitializer 只要我们在 Spring Boot 项目中的 pom.xml 中引入了 spring-boot-starter-web ，即使不进行任何配置，也可以直接使用 Spring MVC 进行 Web 开发。 示例1.创建一个名为 spring-boot-springmvc-demo1 的 Spring Boot 工程，并在其 pom.xml 的dependencies 节点中添加 spring-boot-starter-web 的依赖，代码如下。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 2.在 net.biancheng.www 包下创建一个名为 HelloController，代码如下。 12345678@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;www.biancheng.net&quot;; &#125;&#125; 3.启动 Spring Boot，浏览器访问“http://localhost:8080/hello” 注意：由于 spring-boot-starter-web 默认替我们引入了核心启动器 spring-boot-starter，因此，当 Spring Boot 项目中的 pom.xml 引入了 spring-boot-starter-web 的依赖后，就无须在引入 spring-boot-starter 核心启动器的依赖了。 Spring Boot静态资源映射在 Web 应用中会涉及到大量的静态资源，例如 JS、CSS 和 HTML 等。我们知道，Spring MVC 导入静态资源文件时，需要配置静态资源的映射；但在 SpringBoot 中则不再需要进行此项配置，因为 SpringBoot 已经默认完成了这一工作。 Spring Boot 默认为我们提供了 3 种静态资源映射规则： WebJars 映射 默认资源映射 静态首页（欢迎页）映射 WebJars 映射为了让页面更加美观，让用户有更多更好的体验，Web 应用中通常会使用大量的 JS 和 CSS，例如 jQuery，Backbone.js 和 Bootstrap 等等。 通常我们会将这些 Web 前端资源拷贝到 Java Web 项目的 webapp 相应目录下进行管理。但是 Spring Boot 项目是以 JAR 包的形式进行部署的，不存在 webapp 目录，那么 Web 前端资源该如何引入到 Spring Boot 项目中呢？ WebJars 可以完美的解决上面的问题，它可以 Jar 形式为 Web 项目提供资源文件。 WebJars 可以将 Web 前端资源（JS，CSS 等）打成一个个的 Jar 包，然后将这些 Jar 包部署到 Maven 中央仓库中进行统一管理，当 Spring Boot 项目中需要引入 Web 前端资源时，只需要访问 WebJars 官网，找到所需资源的 pom 依赖，将其导入到项目中即可。 所有通过 WebJars 引入的前端资源都存放在当前项目类路径（classpath）下的“&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;” 目录中。 下图展示如何通过 WebJars 查找 JQuery 的 pom 依赖的过程。 Spring Boot 通过 MVC 的自动配置类 WebMvcAutoConfiguration 为这些 WebJars 前端资源提供了默认映射规则，部分源码如下。 123456789101112131415public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); &#125; else &#123; //WebJars 映射规则 this.addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;); this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123; registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) &#123; ServletContextResource resource = new ServletContextResource(this.servletContext, &quot;/&quot;); registration.addResourceLocations(new Resource[]&#123;resource&#125;); &#125; &#125;); &#125;&#125; 通过以上源码可知，WebJars 的映射路径为“&#x2F;webjars&#x2F;”，即所有访问“&#x2F;webjars&#x2F;”的请求，都会去“classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;”查找 WebJars 前端资源。 示例 11.在 Spring Boot 项目 spring-boot-springmvc-demo1 的 pom.xml 中添加以下依赖，将 jquery 引入到该项目中。 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; 2.Spring Boot 项目中引入的 jquery 的 Jar 包结构如下图。 图片Spring+SpringMVC+SpringBoot+MyBatis%5C1555551O8-1.png) 3.启动 Spring Boot，浏览器访问“http://localhost:8080/webjars/jquery/3.6.0/jquery.js”访问 jquery.js，结果如下图。 默认静态资源映射当访问项目中的任意资源（即“&#x2F;**”）时，Spring Boot 会默认从以下路径中查找资源文件（优先级依次降低）： classpath:&#x2F;META-INF&#x2F;resources&#x2F; classpath:&#x2F;resources&#x2F; classpath:&#x2F;static&#x2F; classpath:&#x2F;public&#x2F; 这些路径又被称为静态资源文件夹，它们的优先级顺序为：classpath:&#x2F;META-INF&#x2F;resources&#x2F; &gt; classpath:&#x2F;resources&#x2F; &gt; classpath:&#x2F;static&#x2F; &gt; classpath:&#x2F;public&#x2F; 。 当我们请求某个静态资源（即以“.html”结尾的请求）时，Spring Boot 会先查找优先级高的文件夹，再查找优先级低的文件夹，直到找到指定的静态资源为止。 示例 21.在 spring-boot-springmvc-demo1 的 src&#x2F;main&#x2F;resources 下的 static 目录中创建一个 hello.html，代码如下。 12345678&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;&lt;body&gt;&lt;h1&gt;欢迎您来到编程帮（www.biancheng.net）&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，浏览器访问 “http://localhost:8080/hello.html”。 静态首页（欢迎页）映射静态资源文件夹下的所有 index.html 被称为静态首页或者欢迎页，它们会被 &#x2F;** 映射，换句话说就是，当我们访问“&#x2F;”或者“&#x2F;index.html”时，都会跳转到静态首页（欢迎页）。 注意，访问静态首页或欢迎页时，其查找顺序也遵循默认静态资源的查找顺序，即先查找优先级高的目录，在查找优先级低的目录，直到找到 index.html 为止。 示例 31.在 spring-boot-springmvc-demo1 的 src&#x2F;main&#x2F;resources 下的 public 目录中创建一个 index.html，代码如下。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，使用浏览器访问“http://localhost:8080/”，结果如下图。 Spring Boot定制Spring MVCSpring Boot 抛弃了传统 xml 配置文件，通过配置类（标注 @Configuration 的类，相当于一个 xml 配置文件）以 JavaBean 形式进行相关配置。Spring Boot 对 Spring MVC 的自动配置可以满足我们的大部分需求，但是我们也可以通过自定义配置类（标注 @Configuration 的类）并实现 WebMvcConfigurer 接口来定制 Spring MVC 配置，例如拦截器、格式化程序、视图控制器等等。 SpringBoot 1.5 及以前是通过继承 WebMvcConfigurerAdapter 抽象类来定制 Spring MVC 配置的，但在 SpringBoot 2.0 后，WebMvcConfigurerAdapter 抽象类就被弃用了，改为实现 WebMvcConfigurer 接口来定制 Spring MvVC 配置。 WebMvcConfigurer 是一个基于 Java 8 的接口，该接口定义了许多与 Spring MVC 相关的方法，其中大部分方法都是 default 类型的，且都是空实现。因此我们只需要定义一个配置类实现 WebMvcConfigurer 接口，并重写相应的方法便可以定制 Spring MVC 的配置。 方法 说明 default void configurePathMatch(PathMatchConfigurer configurer) {} HandlerMappings 路径的匹配规则。 default void configureContentNegotiation(ContentNegotiationConfigurer configurer) {} 内容协商策略（一个请求路径返回多种数据格式）。 default void configureAsyncSupport(AsyncSupportConfigurer configurer) {} 处理异步请求。 default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {} 这个接口可以实现静态文件可以像 Servlet 一样被访问。 default void addFormatters(FormatterRegistry registry) {} 添加格式化器或者转化器。 default void addInterceptors(InterceptorRegistry registry) {} 添加 Spring MVC 生命周期拦截器，对请求进行拦截处理。 default void addResourceHandlers(ResourceHandlerRegistry registry) {} 添加或修改静态资源（例如图片，js，css 等）映射； Spring Boot 默认设置的静态资源文件夹就是通过重写该方法设置的。 default void addCorsMappings(CorsRegistry registry) {} 处理跨域请求。 default void addViewControllers(ViewControllerRegistry registry) {} 主要用于实现无业务逻辑跳转，例如主页跳转，简单的请求重定向，错误页跳转等 default void configureViewResolvers(ViewResolverRegistry registry) {} 配置视图解析器，将 Controller 返回的字符串（视图名称），转换为具体的视图进行渲染。 default void addArgumentResolvers(List resolvers) {} 添加解析器以支持自定义控制器方法参数类型，实现该方法不会覆盖用于解析处理程序方法参数的内置支持； 要自定义内置的参数解析支持， 同样可以通过 RequestMappingHandlerAdapter 直接配置 RequestMappingHandlerAdapter 。 default void addReturnValueHandlers(List handlers) {} 添加处理程序来支持自定义控制器方法返回值类型。使用此选项不会覆盖处理返回值的内置支持； 要自定义处理返回值的内置支持，请直接配置 RequestMappingHandlerAdapter。 default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {} 用于配置默认的消息转换器（转换 HTTP 请求和响应）。 default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {} 直接添加消息转换器，会关闭默认的消息转换器列表； 实现该方法即可在不关闭默认转换器的起提下，新增一个自定义转换器。 default void configureHandlerExceptionResolvers(List resolvers) {} 配置异常解析器。 default void extendHandlerExceptionResolvers(List resolvers) {} 扩展或修改默认的异常解析器列表。 在 Spring Boot 项目中，我们可以通过以下 2 中形式定制 Spring MVC: 扩展 Spring MVC 全面接管 Spring MVC 下面，我们分别对这两种定制 Spring MVC 的形式进行介绍。 扩展 Spring MVC如果 Spring Boot 对 Spring MVC 的自动配置不能满足我们的需要，我们还可以通过自定义一个 WebMvcConfigurer 类型（实现 WebMvcConfigurer 接口）的配置类（标注 @Configuration，但不标注 @EnableWebMvc 注解的类），来扩展 Spring MVC。这样不但能够保留 Spring Boot 对 Spring MVC 的自动配置，享受 Spring Boot 自动配置带来的便利，还能额外增加自定义的 Spring MVC 配置。 示例 11.创建一个名为 spring-boot-adminex 的 Spring Boot 项目，并将后台管理系统 AdminEx 中的 css、fonts、images 和 js 目录及其中的静态资源，移动到该项目的 src&#x2F;main&#x2F;resources&#x2F;static 下，目录结构如下图。 img](Spring+SpringMVC+SpringBoot+MyBatis%5C155G93292-0.png) 2.在 net.biancheng.www.config 包下，创建一个名为 MyMvcConfig 的配置类并实现 WebMvcConfigurer 接口，重写 addViewControllers() 方法，代码如下。 1234567891011//实现 WebMvcConfigurer 接口可以来扩展 SpringMVC 的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //当访问 “/” 或 “/index.html” 时，都直接跳转到登陆页面 registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); &#125;&#125; 3.在 net.biancheng.www.controller 下创建一个名为 IndexController 的 Controller，代码如下。 123456789101112@Controllerpublic class IndexController &#123; /** * 跳转到登陆页面 * @return */ @GetMapping(value = &#123;&quot;/login&quot;&#125;) public String loginPage() &#123; //跳转到登录页 login.html return &quot;login&quot;; &#125;&#125; 4.将 AdminEx 中的 login.html（登录页）移动到 src&#x2F;main&#x2F;resources&#x2F;templates 下，结构如下图。 img](Spring+SpringMVC+SpringBoot+MyBatis%5C155G95093-1.png) 5.启动 Spring Boot，您会发现“http://localhost:8080/login”、“http://localhost:8080/”“http://localhost:8080/index.html”3 个 URL 都能跳转到登陆页 login.html。 全面接管 Spring MVC在一些特殊情况下，我们可能需要抛弃 Spring Boot 对 Spring MVC 的全部自动配置，完全接管 Spring MVC。此时我们可以自定义一个 WebMvcConfigurer 类型（实现 WebMvcConfigurer 接口）的配置类，并在该类上标注 @EnableWebMvc 注解，来实现完全接管 Spring MVC。 &#x3D;&#x3D;注意：完全接管 Spring MVC 后，Spring Boot 对 Spring MVC 的自动配置将全部失效。&#x3D;&#x3D; 示例 21.在 MyMvcConfig 配置类上标注 @EnableWebMvc，除此之外其他文件都不做任何修改，代码如下。 1234567891011//实现 WebMvcConfigurer 接口可以来扩展 SpringMVC 的功能@EnableWebMvc // 完全接管SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //当访问 “/” 或 “/index.html” 时，都直接跳转到登陆页面 registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); &#125;&#125; 2.启动 Spring Boot，在浏览器地址栏输入“http://localhost:8080/”访问登录页，结果如下图。 3.浏览器地址栏输入“http://localhost:8080/css/style.css” ，访问 login.html 中引用的 css 样式表，结果如下图。 我们知道，Spring Boot 能够访问位于静态资源文件夹中的静态文件，这是在 Spring Boot 对 Spring MVC 的默认自动配置中定义的，当我们全面接管 Spring MVC 后，Spring Boot 对 Spring MVC 的默认配置都会失效，此时再访问静态资源文件夹中的静态资源就会报 404 错误。 Thymeleaf教程（10分钟入门）Thymeleaf 是一款用于渲染 XML&#x2F;XHTML&#x2F;HTML5 内容的模板引擎。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 Spring MVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。 1. Thymeleaf 简介Thymeleaf 是新一代 Java 模板引擎，与 Velocity、FreeMarker 等传统 Java 模板引擎不同，Thymeleaf 支持 HTML 原型，其文件后缀为“.html”，因此它可以直接被浏览器打开，此时浏览器会忽略未定义的 Thymeleaf 标签属性，展示 thymeleaf 模板的静态页面效果；当通过 Web 应用程序访问时，Thymeleaf 会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 通过在 html 标签中，增加额外属性来达到“模板+数据”的展示方式，示例代码如下。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text 为 Thymeleaf 属性，用于在展示文本--&gt;&lt;h1 th:text=&quot;迎您来到Thymeleaf&quot;&gt;欢迎您访问静态页面 HTML&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 当直接使用浏览器打开时，浏览器展示结果如下。 1欢迎您访问静态页面HTML 当通过 Web 应用程序访问时，浏览器展示结果如下。 1迎您来到Thymeleaf Thymeleaf 的特点Thymeleaf 模板引擎具有以下特点： 动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。 开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。 与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。 2. Thymeleaf 语法规则在使用 Thymeleaf 之前，首先要在页面的 html 标签中声明名称空间，示例代码如下。 1xmlns:th=&quot;http://www.thymeleaf.org&quot; 在 html 标签中声明此名称空间，可避免编辑器出现 html 验证错误，但这一步并非必须进行的，即使我们不声明该命名空间，也不影响 Thymeleaf 的使用。 Thymeleaf 作为一种模板引擎，它拥有自己的语法规则。Thymeleaf 语法分为以下 2 类： 标准表达式语法 th 属性 2.1 标准表达式语法Thymeleaf 模板引擎支持多种表达式： 变量表达式：${…} 选择变量表达式：*{…} 链接表达式：@{…} 国际化表达式：#{…} 片段引用表达式：~{…} 2.1.1 变量表达式使用 ${} 包裹的表达式被称为变量表达式，该表达式具有以下功能： 获取对象的属性和方法 使用内置的基本对象 使用内置的工具对象 ① 获取对象的属性和方法 使用变量表达式可以获取对象的属性和方法，例如，获取 person 对象的 lastName 属性，表达式形式如下： 1$&#123;person.lastName&#125; ② 使用内置的基本对象 使用变量表达还可以使用内置基本对象，获取内置对象的属性，调用内置对象的方法。 Thymeleaf 中常用的内置基本对象如下： #ctx ：上下文对象； #vars ：上下文变量； #locale：上下文的语言环境； #request：HttpServletRequest 对象（仅在 Web 应用中可用）； #response：HttpServletResponse 对象（仅在 Web 应用中可用）； #session：HttpSession 对象（仅在 Web 应用中可用）； #servletContext：ServletContext 对象（仅在 Web 应用中可用）。 例如，我们通过以下 2 种形式，都可以获取到 session 对象中的 map 属性： 1$&#123;#session.getAttribute(&#x27;map&#x27;)&#125;$&#123;session.map&#125; ③ 使用内置的工具对象 除了能使用内置的基本对象外，变量表达式还可以使用一些内置的工具对象。 strings：字符串工具对象，常用方法有：equals、equalsIgnoreCase、length、trim、toUpperCase、toLowerCase、indexOf、substring、replace、startsWith、endsWith，contains 和 containsIgnoreCase 等； numbers：数字工具对象，常用的方法有：formatDecimal 等； bools：布尔工具对象，常用的方法有：isTrue 和 isFalse 等； arrays：数组工具对象，常用的方法有：toArray、length、isEmpty、contains 和 containsAll 等； lists&#x2F;sets：List&#x2F;Set 集合工具对象，常用的方法有：toList、size、isEmpty、contains、containsAll 和 sort 等； maps：Map 集合工具对象，常用的方法有：size、isEmpty、containsKey 和 containsValue 等； dates：日期工具对象，常用的方法有：format、year、month、hour 和 createNow 等。 例如，我们可以使用内置工具对象 strings 的 equals 方法，来判断字符串与对象的某个属性是否相等，代码如下。 1$&#123;#strings.equals(&#x27;编程帮&#x27;,name)&#125; 2.1.2 选择变量表达式选择变量表达式与变量表达式功能基本一致，只是在变量表达式的基础上增加了与 th:object 的配合使用。当使用 th:object 存储一个对象后，我们可以在其后代中使用选择变量表达式（*{…}）获取该对象中的属性，其中，“*”即代表该对象。 123&lt;div th:object=&quot;$&#123;session.user&#125;&quot; &gt; &lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;&lt;/div&gt; th:object 用于存储一个临时变量，该变量只在该标签及其后代中有效，在后面的内容“th 属性”中我详细介绍。 2.1.3 链接表达式不管是静态资源的引用，还是 form 表单的请求，凡是链接都可以用链接表达式 （@{…}）。 链接表达式的形式结构如下： 无参请求：@{&#x2F;xxx} 有参请求：@{&#x2F;xxx(k1&#x3D;v1,k2&#x3D;v2)} 例如使用链接表达式引入 css 样式表，代码如下。 1&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; 2.1.4 国际化表达式消息表达式一般用于国际化的场景。结构如下。 1th:text=&quot;#&#123;msg&#125;&quot; 注意：此处了解即可，我们会在后面的章节中详细介绍。 2.1.5 片段引用表达式片段引用表达式用于在模板页面中引用其他的模板片段，该表达式支持以下 2 中语法结构： 推荐：~{templatename::fragmentname} 支持：~{templatename::#id} 以上语法结构说明如下： templatename：模版名，Thymeleaf 会根据模版名解析完整路径：&#x2F;resources&#x2F;templates&#x2F;templatename.html，要注意文件的路径。 fragmentname：片段名，Thymeleaf 通过 th:fragment 声明定义代码块，即：th:fragment&#x3D;”fragmentname” id：HTML 的 id 选择器，使用时要在前面加上 # 号，不支持 class 选择器。 2.2 th 属性Thymeleaf 还提供了大量的 th 属性，这些属性可以直接在 HTML 标签中使用，其中常用 th 属性及其示例如下表。 属性 描述 示例 th:id 替换 HTML 的 id 属性 &lt;input id=&quot;html-id&quot; th:id=&quot;thymeleaf-id&quot; /&gt; th:text 文本替换，转义特殊字符 &lt;h1 th:text=&quot;hello，bianchengbang&quot; &gt;hello&lt;/h1&gt; th:utext 文本替换，不转义特殊字符 &lt;div th:utext=&quot;&lt;h1&gt;欢迎来到编程帮！&lt;/h1&gt;&quot; &gt;欢迎你&lt;/div&gt; th:object 在父标签选择对象，子标签使用 *{…} 选择表达式选取值。 没有选择对象，那子标签使用选择表达式和 ${…} 变量表达式是一样的效果。 同时即使选择了对象，子标签仍然可以使用变量表达式。 &lt;div th:object=&quot;$&#123;session.user&#125;&quot; &gt; &lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;&lt;/div&gt; th:value 替换 value 属性 &lt;input th:value = &quot;$&#123;user.name&#125;&quot; /&gt; th:with 局部变量赋值运算 &lt;div th:with=&quot;isEvens = $&#123;prodStat.count&#125;%2 == 0&quot; th:text=&quot;$&#123;isEvens&#125;&quot;&gt;&lt;/div&gt; th:style 设置样式 &lt;div th:style=&quot;&#39;color:#F00; font-weight:bold&#39;&quot;&gt;编程帮 www.biancheng.net&lt;/div&gt; th:onclick 点击事件 &lt;td th:onclick = &quot;&#39;getInfo()&#39;&quot;&gt;&lt;/td&gt; th:each 遍历，支持 Iterable、Map、数组等。 &lt;table&gt; &lt;tr th:each=&quot;m:$&#123;session.map&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;m.getKey()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;m.getValue()&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; th:if 根据条件判断是否需要展示此标签 &lt;a th:if =&quot;$&#123;userId == collect.userId&#125;&quot;&gt; th:unless 和 th:if 判断相反，满足条件时不显示 &lt;div th:unless=&quot;$&#123;m.getKey()==&#39;name&#39;&#125;&quot; &gt;&lt;/div&gt; th:switch 与 Java 的 switch case语句类似 通常与 th:case 配合使用，根据不同的条件展示不同的内容 &lt;div th:switch=&quot;$&#123;name&#125;&quot;&gt; &lt;span th:case=&quot;a&quot;&gt;编程帮&lt;/span&gt; &lt;span th:case=&quot;b&quot;&gt;www.biancheng.net&lt;/span&gt;&lt;/div&gt; th:fragment 模板布局，类似 JSP 的 tag，用来定义一段被引用或包含的模板片段 &lt;footer th:fragment=&quot;footer&quot;&gt;插入的内容&lt;/footer&gt; th:insert 布局标签； 将使用 th:fragment 属性指定的模板片段（包含标签）插入到当前标签中。 &lt;div th:insert=&quot;commons/bar::footer&quot;&gt;&lt;/div&gt; th:replace 布局标签； 使用 th:fragment 属性指定的模板片段（包含标签）替换当前整个标签。 &lt;div th:replace=&quot;commons/bar::footer&quot;&gt;&lt;/div&gt; th:selected select 选择框选中 &lt;select&gt; &lt;option&gt;---&lt;/option&gt; &lt;option th:selected=&quot;$&#123;name==&#39;a&#39;&#125;&quot;&gt; 编程帮 &lt;/option&gt; &lt;option th:selected=&quot;$&#123;name==&#39;b&#39;&#125;&quot;&gt; www.biancheng.net &lt;/option&gt;&lt;/select&gt; th:src 替换 HTML 中的 src 属性 &lt;img th:src=&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; /&gt; th:inline 内联属性； 该属性有 text，none,javascript 三种取值， 在 script 标签中使用时，js 代码中可以获取到后台传递页面的对象。 &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; var name = /*[[$&#123;name&#125;]]*/ &#39;bianchengbang&#39;; alert(name)&lt;/script&gt; th:action 替换表单提交地址 &lt;form th:action=&quot;@&#123;/user/login&#125;&quot; th:method=&quot;post&quot;&gt;&lt;/form&gt; 3. Thymeleaf 公共页面抽取在 Web 项目中，通常会存在一些公共页面片段（重复代码），例如头部导航栏、侧边菜单栏和公共的 js css 等。我们一般会把这些公共页面片段抽取出来，存放在一个独立的页面中，然后再由其他页面根据需要进行引用，这样可以消除代码重复，使页面更加简洁。 3.1 抽取公共页面Thymeleaf 作为一种优雅且高度可维护的模板引擎，同样支持公共页面的抽取和引用。我们可以将公共页面片段抽取出来，存放到一个独立的页面中，并使用 Thymeleaf 提供的 th:fragment 属性为这些抽取出来的公共页面片段命名。 示例 1将公共页面片段抽取出来，存放在 commons.html 中，代码如下。 123&lt;div th:fragment=&quot;fragment-name&quot; id=&quot;fragment-id&quot;&gt; &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt; 3.2 引用公共页面在 Thymeleaf 中，我们可以使用以下 3 个属性，将公共页面片段引入到当前页面中。 th:insert：将代码块片段整个插入到使用了 th:insert 属性的 HTML 标签中； th:replace：将代码块片段整个替换使用了 th:replace 属性的 HTML 标签中； th:include：将代码块片段包含的内容插入到使用了 th:include 属性的 HTML 标签中。 使用上 3 个属性引入页面片段，都可以通过以下 2 种方式实现。 ~{templatename::selector}：模板名::选择器 ~{templatename::fragmentname}：模板名::片段名 通常情况下，{} 可以省略，其行内写法为 [[{…}]] 或 [({…})]，其中 [[{…}]] 会转义特殊字符，[(~{…})] 则不会转义特殊字符。 示例 21.在页面 fragment.html 中引入 commons.html 中声明的页面片段，可以通过以下方式实现。 1234567891011121314&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt; 2.启动 Spring Boot，使用浏览器访问 fragment.html，查看源码，结果如下。 123456789101112131415161718192021222324252627282930&lt;!--th:insert 片段名引入--&gt;&lt;div&gt; &lt;div id=&quot;fragment-id&quot;&gt; &lt;span&gt;公共页面片段&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div&gt; &lt;div id=&quot;fragment-id&quot;&gt; &lt;span&gt;公共页面片段&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div id=&quot;fragment-id&quot;&gt; &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div id=&quot;fragment-id&quot;&gt; &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div&gt; &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div&gt; &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt; 3.3 传递参数Thymeleaf 在抽取和引入公共页面片段时，还可以进行参数传递，大致步骤如下： 传入参数； 使用参数。 3.3.1 传入参数引用公共页面片段时，我们可以通过以下 2 种方式，将参数传入到被引用的页面片段中： 模板名::选择器名或片段名(参数1&#x3D;参数值1,参数2&#x3D;参数值2) 模板名::选择器名或片段名(参数值1,参数值2) 注： 若传入参数较少时，一般采用第二种方式，直接将参数值传入页面片段中； 若参数较多时，建议使用第一种方式，明确指定参数名和参数值，。 示例代码如下： 1234567891011121314&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name(var1=&#x27;insert-name&#x27;,var2=&#x27;insert-name2&#x27;)&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id(var1=&#x27;insert-id&#x27;,var2=&#x27;insert-id2&#x27;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name(var1=&#x27;replace-name&#x27;,var2=&#x27;replace-name2&#x27;)&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id(var1=&#x27;replace-id&#x27;,var2=&#x27;replace-id2&#x27;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name(var1=&#x27;include-name&#x27;,var2=&#x27;include-name2&#x27;)&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id(var1=&#x27;include-id&#x27;,var2=&#x27;include-id2&#x27;)&quot;&gt;&lt;/div&gt; 3.3.2 使用参数在声明页面片段时，我们可以在片段中声明并使用这些参数，例如： 1234&lt;!--使用 var1 和 var2 声明传入的参数，并在该片段中直接使用这些参数 --&gt;&lt;div th:fragment=&quot;fragment-name(var1,var2)&quot; id=&quot;fragment-id&quot;&gt; &lt;p th:text=&quot;&#x27;参数1:&#x27;+$&#123;var1&#125; + &#x27;-------------------参数2:&#x27; + $&#123;var2&#125;&quot;&gt;...&lt;/p&gt;&lt;/div&gt; 启动 Spring Boot，使用浏览器访问 fragment.html，结果如下图。 Spring Boot整合ThymeleafSpring Boot 推荐使用 Thymeleaf 作为其模板引擎。SpringBoot 为 Thymeleaf 提供了一系列默认配置，项目中一但导入了 Thymeleaf 的依赖，相对应的自动配置 （ThymeleafAutoConfiguration 或 FreeMarkerAutoConfiguration） 就会自动生效，因此 Thymeleaf 可以与 Spring Boot 完美整合 。 Spring Boot 整合 Thymeleaf 模板引擎，需要以下步骤： 引入 Starter 依赖 创建模板文件，并放在在指定目录下 引入依赖Spring Boot 整合 Thymeleaf 的第一步，就是在项目的 pom.xml 中添加 Thymeleaf 的 Starter 依赖，代码如下。 12345&lt;!--Thymeleaf 启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 创建模板文件Spring Boot 通过 ThymeleafAutoConfiguration 自动配置类对 Thymeleaf 提供了一整套的自动化配置方案，该自动配置类的部分源码如下。 12345678@Configuration( proxyBeanMethods = false)@EnableConfigurationProperties(&#123;ThymeleafProperties.class&#125;)@ConditionalOnClass(&#123;TemplateMode.class, SpringTemplateEngine.class&#125;)@AutoConfigureAfter(&#123;WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class&#125;)public class ThymeleafAutoConfiguration &#123;&#125; ThymeleafAutoConfiguration 使用 @EnableConfigurationProperties 注解导入了 ThymeleafProperties 类，该类包含了与 Thymeleaf 相关的自动配置属性，其部分源码如下。 12345678910111213141516@ConfigurationProperties( prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = &quot;classpath:/templates/&quot;; private String suffix = &quot;.html&quot;; private String mode = &quot;HTML&quot;; private Charset encoding; private boolean cache;...&#125; ThymeleafProperties 通过 @ConfigurationProperties 注解将配置文件（application.properties&#x2F;yml） 中前缀为 spring.thymeleaf 的配置和这个类中的属性绑定。 在 ThymeleafProperties 中还提供了以下静态变量： DEFAULT_ENCODING：默认编码格式 DEFAULT_PREFIX：视图解析器的前缀 DEFAULT_SUFFIX：视图解析器的后缀 根据以上配置属性可知，Thymeleaf 模板的默认位置在 resources&#x2F;templates 目录下，默认的后缀是 html，即只要将 HTML 页面放在“classpath:&#x2F;templates&#x2F;”下，Thymeleaf 就能自动进行渲染。 与 Spring Boot 其他自定义配置一样，我们可以在 application.properties&#x2F;yml 中修改以 spring.thymeleaf 开始的属性，以实现修改 Spring Boot 对 Thymeleaf 的自动配置的目的。 示例1.创建一个名为 hello.html 的页面，并将该页面放在项目类路径（resources）下的 templates 目录中，hello.html 代码如下。 123456789101112&lt;!DOCTYPE html&gt;&lt;!--导入thymeleaf的名称空间--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text 为 Thymeleaf 属性，用于获取指定属性的值--&gt;&lt;h1 th:text=&quot;&#x27;欢迎来到&#x27;+$&#123;name&#125;&quot;&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.新建一个控制类 HelloController，并通过参数 map 传递数据到前台页面中，代码如下。 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello(Map&lt;String, Object&gt; map) &#123; //通过 map 向前台页面传递数据 map.put(&quot;name&quot;, &quot;编程帮（www.biancheng.net）&quot;); return &quot;hello&quot;; &#125;&#125; 3.启动 Spring Boot，使用浏览器访问“http://localhost:8080/hello”。 Spring Boot国际化国际化（Internationalization 简称 I18n，其中“I”和“n”分别为首末字符，18 则为中间的字符数）是指软件开发时应该具备支持多种语言和地区的功能。换句话说就是，开发的软件需要能同时应对不同国家和地区的用户访问，并根据用户地区和语言习惯，提供相应的、符合用具阅读习惯的页面和数据，例如，为中国用户提供汉语界面显示，为美国用户提供提供英语界面显示。 在 Spring 项目中实现国际化，通常需要以下 3 步： 编写国际化资源（配置）文件； 使用 ResourceBundleMessageSource 管理国际化资源文件； 在页面获取国际化内容。 1. 编写国际化资源文件在 Spring Boot 的类路径下创建国际化资源文件，文件名格式为：基本名_语言代码_国家或地区代码，例如 login_en_US.properties、login_zh_CN.properties。 以 spring-boot-springmvc-demo1为例，在 src&#x2F;main&#x2F;resources 下创建一个 i18n 的目录，并在该目录中按照国际化资源文件命名格式分别创建以下三个文件， login.properties：无语言设置时生效 login_en_US.properties ：英语时生效 login_zh_CN.properties：中文时生效 以上国际化资源文件创建完成后，IDEA 会自动识别它们，并转换成如下的模式： 打开任意一个国际化资源文件，并切换为 Resource Bundle 模式，然后点击“+”号，创建所需的国际化属性，如下图。 2. 使用 ResourceBundleMessageSource 管理国际化资源文件Spring Boot 已经对 ResourceBundleMessageSource 提供了默认的自动配置。 Spring Boot 通过 MessageSourceAutoConfiguration 对 ResourceBundleMessageSource 提供了默认配置，其部分源码如下。 12345678910111213141516171819202122232425262728293031323334353637383940@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Conditional(org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration.ResourceBundleCondition.class)@EnableConfigurationPropertiespublic class MessageSourceAutoConfiguration &#123; private static final Resource[] NO_RESOURCES = &#123;&#125;; // 将 MessageSourceProperties 以组件的形式添加到容器中 // MessageSourceProperties 下的每个属性都与以 spring.messages 开头的属性对应 @Bean @ConfigurationProperties(prefix = &quot;spring.messages&quot;) public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125; //Spring Boot 会从容器中获取 MessageSourceProperties // 读取国际化资源文件的 basename（基本名）、encoding（编码）等信息 // 并封装到 ResourceBundleMessageSource 中 @Bean public MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); //读取国际化资源文件的 basename (基本名),并封装到 ResourceBundleMessageSource 中 if (StringUtils.hasText(properties.getBasename())) &#123; messageSource.setBasenames(StringUtils .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; //读取国际化资源文件的 encoding (编码),并封装到 ResourceBundleMessageSource 中 if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; &#125; ...&#125; 从以上源码可知： Spring Boot 将 MessageSourceProperties 以组件的形式添加到容器中； MessageSourceProperties 的属性与配置文件中以“spring.messages”开头的配置进行了绑定； Spring Boot 从容器中获取 MessageSourceProperties 组件，并从中读取国际化资源文件的 basename（文件基本名）、encoding（编码）等信息，将它们封装到 ResourceBundleMessageSource 中； Spring Boot 将 ResourceBundleMessageSource 以组件的形式添加到容器中，进而实现对国际化资源文件的管理。 查看 MessageSourceProperties 类，其代码如下。 12345678910111213141516public class MessageSourceProperties &#123; private String basename = &quot;messages&quot;; private Charset encoding; @DurationUnit(ChronoUnit.SECONDS) private Duration cacheDuration; private boolean fallbackToSystemLocale; private boolean alwaysUseMessageFormat; private boolean useCodeAsDefaultMessage; public MessageSourceProperties() &#123; this.encoding = StandardCharsets.UTF_8; this.fallbackToSystemLocale = true; this.alwaysUseMessageFormat = false; this.useCodeAsDefaultMessage = false; &#125; ...&#125; 通过以上代码，我们可以得到以下 3 点信息： MessageSourceProperties 为 basename、encoding 等属性提供了默认值； basename 表示国际化资源文件的基本名，其默认取值为“message”，即 Spring Boot 默认会获取类路径下的 message.properties 以及 message_XXX.properties 作为国际化资源文件； 在 application.porperties&#x2F;yml 等配置文件中，使用配置参数“spring.messages.basename”即可重新指定国际化资源文件的基本名。 通过以上源码分析可知，Spring Boot 已经对国际化资源文件的管理提供了默认自动配置，我们这里只需要在 Spring Boot 全局配置文件中，使用配置参数“spring.messages.basename”指定我们自定义的国际资源文件的基本名即可，代码如下（当指定多个资源文件时，用逗号分隔）。 1spring.messages.basename=i18n.login 3. 获取国际化内容由于页面使用的是 Tymeleaf 模板引擎，因此我们可以通过表达式 #{…} 获取国际化内容。 以 spring-boot-adminex 为例，在 login.html 中获取国际化内容，代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;ThemeBucket&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;#&quot; type=&quot;image/png&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;!--将js css 等静态资源的引用修改为 绝对路径--&gt; &lt;link href=&quot;css/style.css&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;css/style-responsive.css&quot; th:href=&quot;@&#123;/css/style-responsive.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;js/html5shiv.js&quot; th:src=&quot;@&#123;/js/html5shiv.js&#125;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/respond.min.js&quot; th:src=&quot;@&#123;/js/respond.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body class=&quot;login-body&quot;&gt;&lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/user/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-signin-heading text-center&quot;&gt; &lt;h1 class=&quot;sign-title&quot; th:text=&quot;#&#123;login.btn&#125;&quot;&gt;Sign In&lt;/h1&gt; &lt;img src=&quot;/images/login-logo.png&quot; th:src=&quot;@&#123;/images/login-logo.png&#125;&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;login-wrap&quot;&gt; &lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; placeholder=&quot;User ID&quot; autofocus th:placeholder=&quot;#&#123;login.username&#125;&quot;/&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot;/&gt; &lt;label class=&quot;checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; th:text=&quot;#&#123;login.remember&#125;&quot;&gt; &lt;span class=&quot;pull-right&quot;&gt; &lt;a data-toggle=&quot;modal&quot; href=&quot;#myModal&quot; th:text=&quot;#&#123;login.forgot&#125;&quot;&gt; &lt;/a&gt; &lt;/span&gt; &lt;/label&gt; &lt;button class=&quot;btn btn-lg btn-login btn-block&quot; type=&quot;submit&quot;&gt; &lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;div class=&quot;registration&quot;&gt; &lt;!--Thymeleaf 行内写法--&gt; [[#&#123;login.not-a-member&#125;]] &lt;a class=&quot;&quot; href=&quot;/registration.html&quot; th:href=&quot;@&#123;/registration.html&#125;&quot;&gt; [[#&#123;login.signup&#125;]] &lt;/a&gt; &lt;!--thymeleaf 模板引擎的参数用（）代替 ？--&gt; &lt;br/&gt; &lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;| &lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Modal --&gt; &lt;div aria-hidden=&quot;true&quot; aria-labelledby=&quot;myModalLabel&quot; role=&quot;dialog&quot; tabindex=&quot;-1&quot; id=&quot;myModal&quot; class=&quot;modal fade&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;Forgot Password ?&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;p&gt;Enter your e-mail address below to reset your password.&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; autocomplete=&quot;off&quot; class=&quot;form-control placeholder-no-fix&quot;&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button data-dismiss=&quot;modal&quot; class=&quot;btn btn-default&quot; type=&quot;button&quot;&gt;Cancel&lt;/button&gt; &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot;&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- modal --&gt; &lt;/form&gt;&lt;/div&gt;&lt;!-- Placed js at the end of the document so the pages load faster --&gt;&lt;!-- Placed js at the end of the document so the pages load faster --&gt;&lt;script src=&quot;js/jquery-1.10.2.min.js&quot; th:src=&quot;@&#123;/js/jquery-1.10.2.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/bootstrap.min.js&quot; th:src=&quot;@&#123;/js/bootstrap.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/modernizr.min.js&quot; th:src=&quot;@&#123;/js/modernizr.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 验证启动 Spring Boot，使用浏览器访问登陆页，此时浏览器默认使用中文，结果如下图。 将浏览器语言切换为英文，再次访问登陆页，结果如下图。 手动切换语言如下图所示，在登陆页（login.html）最下方有两个切换语言的链接，想要通过点击它们来切换进行国际化的语言，该怎么做呢？ 区域信息解析器自动配置我们知道，Spring MVC 进行国际化时有 2 个十分重要的对象： Locale：区域信息对象 LocaleResolver：区域信息解析器，容器中的组件，负责获取区域信息对象 我们可以通过以上两个对象对区域信息的切换，以达到切换语言的目的。 Spring Boot 在 WebMvcAutoConfiguration 中为区域信息解析器（LocaleResolver）进行了自动配置，源码如下。 12345678910111213141516@Bean @ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME) @SuppressWarnings(&quot;deprecation&quot;) public LocaleResolver localeResolver() &#123; if (this.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.webProperties.getLocale()); &#125; if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); Locale locale = (this.webProperties.getLocale() != null) ? this.webProperties.getLocale() : this.mvcProperties.getLocale(); localeResolver.setDefaultLocale(locale); return localeResolver; &#125; 从以上源码可知： 该方法默认向容器中添加了一个区域信息解析器（LocaleResolver）组件，它会根据请求头中携带的“Accept-Language”参数，获取相应区域信息（Locale）对象。 该方法上使用了 @ConditionalOnMissingBean 注解，其参数 name 的取值为 localeResolver（与该方法注入到容器中的组件名称一致），该注解的含义为：当容器中不存在名称为 localResolver 组件时，该方法才会生效。换句话说，当我们手动向容器中添加一个名为“localeResolver”的组件时，Spring Boot 自动配置的区域信息解析器会失效，而我们定义的区域信息解析器则会生效。 手动切换语言1.修改 login.html 切换语言链接，在请求中携带国际化区域信息，代码如下。 123&lt;!--thymeleaf 模板引擎的参数用（）代替 ？--&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;|&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; 2.在 net.biancheng.www 下创建一个 component 包，并在该包中创建一个区域信息解析器 MyLocalResolver，代码如下。 12345678910111213141516171819//自定义区域信息解析器public class MyLocalResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; //获取请求中参数 String l = request.getParameter(&quot;l&quot;); //获取默认的区域信息解析器 Locale locale = Locale.getDefault(); //根据请求中的参数重新构造区域信息对象 if (StringUtils.hasText(l)) &#123; String[] s = l.split(&quot;_&quot;); locale = new Locale(s[0], s[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; 3.在 net.biancheng.www.config 的 MyMvcConfig 中添加以下方法，将自定义的区域信息解析器以组件的形式添加到容器中，代码如下。 12345//将自定义的区域信息解析器以组件的形式添加到容器中@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocalResolver();&#125; Spring Boot拦截器精讲根据 URL 对请求进行拦截，主要应用于登陆校验、权限验证、乱码解决、性能监控和异常处理等功能上。Spring Boot 同样提供了拦截器功能。 在 Spring Boot 项目中，使用拦截器功能通常需要以下 3 步： 定义拦截器； 注册拦截器； 指定拦截规则（如果是拦截所有，静态资源也会被拦截）。 定义拦截器在 Spring Boot 中定义拦截器十分的简单，只需要创建一个拦截器类，并实现 HandlerInterceptor 接口即可。 HandlerInterceptor 接口中定义以下 3 个方法，如下表。 返回值类型 方法声明 描述 boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) 该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。 void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) 该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。 void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) 该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。 示例1以 spring-boot-adminex 项目为例，在 net.biancheng.www.componet 中创建一个名为 LoginInterceptor 的拦截器类，对登陆进行拦截，代码如下。 123456789101112131415161718192021222324252627@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; // 目标方法执行前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;); if (loginUser == null) &#123; //未登录，返回登陆页 request.setAttribute(&quot;msg&quot;, &quot;您没有权限进行此操作，请先登陆！&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response); return false; &#125; else &#123; //放行 return true; &#125; &#125; // 目标方法执行后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;postHandle执行&#123;&#125;&quot;, modelAndView); &#125; // 页面渲染后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;, ex); &#125;&#125; 注册拦截器创建一个实现了 WebMvcConfigurer 接口的配置类（使用了 @Configuration 注解的类），重写 addInterceptors() 方法，并在该方法中调用 registry.addInterceptor() 方法将自定义的拦截器注册到容器中。 示例 2在配置类 MyMvcConfig 中，添加以下方法注册拦截器，代码如下。 12345678@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; ...... @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()); &#125;&#125; 指定拦截规则在使用 registry.addInterceptor() 方法将拦截器注册到容器中后，我们便可以继续指定拦截器的拦截规则了，代码如下。 1234567891011@Slf4j@Configurationpublic class MyConfig implements WebMvcConfigurer &#123; ...... @Override public void addInterceptors(InterceptorRegistry registry) &#123; log.info(&quot;注册拦截器&quot;); registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;) //拦截所有请求，包括静态资源文件 .excludePathPatterns(&quot;/&quot;, &quot;/login&quot;, &quot;/index.html&quot;, &quot;/user/login&quot;, &quot;/css/**&quot;, &quot;/images/**&quot;, &quot;/js/**&quot;, &quot;/fonts/**&quot;); //放行登录页，登陆操作，静态资源 &#125;&#125; 在指定拦截器拦截规则时，调用了两个方法，这两个方法的说明如下： addPathPatterns：该方法用于指定拦截路径，例如拦截路径为“&#x2F;**”，表示拦截所有请求，包括对静态资源的请求。 excludePathPatterns：该方法用于排除拦截路径，即指定不需要被拦截器拦截的请求。 至此，拦截器的基本功能已经完成，接下来，我们先实现 spring-boot-adminex 的登陆功能，为验证登陆拦截做准备。 实现登陆功能1.将 AdminEx 模板中的 main.html 移动到 src&#x2F;main&#x2F;resources&#x2F;templates 中，结构如下图。 2.在 net.bianheng.www.controller 中创建一个 LoginController， 并在其中添加处理登陆请求的方法 doLogin()，代码如下。 12345678910111213141516171819202122@Slf4j@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/user/login&quot;) public String doLogin(User user, Map&lt;String, Object&gt; map, HttpSession session) &#123; if (user != null &amp;&amp; StringUtils.hasText(user.getUsername()) &amp;&amp; &quot;123456&quot;.equals(user.getPassword())) &#123; session.setAttribute(&quot;loginUser&quot;, user); log.info(&quot;登陆成功，用户名：&quot; + user.getUsername()); //防止重复提交使用重定向 return &quot;redirect:/main.html&quot;; &#125; else &#123; map.put(&quot;msg&quot;, &quot;用户名或密码错误&quot;); log.error(&quot;登陆失败&quot;); return &quot;login&quot;; &#125; &#125;/* @RequestMapping(&quot;/main.html&quot;) public String mainPage()&#123; return &quot;main&quot;; &#125;*/&#125; 3.在配置类 MyMvcConfig 中添加视图映射，代码如下。 123456789101112@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //当访问 “/” 或 “/index.html” 时，都直接跳转到登陆页面 registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); //添加视图映射 main.html 指向 dashboard.html registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;main&quot;); &#125; ......&#125; 4.在 login.html 适当位置添加以下代码，显示错误信息。 1&lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt; 验证登陆及登陆拦截功能1.启动 Spring Boot，在未登录的情况下，直接通过“http://localhost:8080/main.html”访问主页，结果如下图。 2.在登陆页用户名和密码输入框内分别输入 “admin”和“admin123”，点击下方的登陆按钮，结果如下图。 3.在登陆页用户名和密码输入框内分别输入 “admin”和“123456”，点击下方的登陆按钮，结果如下图。 Spring Boot默认异常处理Spring Boot 默认异常处理机制Spring Boot 提供了一套默认的异常处理机制，一旦程序中出现了异常，Spring Boot 会自动识别客户端的类型（浏览器客户端或机器客户端），并根据客户端的不同，以不同的形式展示异常信息。 1.对于浏览器客户端而言，Spring Boot 会响应一个“ whitelabel”错误视图，以 HTML 格式呈现错误信息，如图 1； 2.对于机器客户端而言，Spring Boot 将生成 JSON 响应，来展示异常消息。 1234567&#123; &quot;timestamp&quot;: &quot;2021-07-12T07:05:29.885+00:00&quot;, &quot;status&quot;: 404, &quot;error&quot;: &quot;Not Found&quot;, &quot;message&quot;: &quot;No message available&quot;, &quot;path&quot;: &quot;/m1ain.html&quot;&#125; Spring Boot 异常处理自动配置原理Spring Boot 通过配置类 ErrorMvcAutoConfiguration 对异常处理提供了自动配置，该配置类向容器中注入了以下 4 个组件。 ErrorPageCustomizer：该组件会在在系统发生异常后，默认将请求转发到“&#x2F;error”上。 BasicErrorController：处理默认的“&#x2F;error”请求。 DefaultErrorViewResolver：默认的错误视图解析器，将异常信息解析到相应的错误视图上。 DefaultErrorAttributes：用于页面上共享异常信息。 ErrorPageCustomizerErrorMvcAutoConfiguration 向容器中注入了一个名为 ErrorPageCustomizer 的组件，它主要用于定制错误页面的响应规则。 1234@Beanpublic ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) &#123; return new ErrorPageCustomizer(this.serverProperties, dispatcherServletPath);&#125; ErrorPageCustomizer 通过 registerErrorPages() 方法来注册错误页面的响应规则。当系统中发生异常后，ErrorPageCustomizer 组件会自动生效，并将请求转发到 “**&#x2F;error”上，交给 BasicErrorController** 进行处理，其部分代码如下。 1234567@Overridepublic void registerErrorPages(ErrorPageRegistry errorPageRegistry) &#123; //将请求转发到 /errror（this.properties.getError().getPath()）上 ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())); // 注册错误页面 errorPageRegistry.addErrorPages(errorPage);&#125; BasicErrorControllerErrorMvcAutoConfiguration 还向容器中注入了一个错误控制器组件 BasicErrorController，代码如下。 1234567@Bean@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)public BasicErrorController basicErrorController(ErrorAttributes errorAttributes, ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), errorViewResolvers.orderedStream().collect(Collectors.toList()));&#125; BasicErrorController 的定义如下。 123456789101112131415161718192021222324252627282930313233343536373839404142//BasicErrorController 用于处理 “/error” 请求@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; ...... /** * 该方法用于处理浏览器客户端的请求发生的异常 * 生成 html 页面来展示异常信息 * @param request * @param response * @return */ @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; //获取错误状态码 HttpStatus status = getStatus(request); //getErrorAttributes 根据错误信息来封装一些 model 数据，用于页面显示 Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML))); //为响应对象设置错误状态码 response.setStatus(status.value()); //调用 resolveErrorView() 方法，使用错误视图解析器生成 ModelAndView 对象（包含错误页面地址和页面内容） ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model); &#125; /** * 该方法用于处理机器客户端的请求发生的错误 * 产生 JSON 格式的数据展示错误信息 * @param request * @return */ @RequestMapping public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; HttpStatus status = getStatus(request); if (status == HttpStatus.NO_CONTENT) &#123; return new ResponseEntity&lt;&gt;(status); &#125; Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL)); return new ResponseEntity&lt;&gt;(body, status); &#125; ......&#125; Spring Boot 通过 BasicErrorController 进行统一的错误处理（例如默认的“&#x2F;error”请求）。Spring Boot 会自动识别发出请求的客户端的类型（浏览器客户端或机器客户端），并根据客户端类型，将请求分别交给 errorHtml() 和 error() 方法进行处理。 返回值类型 方法声明 客户端类型 错误信息返类型 ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) 浏览器客户端 text&#x2F;html（错误页面） ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) 机器客户端（例如安卓、IOS、Postman 等等） JSON 换句话说，当使用浏览器访问出现异常时，会进入 BasicErrorController 控制器中的 errorHtml() 方法进行处理，当使用安卓、IOS、Postman 等机器客户端访问出现异常时，就进入error() 方法处理。 在 errorHtml() 方法中会调用父类（AbstractErrorController）的 resolveErrorView() 方法，代码如下。 123456789101112protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //获取容器中的所有的错误视图解析器来处理该异常信息 for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; //调用错误视图解析器的 resolveErrorView 解析到错误视图页面 ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 从上述源码可以看出，在响应页面的时候，会在父类的 resolveErrorView 方法中获取容器中所有的 ErrorViewResolver 对象（错误视图解析器，包括 DefaultErrorViewResolver 在内），一起来解析异常信息。 DefaultErrorViewResolverErrorMvcAutoConfiguration 还向容器中注入了一个默认的错误视图解析器组件 DefaultErrorViewResolver，代码如下。 123456@Bean@ConditionalOnBean(DispatcherServlet.class)@ConditionalOnMissingBean(ErrorViewResolver.class)DefaultErrorViewResolver conventionErrorViewResolver() &#123; return new DefaultErrorViewResolver(this.applicationContext, this.resources);&#125; 当发出请求的客户端为浏览器时，Spring Boot 会获取容器中所有的 ErrorViewResolver 对象（错误视图解析器），并分别调用它们的 resolveErrorView() 方法对异常信息进行解析，其中自然也包括 DefaultErrorViewResolver（默认错误信息解析器）。 DefaultErrorViewResolver 的部分代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered &#123; private static final Map&lt;HttpStatus.Series, String&gt; SERIES_VIEWS; static &#123; Map&lt;HttpStatus.Series, String&gt; views = new EnumMap&lt;&gt;(HttpStatus.Series.class); views.put(Series.CLIENT_ERROR, &quot;4xx&quot;); views.put(Series.SERVER_ERROR, &quot;5xx&quot;); SERIES_VIEWS = Collections.unmodifiableMap(views); &#125; ...... @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //尝试以错误状态码作为错误页面名进行解析 ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; //尝试以 4xx 或 5xx 作为错误页面页面进行解析 modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //错误模板页面，例如 error/404、error/4xx、error/500、error/5xx String errorViewName = &quot;error/&quot; + viewName; //当模板引擎可以解析这些模板页面时，就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //在模板能够解析到模板页面的情况下，返回 errorViewName 指定的视图 return new ModelAndView(errorViewName, model); &#125; //若模板引擎不能解析，则去静态资源文件夹下查找 errorViewName 对应的页面 return resolveResource(errorViewName, model); &#125; private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; //遍历所有静态资源文件夹 for (String location : this.resources.getStaticLocations()) &#123; try &#123; Resource resource = this.applicationContext.getResource(location); //静态资源文件夹下的错误页面，例如error/404.html、error/4xx.html、error/500.html、error/5xx.html resource = resource.createRelative(viewName + &quot;.html&quot;); //若静态资源文件夹下存在以上错误页面，则直接返回 if (resource.exists()) &#123; return new ModelAndView(new DefaultErrorViewResolver.HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; return null; &#125; ......&#125; DefaultErrorViewResolver 解析异常信息的步骤如下： 根据错误状态码（例如 404、500、400 等），生成一个错误视图 error&#x2F;status，例如 error&#x2F;404、error&#x2F;500、error&#x2F;400。 尝试使用模板引擎解析 error&#x2F;status 视图，即尝试从 classpath 类路径下的 templates 目录下，查找 error&#x2F;status.html，例如 error&#x2F;404.html、error&#x2F;500.html、error&#x2F;400.html。 若模板引擎能够解析到 error&#x2F;status 视图，则将视图和数据封装成 ModelAndView 返回并结束整个解析流程，否则跳转到第 4 步。 依次从各个静态资源文件夹中查找 error&#x2F;status.html，若在静态文件夹中找到了该错误页面，则返回并结束整个解析流程，否则跳转到第 5 步。 将错误状态码（例如 404、500、400 等）转换为 4xx 或 5xx，然后重复前 4 个步骤，若解析成功则返回并结束整个解析流程，否则跳转第 6 步。 处理默认的 “&#x2F;error ”请求，使用 Spring Boot 默认的错误页面（Whitelabel Error Page）。 DefaultErrorAttributesErrorMvcAutoConfiguration 还向容器中注入了一个组件默认错误属性处理工具 DefaultErrorAttributes，代码如下。 12345@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes();&#125; DefaultErrorAttributes 是 Spring Boot 的默认错误属性处理工具，它可以从请求中获取异常或错误信息，并将其封装为一个 Map 对象返回，其部分代码如下。 1234567891011121314151617181920212223242526272829public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123; ...... @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) &#123; Map&lt;String, Object&gt; errorAttributes = getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE)); if (!options.isIncluded(Include.EXCEPTION)) &#123; errorAttributes.remove(&quot;exception&quot;); &#125; if (!options.isIncluded(Include.STACK_TRACE)) &#123; errorAttributes.remove(&quot;trace&quot;); &#125; if (!options.isIncluded(Include.MESSAGE) &amp;&amp; errorAttributes.get(&quot;message&quot;) != null) &#123; errorAttributes.remove(&quot;message&quot;); &#125; if (!options.isIncluded(Include.BINDING_ERRORS)) &#123; errorAttributes.remove(&quot;errors&quot;); &#125; return errorAttributes; &#125; private Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, webRequest); addErrorDetails(errorAttributes, webRequest, includeStackTrace); addPath(errorAttributes, webRequest); return errorAttributes; &#125; ......&#125; 在 Spring Boot 默认的 Error 控制器（BasicErrorController）处理错误时，会调用 DefaultErrorAttributes 的 getErrorAttributes() 方法获取错误或异常信息，并封装成 model 数据（Map 对象），返回到页面或 JSON 数据中。该 model 数据主要包含以下属性： timestamp：时间戳； status：错误状态码 error：错误的提示 exception：导致请求处理失败的异常对象 message：错误&#x2F;异常消息 trace： 错误&#x2F;异常栈信息 path:错误&#x2F;异常抛出时所请求的URL路径 所有通过 DefaultErrorAttributes 封装到 model 数据中的属性，都可以直接在页面或 JSON 中获取。 Spring Boot全局异常处理我们通常会根据自身的需要对 Spring Boot 全局异常进行统一定制，例如定制错误页面，定制错误数据等。 定制错误页面我们可以通过以下 3 种方式定制 Spring Boot 错误页面： 自定义 error.html 自定义动态错误页面 自定义静态错误页面 自定义 error.html我们可以直接在模板引擎文件夹（&#x2F;resources&#x2F;templates）下创建 error.html ，覆盖 Spring Boot 默认的错误视图页面（Whitelabel Error Page）。 示例 11.在 spring-boot-adminex 的模板引擎文件夹（classpath:&#x2F;resources&#x2F;templates）下，创建一个 error.html，代码如下。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;自定义 error.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;自定义 error.html&lt;/h1&gt;&lt;p&gt;status：&lt;span th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;error：&lt;span th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;timestamp：&lt;span th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;message：&lt;span th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，在完成登陆跳转到主页后，使用浏览器地访问“http://localhost:8080/111”，结果如下图。 src&#x3D;”Spring+SpringMVC+SpringBoot+MyBatis&#x2F;11001Ac0-0.png” Spring Boot 使用了我们自定义的 error.html 覆盖了默认的错误视图页面（Whitelabel Error Page）。 自定义动态错误页面如果 Sprng Boot 项目使用了模板引擎，当程序发生异常时，Spring Boot 的默认错误视图解析器（DefaultErrorViewResolver）就会解析模板引擎文件夹（resources&#x2F;templates&#x2F;）下 error 目录中的错误视图页面。 精确匹配我们可以根据错误状态码（例如 404、500、400 等等）的不同，分别创建不同的动态错误页面（例如 404.html、500.html、400.html 等等），并将它们存放在模板引擎文件夹下的 error 目录中。当发生异常时，Spring Boot 会根据其错误状态码精确匹配到对应的错误页面上。 示例 21.在 spring-boot-adminex 的模板引擎文件夹下 error 目录中，创建一个名为 404.html 的错误页面，代码如下。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;自定义动态错误页面 404.html&lt;/h1&gt;&lt;p&gt;status：&lt;span th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;error：&lt;span th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;timestamp：&lt;span th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;message：&lt;span th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，在完成登陆跳转到主页后，在浏览器地址栏输入“http://localhost:8080/111”，结果如下图。 Spring+SpringMVC+SpringBoot+MyBatis&#x2F;11001BV7-1.png” 模糊匹配我们还可以使用 4xx.html 和 5xx.html 作为动态错误页面的文件名，并将它们存放在模板引擎文件夹下的 error 目录中，来模糊匹配对应类型的所有错误，例如 404、400 等错误状态码以“4”开头的所有异常，都会解析到动态错误页面 4xx.html 上。 示例 3在 spring-boot-adminex 的模板引擎文件夹下 error 目录中，创建一个名为 4xx.html 的错误页面，代码如下。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;自定义动态错误页面 4xx.html&lt;/h1&gt;&lt;p&gt;status：&lt;span th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;error：&lt;span th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;timestamp：&lt;span th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;message：&lt;span th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，在完成登陆跳转到主页后，使用浏览器访问“http://localhost:8080/111”，结果如下图。 自定义静态错误页面若 Sprng Boot 项目没有使用模板引擎，当程序发生异常时，Spring Boot 的默认错误视图解析器（DefaultErrorViewResolver）则会解析静态资源文件夹下 error 目录中的静态错误页面。 精确匹配我们可以根据错误状态码（例如 404、500、400 等等）的不同，分别创建不同的静态错误页面（例如 404.html、500.html、400.html 等等），并将它们存放在静态资源文件夹下的 error 目录中。当发生异常时，Spring Boot 会根据错误状态码精确匹配到对应的错误页面上。 示例 41.在 spring-boot-adminex 的静态资源文件夹 src&#x2F;recources&#x2F;static 下的 error 目录中，创建一个名为 404.html 的静态错误页面，代码如下。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;自定义静态错误页面 404.html&lt;/h1&gt;&lt;p&gt;status：&lt;span th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;error：&lt;span th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;timestamp：&lt;span th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;message：&lt;span th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，在完成登陆跳转到主页后，使用浏览器访问“http://localhost:8080/111”，结果如下图。 由于该错误页为静态页面，无法识别 Thymeleaf 表达式，因此无法展示与错误相关的错误信息。 模糊匹配我们还可以使用 4xx.html 和 5xx.html 作为静态错误页面的文件名，并将它们存放在静态资源文件夹下的 error 目录中，来模糊匹配对应类型的所有错误，例如 404、400 等错误状态码以“4”开头的所有错误，都会解析到静态错误页面 4xx.html 上。 示例 3在 spring-boot-adminex 的模板引擎文件夹下的 error 目录中，创建一个名为 4xx.html 的错误页面，代码如下。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;自定义静态错误页面 4xx.html&lt;/h1&gt;&lt;p&gt;status：&lt;span th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;error：&lt;span th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;timestamp：&lt;span th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;message：&lt;span th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.启动 Spring Boot，在完成登陆跳转到主页后，使用浏览器访问“http://localhost:8080/111”，结果如下图。 错误页面优先级以上 5 种方式均可以定制 Spring Boot 错误页面，且它们的优先级顺序为：自定义动态错误页面（精确匹配）&gt;自定义静态错误页面（精确匹配）&gt;自定义动态错误页面（模糊匹配）&gt;自定义静态错误页面（模糊匹配）&gt;自定义 error.html。 当遇到错误时，Spring Boot 会按照优先级由高到低，依次查找解析错误页，一旦找到可用的错误页面，则直接返回客户端展示。 定制错误数据我们知道，Spring Boot 提供了一套默认的异常处理机制，其主要流程如下： 发生异常时，将请求转发到“**&#x2F;error**”，交由 BasicErrorController（Spring Boot 默认的 Error 控制器） 进行处理； BasicErrorController 根据客户端的不同，自动适配返回的响应形式，浏览器客户端返回错误页面，机器客户端返回 JSON 数据。 BasicErrorController 处理异常时，会调用 DefaultErrorAttributes（默认的错误属性处理工具） 的 getErrorAttributes() 方法获取错误数据。 我们还可以定制 Spring Boot 的错误数据，具体步骤如下。 自定义异常处理类，将请求转发到 “&#x2F;error”，交由 Spring Boot 底层（BasicErrorController）进行处理，自动适配浏览器客户端和机器客户端。 通过继承 DefaultErrorAttributes 来定义一个错误属性处理工具，并在原来的基础上添加自定义的错误数据。 1. 自定义异常处理类被 @ControllerAdvice 注解的类可以用来实现全局异常处理，这是 Spring MVC 中提供的功能，在 Spring Boot 中可以直接使用。 1）在 net.biancheng.net.exception 包内，创建一个名为 UserNotExistException 的异常类，代码如下。 1234567package net.biancheng.www.exception;// 自定义异常public class UserNotExistException extends RuntimeException &#123; public UserNotExistException() &#123; super(&quot;用户不存在！&quot;); &#125;&#125; 2）在 IndexController 添加以下方法，触发 UserNotExistException 异常，代码如下。 123456789101112@Controllerpublic class IndexController &#123; ...... @GetMapping(value = &#123;&quot;/testException&quot;&#125;) public String testException(String user) &#123; if (&quot;user&quot;.equals(user)) &#123; throw new UserNotExistException(); &#125; //跳转到登录页 login.html return &quot;login&quot;; &#125;&#125; 3）在 net.biancheng.www.controller 中，创建一个名为 MyExceptionHandler 异常处理类，代码如下。 123456789101112131415@ControllerAdvicepublic class MyExceptionHandler &#123; @ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //向 request 对象传入错误状态码 request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); //根据当前处理的异常，自定义的错误数据 map.put(&quot;code&quot;, &quot;user.notexist&quot;); map.put(&quot;message&quot;, e.getMessage()); //将自定的错误数据传入 request 域中 request.setAttribute(&quot;ext&quot;,map); return &quot;forward:/error&quot;; &#125;&#125; 2. 自定义错误属性处理工具1）在 net.biancheng.www.componet 包内，创建一个错误属性处理工具类 MyErrorAttributes（继承 DefaultErrorAttributes ），通过该类我们便可以添加自定义的错误数据，代码如下。 1234567891011121314//向容器中添加自定义的储物属性处理工具@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, options); //添加自定义的错误数据 errorAttributes.put(&quot;company&quot;, &quot;www.biancheng.net&quot;); //获取 MyExceptionHandler 传入 request 域中的错误数据 Map ext = (Map) webRequest.getAttribute(&quot;ext&quot;, 0); errorAttributes.put(&quot;ext&quot;, ext); return errorAttributes; &#125;&#125; 2）在 templates&#x2F;error 目录下，创建动态错误页面 5xx.html，代码如下。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;自定义 error.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;status：&lt;span th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;error：&lt;span th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;timestamp：&lt;span th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;message：&lt;span th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;!--取出定制的错误信息--&gt;&lt;h3&gt;以下为定制错误数据：&lt;/h3&gt;&lt;p&gt;company：&lt;span th:text=&quot;$&#123;company&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;code：&lt;span th:text=&quot;$&#123;ext.code&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;path：&lt;span th:text=&quot;$&#123;ext.message&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3）启动 Spring Boot，访问“http://localhost:8080/testException?user=user”，结果如下图。 注意：为了避免拦截器干扰，建议先将拦截器屏蔽掉。 Spring Boot注册Web原生组件（Servlet、Filter、Listener）由于 Spring Boot 默认以 Jar 包方式部署的，默认没有 web.xml，因此无法再像以前一样通过 web.xml 配置来使用 Servlet 、Filter、Listener，但 Spring Boot 提供了 2 种方式来注册这些 Web 原生组件。 通过组件扫描注册 使用 RegistrationBean 注册 通过组件扫描注册Servlet 3.0 提供了以下 3 个注解： @WebServlet：用于声明一个 Servlet； @WebFilter：用于声明一个 Filter； @WebListener：用于声明一个 Listener。 这些注解可直接标注在对应组件上，它们与在 web.xml 中的配置意义相同。每个注解都具有与 web.xml 对应的属性，可直接配置，省去了配置 web.xml 的繁琐。 想要在 SpringBoot 中注册这些原生 Web 组件，可以使用 @ServletComponentScan 注解实现，该注解可以扫描标记 @WebServlet、@WebFilter 和 @WebListener 三个注解的组件类，并将它们注册到容器中。 注意：@ServletComponentScan 注解只能标记在启动类或配置类上。 示例1.使用 @WebServlet 注解声明一个自定义的 Servlet，代码如下。 123456789101112131415//使用 @WebServlet 注解声明一个 Servlet@WebServlet(name = &quot;myServlet&quot;, urlPatterns = &quot;/myServlet&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.write(&quot;Spring Boot Servlet&quot;); writer.close(); &#125;&#125; 1.使用 @WebFilter 注解声明一个自定义的 Filter，代码如下。 1234567891011121314151617//使用 @WebFilter注解声明一个自定义的 Filter@WebFilter(urlPatterns = (&quot;/myServlet&quot;))public class MyFiler implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;MyFiler 初始化&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;MyFiler doFilter&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println(&quot;MyFiler 销毁&quot;); &#125;&#125; 3.使用 @WebListener 注解声明一个自定义的 Listener，代码如下。 123456789101112//使用 @WebListener 注解声明一个自定义的 Listener@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(&quot;MyListener 监听到 ServletContext 初始化&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(&quot;MyListener 监听到 ServletContext 销毁&quot;); &#125;&#125; 4.在启动类上使用 @ServletComponentScan 注解，扫描以上刚刚声明的 Servlet、Filter 和 Listener，并将它们注册到容器中使用，代码如下。 12345678@ServletComponentScan@SpringBootApplicationpublic class SpringBootServletApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootServletApplication.class, args); &#125;&#125; 5.启动 Spring Boot，控制台日志出入如下。 123MyListener 监听到 ServletContext 初始化MyFiler 初始化MyFiler doFilter 由以上日志输出可以看出，自定义的过滤器 Filter 和 监听器 Listener 都已经生效。 6.浏览器访问“http://localhost:8080/myServlet”，结果如下。 由上图可知，自定义的 Servlet 也已经生效了。 使用 RegistrationBean 注册我们还可以在配置类中使用 RegistrationBean 来注册原生 Web 组件，不过这种方式相较于注解方式要繁琐一些。使用这种方式注册的原生 Web 组件，不再需要使用 @WebServlet 、@WebListener 和 @WebListener 等注解。 RegistrationBean 是个抽象类，负责将组件注册到 Servlet 容器中，Spring 提供了三个它的实现类，分别用来注册 Servlet、Filter 和 Listener。 ServletRegistrationBean：Servlet 的注册类 FilterRegistrationBean：Filter 的注册类 ServletListenerRegistrationBean：Listener 的注册类 我们可以在配置类中，使用 @Bean 注解将 ServletRegistrationBean、FilterRegistrationBean 和 ServletListenerRegistrationBean 添加 Spring 容器中，并通过它们将我们自定义的 Servlet、Filter 和 Listener 组件注册到容器中使用。 示例 21.创建自定义 Servlet，代码如下。 12345678910111213public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.write(&quot;Spring Boot Servlet&quot;); writer.close(); &#125;&#125; 2.创建自定义的 Filter，代码如下。 123456789101112131415public class MyFiler implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;MyFiler 初始化&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;MyFiler doFilter&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println(&quot;MyFiler 销毁&quot;); &#125;&#125; 3.创建自定义的 Listener，代码如下。 1234567891011//监听 ServletContext 的初始化和销毁过程public class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(&quot;MyListener 监听到 ServletContext 初始化&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(&quot;MyListener 监听到 ServletContext 销毁&quot;); &#125;&#125; 4.创建一个配置类 MyConfig，使用 @Bean 注解将 ServletRegistrationBean、FilterRegistrationBean 和 ServletListenerRegistrationBean 添加到 Spring 容器中，并分别使用它们注册我们自定义的 Servlet、Filter 和 Listener，示例代码如下。 123456789101112131415161718192021222324@Configurationpublic class MyConfig &#123; // 注册 servlet @Bean public ServletRegistrationBean servletRegistrationBean() &#123; MyServlet myServlet = new MyServlet(); return new ServletRegistrationBean(myServlet, &quot;/myServlet&quot;); &#125; // 注册过滤器 @Bean public FilterRegistrationBean filterRegistrationBean() &#123; MyFiler myFiler = new MyFiler(); FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFiler); //注册该过滤器需要过滤的 url filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/myServlet&quot;)); return filterRegistrationBean; &#125; // 注册监听器 @Bean public ServletListenerRegistrationBean servletListenerRegistrationBean() &#123; MyListener myListener = new MyListener(); return new ServletListenerRegistrationBean(myListener); &#125;&#125; 5.启动 Spring Boot，控制台日志出入如下。 12MyListener 监听到 ServletContext 初始化MyFiler 初始化 由以上日志输出可以看出，自定义的过滤器 Filter 和监听器 Listener 都已经生效。 6.浏览器访问“http://localhost:8080/myServlet”，结果如下图。 由上图可知，自定义的 Servlet 也已经被注册生效了。 Spring Boot JDBC访问数据库对于数据访问层，无论是 SQL（关系型数据库） 还是 NOSQL（非关系型数据库），Spring Boot 都默认采用整合 Spring Data 的方式进行统一处理，通过大量自动配置，来简化我们对数据访问层的操作，我们只需要进行简单的设置即可实现对书层的访问。 导入 JDBC 场景启动器Spring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的场景启动器（Starter），场景启动器中整合了该场景下各种可能用到的依赖，让用户摆脱了处理各种依赖和配置的困扰。 想要在 Spring Boot 中使用 JDBC 进行数据访问，第一步就是要在 pom.xml 中导入 JDBC 场景启动器：spring-boot-starter-data-jdbc，代码如下。 12345&lt;!--导入JDBC的场景启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 查看 spring-boot-starter-data-jdbc 的依赖树，可以看到，该场景启动器默认引入了一个数据源：HikariCP，如下图所示。 导入数据库驱动JDBC 的场景启动器中并没有导入数据库驱动，我们需要根据自身的需求引入所需的数据库驱动。例如，访问 MySQL 数据库时，需要导入 MySQL 的数据库驱动：mysql-connector-java，示例代码如下。 123456&lt;!--导入数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; Spring Boot 默认为数据库驱动程序做了版本仲裁，所以我们在导入数据库驱动时，可以不再声明版本。需要注意的是，数据库驱动的版本必须与数据库的版本相对应。 配置数据源在导入了 JDBC 场景启动器和数据库驱动后，接下来我们就可以在配置文件（application.properties&#x2F;yml）中配置数据源了，示例代码（application.yml）如下。 1234567#数据源连接信息spring: datasource: username: root password: root url: jdbc:mysql://127.0.0.1:3306/databaseName driver-class-name: com.mysql.cj.jdbc.Driver 测试Spring Boot 提供了一个名为 JdbcTemplate 的轻量级数据访问工具，它是对 JDBC 的封装。Spring Boot 对 JdbcTemplate 提供了默认自动配置，我们可以直接使用 @Autowired 或构造函数将它注入到 bean 中使用。 下面，我们通过 JdbcTemplate 来实现对数据库的访问，代码如下。 1234567891011121314151617@SpringBootTestclass SpringBootJdbcApplicationTests &#123; //数据源组件 @Autowired DataSource dataSource; //用于访问数据库的组件 @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() throws SQLException &#123; System.out.println(&quot;默认数据源为：&quot; + dataSource.getClass()); System.out.println(&quot;数据库连接实例：&quot; + dataSource.getConnection()); //访问数据库 Integer i = jdbcTemplate.queryForObject(&quot;SELECT count(*) from `user`&quot;, Integer.class); System.out.println(&quot;user 表中共有&quot; + i + &quot;条数据。&quot;); &#125;&#125; 运行该测试代码，结果如下。 123默认数据源为：class com.zaxxer.hikari.HikariDataSource数据库连接实例：HikariProxyConnection@659763564 wrapping com.mysql.cj.jdbc.ConnectionImpl@59edb4f5user 表中共有1条数据。 通过以上运行结果可以看出，Spring Boot 默认使用 HikariCP 作为其数据源，对数据库的访问。 Spring Boot数据源配置原理在数据库访问过程中，“数据源”无疑是最重要的概念之一，它不仅可以对与数据库访问相关的各种参数进行封装和统一管理，还可以管理数据库连接池，提高数据库连接性能。 目前，在市面上有很多优秀的开源数据源，例如 DBCP、C3P0、Druid、HikariCP 等等。在 Spring Boot 2.x 中，则采用目前性能最佳的 HikariCP 作为其默认数据源。接下来，我们就来具体介绍下 Spring Boot 的默认数据源配置及其原理。 DataSourceAutoConfiguration我们知道，Spring Boot 中几乎所有的默认配置都是通过配置类 XxxAutoConfiguration 进行配置的，Spring Boot 数据源也不例外，它的自动配置类是：DataSourceAutoConfiguration。 DataSourceAutoConfiguration 中共包括以下 5 个内部静态类： EmbeddedDatabaseCondition PooledDataSourceAvailableCondition PooledDataSourceCondition PooledDataSourceConfiguration（池化数据源自动配置类） EmbeddedDatabaseConfiguration（内嵌数据源自动配置类） 其中，PooledDataSourceConfiguration 和 EmbeddedDatabaseConfiguration 为使用了 @Configuration 注解的自动配置类，其余 3 个为限制条件类。 EmbeddedDatabaseConfiguration顾名思义，EmbeddedDatabaseConfiguration 是内嵌数据源的自动配置类，该类中并没有任何的方法实现，它的主要功能都是通过 @Import 注解引入 EmbeddedDataSourceConfiguration 类来实现的。 1@Import(&#123;EmbeddedDataSourceConfiguration.class&#125;) EmbeddedDataSourceConfiguration 向容器中添加了一个 Spring Boot 内嵌的数据源，该数据源支持 HSQL，H2 和 DERBY 三种数据库，其部分代码如下。 12345678910111213141516171819@Configuration( proxyBeanMethods = false)@EnableConfigurationProperties(&#123;DataSourceProperties.class&#125;)public class EmbeddedDataSourceConfiguration implements BeanClassLoaderAware &#123; private ClassLoader classLoader; public EmbeddedDataSourceConfiguration() &#123; &#125; public void setBeanClassLoader(ClassLoader classLoader) &#123; this.classLoader = classLoader; &#125; //向容器中添加 Spring Boot 内嵌的数据源 @Bean( destroyMethod = &quot;shutdown&quot; ) public EmbeddedDatabase dataSource(DataSourceProperties properties) &#123; return (new EmbeddedDatabaseBuilder()).setType(EmbeddedDatabaseConnection.get(this.classLoader).getType()).setName(properties.determineDatabaseName()).build(); &#125;&#125; 通过上面的分析，我们知道自动配置类 EmbeddedDatabaseConfiguration 的作用是向容器中添加一个内嵌的数据源（DataSource），但这是有条件限制的。 在 EmbeddedDatabaseConfiguration 类上还使用一个 @Conditional 注解，该注解使用了 DataSourceAutoConfiguration 的内部限制条件类 EmbeddedDatabaseCondition 来进行条件判断。 1@Conditional(&#123;DataSourceAutoConfiguration.EmbeddedDatabaseCondition.class&#125;) EmbeddedDatabaseCondition 主要用来检测容器中是否已经存在池化数据源（PooledDataSource）。若容器中存在池化数据源时，则 EmbeddedDatabaseConfiguration 不能被实例化。只有当容器中不存在池化数据源时，EmbeddedDatabaseConfiguration 才能被实例化，才能向容器中添加内嵌数据源（EmbeddedDataSource）。 PooledDataSourceConfigurationPooledDataSourceConfiguration 是池化数据源的自动配置类，该类上使用了一个 @Conditional 注解，该注解使用了 DataSourceAutoConfiguration 的内部限制条件类 PooledDataSourceCondition 来进行条件判断。 1@Conditional(&#123;DataSourceAutoConfiguration.PooledDataSourceCondition.class&#125;) PooledDataSourceCondition 与 EmbeddedDatabaseCondition 一样，也是用来检测容器中是否已经存在池化数据源的，但不同的是，PooledDataSourceConfiguration 是只有当容器中存在池化数据源时， 才可以被实例化，才可以向容器中添加池化数据源。 与 EmbeddedDatabaseConfiguration 一样，PooledDataSourceConfiguration 类中也没有任何的方法实现，它的所有功能都是通过 @Import 注解引入其他的类实现的。 1@Import(&#123;Hikari.class, Tomcat.class, Dbcp2.class, OracleUcp.class, Generic.class, DataSourceJmxConfiguration.class&#125;) PooledDataSourceConfiguration 通过 @Import 注解引入了 Hikari、Tomcat、Dbcp2、OracleUcp 和 Generic 五个数据源配置类，它们都是 DataSourceConfiguration 的内部类，且它们的功能类似，都是向容器中添加指定的数据源。 下面我们以 Hikari 为例进行分析，Hikari 的源码如下。 12345678910111213141516171819202122232425@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;HikariDataSource.class&#125;)@ConditionalOnMissingBean(&#123;DataSource.class&#125;)@ConditionalOnProperty( name = &#123;&quot;spring.datasource.type&quot;&#125;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;, matchIfMissing = true)static class Hikari &#123; Hikari() &#123; &#125; @Bean @ConfigurationProperties( prefix = &quot;spring.datasource.hikari&quot; ) HikariDataSource dataSource(DataSourceProperties properties) &#123; HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class); if (StringUtils.hasText(properties.getName())) &#123; dataSource.setPoolName(properties.getName()); &#125; return dataSource; &#125;&#125; 在 Hikari 类中，主要使用以下注解： @Configuration：表示当前类是一个配置类； @ConditionalOnMissingBean({DataSource.class})：表示容器中没有用户自定义的数据源时，该配置类才会被实例化； @ConditionalOnClass({HikariDataSource.class}) ：表示必须在类路径中存在 HikariDataSource 类时，Hikari 才会实例化。而 HikariDataSource 类是由 spring- boot-starter-jdbc 默认将其引入的，因此只要我们在 pom.xml 中引入了该 starter， Hikari 就会被实例化（这也是 Spring Boot 2.x 默认使用 HikariCP 作为其数据源的原因）。； @ConditionalOnProperty( name &#x3D; {“spring.datasource.type”},havingValue &#x3D; “com.zaxxer.hikari.HikariDataSource”,matchIfMissing &#x3D; true)： 表示当 Spring Boot 配置文件中，配置了 spring.datasource.type &#x3D; com.zaxxer.hikari.HikariDataSource（明确指定使用 Hikari 数据源）或者不配置 spring.datasource.type（即默认情况）时，Hikari 才会被实例化。 Hikari 类通过 @Bean 注解向容器中添加了 HikariDataSource 组件，该组件的实例对象是通过调用 DataSourceConfiguration 的 createDataSource() 方法得到的，代码如下。 1234567891011@Bean@ConfigurationProperties( prefix = &quot;spring.datasource.hikari&quot;)HikariDataSource dataSource(DataSourceProperties properties) &#123; HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class); if (StringUtils.hasText(properties.getName())) &#123; dataSource.setPoolName(properties.getName()); &#125; return dataSource;&#125; 在 createDataSource() 方法中，调用 DataSourceProperties 的 initializeDataSourceBuilder() 来初始化 DataSourceBuilder,源码如下。 123protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) &#123; return properties.initializeDataSourceBuilder().type(type).build();&#125; initializeDataSourceBuilder() 方法通过调用 DataSourceBuilder 的 create() 方法创建 DataSourceBuilder 对象，并根据 Spring Boot 的配置文件（application.properties&#x2F;yml）中的配置，依次设置数据源类型、驱动类名、连接 url、 用户名和密码等信息。 1234public DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123; return DataSourceBuilder.create(this.getClassLoader()).type(this.getType()). driverClassName(this.determineDriverClassName()).url(this.determineUrl()).username(this.determineUsername()).password(this.determinePassword());&#125; 上面提到 spring.datasource.type 默认是可以不用配置的，因此在 createDataSource() 方法在获取到回传回来的 DataSourceBuilder 对象后，还需要将其 type 属性再次设置为 HikariDataSource，并调用 DataSourceBuilder 的 build() 方法，完成 HikariDataSource 的初始化。 dataSource() 方法获得数据源对象，并设置了连接池的名字（name），注入到容器中。 自此，我们就完成了对 Spring Boot 数据源自动配置原理的分析。 总结通过对 Spring Boot 数据源自动配置原理的分析可知： 在用户没有配置数据源的情况，若容器中存在 HikariDataSource 类，则 Spring Boot 就会自动实例化 Hikari，并将其作为其数据源。 Spring Boot 的 JDBC 场景启动器（spring-boot-starter-data-jdbc）通过 spring- boot-starter-jdbc 默认引入了 HikariCP 数据源（包含 HikariDataSource 类），因此 Spring Boot 默认使用 HikariCP 作为其数据源。 Spring Boot整合Druid数据源HikariCP 是目前市面上性能最好的数据源产品，但在实际的开发过程中，企业往往更青睐于另一款数据源产品：Druid，它是目前国内使用范围最广的数据源产品。 Druid 是阿里巴巴推出的一款开源的高性能数据源产品，Druid 支持所有 JDBC 兼容的数据库，包括 Oracle、MySQL、SQL Server 和 H2 等等。Druid 不仅结合了 C3P0、DBCP 和 PROXOOL 等数据源产品的优点，同时还加入了强大的监控功能。通过 Druid 的监控功能，可以实时观察数据库连接池和 SQL 的运行情况，帮助用户及时排查出系统中存在的问题。 Druid 不是 Spring Boot 内部提供的技术，它属于第三方技术，我们可以通过以下两种方式进行整合： 自定义整合 Druid 通过 starter 整合 Druid 接下来我们将结合 Spring Boot 项目 spring-boot-adminex，分别对这两种整合方式进行讲解。 自定义整合 Druid自定义整合 Druid 是指：根据 Druid 官方文档和自身的需求，通过手动创建 Druid 数据源的方式，将 Druid 整合到 Spring Boot 中。 1. 引入 Druid 依赖Druid 0.1.18 之后版本都已经发布到 Maven 中央仓库中了，所以我们只需要在项目的 pom.xml 中引入 Druid 的依赖（dependency ），即可将 Druid 导入到 Spring Boot 项目中。 在 spring-boot-adminex 的 pom.xml 中添加以下代码，引入 JDBC 场景启动器、MySql 数据库驱动 和 Druid 依赖。 123456789101112131415161718&lt;!--导入 JDBC 场景启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--导入数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--采用自定义方式整合 druid 数据源--&gt;&lt;!--自定义整合需要编写一个与之相关的配置类--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 2. 创建数据源我们知道，Spring Boot 使用 HikariCP 作为其默认数据源，但其中有一个十分重要的条件，如下图。 @ConditionalOnMissingBean(DataSource.class) 的含义是：当容器中没有 DataSource（数据源类）时，Spring Boot 才会使用 HikariCP 作为其默认数据源。 也就是说，若我们向容器中添加 Druid 数据源类（DruidDataSource，继承自 DataSource）的对象时，Spring Boot 就会使用 Druid 作为其数据源，而不再使用 HikariCP。 例如，在config 包中，创建一个名为 MyDataSourceConfig 的配置类，并将 Druid 数据源对象添加到容器中，代码如下。 123456789101112131415161718@Configurationpublic class MyDataSourceConfig implements WebMvcConfigurer &#123; /** * 当向容器中添加了 Druid 数据源 * 使用 @ConfigurationProperties 将配置文件中 spring.datasource 开头的配置与数据源中的属性进行绑定 */ @ConfigurationProperties(&quot;spring.datasource&quot;) @Bean public DataSource dataSource() throws SQLException &#123; DruidDataSource druidDataSource = new DruidDataSource(); //我们一般不建议将数据源属性硬编码到代码中，而应该在配置文件中进行配置（@ConfigurationProperties 绑定）// druidDataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc&quot;);// druidDataSource.setUsername(&quot;root&quot;);// druidDataSource.setPassword(&quot;root&quot;);// druidDataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); return druidDataSource; &#125;&#125; 在配置文件 application.yml 中添加以下数据源配置，它们会与与 Druid 数据源中的属性进行绑定，代码如下。 1234567#数据源连接信息spring: datasource: username: root password: root url: jdbc:mysql://127.0.0.1:3306/databaseName driver-class-name: com.mysql.cj.jdbc.Driver 注：配置类创建 Druid 数据源对象时，应该尽量避免将数据源信息（例如 url、username 和 password 等）硬编码到代码中，而应该通过 @ConfigurationProperties(“spring.datasource”) 注解，将 Druid 数据源对象的属性与配置文件中的以“spring.datasource”开头的配置进行绑定。 至此，我们就已经将数据源从 HikariCP 切换到了 Druid 了。 示例 1接下来，我们可以使用 Spring Boot 提供的默认测试类 SpringBootAdminexApplicationTests 进行简单的测试，来验证数据源类型是否为 Druid 以及是否能正常获取数据库连接、访问数据库，代码如下。 1234567891011121314151617@SpringBootTestclass SpringBootAdminexApplicationTests &#123; //数据源组件 @Autowired DataSource dataSource; //用于访问数据库的组件 @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() throws SQLException &#123; System.out.println(&quot;默认数据源为：&quot; + dataSource.getClass()); System.out.println(&quot;数据库连接实例：&quot; + dataSource.getConnection()); //访问数据库 Integer i = jdbcTemplate.queryForObject(&quot;SELECT count(*) from `user`&quot;, Integer.class); System.out.println(&quot;user 表中共有&quot; + i + &quot;条数据。&quot;); &#125;&#125; 运行测试程序，结果如下。 123默认数据源为：class com.alibaba.druid.pool.DruidDataSource数据库连接实例：com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@46e190eduser 表中共有2条数据。 根据以上运行结果可以看出，数据源已经成功地切换到了 Druid 数据源，且通过它也可以正常的获取数据库连接，访问数据库。 3. 开启 Druid 内置监控页面Druid 内置提供了一个名为 StatViewServlet 的 Servlet，这个 Servlet 可以开启 Druid 的内置监控页面功能， 展示 Druid 的统计信息，它的主要用途如下： 提供监控信息展示的 html 页面 提供监控信息的 JSON API 注意：使用 StatViewServlet，建议使用 Druid 0.2.6 以上版本。 根据 Druid 官方文档-配置_StatViewServlet 配置，StatViewServlet 是一个标准的 javax.servlet.http.HttpServlet，想要开启 Druid 的内置监控页面，需要将该 Servlet 配置在 Web 应用中的 WEB-INF&#x2F;web.xml 中，web.xml 中配置如下。 12345678&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 我们知道，Spring Boot 项目中是没有 WEB-INF&#x2F;web.xml 的，因此我们可以在配置类中，通过 ServletRegistrationBean 将 StatViewServlet 注册到容器中，来开启 Druid 的内置监控页面。 示例 21.在 MyDataSourceConfig 配置类中添加以下代码，将 StatViewServlet 注入到容器中，开启 Druid 内置监控页面功能。 1234567891011// 开启 Druid 数据源内置监控页面@Beanpublic ServletRegistrationBean statViewServlet() &#123; StatViewServlet statViewServlet = new StatViewServlet(); //向容器中注入 StatViewServlet，并将其路径映射设置为 /druid/* ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(statViewServlet, &quot;/druid/*&quot;); //配置监控页面访问的账号和密码（选配） servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;admin&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); return servletRegistrationBean;&#125; 2.启动 Spring Boot，浏览器访问“http://localhost:8080/druid”，即可访问 Druid 的内置监控页面的登陆页，结果如下。 3.在登陆页输入框内，分别输入我们自定义的用户名（loginUsername）和密码（loginPassword），点击 Sign in 按钮访问监控页面，如下图。 4. 开启 SQL 监控Druid 内置提供了一个 StatFilter，通过它可以开启 Druid 的 SQL 监控功能，对 SQL 进行监控。 StatFilter 的别名是 stat，这个别名的映射配置信息保存在 druid-xxx.jar!&#x2F;META-INF&#x2F;druid-filter.properties 中。Druid 官方文档-配置_StatFilter 中给出了在 Spring 中配置该别名（stat）开启 Druid SQL 监控的方式，配置如下。 1234&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;... ...&lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;&lt;/bean&gt; 根据以上配置我们可以看出，只要在 dataSource 的 Bean 中添加一个取值为“stat”的“filters”属性，就能开启 Druid SQL 监控，因此我们只要将该配置转换为在配置类中进行即可，代码如下。 12345678@ConfigurationProperties(&quot;spring.datasource&quot;)@Beanpublic DataSource dataSource() throws SQLException &#123; DruidDataSource druidDataSource = new DruidDataSource(); //设置 filters 属性值为 stat，开启 SQL 监控 druidDataSource.setFilters(&quot;stat&quot;); return druidDataSource; &#125; 示例 31.为了验证 Druid SQL 监控是否开启，我们需要在 IndexController 中添加一个能够查询数据库的方法，代码如下。 1234567891011121314@Controllerpublic class IndexController &#123; //自动装配 jdbcTemplate @Autowired JdbcTemplate jdbcTemplate; // 访问&quot;/testSql&quot;,访问数据库 @ResponseBody @GetMapping(&quot;/testSql&quot;) public String testSql() &#123; String SQL = &quot;SELECT count(*) from `user`&quot;; Integer integer = jdbcTemplate.queryForObject(SQL, Integer.class); return integer.toString(); &#125;&#125; 2.重启 Spring Boot，浏览器访问“http://localhost:8080/testSql”，结果如下图。 3.访问 Druid 的内置监控页面，切换到 SQL 监控模块，可以看到 Druid SQL 监控已经开启，如下图。 5. 开启防火墙Druid 内置提供了一个 WallFilter，使用它可以开启防火墙功能，防御 SQL 注入攻击。 WallFilter 的别名是 wall，这个别名映射配置信息保存在 druid-xxx.jar!&#x2F;META-INF&#x2F;druid-filter.properties 中。Druid 官方文档-配置 wallfilter 中给出了在 Spring 中使用该别名（wall）开启防火墙的方式，配置如下。 1234&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;... ...&lt;property name=&quot;filters&quot; value=&quot;wall&quot; /&gt;&lt;/bean&gt; WallFilter 可以结合其他 Filter 一起使用，例如： 1234&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; ... &lt;property name=&quot;filters&quot; value=&quot;wall,stat&quot;/&gt;&lt;/bean&gt; 根据以上配置我们可以看出，只要在 dataSource 的 Bean 中添加一个取值为“wall”的“filters”属性，就能开启 Druid 的防火墙功能，因此我们只需要在配置类中为 dataSource 的 filters 属性再添加一个“wall”即可（多个属性值之间使用逗号“，”隔开），代码如下。 123456789@ConfigurationProperties(&quot;spring.datasource&quot;)@Beanpublic DataSource dataSource() throws SQLException &#123; DruidDataSource druidDataSource = new DruidDataSource(); //同时开启 sql 监控(stat) 和防火墙(wall)，中间用逗号隔开。 //开启防火墙能够防御 SQL 注入攻击 druidDataSource.setFilters(&quot;stat,wall&quot;); return druidDataSource;&#125; 示例 41.重启 Spring Boot，浏览器访问“http://localhost:8080/testSql”，结果如下图。 2.访问 Druid 的内置监控页面，切换到 SQL 防火墙，可以看到 Druid 防火墙已经开启，如下图。 6. 开启 Web-JDBC 关联监控Druid 还内置提供了一个名为 WebStatFilter 的过滤器，它可以用来监控与采集 web-jdbc 关联监控的数据。 根据 Druid 官方文档-配置_配置WebStatFilter，想要开启 Druid 的 Web-JDBC 关联监控，只需要将 WebStatFilter 配置在 Web 应用中的 WEB-INF&#x2F;web.xml 中即可，web.xml 配置如下。 123456789101112&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Spring Boot 项目中是没有 WEB-INF&#x2F;web.xml 的，但是我们可以在配置类中，通过 FilterRegistrationBean 将 WebStatFilter 注入到容器中，来开启 Druid 的 Web-JDBC 关联监控。 配置类中示例代码如下。 1234567891011121314/*** 向容器中添加 WebStatFilter* 开启内置监控中的 Web-jdbc 关联监控的数据*/@Beanpublic FilterRegistrationBean druidWebStatFilter() &#123; WebStatFilter webStatFilter = new WebStatFilter(); FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(webStatFilter); // 监控所有的访问 filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); // 监控访问不包括以下路径 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;); return filterRegistrationBean;&#125; 示例 51.重启 Spring Boot，浏览器访问“http://localhost:8080/testSql”，结果如下图。 2.浏览器访问 AdminEx 系统的任意页面，然后再访问 Druid 的内置监控页面，切换到 Web 应用模块，可以看到 Druid 的 Web 监控已经开启，如下图。 与此同时，URI 监控和 Session 监控也都被开启，如下图。 通过 starter 整合 DruidDruid 可以说是国内使用最广泛的数据源连接池产品，但到目前为止 Spring Boot 官方只对 Hikari、Tomcat、Dbcp2 和 OracleUcp 等 4 种数据源产品提供了自动配置支持，对于其他的数据源连接池产品（包括 Druid），则并没有提供自动配置支持。这就导致用户只能通过自定义的方式（第一种整合方式）整合 Druid，非常繁琐。 为了解决这一问题，于是阿里官方提供了 Druid Spring Boot Starter，它可以帮助我们在 Spring Boot 项目中，轻松地整合 Druid 的数据库连接池和监控功能。 使用 Druid Spring Boot Starter 将 Druid 与 Spring Boot 整合，步骤如下。 1. 引入 Druid Spring Boot Starter 依赖在 Spring Boot 项目的 pom.xml 中添加以下依赖，引入 Druid Spring Boot Starter（点击查询最新版本），示例代码如下。 123456&lt;!--添加 druid 的 starter--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 2. 配置属性Druid Spring Boot Starter 已经将 Druid 数据源中的所有模块都进行默认配置，我们也可以通过 Spring Boot 配置文件（application.properties&#x2F;yml）来修改 Druid 各个模块的配置，否则将使用默认配置。 在 Spring Boot 配置文件中配置以下内容： JDBC 通用配置 Druid 数据源连接池配置 Druid 监控配置 Druid 内置 Filter 配置 这些配置内容既可以在 application.properties 中进行配置，也可以在 application.yml 中尽心配置，当配置内容较多时，我们通常推荐使用 application.yml（示例中使用的是 application.yml）。 JDBC 通用配置我们可以在 Spring Boot 的配置文件中对 JDBC 进行通用配置，例如，数据库用户名、数据库密码、数据库 URL 以及 数据库驱动等等，示例代码如下。 1234567#### JDBC 通用配置 #####spring: datasource: username: root #数据库登陆用户名 password: root #数据库登陆密码 url: jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc #数据库url driver-class-name: com.mysql.cj.jdbc.Driver #数据库驱动 Druid 数据源连接池配置我们还可以在 Spring Boot 的配置文件中对 Druid 数据源连接池进行配置，示例代码如下。 123456789101112131415161718#### Druid连接池的配置 ####spring: datasource: druid: initial-size: 5 #初始化连接大小 min-idle: 5 #最小连接池数量 max-active: 20 #最大连接池数量 max-wait: 60000 #获取连接时最大等待时间，单位毫秒 time-between-eviction-runs-millis: 60000 #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 min-evictable-idle-time-millis: 300000 #配置一个连接在池中最小生存的时间，单位是毫秒 validation-query: SELECT 1 FROM DUAL #测试连接 test-while-idle: true #申请连接的时候检测，建议配置为true，不影响性能，并且保证安全性 test-on-borrow: false #获取连接时执行检测，建议关闭，影响性能 test-on-return: false #归还连接时执行检测，建议关闭，影响性能 pool-prepared-statements: false #是否开启PSCache，PSCache对支持游标的数据库性能提升巨大，oracle建议开启，mysql下建议关闭 max-pool-prepared-statement-per-connection-size: 20 #开启poolPreparedStatements后生效 filters: stat,wall #配置扩展插件，常用的插件有=&gt;stat:监控统计 wall:防御sql注入 connection-properties: &#x27;druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000&#x27; #通过connectProperties属性来打开mergeSql功能;慢SQL记录 Druid 监控配置我们还可以在 Spring Boot 的配置文件中对 Druid 内置监控页面、Web-JDBC 关联监控和 Spring 监控等功能进行配置，示例代码如下。 123456789101112131415161718#### Druid 监控配置信息 #### datasource: druid: # StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置 stat-view-servlet: enabled: true #是否开启内置监控页面，默认值为 false url-pattern: &#x27;/druid/*&#x27; #StatViewServlet 的映射路径，即内置监控页面的访问地址 reset-enable: true #是否启用重置按钮 login-username: admin #内置监控页面的登录页用户名 username login-password: admin #内置监控页面的登录页密码 password # WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter web-stat-filter: enabled: true #是否开启内置监控中的 Web-jdbc 关联监控的数据 url-pattern: &#x27;/*&#x27; #匹配路径 exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27; #排除路径 session-stat-enable: true #是否监控session # Spring监控配置，说明请参考Druid Github Wiki，配置_Druid和Spring关联监控配置 aop-patterns: net.biancheng.www.* #Spring监控AOP切入点，如x.y.z.abc.*,配置多个英文逗号分隔 Druid 内置 Filter 配置Druid Spring Boot Starter 对以下 Druid 内置 Filter，都提供了默认配置： StatFilter WallFilter ConfigFilter EncodingConvertFilter Slf4jLogFilter Log4jFilter Log4j2Filter CommonsLogFilter 我们可以通过 spring.datasource.druid.filters&#x3D;stat,wall … 的方式来启用相应的内置 Filter，不过这些 Filter 使用的都是默认配置。如果默认配置不能满足我们的需求，我们还可以在配置文件使用 spring.datasource.druid.filter.* 对这些 Filter 进行配置，示例代码如下。 12345678910111213141516171819#### Druid 监控配置信息 ####spring: datasource: druid: # 对配置已开启的 filters 即 stat(sql 监控) wall（防火墙） filter: #配置StatFilter (SQL监控配置) stat: enabled: true #开启 SQL 监控 slow-sql-millis: 1000 #慢查询 log-slow-sql: true #记录慢查询 SQL #配置WallFilter (防火墙配置) wall: enabled: true #开启防火墙 config: update-allow: true #允许更新操作 drop-table-allow: false #禁止删表操作 insert-allow: true #允许插入操作 delete-allow: true #删除数据操作 在配置 Druid 内置 Filter 时，需要先将对应 Filter 的 enabled 设置为 true，否则内置 Filter 的配置不会生效。 以上所有内容都只是示例配置，Druid Spring Boot Starter 并不是只支持以上属性，它支持 DruidDataSource 内所有具有 setter 方法的属性。 至此，我们就完成了使用 Druid Spring Boot Starter 整合 Druid 的全部过程，至于验证步骤请参考自定义整合。 总结无论是自定义整合还是通过 Druid Spring Boot Starter 整合，都能实现 Spring Boot 整合 Druid 数据源的目的，它们都各有利弊。 根据官方文档，自定义整合 Druid 数据源能够更加清晰地了解 Druid 的各种功能及其实现方式，但整合过程繁琐。 通过 Druid Spring Boot Starter 整合 Druid 数据源，则更加方便快捷，大大简化了整合过程，但无法清晰地了解 Druid 的功能内部的实现方式和原理。 这里，我们更加推荐使用 Druid Spring Boot Starter 进行整合，毕竟这种整合方式大大简化了整个整合的过程。 Spring Boot整合MyBatisMyBatis 是一个半自动化的 ORM 框架，所谓半自动化是指 MyBatis 只支持将数据库查出的数据映射到 POJO 实体类上，而实体到数据库的映射则需要我们自己编写 SQL 语句实现，相较于Hibernate 这种完全自动化的框架，Mybatis 更加灵活，我们可以根据自身的需求编写 sql 语句来实现复杂的数据库操作。 随着 Spring Boot 越来越流行，越来越多的被厂商及开发者所认可，MyBatis 也开发了一套基于 Spring Boot 模式的 starter：mybatis-spring-boot-starter。本节我们就介绍下如何在 Spring Boot 项目中整合 MyBatis。 引入依赖Spring Boot 整合 MyBatis 的第一步，就是在项目的 pom.xml 中引入 mybatis-spring-boot-starter 的依赖，示例代码如下。 123456&lt;!--引入 mybatis-spring-boot-starter 的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; 配置 MyBatis在 Spring Boot 的配置文件（application.properties&#x2F;yml）中对 MyBatis 进行配置，例如指定 mapper.xml 的位置、实体类的位置、是否开启驼峰命名法等等，示例代码如下。 123456789#### MyBatis 配置####mybatis: # 指定 mapper.xml 的位置 mapper-locations: classpath:mybatis/mapper/*.xml #扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名 type-aliases-package: net.biancheng.www.bean configuration: #默认开启驼峰命名法，可以不用设置该属性 map-underscore-to-camel-case: true 注意：使用 MyBatis 时，必须配置数据源信息，例如数据库 URL、数据库用户型、数据库密码和数据库驱动等。 创建实体类在指定的数据库内创建一个 user 表，并插入一些数据，如下表。 id user_id user_name password email 1 001 admin admin &#x31;&#50;&#x33;&#52;&#53;&#x36;&#55;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109; 2 002 user 123456 &#x39;&#56;&#55;&#54;&#x35;&#x34;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d; 3 003 bianchengbang qwertyuiop &#98;&#105;&#x61;&#110;&#99;&#104;&#x65;&#x6e;&#103;&#x62;&#97;&#x6e;&#103;&#x40;&#x73;&#x69;&#110;&#x61;&#x2e;&#99;&#x6f;&#109; 根据数据库 user 表，创建相应的实体类 User，代码如下。 12345678public class User &#123; private Integer id; private String userId; private String userName; private String password; private String email; &#x27;&#x27;&#x27;&#125; 创建 Mapper 接口在mapper 中创建一个 UserMapper 接口，并在该类上使用 @Mapper 注解，代码如下。 12345@Mapperpublic interface UserMapper &#123; //通过用户名密码查询用户数据 User getByUserNameAndPassword(User user);&#125; 创建 Mapper 映射文件在配置文件 application.properties&#x2F;yml 通过 mybatis.mapper-locations 指定的位置中创建 UserMapper.xml，代码如下。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;net.biancheng.www.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;user_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;email&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; id, user_id, user_name, password, email &lt;/sql&gt; &lt;!--根据用户名密码查询用户信息--&gt; &lt;!--application.yml 中通过 type-aliases-package 指定了实体类的为了，因此--&gt; &lt;select id=&quot;getByUserNameAndPassword&quot; resultType=&quot;User&quot;&gt; select * from user where user_name = #&#123;userName,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125; &lt;/select&gt;&lt;/mapper&gt; 使用 Mapper 进行开发时，需要遵循以下规则： mapper 映射文件中 namespace 必须与对应的 mapper 接口的完全限定名一致。 mapper 映射文件中 statement 的 id 必须与 mapper 接口中的方法的方法名一致 mapper 映射文件中 statement 的 parameterType 指定的类型必须与 mapper 接口中方法的参数类型一致。 mapper 映射文件中 statement 的 resultType 指定的类型必须与 mapper 接口中方法的返回值类型一致。 示例 11.在 spring-boot-adminex 项目中 service 包中创建一个名为 UserService 的接口，代码如下。 123public interface UserService &#123; public User getByUserNameAndPassword(User user);&#125; 2.在 service.impl 包中创建 UserService 接口的实现类，并使用 @@Service 注解将其以组件的形式添加到容器中，代码如下。 12345678910@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Autowired UserMapper userMapper; @Override public User getByUserNameAndPassword(User user) &#123; User loginUser = userMapper.getByUserNameAndPassword(user); return loginUser; &#125;&#125; 3.修改 LoginController 中的 doLogin() 方法 ,代码如下。 123456789101112131415161718192021@Slf4j@Controllerpublic class LoginController &#123; @Autowired UserService userService; @RequestMapping(&quot;/user/login&quot;) public String doLogin(User user, Map&lt;String, Object&gt; map, HttpSession session) &#123; //从数据库中查询用户信息 User loginUser = userService.getByUserNameAndPassword(user); if (loginUser != null) &#123; session.setAttribute(&quot;loginUser&quot;, loginUser); log.info(&quot;登陆成功，用户名：&quot; + loginUser.getUserName()); //防止重复提交使用重定向 return &quot;redirect:/main.html&quot;; &#125; else &#123; map.put(&quot;msg&quot;, &quot;用户名或密码错误&quot;); log.error(&quot;登陆失败&quot;); return &quot;login&quot;; &#125; &#125;&#125; 4.启动 Spring Boot，浏览器地址栏输入“http://localhost:8080/” ，访问 AdminEx 系统的登陆页面，分别输入用户名“user”和密码“123456” 5.点击登陆按钮 注解方式通过上面的学习，我们知道 mapper 映射文件其实就是一个 XML 配置文件，它存在 XML 配置文件的通病，即编写繁琐，容易出错。即使是一个十分简单项目，涉及的 SQL 语句也都十分简单，我们仍然需要花费一定的时间在mapper 映射文件的配置上。 为了解决这个问题，MyBatis 针对实际实际业务中使用最多的“增删改查”操作，分别提供了以下注解来替换 mapper 映射文件，简化配置： @Select @Insert @Update @Delete 通过以上注解，基本可以满足我们对数据库的增删改查操作，示例代码如下。 1234567891011121314151617@Mapperpublic interface UserMapper &#123; @Select(&quot;select * from user where user_name = #&#123;userName,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125;&quot;) List&lt;User&gt; getByUserNameAndPassword(User user); @Delete(&quot;delete from user where id = #&#123;id,jdbcType=INTEGER&#125;&quot;) int deleteByPrimaryKey(Integer id); @Insert(&quot;insert into user ( user_id, user_name, password, email)&quot; + &quot;values ( #&#123;userId,jdbcType=VARCHAR&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)&quot;) int insert(User record); @Update(&quot; update user&quot; + &quot; set user_id = #&#123;userId,jdbcType=VARCHAR&#125;, &quot; + &quot; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &quot; + &quot; password = #&#123;password,jdbcType=VARCHAR&#125;, &quot; + &quot; email = #&#123;email,jdbcType=VARCHAR&#125; &quot; + &quot; where id = #&#123;id,jdbcType=INTEGER&#125;&quot;) int updateByPrimaryKey(User record);&#125; 注意事项mapper 接口中的任何一个方法，都只能使用一种配置方式，即注解和 mapper 映射文件二选一，但不同方法之间，这两种方式则可以混合使用，例如方法 1 使用注解方式，方法 2 使用 mapper 映射文件方式。 我们可以根据 SQL 的复杂程度，选择不同的方式来提高开发效率。 如果没有复杂的连接查询，我们可以使用注解的方式来简化配置； 如果涉及的 sql 较为复杂时，则使用 XML （mapper 映射文件）的方式更好一些。 Spring Boot自定义starterstarter 是 SpringBoot 中一种非常重要的机制，它可以将繁杂的配置统一集成到 starter 中，我们只需要通过 maven 将 starter 依赖引入到项目中，SpringBoot 就能自动扫描并加载相应的默认配置。starter 的出现让开发人员从繁琐的框架配置中解放出来，将更多的精力专注于业务逻辑的开发，极大的提高了开发效率。 在一些特殊情况下，我们也可以将一些通用功能封装成自定义的 starter 进行使用，本节我们将为您详细介绍如何自定义 starter。 命名规范SpringBoot 提供的 starter 以 spring-boot-starter-xxx 的形式命名。为了与 SpringBoot 生态提供的 starter 进行区分，官方建议第三方开发者或技术（例如 Druid、Mybatis 等等）厂商自定义的 starter 使用 xxx-spring-boot-starter 的形式命名，例如 mybatis-spring-boot-starter、druid-spring-boot-starter 等等。 模块规范Spring Boot 官方建议我们在自定义 starter 时，创建两个 Module ：autoConfigure Module 和 starter Module，其中 starter Module 依赖于 autoConfigure Module。当然，这只是 Spring Boot 官方的建议，并不是硬性规定，若不需要自动配置代码和依赖项目分离，我们也可以将它们组合到同一个 Module 里。 自定义 starter自定义 starter 可以分为以下 7 步： 创建工程 添加 POM 依赖 定义 propertie 类 定义 Service 类 定义配置类 创建 spring.factories文件 构建 starter 创建工程1.使用 IntelliJ IDEA 创建一个空项目（Empty Project），如下图。 2.在 Project Structure 界面，点击左上角的“+”按钮，选择“New Module”，新建一个名为 bianchengbang-hello-spring-boot-starter 的 Maven Module 和一个名为 bianchengbang-helllo-spring-boot-starter-autoconfiguration 的 Spring Boot Module，如下图。 添加 POM 依赖在 bianchengbang-hello-spring-boot-starter 的 pom.xml 中添加以下代码，将 bianchengbang-helllo-spring-boot-starter-autoconfiguration 作为其依赖项。 12345678&lt;!--添加自动配置模块为其依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.biacheng.www&lt;/groupId&gt; &lt;artifactId&gt;bianchengbang-helllo-spring-boot-starter-autoconfiguration&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 定义 propertie 类在 bianchengbang-helllo-spring-boot-starter-autoconfiguration 的 net.biacheng.www.properties 包中，创建一个实体类：HelloProperties，通过它来映射配置信息，其代码如下。 12345678910// 实体类，用来映射配置信息@ConfigurationProperties(&quot;net.biancheng.www.hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123;return prefix;&#125; public void setPrefix(String prefix) &#123;this.prefix = prefix;&#125; public String getSuffix() &#123;return suffix;&#125; public void setSuffix(String suffix) &#123;this.suffix = suffix;&#125;&#125; HelloProperties 类上使用了 @ConfigurationProperties(“net.biancheng.","tags":["SpringBoot","Java","Spring","SpringMVC"],"categories":["学习"]},{"title":"SpringMVC","path":"/ae0f95e0/","content":"SpringMVCMVC设计模式简介MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。 在 Web 项目的开发中，能够及时、正确地响应用户的请求是非常重要的。用户在网页上单击一个 URL 路径，这对 Web 服务器来说，相当于用户发送了一个请求。而获取请求后如何解析用户的输入，并执行相关处理逻辑，最终跳转至正确的页面显示反馈结果，这些工作往往是控制层（Controller）来完成的。 在请求的过程中，用户的信息被封装在 User 实体类中，该实体类在 Web 项目中属于数据模型层（Model）。 在请求显示阶段，跳转的结果网页就属于视图层（View）。 像这样，控制层负责前台与后台的交互，数据模型层封装用户的输入&#x2F;输出数据，视图层选择恰当的视图来显示最终的执行结果，这样的层次分明的软件开发和处理流程被称为 MVC 模式。 总结如下： 视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。 控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。 数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。 JSP+JavaBeanJSP+JavaBean 中 JSP 用于处理用户请求，JavaBean 用于封装和处理数据。该模式只有视图和模型，一般把控制器的功能交给视图来实现，适合业务流程比较简单的 Web 程序。 通过上图可以发现 JSP 从 HTTP Request（请求）中获得所需的数据，并进行业务逻辑的处理，然后将结果通过 HTTP Response（响应）返回给浏览器。从中可见，JSP+JavaBean 模式在一定程度上实现了 MVC，即 JSP 将控制层和视图合二为一，JavaBean 为模型层。 JSP+JavaBean 模式中 JSP 身兼数职，既要负责视图层的数据显示，又要负责业务流程的控制，结构较为混乱，并且也不是我们所希望的松耦合架构模式，所以当业务流程复杂的时候并不推荐使用。 Servlet+JSP+JavaBeanServlet+JSP+JavaBean 中 Servlet 用于处理用户请求，JSP 用于数据显示，JavaBean 用于数据封装，适合复杂的 Web 程序。 相比 JSP+JavaBean 模式来说，Servlet+JSP+JavaBean 模式将控制层单独划分出来负责业务流程的控制，接收请求，创建所需的 JavaBean 实例，并将处理后的数据返回视图层（JSP）进行界面数据展示。 Servlet+JSP+JavaBean 模式的结构清晰，是一个松耦合架构模式，一般情况下，建议使用该模式。 MVC优缺点任何一件事都有利有弊，下面来了解一下 MVC 的优缺点。 优点 多视图共享一个模型，大大提高了代码的可重用性 MVC 三个模块相互独立，松耦合架构 控制器提高了应用程序的灵活性和可配置性 有利于软件工程化管理总之，我们通过 MVC 设计模式最终可以打造出一个松耦合+高可重用性+高可适用性的完美架构。 缺点 原理复杂 增加了系统结构和实现的复杂性 视图对模型数据的低效率访问 MVC 并不适合小型甚至中型规模的项目，花费大量时间将 MVC 应用到规模并不是很大的应用程序，通常得不偿失，所以对于 MVC 设计模式的使用要根据具体的应用场景来决定。 Spring MVC是什么Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。 Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现，是一个典型的教科书式的 MVC 构架，不像 Struts 等其它框架都是变种或者不是完全基于 MVC 系统的框架。 Spring MVC 角色划分清晰，分工明细，并且和 Spring 框架无缝结合。Spring MVC 是当今业界最主流的 Web 开发框架，以及最热门的开发技能。 在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。 Spring MVC 框架采用松耦合可插拔的组件结构，具有高度可配置性，比起其它 MVC 框架更具有扩展性和灵活性。 此外，Spring MVC 的注解驱动和对 REST 风格的支持，也是它最具特色的功能。无论是在框架设计，还是扩展性、灵活性等方面都全面超越了 Struts2 等 MVC 框架。并且由于 Spring MVC 本身就是 Spring 框架的一部分，所以可以说与 Spring 框架是无缝集成，性能方面具有先天的优越性，对于开发者来说，开发效率也高于其它的 Web 框架，在企业中的应用越来越广泛，成为主流的 MVC 框架。 Spring MVC优点 清晰地角色划分，Spring MVC 在 Model、View 和 Controller 方面提供了一个非常清晰的角色划分，这 3 个方面真正是各司其职，各负其责。 灵活的配置功能，可以把类当作 Bean 通过 XML 进行配置。 提供了大量的控制器接口和实现类，开发者可以使用 Spring 提供的控制器实现类，也可以自己实现控制器接口。 真正做到与 View 层的实现无关。它不会强制开发者使用 JSP，可以根据项目需求使用 Velocity、FreeMarker 等技术。 国际化支持 面向接口编程 与 Spring 框架无缝集成 一个好的框架要减轻开发者处理复杂问题的负担，内部有良好的扩展，并且有一个支持它的强大用户群体，恰恰 Spring MVC 都做到了。 第一个Spring MVC程序1. 创建Web应用并引入JAR包Spring MVC 依赖 JAR 文件包括 Spring 的核心 JAR 包和 commons-logging 的 JAR 包。 Maven 项目在 pom.xml 文件中添加以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!--测试--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;!--J2EE--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt;&lt;/dependency&gt;&lt;!--springframework--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt; &lt;artifactId&gt;system-rules&lt;/artifactId&gt; &lt;version&gt;1.16.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--其他需要的包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 2. Spring MVC配置Spring MVC 是基于 Servlet 的，DispatcherServlet 是整个 Spring MVC 框架的核心，主要负责截获请求并将其分派给相应的处理器处理。所以配置 Spring MVC，首先要定义 DispatcherServlet。跟所有 Servlet 一样，用户必须在 web.xml 中进行配置。 1）定义DispatcherServlet在开发 Spring MVC 应用时需要在 web.xml 中部署 DispatcherServlet，代码如下： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;!-- 部署 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理所有URL --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring MVC 初始化时将在应用程序的 WEB-INF 目录下查找配置文件，该配置文件的命名规则是“servletName-servlet.xml”，例如 springmvc-servlet.xml。 也可以将 Spring MVC 的配置文件存放在应用程序目录中的任何地方，但需要使用 servlet 的 init-param 元素加载配置文件，通过 contextConfigLocation 参数来指定 Spring MVC 配置文件的位置，示例代码如下。 123456789101112131415&lt;!-- 部署 DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 此处使用 Spring 资源路径的方式进行指定，即 classpath:springmvc-servlet.xml。 上述代码配置了一个名为“springmvc”的 Servlet。该 Servlet 是 DispatcherServlet 类型，它就是 Spring MVC 的入口，并通过 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 配置标记容器在启动时就加载此 DispatcherServlet，即自动启动。然后通过 servlet-mapping 映射到“&#x2F;”，即 DispatcherServlet 需要截获并处理该项目的所有 URL 请求。 load-on-startup：1-10 2）创建Spring MVC配置文件在 WEB-INF 目录下创建 springmvc-servlet.xml 文件，如下所示。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- LoginController控制器类，映射到&quot;/login&quot; --&gt; &lt;bean name=&quot;/login&quot; class=&quot;net.biancheng.controller.LoginController&quot;/&gt; &lt;!-- LoginController控制器类，映射到&quot;/register&quot; --&gt; &lt;bean name=&quot;/register&quot; class=&quot;net.biancheng.controller.RegisterController&quot;/&gt;&lt;/beans&gt; 3. 创建Controller创建 RegisterController 和 LoginController 两个传统风格的控制器类（实现 Controller 接口），分别处理首页中“注册”和“登录”超链接的请求。 Controller 是控制器接口，接口中只有一个方法 handleRequest，用于处理请求和返回 ModelAndView。 RegisterController 的具体代码如下。 123456public class LoginController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; return new ModelAndView(&quot;/WEB-INF/jsp/register.jsp&quot;); &#125;&#125; LoginController 的具体代码如下。 123456public class RegisterController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; return new ModelAndView(&quot;/WEB-INF/jsp/login.jsp&quot;); &#125;&#125; 4. 创建Viewindex.jsp 代码如下。 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 未注册的用户，请 &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/register&quot;&gt; 注册&lt;/a&gt;！ &lt;br /&gt; 已注册的用户，去 &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/login&quot;&gt; 登录&lt;/a&gt;！&lt;/body&gt;&lt;/html&gt; 在 WEB-INF 下创建 jsp 文件夹，将 login.jsp 和 register.jsp 放到 jsp 文件夹下。login.jsp 代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录页面！&lt;/body&gt;&lt;/html&gt; register.jsp 代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;body&gt; 注册页面！&lt;/body&gt;&lt;/html&gt;&lt;/head&gt; 5. 部署运行将 springmvcDemo 项目部署到 Tomcat 服务器，首先访问 index.jsp 页面，如下图所示。 Spring MVC和Struts2的区别Spring MVC 和 Struts2 类似，是一款基于传统 MVC 设计模式的 Java EE 框架。它的核心是一个弹性的控制层，能够很好地发挥 MVC 模式的“分离显示逻辑和业务逻辑”的能力。 1. Spring MVC 基于方法开发，Struts2 基于类开发。在使用 Spring MVC 框架进行开发时，会将 URL 请求路径与 Controller 类的某个方法进行绑定，请求参数作为该方法的形参。当用户请求该 URL 路径时， Spring MVC 会将 URL 信息与 Controller 类的某个方法进行映射，生成 Handler 对象，该对象中只包含了一个 method 方法。方法执行结束之后，形参数据也会被销毁。 而在使用 Struts2 框架进行开发时，Action 类中所有方法使用的请求参数都是 Action 类中的成员变量，随着方法变得越来越多，就很难分清楚 Action 中那么多的成员变量到底是给哪一个方法使用的，整个 Action 类会变得十分混乱。 相比较而言，Spring MVC 优点是其所有请求参数都会被定义为相应方法的形参，用户在网页上的请求路径会被映射到 Controller 类对应的方法上，此时请求参数会注入到对应方法的形参上。Spring MVC 的这种开发方式类似于 Service 开发。 2. Spring MVC 可以进行单例开发，Struts2 无法使用单例Spring MVC 支持单例开发模式，而 Struts2 由于只能通过类的成员变量接受参数，所以无法使用单例模式，只能使用多例。 3. 经过专业人员的大量测试，Struts2 的处理速度要比 SpringMVC 慢原因是 Struts2 使用了 Struts 标签，Struts 标签由于设计原因，会出现加载数据慢的情况 这里仅仅比较了 Spring MVC 在某些方面相比 Struts2 的优势，但这并不能说明 Spring MVC 比 Struts2 优秀，仅仅因为早期 Struts2 使用广泛，所以出现的漏洞也比较多，但是在新版本的 Struts2 中也修复了许多漏洞。Spring MVC 自诞生以来，几乎没有什么致命的漏洞 。且 Spring MVC 基于方法开发，这一点较接近 Service 开发，这也是 Spring MVC 近年来备受关注的原因之一。 Spring MVC视图解析器（ViewResolver）视图解析器（ViewResolver）是 Spring MVC 的重要组成部分，负责将逻辑视图名解析为具体的视图对象。 Spring MVC 提供了很多视图解析类，其中每一项都对应 Java Web 应用中特定的某些视图技术。 URLBasedViewResolverUrlBasedViewResolver 是对 ViewResolver 的一种简单实现，主要提供了一种拼接 URL 的方式来解析视图。 UrlBasedViewResolver 通过 prefix 属性指定前缀，suffix 属性指定后缀。当 ModelAndView 对象返回具体的 View 名称时，它会将前缀 prefix 和后缀 suffix 与具体的视图名称拼接，得到一个视图资源文件的具体加载路径，从而加载真正的视图文件并反馈给用户。 使用 UrlBasedViewResolver 除了要配置前缀和后缀属性之外，还需要配置“viewClass”，表示解析成哪种视图。示例代码如下。 1234567&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt; &lt;!--不能省略--&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 上述视图解析器配置了前缀和后缀两个属性，这样缩短了 view 路径。 上述 viewClass 值为 InternalResourceViewResolver，它用来展示 JSP 页面。如果需要使用 jstl 标签展示数据，将 viewClass 属性值指定为 JstlView 即可。 另外，存放在 &#x2F;WEB-INF&#x2F; 目录下的内容不能直接通过 request 请求得到，所以为了安全性考虑，通常把 jsp 文件放在 WEB-INF 目录下。 InternalResourceViewResolverInternalResourceViewResolver 为“内部资源视图解析器”，是日常开发中最常用的视图解析器类型。它是 URLBasedViewResolver 的子类，拥有 URLBasedViewResolver 的一切特性。 InternalResourceViewResolver 能自动将返回的视图名称解析为 InternalResourceView 类型的对象。InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL。也就是说，使用 InternalResourceViewResolver 视图解析时，无需再单独指定 viewClass 属性。示例代码如下。 1234567&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt; &lt;!--可以省略--&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; FreeMarkerViewResolverFreeMarkerViewResolver 是 UrlBasedViewResolver 的子类，可以通过 prefix 属性指定前缀，通过 suffix 属性指定后缀。 FreeMarkerViewResolver 最终会解析逻辑视图配置，返回 freemarker 模板。不需要指定 viewClass 属性。 1234&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;fm_&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;&lt;/bean&gt; 下面指定 FreeMarkerView 类型最终生成的实体视图（模板文件）的路径以及其他配置。需要给 FreeMarkerViewResolver 设置一个 FreeMarkerConfig 的 bean 对象来定义 FreeMarker 的配置信息，代码如下。 123&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot; /&gt;&lt;/bean&gt; 定义了 templateLoaderPath 属性后，Spring 可以通过该属性找到 FreeMarker 模板文件的具体位置。当有模板位于不同的路径时，可以配置 templateLoaderPath 属性，来指定多个资源路径。 然后定义一个 Controller，让其返回 ModelAndView，同时定义一些返回参数和视图信息。 1234567891011@Controller@RequestMapping(&quot;viewtest&quot;)public class ViewController &#123; @RequestMapping(&quot;freemarker&quot;) public ModelAndView freemarker() &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;username&quot;, &quot;BianChengBang&quot;); mv.setViewName(&quot;freemarker&quot;); return mv; &#125;&#125; 当 FreeMarkerViewResolver 解析逻辑视图信息时，会生成一个 URL 为“前缀+视图名+后缀”（这里即“fm_freemarker.ftl”）的 FreeMarkerView 对象，然后通过 FreeMarkerConfigurer 的配置找到 templateLoaderPath 对应文本文件的路径，在该路径下找到该文本文件，从而 FreeMarkerView 就可以利用该模板文件进行视图的渲染，并将 model 数据封装到即将要显示的页面上，最终展示给用户。 在 &#x2F;WEB-INF&#x2F;ftl 文件夹下创建 fm_freemarker.ftl，代码如下。 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;FreeMarker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;b&gt;Welcome!&lt;/b&gt; &lt;i&gt;$&#123;username &#125;&lt;/i&gt;&lt;/body&gt;&lt;/html&gt; Spring MVC执行流程Spring MVC 框架是高度可配置的，包含多种视图技术，例如 JSP、FreeMarker、Tiles、iText 和 POI。Spring MVC 框架并不关心使用的视图技术，也不会强迫开发者只使用 JSP。 Spring MVC 执行流程Spring MVC 执行流程如图所示。 SpringMVC 的执行流程如下。 用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）； 由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。 DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）； HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）； Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）； HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ； DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析； ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet； DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）； 视图负责将结果显示到浏览器（客户端）。 Spring MVC接口Spring MVC 涉及到的组件有 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）。下面对各个组件的功能说明如下。 1）DispatcherServletDispatcherServlet 是前端控制器，从图 1可以看出，Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。 2）HandlerMappingHandlerMapping 是处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。 3）HandlerAdapterHandlerAdapter 是处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。 4）HandlerHandler 是处理器，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。 5）View ResolverView Resolver 是视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。 6）ViewView 是视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。 以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。 注意：由于 Spring MVC 结构比较复杂，所以学习的时候也要掌握学习方法。首先要明确 Spring MVC 是一个工具，既然是工具，那么我们就需要先掌握工具的使用方法，不要陷入细节中，深入浅出，慢慢通过实际运用来加深对其的理解。 Spring MVC @Controller和@RequestMapping注解使用基于注解的控制器具有以下 2 个优点： 在基于注解的控制器类中可以编写多个处理方法，进而可以处理多个请求（动作），这就允许将相关的操作编写在同一个控制器类中，从而减少控制器类的数量，方便以后维护。 基于注解的控制器不需要在配置文件中部署映射，仅需要使用 @RequestMapping 注解一个方法进行请求处理即可。 Controller注解@Controller 注解用于声明某类的实例是一个控制器。创建控制器类 IndexController 1234@Controllerpublic class IndexController &#123; // 处理请求的方法&#125; Spring MVC 使用扫描机制找到应用中所有基于注解的控制器类，所以，为了让控制器类被 Spring MVC 框架扫描到，需要在配置文件中声明 spring-context，并使用 &lt;context:component-scan/&gt; 元素指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下）。 例如，在 springmvcDemo 应用的配置文件 springmvc-servlet.xml 中添加以下代码： 12&lt;!-- 使用扫描机制扫描控制器类，控制器类都在net.biancheng.controller包及其子包下 --&gt;&lt;context:component-scan base-package=&quot;net.biancheng.controller&quot; /&gt; RequestMapping注解一个控制器内有多个处理请求的方法，如 UserController 里通常有增加用户、修改用户信息、删除指定用户、根据条件获取用户列表等。每个方法负责不同的请求操作，而 @RequestMapping 就负责将请求映射到对应的控制器方法上。 在基于注解的控制器类中可以为每个请求编写对应的处理方法。使用 @RequestMapping 注解将请求与处理方法一 一对应即可。 @RequestMapping 注解可用于类或方法上。用于类上，表示类中的所有响应请求的方法都以该地址作为父路径。 @RequestMapping 注解常用属性如下。 1. value 属性value 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称。如下。 12@RequestMapping(value=&quot;toUser&quot;)@RequestMapping(&quot;toUser&quot;) value 属性支持通配符匹配，如 @RequestMapping(value&#x3D;”toUser&#x2F;*”) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问。 2. path属性path 属性和 value 属性都用来作为映射使用。即 @RequestMapping(value&#x3D;”toUser”) 和 @RequestMapping(path&#x3D;”toUser”) 都能访问 toUser() 方法。 path 属性支持通配符匹配，如 @RequestMapping(path&#x3D;”toUser&#x2F;*”) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问。 3. name属性name属性相当于方法的注释，使方法更易理解。如 @RequestMapping(value &#x3D; “toUser”,name &#x3D; “获取用户信息”)。 4. method属性method 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求。 @RequestMapping(value &#x3D; “toUser”,method &#x3D; RequestMethod.GET) 表示该方法只支持 GET 请求。也可指定多个 HTTP 请求，如 @RequestMapping(value &#x3D; “toUser”,method &#x3D; {RequestMethod.GET,RequestMethod.POST})，说明该方法同时支持 GET 和 POST 请求。 5. params属性params 属性用于指定请求中规定的参数，代码如下。 1234@RequestMapping(value = &quot;toUser&quot;,params = &quot;type&quot;)public String toUser() &#123; return &quot;showUser&quot;;&#125; 以上代码表示请求中必须包含 type 参数时才能执行该请求。即 http://localhost:8080/toUser?type=xxx 能够正常访问 toUser() 方法，而 http://localhost:8080/toUser 则不能正常访问 toUser() 方法。 1234@RequestMapping(value = &quot;toUser&quot;,params = &quot;type=1&quot;)public String toUser() &#123; return &quot;showUser&quot;;&#125; 以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求。即 http://localhost:8080/toUser?type=1 能够正常访问 toUser() 方法，而 http://localhost:8080/toUser?type=2 则不能正常访问 toUser() 方法。 6. header属性header 属性表示请求中必须包含某些指定的 header 值。 @RequestMapping(value &#x3D; “toUser”,headers &#x3D; “Referer&#x3D;http://www.xxx.com“) 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“http://www.xxx.com”时，才能执行该请求。 7. consumers属性consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如：application&#x2F;json、text&#x2F;html。如@RequestMapping(value &#x3D; “toUser”,consumes &#x3D; “application&#x2F;json”)。 8. produces属性produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json”)。 除此之外，produces 属性还可以指定返回值的编码。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json,charset&#x3D;utf-8”)，表示返回 utf-8 编码。 使用 @RequestMapping 来完成映射，具体包括 4 个方面的信息项：请求 URL、请求参数、请求方法和请求头。 通过请求URL进行映射1）方法级别注解1234567891011@Controllerpublic class IndexController &#123; @RequestMapping(value = &quot;/index/login&quot;) public String login() &#123; return &quot;login&quot;; &#125; @RequestMapping(value = &quot;/index/register&quot;) public String register() &#123; return &quot;register&quot;; &#125;&#125; 上述示例中有两个 RequestMapping 注解语句，它们都作用在处理方法上。在整个 Web 项目中，@RequestMapping 映射的请求信息必须保证全局唯一。 用户可以使用如下 URL 访问 login 方法（请求处理方法），在访问 login 方法之前需要事先在 &#x2F;WEB-INF&#x2F;jsp&#x2F; 目录下创建 login.jsp。 1http://localhost:8080/springmvcDemo/index/login 2）类级别注解123456789101112@Controller@RequestMapping(&quot;/index&quot;)public class IndexController &#123; @RequestMapping(&quot;/login&quot;) public String login() &#123; return &quot;login&quot;; &#125; @RequestMapping(&quot;/register&quot;) public String register() &#123; return &quot;register&quot;; &#125;&#125; 在类级别注解的情况下，控制器类中的所有方法都将映射为类级别的请求。用户可以使用如下 URL 访问 login 方法。 1http://localhost:8080/springmvcDemo/index/login 为了方便维护程序，建议开发者采用类级别注解，将相关处理放在同一个控制器类中。例如，对用户的增、删、改、查等处理方法都可以放在 UserController 控制类中。 通过请求参数、请求方法进行映射@RequestMapping 除了可以使用请求 URL 映射请求之外，还可以使用请求参数、请求方法来映射请求，通过多个条件可以让请求映射更加精确。 123456@Controllerpublic class IndexController &#123; @RequestMapping(value = &quot;/index/success&quot; method=RequestMethod.GET, Params=&quot;username&quot;) public String success(@RequestParam String username) &#123; return &quot;index&quot;;&#125; 上述代码中，@RequestMapping 的 value 表示请求的 URL；method 表示请求方法，此处设置为 GET 请求，若是 POST 请求，则无法进入 success 这个处理方法中。params 表示请求参数，此处参数名为 username。 编写请求处理方法在控制类中每个请求处理方法可以有多个不同类型的参数，以及一个多种类型的返回结果。 1）请求处理方法中常出现的参数类型如果需要在请求处理方法中使用 Servlet API 类型，那么可以将这些类型作为请求处理方法的参数类型。Servlet API 参数类型的示例代码如下： 12345678910@Controller@RequestMapping(&quot;/index&quot;)public class IndexController &#123; @RequestMapping(&quot;/login&quot;) public String login(HttpSession session,HttpServletRequest request) &#123; session.setAttribute(&quot;skey&quot;, &quot;session范围的值&quot;); session.setAttribute(&quot;rkey&quot;, &quot;request范围的值&quot;); return &quot;login&quot;; &#125;&#125; 除了 Servlet API 参数类型以外，还有输入输出流、表单实体类、注解类型、与 Spring 框架相关的类型等，这些类型在后续章节中使用时再详细介绍。 其中特别重要的类型是 org.springframework.ui.Model 类型，该类型是一个包含 Map 的 Spring MVC类型。在每次调用请求处理方法时 Spring MVC 都将创建 org.springframework.ui.Model 对象。Model 参数类型的示例代码如下： 12345678910@Controller@RequestMapping(&quot;/index&quot;)public class IndexController &#123; @RequestMapping(&quot;/register&quot;) public String register(Model model) &#123; /*在视图中可以使用EL表达式$&#123;success&#125;取出model中的值*/ model.addAttribute(&quot;success&quot;, &quot;注册成功&quot;); return &quot;register&quot;; &#125;&#125; 2）请求处理方法常见的返回类型请求处理方法可以返回如下类型的对象： ModelAndView Model 包含模型属性的 Map View 代表逻辑视图名的 String void 其它任意Java类型 最常见的返回类型就是代表逻辑视图名称的 String 类型 示例web.xml 代码如下。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;!-- 部署 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理所有URL --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 配置文件代码如下。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;net.biancheng.controller&quot; /&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!--后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 创建 User 实体类，代码如下。如前面所说，使用 Controller 注解的一个优点在于一个控制类可以包含多个请求处理方法。创建 UserController，代码如下。 123456789101112131415@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/login&quot;) public String getLogin(Model model) &#123; User us = new User(); us.setName(&quot;编程帮&quot;); model.addAttribute(&quot;user&quot;, us); return &quot;login&quot;; &#125; @RequestMapping(&quot;/register&quot;) public String getRegister() &#123; return &quot;register&quot;; &#125;&#125; index.jsp 文件页面代码如下。 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 未注册的用户，请 &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/user/register&quot;&gt; 注册&lt;/a&gt;！ &lt;br /&gt; 已注册的用户，去 &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/user/login&quot;&gt; 登录&lt;/a&gt;！&lt;/body&gt;&lt;/html&gt; login.jsp 代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录页面！ 欢迎 $&#123;user.name&#125; 登录&lt;/body&gt;&lt;/html&gt; register.jsp 代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 注册页面！&lt;/body&gt;&lt;/html&gt; 当用户单击“注册”超链接时，控制器会将该请求转发给 UserController 的 getLogin 方法处理，处理后跳转到 &#x2F;WEB-INF&#x2F;jsp 下的 register.jsp 视图。同理，当单击“登录”超链接时，控制器处理后转到 &#x2F;WEB-INF&#x2F;jsp下的 login.jsp 视图。 Spring MVC传递参数Spring MVC Controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式： 通过实体 Bean 接收请求参数 通过处理方法的形参接收请求参数 通过 HttpServletRequest 接收请求参数 通过 @PathVariable 接收 URL 中的请求参数 通过 @RequestParam 接收请求参数 通过 @ModelAttribute 接收请求参数 通过实体Bean接收请求参数实体 Bean 接收请求参数适用于 get 和 post 提交请求方式。需要注意，Bean 的属性名称必须与请求参数名称相同。示例代码如下。 1234567891011@RequestMapping(&quot;/login&quot;)public String login(User user, Model model) &#123; if (&quot;bianchengbang&quot;.equals(user.getName()) &amp;&amp; &quot;123456&quot;.equals(user.getPwd())) &#123; model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;); return &quot;main&quot;; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; &#125;&#125; 通过处理方法的形参接收请求参数通过处理方法的形参接收请求参数就是直接把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。该接收参数方式适用于 get 和 post 提交请求方式。示例代码如下： 1234567891011@RequestMapping(&quot;/login&quot;)public String login(String name, String pwd, Model model) &#123; if (&quot;bianchengbang&quot;.equals(user.getName()) &amp;&amp; &quot;123456&quot;.equals(user.getPwd())) &#123; model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;); return &quot;main&quot;; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; &#125;&#125; 通过HttpServletRequest接收请求参数通过 HttpServletRequest 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下： 12345678910111213@RequestMapping(&quot;/login&quot;)public String login(HttpServletRequest request, Model model) &#123; String name = request.getParameter(&quot;name&quot;); String pwd = request.getParameter(&quot;pwd&quot;); if (&quot;bianchengbang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123; model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;); return &quot;main&quot;; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; &#125;&#125; 通过@PathVariable接收URL中的请求参数通过 @PathVariable 获取 URL 中的参数，示例代码如下。 12345678910@RequestMapping(&quot;/login/&#123;name&#125;/&#123;pwd&#125;&quot;)public String login(@PathVariable String name, @PathVariable String pwd, Model model) &#123; if (&quot;bianchengbang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123; model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;); return &quot;main&quot;; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; &#125;&#125; 在访问“http://localhost:8080/springMVCDemo02/user/register/bianchengbang/123456”路径时，上述代码会自动将 URL 中的模板变量 {name} 和 {pwd} 绑定到通过 @PathVariable 注解的同名参数上，即 name&#x3D;bianchengbang、pwd&#x3D;123456。 通过@RequestParam接收请求参数在方法入参处使用 @RequestParam 注解指定其对应的请求参数。@RequestParam 有以下三个参数： value：参数名 required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常 defaultValue：参数默认值 通过 @RequestParam 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。 12345678910@RequestMapping(&quot;/login&quot;)public String login(@RequestParam String name, @RequestParam String pwd, Model model) &#123; if (&quot;bianchengbang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123; model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;); return &quot;main&quot;; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; &#125;&#125; 该方式与“通过处理方法的形参接收请求参数”部分的区别如下：当请求参数与接收参数名不一致时，“通过处理方法的形参接收请求参数”不会报 404 错误，而“通过 @RequestParam 接收请求参数”会报 404 错误。 通过@ModelAttribute接收请求参数@ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用。 而“通过实体 Bean 接收请求参数”中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据）。 通过 @ModelAttribute 注解接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。 1234567891011@RequestMapping(&quot;/login&quot;)public String login(@ModelAttribute(&quot;user&quot;) User user, Model model) &#123; if (&quot;bianchengbang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123; model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;); return &quot;main&quot;; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; &#125;&#125; Spring MVC重定向和转发Spring MVC 请求方式分为转发、重定向 2 种，分别使用 forward 和 redirect 关键字在 controller 层进行处理。 重定向是将用户从当前处理请求定向到另一个视图（例如 JSP）或处理请求，以前的请求（request）中存放的信息全部失效，并进入一个新的 request 作用域；转发是将用户对当前处理的请求转发给另一个视图或处理请求，以前的 request 中存放的信息不会失效。 转发是服务器行为，重定向是客户端行为。 1）转发过程客户浏览器发送 http 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request。 在客户浏览器的地址栏中显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。 2）重定向过程客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求，请求 URL 是新的 location 地址，服务器根据此请求寻找资源并发送给客户。 在这里 location 可以重定向到任意 URL，既然是浏览器重新发出了请求，那么就没有什么 request 传递的概念了。在客户浏览器的地址栏中显示的是其重定向的路径，客户可以观察到地址的变化。重定向行为是浏览器做了至少两次的访问请求。 在 Spring MVC 框架中，控制器类中处理方法的 return 语句默认就是转发实现，只不过实现的是转发到视图。示例代码如下： 1234@RequestMapping(&quot;/register&quot;)public String register() &#123; return &quot;register&quot;; //转发到register.jsp&#125; 在 Spring MVC 框架中，重定向与转发的示例代码如下： 12345678910111213141516171819@Controller@RequestMapping(&quot;/index&quot;)public class IndexController &#123; @RequestMapping(&quot;/login&quot;) public String login() &#123; //转发到一个请求方法（同一个控制器类可以省略/index/） return &quot;forward:/index/isLogin&quot;; &#125; @RequestMapping(&quot;/isLogin&quot;) public String isLogin() &#123; //重定向到一个请求方法 return &quot;redirect:/index/isRegister&quot;; &#125; @RequestMapping(&quot;/isRegister&quot;) public String isRegister() &#123; //转发到一个视图 return &quot;register&quot;; &#125;&#125; 在 Spring MVC 框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要 DispatcherServlet 的资源，例如： 1return &quot;forward:/html/my.html&quot;; 则需要使用 mvc:resources 配置： 1&lt;mvc:resources location=&quot;/html/&quot; mapping=&quot;/html/**&quot; /&gt; Spring MVC @Autowired和@Service注解将依赖注入到 Spring MVC 控制器时需要用到 @Autowired 和 @Service 注解。 @Autowired 注解属于 org.springframework.beans.factory. annotation 包，可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 @Service 注解属于 org.springframework.stereotype 包，会将标注类自动注册到 Spring 容器中。 在配置文件中需要添加 &lt;component-scan&#x2F;&gt; 元素来扫描依赖基本包。 1&lt;context:component-scan base-package=&quot;net.biancheng.service&quot;/&gt; 示例User 实体类如下。 12345public class User &#123; private String name; private String pwd; /*省略setter和getter方法*/&#125; 新建 net.biancheng.service 包，创建 UserService 接口，代码如下。 1234public interface UserService &#123; boolean login(User user); boolean register(User user);&#125; 创建 UserServiceImpl 类，实现 UserService 接口，代码如下。 1234567891011121314151617@Servicepublic class UserServiceImpl implements UserService &#123; @Override public boolean login(User user) &#123; if (&quot;bianchengbang&quot;.equals(user.getName()) &amp;&amp; &quot;123456&quot;.equals(user.getPwd())) &#123; return true; &#125; return false; &#125; @Override public boolean register(User user) &#123; if (&quot;bianchengbang&quot;.equals(user.getName()) &amp;&amp; &quot;123456&quot;.equals(user.getPwd())) &#123; return true; &#125; return false; &#125;&#125; 注意：为了使类能被 Spring 扫描到，必须为其标注 @Service。 创建 UserController 类，代码如下。 12345678910111213141516171819202122@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @RequestMapping(&quot;/login&quot;) public String getLogin(Model model) &#123; User us = new User(); us.setName(&quot;bianchengbang&quot;); userService.login(us); model.addAttribute(&quot;user&quot;, us); return &quot;login&quot;; &#125; @RequestMapping(&quot;/register&quot;) public String getRegister(Model model) &#123; User us = new User(); us.setName(&quot;bianchengbang&quot;); userService.login(us); model.addAttribute(&quot;user&quot;, us); return &quot;register&quot;; &#125;&#125; 在 UserService 上添加 @Autowired 注解会使 UserService 的一个实例被注入到 UserController 实例中。 springmvc-servlet.xml 代码如下。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;net.biancheng&quot; /&gt; &lt;mvc:annotation-driven /&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!--后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 代码如下。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;!-- 部署 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理所有URL --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp 文件内容如下。 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 未注册的用户，请 &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/user/register&quot;&gt; 注册&lt;/a&gt;！ &lt;br /&gt; 已注册的用户，去 &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/user/login&quot;&gt; 登录&lt;/a&gt;！&lt;/body&gt;&lt;/html&gt; login.jsp 文件内容如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录页面！ 欢迎 $&#123;user.name&#125; 登录&lt;/body&gt;&lt;/html&gt; register.jsp 文件内容如下。 12345678910111213&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 注册页面！ 注册账号成功，用户名为： $&#123;user.name &#125;&lt;/body&gt;&lt;/html&gt; Spring MVC @ModelAttribute注解在 Controller 中使用 @ModelAttribute 时，有以下几种应用情况。 应用在方法上 应用在方法的参数上 应用在方法上，并且方法也使用了 @RequestMapping 需要注意的是，因为模型对象要先于 controller 方法之前创建，所以被 @ModelAttribute 注解的方法会在 Controller 每个方法执行之前都执行。因此一个 Controller 映射多个 URL 时，要谨慎使用。 1. 应用在方法上下面从应用在有无返回值的方法上两个方面进行讲解。 1）应用在无返回值的方法示例 1：创建 ModelAttributeController，代码如下。 123456789101112@Controllerpublic class ModelAttributeController &#123; // 方法无返回值 @ModelAttribute public void myModel(@RequestParam(required = false) String name, Model model) &#123; model.addAttribute(&quot;name&quot;, name); &#125; @RequestMapping(value = &quot;/model&quot;) public String model() &#123; return &quot;index&quot;; &#125;&#125; 创建 index.jsp 页面，代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;编程帮&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;name &#125;&lt;/body&gt;&lt;/html&gt; 访问地址：http://localhost:8080/springmvcDemo2/model?name=%E7%BC%96%E7%A8%8B%E5%B8%AE。 以上示例，在请求 &#x2F;model?name&#x3D;%E7%BC%96%E7%A8%8B%E5%B8%AE 后，Spring MVC 会先执行 myModel 方法，将 name 的值存入到 Model 中。然后执行 model 方法，这样 name 的值就被带到了 model 方法中。 将 myModel 和 model 方法合二为一后，代码如下。 12345@RequestMapping(value = &quot;/model&quot;)public String model(@RequestParam(required = false) String name, Model model) &#123; model.addAttribute(&quot;name&quot;, name); return &quot;index&quot;;&#125; 2）应用在有返回值的方法示例 2：修改 ModelAttributeController 控制类，代码如下。 123456789101112@Controllerpublic class ModelAttributeController &#123; // 方法有返回值 @ModelAttribute(&quot;string&quot;) public String myModel(@RequestParam(required = false) String name) &#123; return name; &#125; @RequestMapping(value = &quot;/model&quot;) public String model() &#123; return &quot;index&quot;; &#125;&#125; 修改 index.jsp，代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;编程帮&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;string &#125;&lt;/body&gt;&lt;/html&gt; 访问地址和运行结果与示例 1 相同。 http://localhost:8080/springmvcDemo2/model?name=%E7%BC%96%E7%A8%8B%E5%B8%AE 对于以上情况，返回值对象 name 会被默认放到隐含的 Model 中，在 Model 中 key 为返回值首字母小写，value 为返回的值。等同于 model.addAttribute(&quot;string&quot;, name);。 但正常情况下，程序中尽量不要出现 key 为 string、int、float 等这样数据类型的返回值。使用 @ModelAttribute 注解 value 属性可以自定义 key，代码如下。 12345// 方法有返回值@ModelAttribute(&quot;name&quot;)public String myModel(@RequestParam(required = false) String name) &#123; return name;&#125; 等同于 1model.addAttribute(&quot;name&quot;, name); 2. 应用在方法的参数上@ModelAttribute 注解在方法的参数上，调用方法时，模型的值会被注入。这在实际使用时非常简单，常用于将表单属性映射到模型对象。 123456789@RequestMapping(&quot;/register&quot;)public String register(@ModelAttribute(&quot;user&quot;) UserForm user) &#123; if (&quot;zhangsan&quot;.equals(uname) &amp;&amp; &quot;123456&quot;.equals(upass)) &#123; logger.info(&quot;成功&quot;); return &quot;login&quot;; &#125; else &#123; logger.info(&quot;失败&quot;); return &quot;register&quot;;&#125; 上述代码中“@ModelAttribute(“user”) UserForm user”语句的功能有两个： 将请求参数的输入封装到 user 对象中 创建 UserForm 实例 以“user”为键值存储在 Model 对象中，和“model.addAttribute(“user”,user)”语句的功能一样。如果没有指定键值，即“@ModelAttribute UserForm user”，那么在创建 UserForm 实例时以“userForm”为键值存储在 Model 对象中，和“model.addAtttribute(“userForm”, user)”语句的功能一样。 3. ModelAttribute+RequestMapping示例 3：修改 ModelAttributeController，代码如下。 123456789@Controllerpublic class ModelAttributeController &#123; // @ModelAttribute和@RequestMapping同时放在方法上 @RequestMapping(value = &quot;/index&quot;) @ModelAttribute(&quot;name&quot;) public String model(@RequestParam(required = false) String name) &#123; return name; &#125;&#125; index.jsp 代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;编程帮&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;name &#125;&lt;/body&gt;&lt;/html&gt; 访问地址：http://localhost:8080/springmvcDemo2/index?name=%E7%BC%96%E7%A8%8B%E5%B8%AE @ModelAttribute 和 @RequestMapping 注解同时应用在方法上时，有以下作用： 方法的返回值会存入到 Model 对象中，key 为 ModelAttribute 的 value 属性值。 方法的返回值不再是方法的访问路径，访问路径会变为 @RequestMapping 的 value 值，例如：@RequestMapping(value &#x3D; “&#x2F;index”) 跳转的页面是 index.jsp 页面。 总而言之，@ModelAttribute 注解的使用方法有很多种，非常灵活，可以根据业务需求选择使用。 Model和ModelView的区别Model：每次请求中都存在的默认参数，利用其 addAttribute() 方法即可将服务器的值传递到客户端页面中。 ModelAndView：包含 model 和 view 两部分，使用时需要自己实例化，利用 ModelMap 来传值，也可以设置 view 的名称。 拓展@ModelAttribute 注解的方法会在每次调用该控制器类的请求处理方法前被调用。这种特性可以用来控制登录权限。 控制登录权限的方法有很多，例如拦截器、过滤器等。 创建 BaseController，代码如下所示。 12345678public class BaseController &#123; @ModelAttribute public void isLogin(HttpSession session) throws Exception &#123; if (session.getAttribute(&quot;user&quot;) == null) &#123; throw new Exception(&quot;没有权限&quot;); &#125; &#125;&#125; 创建 ModelAttributeController ，代码如下所示： 123456789101112131415@RequestMapping(&quot;/admin&quot;)public class ModelAttributeController extends BaseController &#123; @RequestMapping(&quot;/add&quot;) public String add() &#123; return &quot;addSuccess&quot;; &#125; @RequestMapping(&quot;/update&quot;) public String update() &#123; return &quot;updateSuccess&quot;; &#125; @RequestMapping(&quot;/delete&quot;) public String delete() &#123; return &quot;deleteSuccess&quot;; &#125;&#125; 在上述 ModelAttributeController 类中的 add、update、delete 请求处理方法执行时，首先执行父类 BaseController 中的 isLogin 方法判断登录权限，可以通过地址“http://localhost:8080/springMVCDemo2/admin/add”测试登录权限。 Spring MVC类型转换器（Converter）Spring MVC 框架的 Converter&lt;S，T&gt; 是一个可以将一种数据类型转换成另一种数据类型的接口，这里 S 表示源类型，T 表示目标类型。开发者在实际应用中使用框架内置的类型转换器基本上就够了，但有时需要编写具有特定功能的类型转换器。 例如，用户输入的日期可能有许多种形式，如“December 25,2014”“12&#x2F;25&#x2F;2014”和“2014-12-25”，这些都表示同一个日期。默认情况下，Spring 会期待用户输入的日期样式与当前语言区域的日期样式相同。例如，对于美国的用户而言，就是月&#x2F;日&#x2F;年的格式。如果希望 Spring 在将输入的日期字符串绑定到 LocalDate 时，使用不同的日期样式，则需要编写一个 Converter，才能将字符串转换成日期。 java.time.LocalDate 类是 Java 8 的一个新类型，用来替代 java.util.Date。还需使用新的 Date&#x2F;Time API 来替换旧有的 Date 和 Calendar 类。 内置的类型转换器在 Spring MVC 框架中，对于常用的数据类型，开发者无须创建自己的类型转换器，因为 Spring MVC 框架有许多内置的类型转换器用于完成常用的类型转换。Spring MVC 框架提供的内置类型转换包括以下几种类型。 1）标量转换器 名称 作用 StringToBooleanConverter String 到 boolean 类型转换 ObjectToStringConverter Object 到 String 转换，调用 toString 方法转换 StringToNumberConverterFactory String 到数字转换（例如 Integer、Long 等） NumberToNumberConverterFactory 数字子类型（基本类型）到数字类型（包装类型）转换 StringToCharacterConverter String 到 Character 转换，取字符串中的第一个字符 NumberToCharacterConverter 数字子类型到 Character 转换 CharacterToNumberFactory Character 到数字子类型转换 StringToEnumConverterFactory String 到枚举类型转换，通过 Enum.valueOf 将字符串转换为需要的枚举类型 EnumToStringConverter 枚举类型到 String 转换，返回枚举对象的 name 值 StringToLocaleConverter String 到 java.util.Locale 转换 PropertiesToStringConverter java.util.Properties 到 String 转换，默认通过 ISO-8859-1 解码 StringToPropertiesConverter String 到 java.util.Properties 转换，默认使用 ISO-8859-1 编码 2）集合、数组相关转换器 名称 作用 ArrayToCollectionConverter 任意数组到任意集合（List、Set）转换 CollectionToArrayConverter 任意集合到任意数组转换 ArrayToArrayConverter 任意数组到任意数组转换 CollectionToCollectionConverter 集合之间的类型转换 MapToMapConverter Map之间的类型转换 ArrayToStringConverter 任意数组到 String 转换 StringToArrayConverter 字符串到数组的转换，默认通过“，”分割，且去除字符串两边的空格（trim） ArrayToObjectConverter 任意数组到 Object 的转换，如果目标类型和源类型兼容，直接返回源对象；否则返回数组的第一个元素并进行类型转换 ObjectToArrayConverter Object 到单元素数组转换 CollectionToStringConverter 任意集合（List、Set）到 String 转换 StringToCollectionConverter String 到集合（List、Set）转换，默认通过“，”分割，且去除字符串两边的空格（trim） CollectionToObjectConverter 任意集合到任意 Object 的转换，如果目标类型和源类型兼容，直接返回源对象；否则返回集合的第一个元素并进行类型转换 ObjectToCollectionConverter Object 到单元素集合的类型转换 类型转换是在视图与控制器相互传递数据时发生的。Spring MVC 框架对于基本类型（例如 int、long、float、double、boolean 以及 char 等）已经做好了基本类型转换。 注意：在使用内置类型转换器时，请求参数输入值与接收参数类型要兼容，否则会报 400 错误。请求参数类型与接收参数类型不兼容问题需要学习输入校验后才可解决。 自定义类型转换器例如需要用户在页面表单中输入信息来创建商品信息。当输入“bianchengbang，18，1.85”时表示在程序中自动创建一个 new User，并将“bianchengbang”值自动赋给 name 属性，将“18”值自动赋给 age 属性，将“1.85”值自动赋给 height 属性。 如果想实现上述应用，需要做以下 5 件事： 创建实体类。 创建控制器类。 创建自定义类型转换器类。 注册类型转换器。 创建相关视图。 示例1. 创建实体类创建 User 实体类，代码如下。 123456public class User &#123; private String name; private Integer age; private Double height; /**省略setter和getter方法*/&#125; 2. 创建控制器类创建 UserController 控制器，代码如下。 1234567@Controllerpublic class UserController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser() &#123; return &quot;addUser&quot;; &#125;&#125; 创建 ConverterController 控制器，代码如下。 12345678@Controllerpublic class ConverterController &#123; @RequestMapping(&quot;/converter&quot;) public String myConverter(@RequestParam(&quot;user&quot;) User user, Model model) &#123; model.addAttribute(&quot;user&quot;, user); return &quot;showUser&quot;; &#125;&#125; 3. 创建自定义类型转换器创建自定义类型转换器 UserConverter，代码如下。 12345678910111213141516171819@Componentpublic class UserConverter implements Converter&lt;String, User&gt; &#123; @Override public User convert(String source) &#123; // 创建User实例 User user = new User(); // 以“，”分隔 String stringvalues[] = source.split(&quot;,&quot;); if (stringvalues != null &amp;&amp; stringvalues.length == 3) &#123; // 为user实例赋值 user.setName(stringvalues[0]); user.setAge(Integer.parseInt(stringvalues[1])); user.setHeight(Double.parseDouble(stringvalues[2])); return user; &#125; else &#123; throw new IllegalArgumentException(String.format(&quot;类型转换失败， 需要格式&#x27;编程帮, 18,1.85&#x27;,但格式是[% s ] &quot;, source)); &#125; &#125;&#125; 4. 配置转换器在 springmvc-servlet.xml 文件中添加以下代码。 123456789&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; /&gt;&lt;!--注册类型转换器UserConverter --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;net.biancheng.converter.UserConverter&quot; /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 5. 创建相关视图创建添加用户页面 addUser.jsp，代码如下。 123456789101112131415161718&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/converter&quot; method=&quot;post&quot;&gt; 请输入用户信息（格式为编程帮, 18,1.85）: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建显示用户页面 showUser.jsp，代码如下。 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 您创建的用户信息如下： &lt;br/&gt; &lt;!-- 使用EL表达式取出model中的user信息 --&gt; 用户名：$&#123;user.name &#125; &lt;br/&gt; 年龄：$&#123;user.age &#125; &lt;br/&gt; 身高：$&#123;user.height &#125;&lt;/body&gt;&lt;/html&gt; 6. 测试访问地址：http://localhost:8080/springmvcDemo2/addUser，运行结果如下图所示。 Spring MVC数据格式化（Formatter）Spring MVC 框架的 Formatter 与 Converter&lt;S, T&gt; 一样，也是一个可以将一种数据类型转换成另一种数据类型的接口。 不同的是，Formatter 的源类型必须是 String 类型，而 Converter 的源类型可以是任意数据类型。 Formatter 更适合 Web 层，而 Converter 可以在任意层中。 所以对于需要转换表单中的用户输入的情况，应该选择 Formatter，而不是 Converter。 在 Web 应用中由 HTTP 发送的请求数据到控制器中都是以 String 类型获取，因此在 Web 应用中选择 Formatter 比选择 Converter&lt;S, T&gt; 更加合理。 内置的格式化转换器Spring MVC 提供了几个内置的格式化转换器，具体如下。 NumberFormatter：实现 Number 与 String 之间的解析与格式化。 CurrencyFormatter：实现 Number 与 String 之间的解析与格式化（带货币符号）。 PercentFormatter：实现 Number 与 String 之间的解析与格式化（带百分数符号）。 DateFormatter：实现 Date 与 String 之间的解析与格式化。 自定义格式化转换器自定义格式化转换器就是编写一个实现 org.springframework.format.Formatter 接口的 Java 类。该接口声明如下。 1public interface Formatter&lt;T&gt; 这里的 T 表示由字符串转换的目标数据类型。该接口有 parse 和 print 两个接口方法，自定义格式化转换器类必须覆盖它们。 12public T parse(String s, java.util.Locale locale)public String print(T object, java.util.Locale locale) parse 方法的功能是利用指定的 Locale 将一个 String 类型转换成目标类型，print 方法与之相反，用于返回目标对象的字符串表示。 示例1. 创建实体类创建 User 实体类，代码如下。 1234567public class User &#123; private String name; private Integer age; private Double height; private Date createDate; /**省略setter和getter方法*/&#125; 2. 创建控制器类创建 FormatterController 控制器类，代码如下。 12345678@Controllerpublic class FormatterController &#123; @RequestMapping(&quot;/formatter&quot;) public String myFormatter(User us, Model model) &#123; model.addAttribute(&quot;user&quot;, us); return &quot;showUser&quot;; &#125;&#125; 3. 创建自定义格式化转换器类创建 MyFormatter 的自定义格式化转换器类，代码如下。 12345678910@Componentpublic class MyFormatter implements Formatter&lt;Date&gt; &#123; SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); public String print(Date object, Locale arg1) &#123; return dateFormat.format(object); &#125; public Date parse(String source, Locale arg1) throws ParseException &#123; return dateFormat.parse(source); // Formatter只能对字符串转换 &#125;&#125; 4. 注册格式化转换器在 springmvc-servlet.xml 配置文件中注册格式化转换器，具体代码如下： 123456789&lt;!--注册MyFormatter --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;net.biancheng.formatter.MyFormatter&quot; /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; /&gt; 5. 创建相关视图创建添加用户页面 addUser.jsp，代码如下。 12345678910111213141516171819202122&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/formatter&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt; &lt;br&gt; 身高：&lt;input type=&quot;text&quot; name=&quot;height&quot; /&gt; &lt;br&gt; 创建日期：&lt;input type=&quot;text&quot; name=&quot;createDate&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建信息显示页面 showUser.jsp，代码如下。 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 您创建的用户信息如下： &lt;br /&gt; &lt;!-- 使用EL表达式取出model中的user信息 --&gt; 用户名：$&#123;user.name &#125; &lt;br /&gt; 年龄：$&#123;user.age &#125; &lt;br /&gt; 身高：$&#123;user.height &#125; &lt;br /&gt; 创建日期：$&#123;user.createDate &#125;&lt;/body&gt;&lt;/html&gt; 6. 测试运行访问地址：http://localhost:8080/springmvcDemo2/addUser。 Spring MVC表单标签库我们在进行 Spring MVC 项目开发时，一般会使用 EL 表达式和 JSTL 标签来完成页面视图的开发。其实 Spring 也有自己的一套表单标签库，通过 Spring 表单标签，可以很容易地将模型数据中的命令对象绑定到 HTML 表单元素中。下面我们就通过一个示例来演示该标签库的用法。 首先和 JSTL 标签的使用方法相同，在使用 Spring 表单标签之前，必须在 JSP 页面开头处声明 taglib 指令，指令代码如下。 1&lt;%@ taglib prefix=&quot;fm&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; 名称 作用 form 渲染表单元素 input 输入框组件标签，渲染 &lt;input type&#x3D;”text”&#x2F;&gt; 元素 password 密码框组件标签，渲染 &lt;input type&#x3D;”password”&#x2F;&gt; 元素 hidden 隐藏框组件标签，渲染 &lt;input type&#x3D;”hidden”&#x2F;&gt; 元素 textarea 多行输入框组件标签，渲染 textarea 元素 checkbox 复选框组件标签，渲染一个 &lt;input type&#x3D;”checkbox”&#x2F;&gt; 元素 checkboxes 渲染多个 &lt;input type&#x3D;”checkbox”&#x2F;&gt; 元素 radiobutton 单选框组件标签，渲染一个 &lt;input type&#x3D;”radio”&#x2F;&gt; 元素 radiobuttons 渲染多个 &lt;input type&#x3D;”radio”&#x2F;&gt; 元素 select 下拉列表组件标签，渲染一个选择元素 option 渲染一个选项元素 options 渲染多个选项元素 errors 显示表单数据校验所对应的错误信息 以上标签基本都拥有以下属性。 path：属性路径，表示表单对象属性，如 userName、userCode 等。 cssClass：表单组件对应的 CSS 样式类名。 cssErrorClass：当提交表单后报错（服务端错误），采用的 CSS 样式类。 cssStyle：表单组件对应的 CSS 样式。 htmlEscape：绑定的表单属性值是否要对 HTML 特殊字符进行转换，默认为 true。 示例下面以 fm:form 表单标签为例，模仿添加用户信息。 1. 创建实体类创建实体类 user，代码如下。 123456public class User &#123; private String name; private Integer age; private Double height; /** 省略setter和getter方法*/&#125; 2. 创建页面创建 addUser.jsp，代码如下。 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;fm&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;fm:form method=&quot;post&quot; modelAttribute=&quot;user&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/showuser&quot;&gt; 用户名：&lt;fm:input path=&quot;name&quot;/&gt; &lt;br /&gt; 年龄：&lt;fm:input path=&quot;age&quot;/&gt; &lt;br /&gt; 身高：&lt;fm:input path=&quot;height&quot;/&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; /&gt; &lt;/fm:form&gt;&lt;/body&gt;&lt;/html&gt; fm:form 标签的 modelAttribute 属性用于指定绑定的模型属性。默认从模型中尝试取名为“command”的表单对象，若不存在此表单对象，将会报错。所以一般情况下会指定 modelAttribute 属性。 此外，表单组件标签页拥有 HTML 标签的各种属性，如 id、onclick 等，都可以根据需要灵活使用。 创建显示页面 showUser.jsp，代码如下。 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 您创建的用户信息如下： &lt;br /&gt; &lt;!-- 使用EL表达式取出model中的user信息 --&gt; 用户名：$&#123;user.name &#125; &lt;br /&gt; 年龄：$&#123;user.age &#125; &lt;br /&gt; 身高：$&#123;user.height &#125;&lt;/body&gt;&lt;/html&gt; 3. 创建控制器类创建 UserController，代码如下。 1234567891011@Controllerpublic class UserController &#123; @RequestMapping(value = &quot;/addUser&quot;, method = RequestMethod.GET) public String add(@ModelAttribute(&quot;user&quot;) User user) &#123; return &quot;addUser&quot;; &#125; @RequestMapping(value = &quot;/showuser&quot;, method = RequestMethod.POST) public String showuser(User user, HttpSession session, HttpServletRequest request) &#123; return &quot;showUser&quot;; &#125;&#125; 4. 测试运行访问地址：http://localhost:8080/springmvcDemo2/addUser，运行结果如下图所示。 Spring MVC JSON数据交互Spring MVC 在数据绑定的过程中需要对传递数据的格式和类型进行转换，它既可以转换 String 等类型的数据，也可以转换 JSON 等其他类型的数据。 JSON 概述JSON（JavaScript Object Notation, JS 对象标记）是一种轻量级的数据交换格式。与 XML 一样，JSON 也是基于纯文本的数据格式。它有对象结构和数组结构两种数据结构。 1）对象结构对象结构以&#123;开始、以&#125;结束，中间部分由 0 个或多个以英文,分隔的 key&#x2F;value 对构成，key 和 value 之间以英文:分隔。对象结构的语法结构如下： 12345&#123; key1:value1, key2:value2, ...&#125; 其中，key 必须为 String 类型，value 可以是 String、Number、Object、Array 等数据类型。例如，一个 person 对象包含姓名、密码、年龄等信息，使用 JSON 的表示形式如下： 12345&#123; &quot;pname&quot;:&quot;张三&quot;, &quot;password&quot;:&quot;123456&quot;, &quot;page&quot;:40&#125; 2）数组结构数组结构以[开始、以]结束，中间部分由 0 个或多个以英文,分隔的值的列表组成。数组结构的语法结构如下： 12345[ value1, value2, ...] 上述两种（对象、数组）数据结构也可以分别组合构成更加复杂的数据结构。例如，一个 student 对象包含 sno、sname、hobby 和 college 对象，其 JSON 的表示形式如下： 123456789&#123; &quot;sno&quot;:&quot;201802228888&quot;, &quot;sname&quot;:&quot;张三&quot;, &quot;hobby&quot;:[&quot;篮球&quot;,&quot;足球&quot;]， &quot;college&quot;:&#123; &quot;cname&quot;:&quot;清华大学&quot;, &quot;city&quot;:&quot;北京&quot; &#125;&#125; JSON 数据转换为实现浏览器与控制器类之间的 JSON 数据交互，Spring MVC 提供了 MappingJackson2HttpMessageConverter 实现类默认处理 JSON 格式请求响应。该实现类利用 Jackson 开源包读写 JSON 数据，将 Java 对象转换为 JSON 对象和 XML 文档，同时也可以将 JSON 对象和 XML 文档转换为 Java 对象。 在使用注解开发时需要用到两个重要的 JSON 格式转换注解，分别是 @RequestBody 和 @ResponseBody。 @RequestBody：用于将请求体中的数据绑定到方法的形参中，该注解应用在方法的形参上。 @ResponseBody：用于直接返回 return 对象，该注解应用在方法上。 需要注意的是，在该处理方法上，除了通过 @RequestMapping 指定请求的 URL，还有一个 @ResponseBody 注解。该注解的作用是将标注该注解的处理方法的返回结果直接写入 HTTP Response Body（Response 对象的 body 数据区）中。一般情况下，@ResponseBody 都会在异步获取数据时使用，被其标注的处理方法返回的数据都将输出到响应流中，客户端获取并显示数据。 各个JSON技术比较早期 JSON 的组装和解析都是通过手动编写代码来实现的，这种方式效率不高，所以后来有许多的关于组装和解析 JSON 格式信息的工具类出现，如 json-lib、Jackson、Gson 和 FastJson 等，可以解决 JSON 交互的开发效率。 1）json-libjson-lib 最早也是应用广泛的 JSON 解析工具，缺点是依赖很多的第三方包，如 commons-beanutils.jar、commons-collections-3.2.jar、commons-lang-2.6.jar、commons-logging-1.1.1.jar、ezmorph-1.0.6.jar 等。 对于复杂类型的转换，json-lib 在将 JSON 转换成 Bean 时还有缺陷，比如一个类里包含另一个类的 List 或者 Map 集合，json-lib 从 JSON 到 Bean 的转换就会出现问题。 所以 json-lib 在功能和性能上面都不能满足现在互联网化的需求。 2）开源的Jackson开源的 Jackson 是 Spring MVC 内置的 JSON 转换工具。相比 json-lib 框架，Jackson 所依赖 jar 文件较少，简单易用并且性能也要相对高些。并且 Jackson 社区相对比较活跃，更新速度也比较快。 但是 Jackson 对于复杂类型的 JSON 转换 Bean 会出现问题，一些集合 Map、List 的转换出现问题。而 Jackson 对于复杂类型的 Bean 转换 JSON，转换的 JSON 格式不是标准的 JSON 格式。 3）Google的GsonGson 是目前功能最全的 JSON 解析神器，Gson 当初是应 Google 公司内部需求由 Google 自行研发。自从在 2008 年 5 月公开发布第一版后，Gson 就已经被许多公司或用户应用。 Gson 主要提供了 toJson 与 fromJson 两个转换函数，不需要依赖其它的 jar 文件，就能直接在 JDK 上运行。在使用这两个函数转换之前，需要先创建好对象的类型以及其成员才能成功的将 JSON 字符串转换为相对应的对象。 类里面只要有 get 和 set 方法，Gson 完全可以将复杂类型的 JSON 到 Bean 或 Bean 到 JSON 的转换，是 JSON 解析的神器。Gson 在功能上面无可挑剔，但性能比 FastJson 有所差距。 4）阿里巴巴的FastJsonFastJson 是用 Java 语言编写的高性能 JSON 处理器，由阿里巴巴公司开发。 FastJson 不需要依赖其它的 jar 文件，就能直接在 JDK 上运行。 FastJson 在复杂类型的 Bean 转换 JSON 上会出现一些问题，可能会出现引用的类型，导致 JSON 转换出错，需要制定引用。 FastJson 采用独创的算法，将 parse 的速度提升到极致，超过所有 JSON 库。 综上 4 种 JSON 技术的比较，在项目选型的时候可以使用 Google 的 Gson 和阿里巴巴的 FastJson 两种并行使用，如果只是功能要求，没有性能要求，可以使用Google 的 Gson。如果有性能上面的要求可以使用 Gson 将 Bean 转换 JSON 确保数据的正确，使用 FastJson 将 JSON 转换 Bean。 示例本节示例基于阿里巴巴提供的 FastJson。下面结合具体需求演示 Spring MVC 如何处理 JSON 格式数据。 1. 导入jar文件Maven 项目在 pom.xml 文件中添加以下依赖。 123456&lt;!-- fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; 2. 配置Spring MVC核心配置文件在 springmvc-servlet.xml 中添加以下代码。 1234567891011121314151617181920212223242526&lt;mvc:annotation-driven&gt;&lt;!--配置@ResponseBody由fastjson解析 --&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot; /&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;mvc:default-servlet-handler /&gt;&lt;bean id=&quot;fastJsonpResponseBodyAdvice&quot; class=&quot;com.alibaba.fastjson.support.spring.FastJsonpResponseBodyAdvice&quot;&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;callback&lt;/value&gt; &lt;value&gt;jsonp&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- annotation-driven用于简化开发的配置，注解DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter --&gt;&lt;!-- 使用resources过滤掉不需要dispatcherservlet的资源（即静态资源，例如css、js、html、images）。 在使用resources时必须使用annotation-driven，否则resources元素会阻止任意控制器被调用 --&gt;&lt;!-- 允许js目录下的所有文件可见 --&gt;&lt;mvc:resources location=&quot;/&quot; mapping=&quot;/**&quot; /&gt; 3. 创建POJO类创建 User 类，代码如下。 123456public class User &#123; private String name; private String password; private Integer age; /**省略setter和getter方法*/&#125; 4. 创建JSP页面创建 index.jsp 页面测试 JSON 数据交互，代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;测试JSON交互&lt;/title&gt;&lt;script type=&quot;text/javaScript&quot; src=&quot;$&#123;pageContext.request.contextPath &#125;/js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; /&gt; &lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;testJson()&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;script type=&quot;text/javaScript&quot;&gt; function testJson() &#123; var name = $(&quot;#name&quot;).val(); var password = $(&quot;#password&quot;).val(); var age = $(&quot;#age&quot;).val(); $.ajax(&#123; //请求路径 url : &quot;$&#123;pageContext.request.contextPath&#125;/testJson&quot;, //请求类型 type : &quot;post&quot;, //data表示发送的数据 data : JSON.stringify(&#123; name : name, password : password, age : age &#125;), //定义发送请求的数据格式为JSON字符串 contentType : &quot;application/json;charset=utf-8&quot;, //定义回调响应的数据格式为JSON字符串，该属性可以省略 dataType : &quot;json&quot;, //成功响应的结果 success : function(data) &#123; if (data != null) &#123; alert(&quot;输入的用户名：&quot; + data.name + &quot;，密码：&quot; + data.password + &quot;， 年龄：&quot; + data.age); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 由于在 index.jsp 中使用的是 JQuery 的 AJAX 进行的 JSON 的数据提交和响应，所以还需要引入 jquery.js 文件。这里我们引入的是 webapp 目录下的 js 文件夹中的 jquery-3.2.1.min.js。 5. 创建控制器在 UserController 中添加以下代码。 1234567891011/*** 接收页面请求的JSON参数，并返回JSON格式的结果*/@RequestMapping(&quot;/testJson&quot;)@ResponseBodypublic User testJson(@RequestBody User user) &#123; // 打印接收的 JSON数据 System.out.println(&quot;name=&quot; + user.getName() + &quot;,password=&quot; + user.getPassword() + &quot;,age=&quot; + user.getAge()); // 返回JSON格式的响应 return user;&#125; 在上述控制器类中编写了接收和响应 JSON 格式数据的 testJson 方法，方法中的 @RequestBody 注解用于将前端请求体中的 JSON 格式数据绑定到形参 user 上，@ResponseBody 注解用于直接返回 Person 对象（当返回 POJO 对象时默认转换为 JSON 格式数据进行响应）。 6. 测试JSON数据交互访问地址：http://localhost:8080/springmvcDemo2/index.jsp Spring MVC拦截器（Interceptor）在系统中，经常需要在处理用户请求之前和之后执行一些行为，例如检测用户的权限，或者将请求的信息记录到日志中，即平时所说的“权限检测”及“日志记录”。当然不仅仅这些，所以需要一种机制，拦截用户的请求，在请求的前后添加处理逻辑。 Spring MVC 提供了 Interceptor 拦截器机制，用于请求的预处理和后处理。 在开发一个网站时可能有这样的需求：某些页面只希望几个特定的用户浏览。对于这样的访问权限控制，应该如何实现呢？拦截器就可以实现上述需求。在 Struts2 框架中，拦截器是其重要的组成部分，Spring MVC 框架也提供了拦截器功能。 Spring MVC 的拦截器（Interceptor）与 Java Servlet 的过滤器（Filter）类似，它主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上。 拦截器的定义在 Spring MVC 框架中定义一个拦截器需要对拦截器进行定义和配置，主要有以下 2 种方式。 通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类（例如 HandlerInterceptorAdapter）来定义； 通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义。 本节以实现 HandlerInterceptor 接口的定义方式为例讲解自定义拦截器的使用方法。示例代码如下。 1234567891011121314151617181920public class TestInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion方法在控制器的处理请求方法执行完成后执行，即视图渲染结束之后执行&quot;); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle方法在控制器的处理请求方法调用之后，解析视图之前执行&quot;); &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle方法在控制器的处理请求方法调用之前执行&quot;); return false; &#125;&#125; 上述拦截器的定义中实现了 HandlerInterceptor 接口，并实现了接口中的 3 个方法，说明如下。 preHandle( )：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。 postHandle( )：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。 afterCompletion( )：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。 拦截器的配置让自定义的拦截器生效需要在 Spring MVC 的配置文件中进行配置，配置示例代码如下： 12345678910111213141516171819&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!-- 配置一个全局拦截器，拦截所有请求 --&gt; &lt;bean class=&quot;net.biancheng.interceptor.TestInterceptor&quot; /&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器作用的路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;!-- 配置不需要拦截作用的路径 --&gt; &lt;mvc:exclude-mapping path=&quot;&quot; /&gt; &lt;!-- 定义&lt;mvc:interceptor&gt;元素中，表示匹配指定路径的请求才进行拦截 --&gt; &lt;bean class=&quot;net.biancheng.interceptor.Interceptor1&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器作用的路径 --&gt; &lt;mvc:mapping path=&quot;/gotoTest&quot; /&gt; &lt;!-- 定义在&lt;mvc:interceptor&gt;元素中，表示匹配指定路径的请求才进行拦截 --&gt; &lt;bean class=&quot;net.biancheng.interceptor.Interceptor2&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 在上述示例代码中，元素说明如下。 &lt;mvc:interceptors&gt;：该元素用于配置一组拦截器。 &lt;bean&gt;：该元素是 &lt;mvc:interceptors&gt; 的子元素，用于定义全局拦截器，即拦截所有的请求。 &lt;mvc:interceptor&gt;：该元素用于定义指定路径的拦截器。 &lt;mvc:mapping&gt;：该元素是 &lt;mvc:interceptor&gt; 的子元素，用于配置拦截器作用的路径，该路径在其属性 path 中定义。path 的属性值为/**时，表示拦截所有路径，值为/gotoTest时，表示拦截所有以/gotoTest结尾的路径。如果在请求路径中包含不需要拦截的内容，可以通过 &lt;mvc:exclude-mapping&gt; 子元素进行配置。 需要注意的是，&lt;mvc:interceptor&gt; 元素的子元素必须按照 &lt;mvc:mapping…&#x2F;&gt;、&lt;mvc:exclude-mapping…&#x2F;&gt;、&lt;bean…&#x2F;&gt; 的顺序配置。 示例下面通过拦截器来完成一个用户登录权限验证的 Web 应用，具体要求如下：只有成功登录的用户才能访问系统的主页面 main.jsp，如果没有成功登录而直接访问主页面，则拦截器将请求拦截，并转发到登录页面 login.jsp。当成功登录的用户在系统主页面中单击“退出”链接时回到登录页面。 1）创建 POJO 类创建 User 类，代码如下。 12345public class User &#123; private String name; private String pwd; /**省略setter和getter方法*/&#125; 2）创建控制器类创建控制器类 UserController，代码如下。 1234567891011121314151617181920212223242526272829303132@Controllerpublic class UserController &#123; // 登录页面初始化 @RequestMapping(&quot;/toLogin&quot;) public String initLogin() &#123; return &quot;login&quot;; &#125; // 处理登录功能 @RequestMapping(&quot;/login&quot;) public String login(User user, Model model, HttpSession session) &#123; System.out.println(user.getName()); if (&quot;bianchengbang&quot;.equals(user.getName()) &amp;&amp; &quot;123456&quot;.equals(user.getPwd())) &#123; // 登录成功，将用户信息保存到session对象中 session.setAttribute(&quot;user&quot;, user); // 重定向到主页面的跳转方法 return &quot;redirect:main&quot;; &#125; model.addAttribute(&quot;msg&quot;, &quot;用户名或密码错误，请重新登录！ &quot;); return &quot;login&quot;; &#125; // 跳转到主页面 @RequestMapping(&quot;/main&quot;) public String toMain() &#123; return &quot;main&quot;; &#125; // 退出登录 @RequestMapping(&quot;/logout&quot;) public String logout(HttpSession session) &#123; // 清除 session session.invalidate(); return &quot;login&quot;; &#125;&#125; 3）创建拦截器类创建拦截器类 LoginInterceptor，代码如下。 12345678910111213141516171819202122232425262728293031public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 获取请求的URL String url = request.getRequestURI(); // login.jsp或登录请求放行，不拦截 if (url.indexOf(&quot;/toLogin&quot;) &gt;= 0 || url.indexOf(&quot;/login&quot;) &gt;= 0) &#123; return true; &#125; // 获取 session HttpSession session = request.getSession(); Object obj = session.getAttribute(&quot;user&quot;); if (obj != null) return true; // 没有登录且不是登录页面，转发到登录页面，并给出提示错误信息 request.setAttribute(&quot;msg&quot;, &quot;还没登录，请先登录！&quot;); request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); return false; &#125; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 4）配置拦截器在 WEB-INF 目录下创建配置文件 springmvc-servlet.xml 和 web.xml。web.xml 的代码和 以前一样，这里不再赘述。在 springmvc-servlet.xml 文件中配置拦截器 LoginInterceptor，代码如下。 12345678&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器作用的路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;bean class=&quot;net.biancheng.interceptor.LoginInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 5）创建视图 JSP 页面在 WEB-INF 目录下创建文件夹 jsp，并在该文件夹中创建 login.jsp 和 main.jsp。 login.jsp 的代码如下： 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg &#125; &lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; main.jsp 的代码如下： 12345678910111213&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 欢迎 $&#123;user.name &#125;，登录编程帮！&lt;br /&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/logout&quot;&gt;退出&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 6）发布并测试应用首先将 springmvcDemo2 应用发布到 Tomcat 服务器并启动 Tomcat 服务器，然后通过地址“http://localhost:8080/springmvcDemo2/main”测试应用 Spring MVC数据校验一般情况下，用户的输入是随意的，为了保证数据的合法性，数据验证是所有 Web 应用必须处理的问题。 Spring MVC 有以下两种方法可以验证输入： 利用 Spring 自带的验证框架 利用 JSR 303 实现 数据验证分为客户端验证和服务器端验证，客户端验证主要是过滤正常用户的误操作，通过 JavaScript 代码完成。服务器端验证是整个应用阻止非法数据的最后防线，通过在应用中编程实现。 本节使用 JSR 303 实现服务器端的数据验证。 JSR 303 是 Java 为 Bean 数据合法性校验所提供的标准框架。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。 JSR 303 不需要编写验证器，它定义了一套可标注在成员变量、属性方法上的校验注解，如下表所示。 名称 说明 @Null 被标注的元素必须为 null @NotNull 被标注的元素必须不为 null @AssertTrue 被标注的元素必须为 true @AssertFalse 被标注的元素必须为 false @Min(value) 被标注的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被标注的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMax(value) 被标注的元素必须是一个数字，其值必须大于等于指定的最大值 @DecimalMin(value) 被标注的元素必须是一个数字，其值必须小于等于指定的最小值 @size 被标注的元素的大小必须在指定的范围内 @Digits（integer，fraction） 被标注的元素必须是一个数字，其值必须在可接受的范围内；integer 指定整数精度，fraction 指定小数精度 @Past 被标注的元素必须是一个过去的日期 @Future 被标注的元素必须是一个将来的日期 @Pattern(value) 被标注的元素必须符合指定的正则表达式 Spring MVC 支持 JSR 303 标准的校验框架，Spring 的 DataBinder 在进行数据绑定时，可同时调用校验框架来完成数据校验工作，非常简单方便。在 Spring MVC 中，可以直接通过注解驱动的方式来进行数据校验。 Spring 本身没有提供 JSR 303 的实现，Hibernate Validator 实现了 JSR 303，所以必须在项目中加入来自 Hibernate Validator 库的 jar 文件。本节使用版本为 hibernate-validator-5.1.0.Final-dist.zip，复制其中的 3 个 jar 文件即可，Spring 将会自动加载并装配。 hibernate-validator-5.1.0.Final.jar jboss-logging-3.1.0.CR2.jar validation-api-1.0.0.GA.jar 示例1. 导入依赖pom.xml 文件中添加以下代码。 12345678910111213141516&lt;!-- 数据校验 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.1.0.CR2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt;&lt;/dependency&gt; 2. 创建实体类创建 User 实体类，代码如下。 12345678910public class User &#123; @NotNull(message = &quot;用户id不能为空&quot;) private Integer id; @NotNull @Length(min = 2, max = 8, message = &quot;用户名不能少于2位大于8位&quot;) private String name; @Email(regexp = &quot;[a-zA-Z0-9]+@[a-zA-Z0-9]+\\\\.[a-zA-Z0-9]&quot;, message = &quot;邮箱格式不正确&quot;) private String email; /** 省略setter和getter方法*/&#125; 3. 创建JSP页面创建 addUser.jsp，代码如下。 1234567891011121314151617181920&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/validate&quot; method=&quot;post&quot;&gt; 用户id：&lt;input type=&quot;text&quot; name=&quot;id&quot; /&gt; &lt;br&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4. 创建控制器创建 UserController 控制器类，代码如下。 1234567891011121314151617181920@Controllerpublic class UserController &#123; @RequestMapping(&quot;/validate&quot;) public String validate(@Valid User user, BindingResult result) &#123; // 如果有异常信息 if (result.hasErrors()) &#123; // 获取异常信息对象 List&lt;ObjectError&gt; errors = result.getAllErrors(); // 将异常信息输出 for (ObjectError error : errors) &#123; System.out.println(error.getDefaultMessage()); &#125; &#125; return &quot;index&quot;; &#125; @RequestMapping(value = &quot;/addUser&quot;) public String add() &#123; return &quot;addUser&quot;; &#125;&#125; 5. 运行测试访问地址：http://localhost:8080/springmvcDemo2/addUser Spring MVC异常处理在 Spring MVC 应用的开发中，不管是操作底层数据库，还是业务层或控制层，都会不可避免地遇到各种可预知的、不可预知的异常。我们需要捕捉处理异常，才能保证程序不被终止。 Spring MVC 有以下 3 种处理异常的方式： 使用 Spring MVC 提供的简单异常处理器 SimpleMappingExceptionResolver。 实现 Spring 的异常处理接口 HandlerExceptionResolver，自定义自己的异常处理器。 使用 @ExceptionHandler 注解实现异常处理 1. @ExceptionHandler局部异常处理仅能处理指定 Controller 中的异常。 示例 1：下面使用 @ExceptionHandler 注解实现。定义一个处理过程中可能会存在异常情况的 testExceptionHandle 方法。 12345@RequestMapping(&quot;/testExceptionHandle&quot;)public String testExceptionHandle(@RequestParam(&quot;i&quot;) Integer i) &#123; System.out.println(10 / i); return &quot;success&quot;;&#125; 显然，当 i&#x3D;0 时会产生算术运算异常。 下面在同一个类中定义处理异常的方法。 123456@ExceptionHandler(&#123; ArithmeticException.class &#125;)public String testArithmeticException(Exception e) &#123; System.out.println(&quot;打印错误信息 ===&gt; ArithmeticException:&quot; + e); // 跳转到指定页面 return &quot;error&quot;;&#125; 注意：该注解不是加在产生异常的方法上，而是加在处理异常的方法上。 异常页面 error.jsp 代码如下。 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 发生算术运算异常，请重新输出数据！&lt;/body&gt;&lt;/html&gt; 访问地址：http://localhost:8080/springmvcDemo2/testExceptionHandle?i=0，页面跳转到 error.jsp 页面 控制器输出结果如下。 1打印错误信息 ===&gt; ArithmeticException:java.lang.ArithmeticException: / by zero @ExceptionHandler 注解定义的方法优先级问题：例如发生的是 NullPointerException，但是声明的异常有 RuntimeException 和 Exception，这时候会根据异常的最近继承关系找到继承深度最浅的那个@ExceptionHandler 注解方法，即标记了 RuntimeException 的方法。 被 @ExceptionHandler 标记为异常处理方法，不能在方法中设置别的形参。但是可以使用 ModelAndView 向前台传递数据。 使用局部异常处理，仅能处理某个 Controller 中的异常，若需要对所有异常进行统一处理，可使用以下两种方法。 2. HandlerExceptionResolverSpring MVC 通过 HandlerExceptionResolver 处理程序异常，包括处理器异常、数据绑定异常以及控制器执行时发生的异常。HandlerExceptionResolver 仅有一个接口方法，源码如下。 12345public interface HandlerExceptionResolver &#123; @Nullable ModelAndView resolveException( HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);&#125; 发生异常时，Spring MVC 会调用 resolveException() 方法，并转到 ModelAndView 对应的视图中，返回一个异常报告页面反馈给用户。 示例 2：创建一个 HandlerExceptionResolver 接口的实现类 MyExceptionHandler，代码如下。 1234567891011public class MyExceptionHandler implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) &#123; Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;(); // 根据不同错误转向不同页面（统一处理），即异常与View的对应关系 if (arg3 instanceof ArithmeticException) &#123; return new ModelAndView(&quot;error&quot;, model); &#125; return new ModelAndView(&quot;error-2&quot;, model); &#125;&#125; 在 springmvc-servlet.xml 文件中添加以下代码。 12&lt;!--托管MyExceptionHandler--&gt;&lt;bean class=&quot;net.biancheng.exception.MyExceptionHandler&quot;/&gt; 再次访问 http://localhost:8080/springmvcDemo2/testExceptionHandle?i=0，页面跳转到 error.jsp 页面 3. SimpleMappingExceptionResolver全局异常处理可使用 SimpleMappingExceptionResolver 来实现。它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常。 示例 3：在 springmvc-servlet.xml 中配置全局异常，代码如下。 12345678910111213&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 定义默认的异常处理页面，当该异常类型注册时使用 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;&gt;&lt;/property&gt; &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常页名作为值 --&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;!-- 在这里还可以继续扩展对不同异常类型的处理 --&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 再次访问 http://localhost:8080/springmvcDemo2/testExceptionHandle?i=0，页面跳转到 error.jsp 页面 Spring MVC REST风格REST（Representational State Transfer）即表述性转移，是目前最流行的一种软件架构风格。它结构清晰、易于理解、有较好的扩展性。 REST 概念较为复杂，我们不过多解释，大家简单了解 Spring MVC 的 REST 风格的简单使用即可。 Spring REST 风格可以简单理解为：使用 URL 表示资源时，每个资源都用一个独一无二的 URL 来表示，并使用 HTTP 方法表示操作，即准确描述服务器对资源的处理动作（GET、POST、PUT、DELETE），实现资源的增删改查。 GET：表示获取资源 POST：表示新建资源 PUT：表示更新资源 DELETE：表示删除资源 下面举例说明 REST 风格的 URL 与传统 URL 的区别。 123/userview.html?id=12 VS /user/view/12/userdelete.html?id=12 VS /user/delete/12/usermodify.html?id=12 VS /user/modify/12 我们发现 REST 风格的 URL 中最明显的就是参数不再使用“?”传递。这种风格的 URL 可读性更好，使得项目架构清晰，最关键的是 Spring MVC 也提供对这种风格的支持。 但是也有弊端，对于国内项目，URL 参数有时会传递中文，而中文乱码是一个令人头疼的问题，所以我们应该根据实际情况进行灵活处理。很多网站都是传统 URL 风格与 REST 风格混搭使用。 示例由于 HTTP 不支持 PUT 和 DELETE 请求，所以需要将 DELETE 和 PUT 请求转换成 POST 请求，在 web.xml 中配置过滤器 HiddenHttpMethodFilter。 123456789&lt;!-- HiddenHttpMethodFilter过滤器可以将POST请求转化为put请求和delete请求! --&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 新建 rest.jsp 代码如下。 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;REST风格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;发送GET请求&lt;/h4&gt; &lt;a href=&quot; user/1&quot;&gt;GET&lt;/a&gt; &lt;h4&gt;发送POST请求&lt;/h4&gt; &lt;form action=&quot;user/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;POST&quot; /&gt; &lt;/form&gt; &lt;!-- 发送PUT和DELETE请求时，需要添加一个隐藏域 --&gt; &lt;h4&gt;发送PUT请求&lt;/h4&gt; &lt;form action=&quot; user/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;PUT&quot; /&gt; &lt;/form&gt; &lt;h4&gt;发送DELETE请求&lt;/h4&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot; /&gt; &lt;form action=&quot; user/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;DELETE&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 下面通过 @RequestMapping 映射请求中的 method 参数实现四种请求方式的调用，UserController 代码如下。 123456789101112131415161718192021222324252627@Controllerpublic class UserController &#123; @RequestMapping(&quot;/torest&quot;) public String torest() &#123; return &quot;rest&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET) public String hello(@PathVariable Integer id) &#123; System.out.println(&quot;test rest get:&quot; + id); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.POST) public String hello() &#123; System.out.println(&quot;test POST:&quot;); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.DELETE) public String helloDelete(@PathVariable Integer id) &#123; System.out.println(&quot;test rest delete:&quot; + id); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.PUT) public String helloPUt(@PathVariable Integer id) &#123; System.out.println(&quot;test rest put:&quot; + id); return &quot;success&quot;; &#125;&#125; 访问地址：http://localhost:8080/springmvcDemo2/torest Spring MVC文件上传Spring MVC 框架的文件上传基于 commons-fileupload 组件，并在该组件上做了进一步的封装，简化了文件上传的代码实现，取消了不同上传组件上的编程差异。 MultipartResolver接口在 Spring MVC 中实现文件上传十分容易，它为文件上传提供了直接支持，即 MultpartiResolver 接口。MultipartResolver 用于处理上传请求，将上传请求包装成可以直接获取文件的数据，从而方便操作。 MultpartiResolver 接口有以下两个实现类： StandardServletMultipartResolver：使用了 Servlet 3.0 标准的上传方式。 CommonsMultipartResolver：使用了 Apache 的 commons-fileupload 来完成具体的上传操作。 MultpartiResolver 接口具有以下方法。 名称 作用 byte[] getBytes() 以字节数组的形式返回文件的内容 String getContentType() 返回文件的内容类型 InputStream getInputStream() 返回一个InputStream，从中读取文件的内容 String getName() 返回请求参数的名称 String getOriginalFillename() 返回客户端提交的原始文件名称 long getSize() 返回文件的大小，单位为字节 boolean isEmpty() 判断被上传文件是否为空 void transferTo(File destination) 将上传文件保存到目标目录下 下面我们使用 CommonsMultipartResolver 来完成文件上传，分为单文件上传和多文件上传两部分介绍。 单文件上传1. 导入 jar 文件文件上传使用 Apache Commons FileUpload 组件，需要导入 commons-io-2.4.jar 和 commons-fileupload-1.2.2.jar 两个 jar 文件（可在 Apache 官网下载）。 Maven 项目在 pom.xml 文件中添加以下依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt; 2. 配置 MultipartResolver使用 CommonsMultipartReslover 配置 MultipartResolver 解析器，在 springmvc-servlet.xml 中添加代码如下。 123456&lt;!-- 配置MultipartResolver，用于上传文件，使用spring的CommonsMultipartResolver --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;&lt;/bean&gt; defaultEncoding：请求的编码格式，默认为 ISO-8859-1，此处设置为 UTF-8（注：defaultEncoding 必须和 JSP 中的 pageEncoding 一致，以便正确读取表单的内容）。 maxUploadSize：上传文件大小上限，单位为字节。 3. 编写文件上传表单页面负责文件上传表单的编码类型必须是“multipart&#x2F;form-data”类型。 fleUpload.jsp 代码如下。 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/fileupload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;br&gt; 文件描述：&lt;input type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 基于表单的文件上传需要使用 enctype 属性，并将它的值设置为 multipart&#x2F;form-data，同时将表单的提交方式设置为 post。表单的 enctype 属性指定的是表单数据的编码方式，该属性有以下 3 个值。 application&#x2F;x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的 value 属性值。 multipart&#x2F;form-data：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里。 text&#x2F;plain：该编码方式只有当表单的 action 属性为“mailto：”URL 的形式时才使用，主要适用于直接通过表单发送邮件的方式。 由上面 3 个属性的解释可知，在基于表单上传文件时 enctype 的属性值应为 multipart&#x2F;form-data。 4. 创建POJO类创建 FileDomain 类，在该 POJO 类中声明一个 MultipartFile 类型的属性封装被上传的文件信息，属性名与文件选择页面 filleUpload.jsp 中的 file 类型的表单参数名 myfile 相同，代码如下。 12345public class FileDomain &#123; private String description; private MultipartFile myfile; /** 省略setter和getter参数*/&#125; 5. 编写控制器创建 FileUploadController 控制类，具体代码如下。 12345678910111213141516171819202122232425262728293031@Controllerpublic class FileUploadController &#123; // 得到一个用来记录日志的对象，这样在打印信息时能够标记打印的是哪个类的信息 private static final Log logger = LogFactory.getLog(FileUploadController.class); @RequestMapping(&quot;getFileUpload&quot;) public String getFileUpload() &#123; return &quot;fileUpload&quot;; &#125; // 单文件上传 @RequestMapping(&quot;/fileupload&quot;) public String oneFileUpload(@ModelAttribute FileDomain fileDomain, HttpServletRequest request) &#123; /* * 文件上传到服务器的位置“/uploadfiles”,该位置是指 workspace\\.metadata\\.plugins\\org.eclipse * .wst.server.core\\tmp0\\wtpwebapps, 发布后使用 */ String realpath = request.getServletContext().getRealPath(&quot;uploadfiles&quot;); String fileName = fileDomain.getMyfile().getOriginalFilename(); File targetFile = new File(realpath, fileName); if (!targetFile.exists()) &#123; targetFile.mkdirs(); &#125; // 上传 try &#123; fileDomain.getMyfile().transferTo(targetFile); logger.info(&quot;成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return &quot;showFile&quot;; &#125;&#125; 6. 创建成功显示页面showFile.jsp 代码如下。 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文件描述：$&#123;fileDomain.description &#125; &lt;br&gt; &lt;!-- fileDomain.getMyFile().getOriginalFilename()--&gt; 文件名称：$&#123;fileDomain.myfile.originalFilename &#125;&lt;/body&gt;&lt;/html&gt; 7. 测试文件上传访问地址：http://localhost:8080/springmvcDemo2/getFileUpload 多文件上传在以上代码的基础上，实现 Spring MVC 多文件上传。 1. 创建 JSP 页面创建 multiFiles.jsp 页面，在该页面中使用表单上传多个文件。代码如下。 12345678910111213141516171819202122&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;fm&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;多文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/multifile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件1：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;br&gt; 文件描述1：&lt;input type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;br&gt; 选择文件2：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;br&gt; 文件描述2：&lt;input type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;br&gt; 选择文件3：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;br&gt; 文件描述3：&lt;input type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2. 创建POJO类创建 MultiFileDomain 类，上传多文件时用于封装文件信息，代码如下。 123456789101112public class MultiFileDomain &#123; private List&lt;String&gt; description; private List&lt;MultipartFile&gt; myfile; public List&lt;String&gt; getDescription() &#123;return description;&#125; public void setDescription(List&lt;String&gt; description) &#123; this.description = description; &#125; public List&lt;MultipartFile&gt; getMyfile() &#123;return myfile;&#125; public void setMyfile(List&lt;MultipartFile&gt; myfile) &#123; this.myfile = myfile; &#125;&#125; 3. 添加多文件上传处理方法在 FileUploadController 控制器类中添加多文件上传处理方法 multifile，具体代码如下。 123456789101112131415161718192021222324252627@RequestMapping(&quot;/getmultiFile&quot;)public String getmultiFile() &#123; return &quot;multiFiles&quot;;&#125;// 多文件上传@RequestMapping(&quot;/multifile&quot;)public String multiFileUpload(@ModelAttribute MultiFileDomain multiFileDomain, HttpServletRequest request) &#123; String realpath = request.getServletContext().getRealPath(&quot;uploadfiles&quot;); File targetDir = new File(realpath); if (!targetDir.exists()) &#123; targetDir.mkdirs(); &#125; List&lt;MultipartFile&gt; files = multiFileDomain.getMyfile(); System.out.println(&quot;files&quot;+files); for (int i = 0; i &lt; files.size(); i++) &#123; MultipartFile file = files.get(i); String fileName = file.getOriginalFilename(); File targetFile = new File(realpath, fileName); // 上传 try &#123; file.transferTo(targetFile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return &quot;showMulti&quot;;&#125; 4. 创建成功显示页面创建多文件上传成功显示页面 showMulti.jsp，具体代码如下： 123456789101112131415161718192021222324252627&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;多文件上传显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;详情&lt;/td&gt; &lt;td&gt;文件名&lt;/td&gt; &lt;/tr&gt; &lt;!-- 同时取两个数组的元素 --&gt; &lt;c:forEach items=&quot;$&#123;multiFileDomain.description&#125;&quot; var=&quot;description&quot; varStatus=&quot;loop&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;description&#125;&lt;/td&gt; &lt;td&gt;$&#123;multiFileDomain.myfile[loop.count-1].originalFilename&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;!-- fileDomain.getMyfile().getOriginalFilename() --&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5. 测试文件上传访问地址：http://localhost:8080/springmvcDemo2/getmultiFile Spring MVC文件下载文件下载的实现方法文件下载有以下两种实现方法： 通过超链接实现下载：实现简单，但暴露了下载文件的真实位置，并且只能下载 Web 应用程序所在目录下的文件，WEB-INF 目录除外。 利用程序编码实现下载：增强安全访问控制，可以下载除 Web 应用程序所在目录以外的文件，也可以将文件保存到数据库中。利用程序编码实现下载需要设置以下两个报头： Web 服务器需要告诉浏览器其所输出内容的类型不是普通文本文件或 HTML 文件，而是一个要保存到本地的下载文件，这需要设置 Content-Type 的值为 application&#x2F;x-msdownload。 Web 服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置 Content-Disposition 报头。该报头指定了接收程序处理数据内容的方式，在 HTTP 应用中只有 attachment 是标准方式，attachment 表示要求用户干预。在 attachment 后面还可以指定 filename 参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。 设置报头的示例如下： 12response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;);response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+filename); 程序编码文件下载可分为两个步骤： 在客户端使用一个文件下载超链接，链接指向后台下载文件的方法以及文件名。 在控制器类中，提供文件下载方法进行下载。 示例要求从上传文件的目录（workspace.metadata.plugins\\org.eclipse.wst.server.core\\tmp0\\wtpwebapps\\springMVCDemo2\\uploadfiles）中下载文件，具体开发步骤如下。 1. 编写控制器类首先编写控制器类 FileDownController，在该类中有 3 个方法，即 show、down 和 toUTF8String。其中， show 方法获取被下载的文件名称； down 方法执行下载功能； toUTF8String 方法是下载保存时中文文件名的字符编码转换方法。 FileDownController 类的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Controllerpublic class FileDownController &#123; // 得到一个用来记录日志的对象，在打印时标记打印的是哪个类的信息 private static final Log logger = LogFactory .getLog(FileDownController.class); // 显示要下载的文件 @RequestMapping(&quot;showDownFiles&quot;) public String show(HttpServletRequest request, Model model) &#123; // 从 workspace\\.metadata\\.plugins\\org.eclipse.wst.server.core\\ // tmp0\\wtpwebapps\\springMVCDemo11\\下载 String realpath = request.getServletContext() .getRealPath(&quot;uploadfiles&quot;); File dir = new File(realpath); File files[] = dir.listFiles(); // 获取该目录下的所有文件名 ArrayList&lt;String&gt; fileName = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; files.length; i++) &#123; fileName.add(files[i].getName()); &#125; model.addAttribute(&quot;files&quot;, fileName); return &quot;showDownFiles&quot;; &#125; // 执行下载 @RequestMapping(&quot;down&quot;) public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response) &#123; String aFilePath = null; // 要下载的文件路径 FileInputStream in = null; // 输入流 ServletOutputStream out = null; // 输出流 try &#123; // 从workspace\\.metadata\\.plugins\\org.eclipse.wst.server.core\\ // tmp0\\wtpwebapps下载 aFilePath = request.getServletContext().getRealPath(&quot;uploadfiles&quot;); // 设置下载文件使用的报头 response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + toUTF8String(filename)); // 读入文件 in = new FileInputStream(aFilePath + &quot;\\\\&quot; + filename); // 得到响应对象的输出流，用于向客户端输出二进制数据 out = response.getOutputStream(); out.flush(); int aRead = 0; byte b[] = new byte[1024]; while ((aRead = in.read(b)) != -1 &amp; in != null) &#123; out.write(b, 0, aRead); &#125; out.flush(); in.close(); out.close(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; logger.info(&quot;下载成功&quot;); return null; &#125; // 下载保存时中文文件名的字符编码转换方法 public String toUTF8String(String str) &#123; StringBuffer sb = new StringBuffer(); int len = str.length(); for (int i = 0; i &lt; len; i++) &#123; // 取出字符中的每个字符 char c = str.charAt(i); // Unicode码值为0~255时，不做处理 if (c &gt;= 0 &amp;&amp; c &lt;= 255) &#123; sb.append(c); &#125; else &#123; // 转换 UTF-8 编码 byte b[]; try &#123; b = Character.toString(c).getBytes(&quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); b = null; &#125; // 转换为%HH的字符串形式 for (int j = 0; j &lt; b.length; j++) &#123; int k = b[j]; if (k &lt; 0) &#123; k &amp;= 255; &#125; sb.append(&quot;%&quot; + Integer.toHexString(k).toUpperCase()); &#125; &#125; &#125; return sb.toString(); &#125;&#125; 1234567891011121314151617@RequestMapping(value=&quot;/download&quot;) public ResponseEntity&lt;byte[]&gt; download(HttpServletRequest request, @RequestParam(&quot;filename&quot;) String filename, Model model)throws Exception &#123; //下载文件路径 String path = request.getServletContext().getRealPath(&quot;/images/&quot;); File file = new File(path + File.separator + filename); HttpHeaders headers = new HttpHeaders(); //下载显示的文件名，解决中文名称乱码问题 String downloadFielName = new String(filename.getBytes(&quot;UTF-8&quot;),&quot;iso-8859-1&quot;); //通知浏览器以attachment（下载方式）打开图片 headers.setContentDispositionFormData(&quot;attachment&quot;, downloadFielName); //application/octet-stream ： 二进制流数据（最常见的文件下载）。 headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED); &#125; 1headers.add(&quot;Content-Disposition&quot;, &quot;attchement;filename=&quot; + URLEncoder.encode(file.getName(), &quot;UTF-8&quot;)); 2. 创建文件列表页面下载文件示例需要一个显示被下载文件的 JSP 页面 showDownFiles.jsp，代码如下： 1234567891011121314151617181920212223&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;被下载的文件名&lt;/td&gt; &lt;/tr&gt; &lt;!--遍历 model中的 files--&gt; &lt;c:forEach items=&quot;$&#123;files&#125;&quot; var=&quot;filename&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/down?filename=$&#123;filename&#125;&quot;&gt;$&#123;filename&#125;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 3. 测试下载功能访问地址：http://localhost:8080/springmvcDemo2/showDownFiles SpringMVC访问静态资源的三种方式如果你的DispatcherServlet拦截 .do这样的URL，就不存在访问不到静态资源的问题。如果你的DispatcherServlet拦截“&#x2F;”，拦截了所有的请求，同时对.js,.jpg的访问也就被拦截了。 方案一：激活Tomcat的defaultServlet来处理静态文件 在web.xml里添加如下配置 123456789101112&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 要配置多个，每种文件配置一个。要写在DispatcherServlet的前面， 让defaultServlet先拦截，这个就不会进入Spring了，我想性能是最好的吧。 12345Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 -- &quot;default&quot;Google App Engine 默认 Servlet的名字 -- &quot;_ah_default&quot;Resin 默认 Servlet的名字 -- &quot;resin-file&quot;WebLogic 默认 Servlet的名字 -- &quot;FileServlet&quot;WebSphere 默认 Servlet的名字 -- &quot;SimpleFileServlet&quot; 方案二： 在spring3.0.4以后版本提供了mvc:resources &lt;mvc:resources&gt; 的使用方法： 12&lt;!--对静态资源文件的访问--&gt;&lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot; /&gt; &#x2F;images &#x2F;**映射到 ResourceHttpRequestHandler 进行处理，location指定静态资源的位置.可以是web application根目录下、jar包里面，这样可以把静态资源压缩到jar包中。cache-period可以使得静态资源进行web cache。 如果出现下面的错误，可能是没有配置 &lt;mvc:annotation-driven &#x2F;&gt; 的原因。报错WARNING: No mapping found for HTTP request with URI [&#x2F;mvc&#x2F;user&#x2F;findUser&#x2F;lisi&#x2F;770] in DispatcherServlet with name ‘springMVC’ 使用 &lt;mvc:resources&#x2F;&gt; 元素,把 mapping 的 URI 注册到 SimpleUrlHandlerMapping的urlMap 中,key 为 mapping 的 URI pattern值,而value为 ResourceHttpRequestHandler,这样就巧妙的把对静态资源的访问由 HandlerMapping 转到ResourceHttpRequestHandler 处理并返回,所以就支持 classpath 目录, jar 包内静态资源的访问.另外需要注意的一点是,不要对 SimpleUrlHandlerMapping 设置 defaultHandler. 因为对 static uri 的 defaultHandler 就是ResourceHttpRequestHandler,否则无法处理static resources request. mapping：映射location：本地资源路径，注意必须是webapp根目录下的路径。两个*，它表示映射resources&#x2F;下所有的URL，包括子路径（即接多个&#x2F;） 陷阱：配置的location一定要是webapp根目录下才行，如果你将资源目录，放置到webapp&#x2F;WEB-INF下面的话，则就会访问失败。这个问题常常会犯。 WEB-INF目录作用WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。当然，你非要放在WEB-INF中，则必须修改resources映射，如： 1&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/js/&quot; /&gt; 方案三 ，使用&lt;mvc:default-servlet-handler&#x2F;&gt; &lt;mvc:default-servlet-handler&#x2F;&gt;会把 “&#x2F;**” url,注册到 SimpleUrlHandlerMapping 的 urlMap 中,把对静态资源的访问由 HandlerMapping 转到 org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler 处理并返回.DefaultServletHttpRequestHandler 使用就是各个 Servlet 容器自己的默认 Servlet. 补充说明：多个HandlerMapping的执行顺序问题：DefaultAnnotationHandlerMapping 的 order 属性值是：0**&lt;mvc:resources&#x2F; &gt;**自动注册的 SimpleUrlHandlerMapping 的 order 属性值是： 2147483646**&lt;mvc:default-servlet-handler&#x2F;&gt;自动注册的 SimpleUrlHandlerMapping 的 order 属性值是：2147483647spring 会先执行 order 值比较小的。当访问一个 a.jpg 图片文件时，先通过 DefaultAnnotationHandlerMapping 来找处理器，一定是找不到的，我们没有叫 a.jpg 的 Action。再按 order 值升序找，由于最后一个 SimpleUrlHandlerMapping 是匹配 “&#x2F;“ 的，所以一定会匹配上，再响应图片。","tags":["Java","Spring","SpringMVC"],"categories":["学习"]},{"title":"Spring","path":"/6b3e1469/","content":"SpringSpring是什么Spring 是分层的 Java SE&#x2F;EE 一站式轻量级开源框架，以 IoC（Inverse of Control，控制反转）和 AOP（Aspect Oriented Programming，面向切面编程）为内核。 Spring 框架具有以下几个特点。1）方便解耦，简化开发Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 管理。 2）方便集成各种优秀框架Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis 等）的直接支持。 3）降低 Java EE API 的使用难度Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低。 4）方便程序的测试Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。 5）AOP 编程的支持Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。 6）声明式事务的支持只需要通过配置就可以完成对事务的管理，而无须手动编程。 Spring体系结构Spring 框架采用分层的理念，根据功能的不同划分成了多个模块，这些模块大体可分为 Data Access&#x2F;Integration（数据访问与集成）、Web、AOP、Aspects、Instrumentation（检测）、Messaging（消息处理）、Core Container（核心容器）和 Test。如下图所示（以下是 Spring Framework 4.x 版本后的系统架构图）。 1. Data Access&#x2F;Integration（数据访问／集成）数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。 JDBC 模块：提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。 ORM 模块：提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。 OXM 模块：提供了一个支持 Object &#x2F;XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。 JMS 模块：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Transactions 事务模块：支持编程和声明式事务管理。 2. Web模块Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Portlet 组件，具体介绍如下。 Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC 容器初始化以及 Web 应用上下文。 Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。 WebSocket 模块：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。 Portlet 模块：提供了在 Portlet 环境中使用 MVC 实现，类似 Web-Servlet 模块的功能。 3. Core Container（Spring的核心容器）Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。 Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。 Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。 Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。 SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。 4. AOP、Aspects、Instrumentation和Messaging在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下： AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。 messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。 5. Test模块Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。 Spring开发环境搭建安装JDK下载Eclipse IDE下载Apache Common Logging API下载SpringSpring 的目录介绍 名称 作用 docs 包含 Spring 的 API 文档和开发规范 libs 包含开发需要的 jar 包和源码包 schema 包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束 Spring 依赖jar包介绍在 libs 目录中，包含了 Spring 框架提供的所有 jar 文件，其中有 4 个 jar 文件是 Spring 框架的基础包，分别对应 Spring 容器的四个模块。 名称 作用 spring-core-x.x.xx.RELEASE.jar 包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。 spring-beans-x.x.xx.RELEASE.jar 所有应用都要用到的，它包含访问配置文件、创建和管理 Bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。 spring-context-x.x.xx.RELEASE.jar Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等 spring-expression-x.x.xx.RELEASE.jar 定义了 Spring 的表达式语言。需要注意的是，在使用 Spring 开发时，除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息 使用 Spring 框架时，只需将 Spring 的 4 个基础包以及 commons-logging-1.2.jar 包复制到项目的 lib 目录，并发布到类路径中即可。 第一个Spring程序1. 创建Java项目2. 添加jar包运行该程序需要以下 3 个文件。您可以选择先导入以下文件，后面根据需求在添加相应的 jar 包，或直接导入所有 Spring 相关 jar 包。 org.springframework.core-5.2.3.RELEASE.jar org.springframework.beans-5.2.3.RELEASE.jar commons.logging-1.2.jar 3. 创建Java类创建 net.biancheng 包，在该包下创建 HelloWorld.java 和 MainApp.java 类。 HelloWorld.java 类的代码如下。 1234567891011public class HelloWorld &#123; private String message; public void setMessage(String message) &#123; this.message = message; &#125; public void getMessage() &#123; System.out.println(&quot;message : &quot; + message); &#125;&#125; MainApp.java 类的代码如下。 1234567public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;); obj.getMessage(); &#125;&#125; 关于以上代码，需要注意以下两点： 创建 ApplicationContext 对象时，我们使用了 ClassPathXmlApplicationContext 类。该类用于加载 Spring 配置文件、创建和初始化所有对象，也就是下面配置文件中提到的 Bean。 ApplicationContext.getBean() 方法用来获取 Bean，该方法返回值类型为 Object，通过强制类型转换为 HelloWorld 的实例对象，根据该对象调用类中的方法。 4. 创建配置文件在 src 目录下创建 Spring 配置文件 Beans.xml，内容如下。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;net.biancheng.HelloWorld&quot;&gt; &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 您也可以将该配置文件命名为其它有效的名称。需要注意的是，该文件名必须与 MainApp.java 中读取的配置文件名称一致。 Beans.xml 用于给不同的 Bean 分配唯一的 ID，并给相应的 Bean 属性赋值。例如，在以上代码中，我们可以在不影响其它类的情况下，给 message 变量赋值。 5. 运行程序运行 MainApp.java，Eclipse IDE 控制台中显示信息如下。 1message : Hello World! 至此，我们就成功创建了第一个 Spring 应用程序。 Spring IoC容器IoC 容器是 Spring 的核心，也可以称为 Spring 容器。Spring 通过 IoC 容器来管理对象的实例化和初始化，以及对象从创建到销毁的整个生命周期。 由 IoC 容器管理的对象称为 Spring Bean，Spring Bean 就是 Java 对象。 Spring 通过读取 XML 或 Java 注解中的信息来获取哪些对象需要实例化。 Spring 提供 2 种不同类型的 IoC 容器，即 BeanFactory 和 ApplicationContext 容器。 1. BeanFactory 容器由 org.springframework.beans.factory.BeanFactory 接口定义，采用懒加载（lazy-load），所以容器启动比较快。 为了能够兼容 Spring 集成的第三方框架（如 BeanFactoryAware、InitializingBean、DisposableBean），所以目前仍然保留了该接口。 简单来说，BeanFactory 就是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。 BeanFactory 接口有多个实现类，最常见的是 org.springframework.beans.factory.xml.XmlBeanFactory。使用 BeanFactory 需要创建 XmlBeanFactory 类的实例，通过 XmlBeanFactory 类的构造函数来传递 Resource 对象。如下所示。 12Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;); BeanFactory factory = new XmlBeanFactory(resource); 2. ApplicationContext 容器ApplicationContext 继承了 BeanFactory 接口，由 org.springframework.context.ApplicationContext 接口定义，对象在启动容器时加载。ApplicationContext 在 BeanFactory 的基础上增加了很多企业级功能，例如 AOP、国际化、事件支持等。 ApplicationContext 接口有两个常用的实现类，具体如下。 1）ClassPathXmlApplicationContext该类从类路径 ClassPath 中寻找指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作，具体如下所示。 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext(String configLocation); 在上述代码中，configLocation 参数用于指定 Spring 配置文件的名称和位置，如 Beans.xml。 2）FileSystemXmlApplicationContext该类从指定的文件系统路径中寻找指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作，具体如下所示。 1ApplicationContext applicationContext = new FileSystemXmlApplicationContext(String configLocation); 它与 ClassPathXmlApplicationContext 的区别是：在读取 Spring 的配置文件时，FileSystemXmlApplicationContext 不会从类路径中读取配置文件，而是通过参数指定配置文件的位置。即 FileSystemXmlApplicationContext 可以获取类路径之外的资源，如“F:&#x2F;workspaces&#x2F;Beans.xml”。 通常在 Java 项目中，会采用 ClassPathXmlApplicationContext 类实例化 ApplicationContext 容器的方式，而在 Web 项目中，ApplicationContext 容器的实例化工作会交由 Web 服务器完成。Web 服务器实例化 ApplicationContext 容器通常使用基于 ContextLoaderListener 实现的方式，它只需要在 web.xml 中添加如下代码： 1234567891011121314&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--spring将加载spring目录下的applicationContext.xml文件--&gt; &lt;param-value&gt; classpath:spring/applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 需要注意的是，BeanFactory 和 ApplicationContext 都是通过 XML 配置文件加载 Bean 的。 二者的主要区别在于，如果 Bean 的某一个属性没有注入，使用 BeanFacotry 加载后，第一次调用 getBean() 方法时会抛出异常，而 ApplicationContext 则会在初始化时自检，这样有利于检查所依赖的属性是否注入。 因此，在实际开发中，通常都选择使用 ApplicationContext，只有在系统资源较少时，才考虑使用 BeanFactory。 Spring Bean定义由 Spring IoC 容器管理的对象称为 Bean，Bean 根据 Spring 配置文件中的信息创建。 Spring 配置文件支持两种格式，即 XML 文件格式和 Properties 文件格式。 Properties 配置文件主要以 key-value 键值对的形式存在，只能赋值，不能进行其他操作，适用于简单的属性配置。 XML 配置文件是树形结构，相对于 Properties 文件来说更加灵活。XML 配置文件结构清晰，但是内容比较繁琐，适用于大型复杂的项目。 通常情况下，Spring 的配置文件使用 XML 格式。XML 配置文件的根元素是&lt;beans&gt;，该元素包含了多个子元素&lt;bean&gt;。每一个 &lt;bean&gt; 元素都定义了一个 Bean，并描述了该 Bean 如何被装配到 Spring 容器中。 使用 id 属性定义了 Bean，并使用 class 属性指定了 Bean 对应的类。 &lt;bean&gt; 元素中可以包含很多属性，其常用属性如下表所示。 &lt;bean&gt;元素的常用属性 属性名称 描述 id Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成。id 的值必须以字母开始，可以使用字母、数字、下划线等符号。 name name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开。Spring 容器可以通过 name 属性配置和管理容器中的 Bean。 class 该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，即类的全限定名。 scope 用于设定 Bean 实例的作用域，属性值可以为 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton constructor-arg &lt;bean&gt;元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型 property &lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 setter 方法来属性赋值，从而完成依赖注入。该元素的 name 属性用于指定 Bean 实例中相应的属性名 ref &lt;property&gt; 和 &lt;constructor-arg&gt; 等元素的子元索，该元素中的 bean 属性用于指定对某个 Bean 实例的引用 value &lt;property&gt; 和 &lt;constractor-arg&gt; 等元素的子元素，用于直接指定一个常量值 list 用于封装 List 或数组类型的依赖注入 set 用于封装 Set 类型的依赖注入 map 用于封装 Map 类型的依赖注入 entry &lt;map&gt; 元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value 子元素指定其值 init-method 容器加载 Bean 时调用该方法，类似于 Servlet 中的 init() 方法 destroy-method 容器删除 Bean 时调用该方法，类似于 Servlet 中的 destroy() 方法。该方法只在 scope&#x3D;singleton 时有效 lazy-init 懒加载，值为 true，容器在首次请求时才会创建 Bean 实例；值为 false，容器在启动时创建 Bean 实例。该方法只在 scope&#x3D;singleton 时有效 Spring Bean作用域作用域的种类Spring 容器在初始化一个 Bean 实例时，同时会指定该实例的作用域。Spring 5 支持以下 6 种作用域。 1）singleton默认值，单例模式，表示在 Spring 容器中只有一个 Bean 实例，Bean 以单例的方式存在。 2）prototype原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个 Bean 实例。 3）request每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。 4）session同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。 5）application同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。 类似于 singleton，不同的是，singleton 表示每个 IoC 容器中仅有一个 Bean 实例，而同一个 Web 应用中可能会有多个 IoC 容器，但一个 Web 应用只会有一个 ServletContext，也可以说 application 才是 Web 应用中货真价实的单例模式。 6）websocketwebsocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。 注意：Spring 5 版本之前还支持 global Session，该值表示在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。一般用于 Portlet 应用环境。Spring 5.2.0 版本中已经将该值移除了。 request、session、application、websocket 和 global Session 作用域只能在 Web 环境下使用，如果使用 ClassPathXmlApplicationContext 加载这些作用域中的任意一个的 Bean，就会抛出以下异常。 1java.lang.IllegalStateException: No Scope registered for scope name &#x27;xxx&#x27; 7）自定义作用域singletonsingleton 是 Spring 容器默认的作用域。当 Bean 的作用域为 singleton 时，Spring 容器中只会存在一个共享的 Bean 实例。该 Bean 实例将存储在高速缓存中，并且所有对 Bean 的请求，只要 id 与该 Bean 定义相匹配，都会返回该缓存对象。 通常情况下，这种单例模式对于无会话状态的 Bean（如 DAO 层、Service 层）来说，是最理想的选择。 在 Spring 配置文件中，可以使用 &lt;bean&gt; 元素的 scope 属性，将 Bean 的作用域定义成 singleton，其配置方式如下所示： 1&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;/&gt; prototype对于 prototype 作用域的 Bean，Spring 容器会在每次请求该 Bean 时都创建一个新的 Bean 实例。prototype 作用域适用于需要保持会话状态的 Bean（如 Struts2 的 Action 类）。 在 Spring 配置文件中，可以使用 &lt;bean&gt; 元素的 scope 属性，将 Bean 的作用域定义成 prototype，其配置方式如下所示： 1&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;/&gt; Spring Bean生命周期在传统的 Java 应用中，Bean 的生命周期很简单，使用关键字 new 实例化 Bean，当不需要该 Bean 时，由 Java 自动进行垃圾回收。 Spring 中 Bean 的生命周期较复杂，可以表示为：Bean 的定义 -&gt; Bean 的初始化 -&gt; Bean 的使用 -&gt; Bean 的销毁。 Spring 根据 Bean 的作用域来选择管理方式。对于 singleton 作用域的 Bean，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁； 而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。 Bean实例化的三种方式使用类的无参数构造创建1.首先定义一个 bean bean1.java： 12345public class Bean1 &#123;\tpublic void print()&#123; System.out.println(&quot;Bean1......&quot;);\t&#125;&#125; 这个bean只有一个print方法 2.在Spring配置文件Bean.xml 中 配置 bean： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 关键部分 --&gt;\t&lt;bean id=&quot;bean1&quot; class=&quot;com.spring.demo.Bean1&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; id 为 在 xml 里的这个 bean的标识。 class 为xml 里的这个bean 绑定的java类(bean)的全路径(包名+类名) 这个标签会自动寻找 Bean1类中的无参数构造函数来创建对象 使用静态工厂创建1.定义一个bean： bean2.java： 12345public class Bean2 &#123;\tpublic void print()&#123; System.out.println(&quot;Bean2......&quot;);\t&#125;&#125; 2.配置spring的配置文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 关键部分 --&gt;\t&lt;bean id=&quot;bean2&quot; class=&quot;com.spring.demo.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; factory-method &#x3D; “getBean2”表示调用 class 下的 getBean2方法来创建对象(而且factory-method指定的方法必须为static静态方法) 3.定义静态工厂类 12345public class Bean2Factory &#123;\tpublic static Bean2 getBean2()&#123; return new Bean2();\t&#125;&#125; 注意静态工厂类的创建对象方法为静态 使用实例工厂创建1.定义一个bean： 12345public class Bean3 &#123;\tpublic void print()&#123; System.out.println(&quot;Bean3......&quot;);\t&#125;&#125; 2.配置spring的配置文件： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 关键部分 --&gt;\t&lt;bean id=&quot;bean3factory&quot; class=&quot;com.spring.demo.Bean3Factory&quot;&gt;&lt;/bean&gt;\t&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3factory&quot; factory-method=&quot;getBean3&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 为在xml配置文件中定义一个bean，这个bean的id 为bean3factory ，创建所用到的类(class)为com.spring.demo 包下的 Bean3Factory类 在定义一个bean，id 为bean3，生产它的工厂类为 bean3factory，调用 bean3factory生产 bean3的方法为 (bean3factory的)getBean3()方法 3.(非静态)工厂类 12345public class Bean3Factory &#123;\tpublic Bean3 getBean3()&#123; return new Bean3();\t&#125;&#125; 静态工厂类与非静态工厂类的区别是，前者不需要创建对象，直接可以调用静态方法创建bean；后者则要先创建对象，然后再通过对象调用其方法创建bean Spring Bean生命周期执行流程Spring 容器在确保一个 Bean 能够使用之前，会进行很多工作。Spring 容器中 Bean 的生命周期流程如下图所示。 Bean 生命周期的整个执行过程描述如下。 Spring 启动，查找并加载需要被 Spring 管理的 Bean，并实例化 Bean。 利用依赖注入完成 Bean 中所有属性值的配置注入。 如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。 如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。 如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。 如果 Bean 实现了 BeanPostProcessor接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。 如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。 如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。 如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 **postProcessAfterInitialization()**。此时，Bean 已经可以被应用系统使用了。 如果在 &lt;bean&gt; 中指定了该 Bean 的作用域为 singleton，则将该 Bean 放入 Spring IoC 的缓存池中，触发 Spring 对该 Bean 的生命周期管理；如果在 &lt;bean&gt; 中指定了该 Bean 的作用域为 prototype，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。 如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法销毁 Bean；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。 Spring 为 Bean 提供了细致全面的生命周期过程，实现特定的接口或设置 &lt;bean&gt; 的属性都可以对 Bean 的生命周期过程产生影响。建议不要过多的使用 Bean 实现接口，因为这样会导致代码的耦合性过高。 Spring 官方提供了 3 种方法实现初始化回调和销毁回调： 实现 InitializingBean 和 DisposableBean 接口； 在 XML 中配置 init-method 和 destory-method； 使用 @PostConstruct 和 @PreDestory 注解。 在一个 Bean 中有多种生命周期回调方法时，优先级为：注解 &gt; 接口 &gt; XML。 不建议使用接口和注解，这会让 pojo 类和 Spring 框架紧耦合。 初始化回调1. 使用接口org.springframework.beans.factory.InitializingBean 接口提供了以下方法： 1void afterPropertiesSet() throws Exception; 您可以实现以上接口，在 afterPropertiesSet 方法内指定 Bean 初始化后需要执行的操作。 1234567&lt;bean id=&quot;...&quot; class=&quot;...&quot; /&gt;public class User implements InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;调用接口：InitializingBean，方法：afterPropertiesSet，无参数&quot;); &#125;&#125; 2. 配置XML可以通过 init-method 属性指定 Bean 初始化后执行的方法。 123456&lt;bean id=&quot;...&quot; class=&quot;...&quot; init-method=&quot;init&quot;/&gt;public class User &#123; public void init() &#123; System.out.println(&quot;调用init-method指定的初始化方法:init&quot; ); &#125;&#125; 3. 使用注解使用 @PostConstruct 注解标明该方法为 Bean 初始化后的方法。 123456public class ExampleBean &#123; @PostConstruct public void init() &#123; System.out.println(&quot;@PostConstruct注解指定的初始化方法:init&quot; ); &#125;&#125; 销毁回调1. 使用接口org.springframework.beans.factory.DisposableBean 接口提供了以下方法： 1void destroy() throws Exception; 您可以实现以上接口，在 destroy 方法内指定 Bean 初始化后需要执行的操作。 1234567&lt;bean id=&quot;...&quot; class=&quot;...&quot; /&gt;public class User implements DisposableBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;调用接口：InitializingBean，方法：afterPropertiesSet，无参数&quot;); &#125;&#125; 2. 配置XML可以通过 destroy-method 属性指定 Bean 销毁后执行的方法。 123456&lt;bean id=&quot;...&quot; class=&quot;...&quot; destroy-method=&quot;destroy&quot;/&gt;public class User &#123; public void destroy() &#123; System.out.println(&quot;调用destroy-method指定的销毁方法:destroy&quot; ); &#125;&#125; 3. 使用注解使用 @PreDestory 注解标明该方法为 Bean 销毁前执行的方法。 123456public class ExampleBean &#123; @PreDestory public void destroy() &#123; System.out.println(&quot;@PreDestory注解指定的初始化方法:destroy&quot; ); &#125;&#125; AbstractApplicationContext 类的 registerShutdownHook() 方法，来确保正常关机并调用相关的 destroy() 方法。 默认的初始化和销毁方法如果多个 Bean 需要使用相同的初始化或者销毁方法，不用为每个 bean 声明初始化和销毁方法，可以使用 default-init-method 和 default-destroy-method 属性，如下所示。 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot; default-init-method=&quot;init&quot; default-destroy-method=&quot;destroy&quot;&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; ... &lt;/bean&gt; &lt;/beans&gt; BeanPostProcessor（Spring后置处理器）BeanPostProcessor 接口也被称为后置处理器，通过该接口可以自定义调用初始化前后执行的操作方法。 BeanPostProcessor 接口源码如下： 1234public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; postProcessBeforeInitialization 在 Bean 实例化、依赖注入后，初始化前调用。 postProcessAfterInitialization 在 Bean 实例化、依赖注入、初始化都完成后调用。 当需要添加多个后置处理器实现类时，默认情况下 Spring 容器会根据后置处理器的定义顺序来依次调用。也可以通过实现 Ordered 接口的 getOrder 方法指定后置处理器的执行顺序。该方法返回值为整数，默认值为 0，值越大优先级越低。 需要注意的是，postProcessBeforeInitialization 和 postProcessAfterInitialization 方法返回值不能为 null，否则会报空指针异常或者通过 getBean() 方法获取不到 Bean 实例对象，因为后置处理器从Spring IoC 容器中取出 Bean 实例对象后没有再次放回到 IoC 容器中。 由于 getOrder 方法返回值越大，优先级越低 示例HelloWorld 类代码如下。 123456789101112131415public class HelloWorld &#123; private String message; public void setMessage(String message) &#123; this.message = message; &#125; public void getMessage() &#123; System.out.println(&quot;Message : &quot; + message); &#125; public void init() &#123; System.out.println(&quot;Bean正在初始化&quot;); &#125; public void destroy() &#123; System.out.println(&quot;Bean将要被销毁&quot;); &#125;&#125; InitHelloWorld 类代码如下。 12345678910111213141516public class InitHelloWorld implements BeanPostProcessor, Ordered &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;A Before : &quot; + beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;A After : &quot; + beanName); return bean; &#125; @Override public int getOrder() &#123; return 5; &#125;&#125; InitHelloWorld2 的代码如下。 12345678910111213141516public class InitHelloWorld2 implements BeanPostProcessor, Ordered &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;B Before : &quot; + beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;B After : &quot; + beanName); return bean; &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; Beans.xml 代码如下。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;net.biancheng.HelloWorld&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;message&quot; value=&quot;Hello World！&quot; /&gt; &lt;/bean&gt; &lt;!-- 注册处理器 --&gt; &lt;bean class=&quot;net.biancheng.InitHelloWorld&quot; /&gt; &lt;bean class=&quot;net.biancheng.InitHelloWorld2&quot; /&gt;&lt;/beans&gt; MainApp 类代码如下。 12345678public class MainApp &#123; public static void main(String[] args) &#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;); obj.getMessage(); context.registerShutdownHook(); &#125;&#125; 运行结果如下。 1234567B Before : helloWorldA Before : helloWorldBean正在初始化B After : helloWorldA After : helloWorldMessage : Hello World！Bean将要被销毁 Spring Bean继承Bean 定义可以包含很多配置信息，包括构造函数参数、属性值和容器的一些具体信息，如初始化方法、销毁方法等。子 Bean 可以继承父 Bean 的配置数据，根据需要，子 Bean 可以重写值或添加其它值。 Spring Bean 定义的继承与 Java 中的继承无关。 在配置文件中通过 parent 属性来指定继承的父 Bean。 示例HelloWorld 类代码如下。 12345public class HelloWorld &#123; private String message1; private String message2; ...&#125; HelloChina 类代码如下。 123456public class HelloChina &#123; private String message1; private String message2; private String message3; ...&#125; 在配置文件中，分别为 HelloWorld 中的 message1 和 message2 赋值。使用 parent 属性将 HelloChain 定义为 HelloWorld 的子类，并为 HelloChain 中的 message1 和 message3 赋值。 Beans.xml 文件代码如下。 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;net.biancheng.HelloWorld&quot;&gt; &lt;property name=&quot;message1&quot; value=&quot;Hello World！&quot; /&gt; &lt;property name=&quot;message2&quot; value=&quot;Hello World2！&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;helloChina&quot; class=&quot;net.biancheng.HelloChina&quot; parent=&quot;helloWorld&quot;&gt; &lt;property name=&quot;message1&quot; value=&quot;Hello China！&quot; /&gt; &lt;property name=&quot;message3&quot; value=&quot;Hello China3！&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp 类代码如下。 123456789101112public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); HelloWorld objA = (HelloWorld) context.getBean(&quot;helloWorld&quot;); objA.getMessage1(); objA.getMessage2(); HelloChina objB = (HelloChina) context.getBean(&quot;helloChina&quot;); objB.getMessage1(); objB.getMessage2(); objB.getMessage3(); &#125;&#125; 运行结果如下。 12345World Message1 : Hello World！World Message2 : Hello World2！China Message1 : Hello China！China Message2 : Hello World2！China Message3 : Hello China3！ 由结果可以看出，我们在创建 helloChina 时并没有给 message2 赋值，但是由于 Bean 的继承，将值传递给了 message2。 Bean定义模板您可以创建一个 Bean 定义模板，该模板只能被继承，不能被实例化。创建 Bean 定义模板时，不用指定 class 属性，而是指定 abstarct&#x3D;”true” 将该 Bean 定义为抽象 Bean，如下所示。 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;beanTeamplate&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot; /&gt; &lt;property name=&quot;message2&quot; value=&quot;Hello World2!&quot; /&gt; &lt;property name=&quot;message3&quot; value=&quot;Hello World3!&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;helloChina&quot; class=&quot;net.biancheng.HelloChina&quot; parent=&quot;beanTeamplate&quot;&gt; &lt;property name=&quot;message1&quot; value=&quot;Hello China!&quot; /&gt; &lt;property name=&quot;message3&quot; value=&quot;Hello China!&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; Spring依赖注入Spring 依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。使用依赖注入可以更轻松的管理和测试应用程序。 &#x3D;&#x3D;当某个 Java 实例需要另一个 Java 实例时，传统的方法是由调用者创建被调用者的实例（例如，使用 new 关键字获得被调用者实例），而使用 Spring 框架后，被调用者的实例不再由调用者创建，而是由 Spring 容器创建，这称为控制反转。&#x3D;&#x3D; &#x3D;&#x3D;Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。&#x3D;&#x3D; 依赖注入主要有两种实现方式，分别是 setter 注入（又称设值注入）和构造函数注入。 1）构造函数注入指 IoC 容器使用构造函数注入被依赖的实例。可以通过调用带参数的构造函数实现依赖注入，每个参数代表一个依赖。 2）setter 注入指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 Bean 后，调用该 Bean 的 setter 方法，即可实现基于 setter 的 DI。 在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 Java 的反射机制调用 setXxx() 方法进行属性的注入。因此，setter 注入要求 Bean 的对应类必须满足以下两点要求。 必须提供一个默认的无参构造方法。 必须为需要注入的属性提供对应的 setter 方法。 使用 setter 注入时，在 Spring 配置文件中，需要使用 &lt;bean&gt; 元素的子元素 &lt;property&gt; 为每个属性注入值。而使用构造注入时，在配置文件中，主要使用 &lt;constructor-arg&gt; 标签定义构造方法的参数，使用其 value 属性（或子元素）设置该参数的值。 构造函数注入在&lt;constructor-arg&gt; 标签中，包含 ref、value、type、index 等属性。 value 属性用于注入基本数据类型以及字符串类型的值； ref 属性用于注入已经定义好的 Bean； type 属性用来指定对应的构造函数，当构造函数有多个参数时，可以使用 index 属性指定参数的位置， index 属性值从 0 开始。 例 1Person 类代码如下。 12345678910public class Person &#123; private Man man; public Person(Man man) &#123; System.out.println(&quot;在Person的有参构造函数内&quot;); this.man = man; &#125; public void man() &#123; man.show(); &#125;&#125; Man 类代码如下。 12345678910111213141516public class Man &#123; private String name; private int age; public Man() &#123; System.out.println(&quot;在man的构造函数内&quot;); &#125; public Man(String name, int age) &#123; System.out.println(&quot;在man的有参构造函数内&quot;); this.name = name; this.age = age; &#125; public void show() &#123; System.out.println(&quot;名称：&quot; + name + &quot; 年龄：&quot; + age); &#125; ...&#125; Beans.xml 配置文件如下。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot;&gt; &lt;constructor-arg ref=&quot;man&quot; type=&quot;net.biancheng.Man&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp 类代码如下。 1234567public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); Person person = (Person) context.getBean(&quot;person&quot;); person.man(); &#125;&#125; 运行结果如下。 1234在man的有参构造函数内在Person的有参构造函数内名称：bianchengbang年龄：12 setter注入在 &lt;property&gt; 标签中，包含 name、ref、value 等属性。 name 用于指定参数名称； value 属性用于注入基本数据类型以及字符串类型的值； ref 属性用于注入已经定义好的 Bean。 例 2在例 1 的基础上修改 Person 类的内容，代码如下。 12345678910111213public class Person &#123; private Man man; public void man() &#123; man.show(); &#125; public Man getMan() &#123; return man; &#125; public void setMan(Man man) &#123; System.out.println(&quot;在setMan方法内&quot;); this.man = man; &#125;&#125; Beans.xml 配置文件如下。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot;&gt; &lt;property name=&quot;man&quot; ref=&quot;man&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;bianchengbang&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 运行结果如下。 1234在man的构造函数内在setMan方法内名称：bianchengbang年龄：12 Spring注入内部BeanJava 中在类内部定义的类称为内部类，同理在 Bean 中定义的 Bean 称为内部 Bean。注入内部 Bean 使用 &lt;property&gt; 和 &lt;constructor-arg&gt; 中的 &lt;bean&gt; 标签。如下所示。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;outerBean&quot; class=&quot;...&quot;&gt; &lt;property name=&quot;target&quot;&gt; &lt;!-- 定义内部Bean --&gt; &lt;bean class=&quot;...&quot; /&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 内部 Bean 的定义不需要指定 id 和 name 。如果指定了，容器也不会将其作为区分 Bean 的标识符，反而会无视内部 Bean 的 scope 属性。所以内部 Bean 总是匿名的，而且总是随着外部 Bean 创建。 在实际开发中很少注入内部 Bean，因为开发者无法将内部的 Bean 注入外部 Bean 以外的其它 Bean。 示例Person 类代码如下。 12345678910111213public class Person &#123; private Man man; public Man getMan() &#123; return man; &#125; public void setMan(Man man) &#123; System.out.println(&quot;在setMan方法内&quot;); this.man = man; &#125; public void man() &#123; man.show(); &#125;&#125; Man 类代码如下。 12345678910111213141516public class Man &#123; private String name; private int age; public Man() &#123; System.out.println(&quot;在man的构造函数内&quot;); &#125; public Man(String name, int age) &#123; System.out.println(&quot;在man的有参构造函数内&quot;); this.name = name; this.age = age; &#125; public void show() &#123; System.out.println(&quot;名称：&quot; + name + &quot; 年龄：&quot; + age); &#125; ...&#125; Beans.xml 配置文件如下。 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot;&gt; &lt;property name=&quot;man&quot;&gt; &lt;bean class=&quot;net.biancheng.Man&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;bianchengbang&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp 类代码如下。 1234567public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); Person person = (Person) context.getBean(&quot;person&quot;); person.man(); &#125;&#125; 运行结果如下。 1234在man的有参构造函数内在Person的构造函数内名称：bianchengbang年龄：12 Spring注入集合如果需要传递类似于 Java Collection 类型的值，例如 List、Set、Map 和 properties，可以使用 Spring 提供的集合配置标签，如下表所示。 标签 说明 &lt;list&gt; 用于注入 list 类型的值，允许重复 &lt;set&gt; 用于注入 set 类型的值，不允许重复 &lt;map&gt; 用于注入 key-value 的集合，其中 key-value 可以是任意类型 &lt;props&gt; 用于注入 key-value 的集合，其中 key-value 都是字符串类型 示例JavaCollection 类代码如下。 12345678910111213141516171819202122232425262728293031323334public class JavaCollection &#123; List manList; Set manSet; Map manMap; Properties manProp; public void setManList(List manList) &#123; this.manList = manList; &#125; public List getManList() &#123; System.out.println(&quot;List Elements :&quot; + manList); return manList; &#125; public void setManSet(Set manSet) &#123; this.manSet = manSet; &#125; public Set getManSet() &#123; System.out.println(&quot;Set Elements :&quot; + manSet); return manSet; &#125; public void setManMap(Map manMap) &#123; this.manMap = manMap; &#125; public Map getManMap() &#123; System.out.println(&quot;Map Elements :&quot; + manMap); return manMap; &#125; public void setManProp(Properties manProp) &#123; this.manProp = manProp; &#125; public Properties getManProp() &#123; System.out.println(&quot;Property Elements :&quot; + manProp); return manProp; &#125;&#125; MainApp 类代码如下。 1234567public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); JavaCollection jc = (JavaCollection) context.getBean(&quot;javaCollection&quot;); jc.getManList();jc.getManSet();jc.getManMap();jc.getManProp(); &#125;&#125; Beans.xml 配置文件如下。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;javaCollection&quot; class=&quot;net.biancheng.JavaCollection&quot;&gt; &lt;property name=&quot;manList&quot;&gt; &lt;list&gt; &lt;value&gt;编程帮&lt;/value&gt; &lt;value&gt;百度&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;manSet&quot;&gt; &lt;set&gt; &lt;value&gt;编程帮&lt;/value&gt; &lt;value&gt;百度&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;manMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;编程帮&quot; /&gt; &lt;entry key=&quot;2&quot; value=&quot;百度&quot; /&gt; &lt;entry key=&quot;3&quot; value=&quot;C语言中文网&quot; /&gt; &lt;entry key=&quot;4&quot; value=&quot;C语言中文网&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;manProp&quot;&gt; &lt;props&gt; &lt;prop key=&quot;one&quot;&gt;编程帮&lt;/prop&gt; &lt;prop key=&quot;one&quot;&gt;编程帮&lt;/prop&gt; &lt;prop key=&quot;two&quot;&gt;百度&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行结果如下。 1234List Elements :[编程帮, 百度]Set Elements :[编程帮, 百度]Map Elements :&#123;1=编程帮, 2=百度&#125;Property Elements :&#123;two=百度, one=编程帮&#125; 注入Bean引用也可以在集合元素中注入 Bean，如下所示。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;property name=&quot;manList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;man1&quot; /&gt; &lt;ref bean=&quot;man2&quot; /&gt; &lt;value&gt;编程帮&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;manSet&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;man1&quot; /&gt; &lt;ref bean=&quot;man2&quot; /&gt; &lt;value&gt;编程帮&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;manMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;one&quot; value=&quot;编程帮&quot; /&gt; &lt;entry key=&quot;two&quot; value-ref=&quot;man1&quot; /&gt; &lt;entry key=&quot;three&quot; value-ref=&quot;man2&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注入null和空字符串的值Spring 会把属性的空参数直接当成空字符串来处理，如果您需要传递一个空字符串值，可以这样写： 123&lt;bean id = &quot;...&quot; class = &quot;exampleBean&quot;&gt; &lt;property name = &quot;email&quot; value = &quot;&quot;/&gt;&lt;/bean&gt; 等效于以下代码 1exampleBean.setEmail(&quot;&quot;) 如果需要传递 NULL 值， 元素用来处理 Null 值。 123&lt;bean id = &quot;...&quot; class = &quot;exampleBean&quot;&gt; &lt;property name = &quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt; 等效于以下代码 1exampleBean.setEmail(null) Spring Bean自动装配Bean 的装配可以理解为依赖关系注入，Bean 的装配方式也就是 Bean 的依赖注入方式。Spring 容器支持多种装配 Bean 的方式，如基于 XML 的 Bean 装配、基于 Annotation 的 Bean 装配和自动装配等。 自动装配就是指 Spring 容器在不使用 &lt;constructor-arg&gt; 和&lt;property&gt; 标签的情况下，可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。 使用自动装配需要配置 &lt;bean&gt; 元素的 autowire 属性。autowire 属性有五个值，具体说明如下表所示。 名称 说明 no 默认值，表示不使用自动装配，Bean 依赖必须通过 ref 元素定义。 byName 根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。 byType 根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。 constructor 类似于 byType，根据构造方法参数的数据类型，进行 byType 模式的自动装配。 autodetect（3.0版本不支持） 如果 Bean 中有默认的构造方法，则用 constructor 模式，否则用 byType 模式。 示例Person 类代码如下。 1234567891011public class Person &#123; private Man man; public Person() &#123;System.out.println(&quot;在Person的构造函数内&quot;);&#125; public Person(Man man) &#123; System.out.println(&quot;在Person的有参构造函数内&quot;); this.man = man; &#125; public void man() &#123;man.show();&#125; public Man getMan() &#123;return man;&#125; public void setMan(Man man) &#123;this.man = man;&#125;&#125; Man 类代码如下。 12345678910111213141516public class Man &#123; private String name; private int age; public Man() &#123; System.out.println(&quot;在man的构造函数内&quot;); &#125; public Man(String name, int age) &#123; System.out.println(&quot;在man的有参构造函数内&quot;); this.name = name; this.age = age; &#125; public void show() &#123; System.out.println(&quot;名称：&quot; + name + &quot; 年龄：&quot; + age); &#125; ...&#125; MainApp 类代码如下。 1234567public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); Person person = (Person) context.getBean(&quot;person&quot;); person.man(); &#125;&#125; 1）不使用自动装配（autowire&#x3D;”no”）autowire&#x3D;”no” 表示不使用自动装配，需要手动注入，Bean 依赖通过 ref 元素定义，Beans.xml 配置文件如下。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot; autowire=&quot;no&quot;&gt; &lt;constructor-arg ref=&quot;man&quot; type=&quot;net.biancheng.Man&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行结果如下。 1234在man的有参构造函数内在Person的有参构造函数内名称：bianchengbang年龄：12 2）按名称自动装配（autowire&#x3D;”byName”）autowire&#x3D;”byName” 表示按属性名称自动装配，XML 文件中 Bean 的 id 必须与类中的属性名称相同。配置文件内容修改如下。 12345&lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot; autowire=&quot;byName&quot;/&gt; 如果更改 Bean 的名称，很可能不会注入依赖项。 将 Bean 的名称更改为 man1，配置文件如下： 12345&lt;bean id=&quot;man1&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot; autowire=&quot;byName&quot;/&gt; 注入失败，异常信息为： 1234在man的有参构造函数内Exception in thread &quot;main&quot; java.lang.NullPointerExceptionat net.biancheng.Person.man(Person.java:16)at net.biancheng.MainApp.main(MainApp.java:10) 3）按类型自动装配（autowire&#x3D;”byType”）XML 文件中 Bean 的 id 与类中的属性名称可以不同，但必须只有一个类型的 Bean。配置文件内容修改如下。 12345&lt;bean id=&quot;man1&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot; autowire=&quot;byType&quot;/&gt; 如果您有相同类型的多个 Bean，则注入失败，并且引发异常。 添加 id 为 man2 的 Bean，配置文件代码如下。 123456789&lt;bean id=&quot;man1&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;man2&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot; autowire=&quot;byType&quot;/&gt; 异常信息为： 123456在man的有参构造函数内在man的有参构造函数内在Person的构造函数内一月 26, 2021 1:34:14 下午 org.springframework.context.support.AbstractApplicationContext refresh警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;person&#x27; defined in class path resource [Beans.xml]: Unsatisfied dependency expressed through bean property &#x27;man&#x27;; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;net.biancheng.Man&#x27; available: expected single matching bean but found 2: man1,man2... 4）构造函数自动装配（autowire&#x3D;”constructor”）类中构造函数的参数必须在配置文件中有相同的类型，配置文件内容修改如下。 12345&lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;constructor-arg value=&quot;bianchengbang&quot; /&gt; &lt;constructor-arg value=&quot;12&quot; type=&quot;int&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; class=&quot;net.biancheng.Person&quot; autowire=&quot;constructor&quot;/&gt; 自动装配的优缺点优点 自动装配只需要较少的代码就可以实现依赖注入。 缺点 不能自动装配简单数据类型，比如 int、boolean、String 等。 相比较显示装配，自动装配不受程序员控制。 Spring基于注解装配BeanJava 从 JDK 5.0 以后，提供了 Annotation（注解）功能，Spring 2.5 版本开始也提供了对 Annotation 技术的全面支持，我们可以使用注解来配置依赖注入。 Spring 默认不使用注解装配 Bean，因此需要在配置文件中添加 **&lt;context:annotation-config&#x2F;&gt;**，启用注解。 Spring 中常用的注解如下。 1）@Component可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。 2）@Repository用于将数据访问层（DAO层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 3）@Service通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 4）@Controller通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 5）@Autowired可以应用到 Bean 的属性变量、属性的 setter 方法、非 setter 方法及构造函数等，配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型进行装配。 6）@Resource作用与 Autowired 相同，区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 实例名称进行装配。 @Resource 中有两个重要属性：name 和 type。 Spring 将 name 属性解析为 Bean 的实例名称，type 属性解析为 Bean 的实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。 7）@Qualifier与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。 示例UserDao 代码如下。 123456public interface UserDao &#123; /** * 输出方法 */ public void outContent();&#125; UserDaoImpl 代码如下。 1234567@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void outContent() &#123; System.out.println(&quot;编程帮&quot;); &#125;&#125; UserService 代码如下。 123456public interface UserService &#123; /** * 输出方法 */ public void outContent();&#125; UserServiceImpl 代码如下。 123456789101112131415161718@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService&#123; @Resource(name=&quot;userDao&quot;) private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void outContent() &#123; userDao.outContent(); System.out.println(&quot;一个在线学习编程的网站&quot;); &#125;&#125; UserController 代码如下。 123456789101112131415@Controller(&quot;userController&quot;)public class UserController &#123; @Resource(name = &quot;userService&quot;) private UserService userService; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void outContent() &#123; userService.outContent(); System.out.println(&quot;专注于分享优质编程教程&quot;); &#125;&#125; Beans.xml 代码如下。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--使用context命名空间，通知spring扫描指定目录，进行注解的解析 --&gt; &lt;context:component-scan base-package=&quot;net.biancheng&quot; /&gt;&lt;/beans&gt; MainApp 类代码如下。 1234567public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserController uc = (UserController) ctx.getBean(&quot;userController&quot;); uc.outContent(); &#125;&#125; 运行结果如下。 123编程帮一个在线学习编程的网站专注于分享优质编程教程 Spring AOP（面向切面编程）AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，和 OOP（面向对象编程）类似，也是一种编程思想。 AOP 采取横向抽取机制（动态代理），取代了传统纵向继承机制的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。主要作用是分离功能性需求和非功能性需求，使开发人员可以集中处理某一个关注点或者横切逻辑，减少对业务代码的侵入，增强代码的可读性和可维护性。 简单的说，AOP 的作用就是保证开发者在不修改源代码的前提下，为系统中的业务组件添加某种通用功能。AOP 就是代理模式的典型应用。 目前最流行的 AOP 框架有两个，分别为 Spring AOP 和 AspectJ。 Spring AOP 是基于 AOP 编程模式的一个框架，它能够有效的减少系统间的重复代码，达到松耦合的目的。Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。有两种实现方式：基于接口的 JDK 动态代理和基于继承的 CGLIB 动态代理。 AspectJ 是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入。 为什么使用AOPAOP 提供了一种可插入的方式，可以在实际逻辑之前、之后或周围添加其它关注点。比如一个类中有以下 10 个方法。 123456789101112class A&#123; public void m1()&#123;...&#125; public void m2()&#123;...&#125; public void m3()&#123;...&#125; public void m4()&#123;...&#125; public void m5()&#123;...&#125; public void n1()&#123;...&#125; public void n2()&#123;...&#125; public void p1()&#123;...&#125; public void p2()&#123;...&#125; public void p3()&#123;...&#125; &#125; 以 m 开头的方法有 5 种，以 n 开头的方法有 2 种，以 p 开头的方法有 3 种。现在要求在以 m 开头的方法后添加发送通知功能。 在不使用 AOP 的情况下，我们必须修改以 m 开头的 5 种方法，在方法中调用发送通知的方法。 如果使用 AOP，我们不用在方法内调用发送通知的方法，只需要在类的方法中定义切入点，然后在 XML 文件中调用。如果需要删除或修改此功能，那么只需要在 XML 文件中进行更改。由此可以看出，使用 AOP 可以增强代码的可维护性。 AOP术语 名称 说明 Joinpoint（连接点） 指那些被拦截到的点，在 Spring 中，指可以被动态代理拦截目标类的方法。 Pointcut（切入点） 指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。 Advice（通知） 指拦截到 Joinpoint 之后要做的事情，即对切入点增强的内容。 Target（目标） 指代理的目标对象。 Weaving（植入） 指把增强代码应用到目标上，生成代理对象的过程。 Proxy（代理） 指生成的代理对象。 Aspect（切面） 切入点和通知的结合。 Advice 直译为通知，也有的资料翻译为“增强处理”，共有 5 种类型，如下表所示。 通知 说明 before（前置通知） 通知方法在目标方法调用之前执行 after（后置通知） 通知方法在目标方法返回或异常后调用 after-returning（返回后通知） 通知方法会在目标方法返回后调用 after-throwing（抛出异常通知） 通知方法会在目标方法抛出异常后调用 around（环绕通知） 通知方法会将目标方法封装起来 AOP 是 Spring 的核心之一，在 Spring 中经常会使用 AOP 来简化编程。在 Spring 框架中使用 AOP 主要有以下优势。 提供声明式企业服务，特别是作为 EJB 声明式服务的替代品。最重要的是，这种服务是声明式事务管理。 允许用户实现自定义切面。在某些不适合用 OOP 编程的场景中，采用 AOP 来补充。 可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时也提高了开发效率。 Spring JDK动态代理Spring JDK 动态代理需要实现 InvocationHandler 接口，重写 invoke 方法，客户端使用 Java.lang.reflect.Proxy 类产生动态代理类的对象。 示例UserManager 类代码如下。 123456public interface UserManager &#123; // 新增用户抽象方法 void addUser(String userName, String password); // 删除用户抽象方法 void delUser(String userName);&#125; UserManagerImpl 类代码如下。 123456789101112public class UserManagerImpl implements UserManager &#123; @Override public void addUser(String userName, String password) &#123; System.out.println(&quot;正在执行添加用户方法&quot;); System.out.println(&quot;用户名称: &quot; + userName + &quot; 密码: &quot; + password); &#125; @Override public void delUser(String userName) &#123; System.out.println(&quot;正在执行删除用户方法&quot;); System.out.println(&quot;用户名称: &quot; + userName); &#125;&#125; MyAspect 类代码如下。 12345678public class MyAspect &#123; public void myBefore() &#123; System.out.println(&quot;方法执行之前&quot;); &#125; public void myAfter() &#123; System.out.println(&quot;方法执行之后&quot;); &#125;&#125; MyAspect 类在切面中定义了两个增强的方法，分别为 myBefore 和 myAfter。 JdkProxy 类代码如下。 1234567891011121314151617181920212223242526272829/*** JDK动态代理实现InvocationHandler接口*/public class JdkProxy implements InvocationHandler &#123; private Object target; // 需要代理的目标对象 final MyAspect myAspect = new MyAspect(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; myAspect.myBefore(); Object result = method.invoke(target, args); myAspect.myAfter(); return result; &#125; // 定义获取代理对象方法 private Object getJDKProxy(Object targetObject) &#123; // 为目标对象target赋值 this.target = targetObject; // JDK动态代理只能代理实现了接口的类，从 newProxyInstance 函数所需的参数就可以看出来 return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(),this); &#125; public static void main(String[] args) &#123; JdkProxy jdkProxy = new JdkProxy(); // 实例化JDKProxy对象 UserManager user = (UserManager) jdkProxy.getJDKProxy(new UserManagerImpl()); // 获取代理对象 user.addUser(&quot;bianchengbang&quot;, &quot;www.biancheng.net&quot;); // 执行新增方法 user.delUser(&quot;bianchengbang&quot;); // 执行删除方法 &#125;&#125; 运行结果如下。 12345678方法执行之前正在执行添加用户方法用户名称: bianchengbang 密码: www.biancheng.net方法执行之后方法执行之前正在执行删除用户方法用户名称: bianchengbang方法执行之后 Spring CGLlB动态代理JDK 动态代理使用起来非常简单，但是 JDK 动态代理的目标类必须要实现一个或多个接口，具有一定的局限性。如果不希望实现接口，可以使用 CGLIB代理。 CGLIB（Code Generation Library）是一个高性能开源的代码生成包，它被许多 AOP 框架所使用，其底层是通过使用一个小而快的字节码处理框架 ASM（Java 字节码操控框架）转换字节码并生成新的类。使用 CGLIB 需要导入 CGLIB 和 ASM 包，即 asm-x.x.jar 和 CGLIB-x.x.x.jar 。如果您已经导入了 Spring 的核心包 spring-core-x.x.x.RELEASE.jar，就不用再导入 asm-x.x.jar 和 cglib-x.x.x.jar 了。 Spring 核心包中包含 CGLIB 和 asm，也就是说 Spring 核心包已经集成了 CGLIB 所需要的包，所以在开发中不需要另外导入asm-x.x.jar 和 cglib-x.x.x.jar 包了。 示例UserManager 类代码如下。 123456public interface UserManager &#123; // 新增用户抽象方法 void addUser(String userName, String password); // 删除用户抽象方法 void delUser(String userName);&#125; UserManagerImpl 类代码如下。 123456789101112public class UserManagerImpl implements UserManager &#123; @Override public void addUser(String userName, String password) &#123; System.out.println(&quot;正在执行添加用户方法&quot;); System.out.println(&quot;用户名称: &quot; + userName + &quot; 密码: &quot; + password); &#125; @Override public void delUser(String userName) &#123; System.out.println(&quot;正在执行删除用户方法&quot;); System.out.println(&quot;用户名称: &quot; + userName); &#125;&#125; MyAspect 类代码如下。 12345678public class MyAspect &#123; public void myBefore() &#123; System.out.println(&quot;方法执行之前&quot;); &#125; public void myAfter() &#123; System.out.println(&quot;方法执行之后&quot;); &#125;&#125; CglibProxy 类代码如下。 1234567891011121314151617181920212223242526272829303132/*** CGLIB动态代理，实现MethodInterceptor接口*/public class CglibProxy implements MethodInterceptor &#123; private Object target;// 需要代理的目标对象 final MyAspect myAspect = new MyAspect(); // 重写拦截方法 @Override public Object intercept(Object obj, Method method, Object[] arr, MethodProxy proxy) throws Throwable &#123; myAspect.myBefore(); Object invoke = method.invoke(target, arr);// 方法执行，参数：target目标对象 arr参数数组 myAspect.myAfter(); return invoke; &#125; // 定义获取代理对象方法 public Object getCglibProxy(Object objectTarget) &#123; // 为目标对象target赋值 this.target = objectTarget; Enhancer enhancer = new Enhancer(); // 设置父类,因为CGLIB是针对指定的类生成一个子类，所以需要指定父类 enhancer.setSuperclass(objectTarget.getClass()); enhancer.setCallback(this);// 设置回调 Object result = enhancer.create();// 创建并返回代理对象 return result; &#125; public static void main(String[] args) &#123; CglibProxy cglib= new CglibProxy();// 实例化CglibBProxy对象 UserManager user = (UserManager) cglib.getCglibProxy(new UserManagerImpl());// 获取代理对象 user.addUser(&quot;bianchengbang&quot;, &quot;www.biancheng.net&quot;); // 执行新增方法 user.delUser(&quot;bianchengbang&quot;); // 执行删除方法 &#125;&#125; 运行结果如下。 12345678方法执行之前正在执行添加用户方法用户名称: bianchengbang 密码: www.biancheng.net方法执行之后方法执行之前正在执行删除用户方法用户名称: bianchengbang方法执行之后 JDK代理和CGLIB代理的区别JDK 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。而 CGLIB 动态代理是利用 ASM 开源包，加载代理对象类的 class 文件，通过修改其字节码生成子类来处理。 JDK 动态代理只能对实现了接口的类生成代理，而不能针对类。 CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以该类或方法不能声明成 final 类型。 JDK动态代理特点 代理对象必须实现一个或多个接口 以接口的形式接收代理实例，而不是代理类 CGLIB动态代理特点 代理对象不能被 final 修饰 以类或接口形式接收代理实例 JDK与CGLIB动态代理的性能比较生成代理实例性能：JDK &gt; CGLIB代理实例运行性能：JDK &gt; CGLIB Spring集成AspectJAspectJ 是一个基于 Java 语言的 AOP 框架，它扩展了 Java 语言，提供了强大的 AOP 功能。 使用 AspectJ 需要导入以下 jar 包： Aspectjrt.jar Aspectjweaver.jar Aspectj.jar 使用 AspectJ 开发 AOP 通常有以下 2 种方式： 基于 XML 的声明式 AspectJ 基于 Annotation 的声明式 AspectJ Spring AOP：基于AspectJ XML开发基于 XML 的声明式是指通过 Spring 配置文件的方式来定义切面、切入点及通知，而所有的切面和通知都必须定义在 &lt;aop:config&gt; 元素中。 在使用 &lt;aop:config&gt; 元素之前，我们需要先导入 Spring aop 命名空间，如下所示。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt; ...&lt;/beans&gt; 定义切面&lt;aop:aspect&gt;在 Spring 配置文件中，使用 &lt;aop:aspect&gt; 元素定义切面，该元素可以将定义好的 Bean 转换为切面 Bean，所以使用 &lt;aop:aspect&gt; 之前需要先定义一个普通的 Spring Bean。 12345&lt;aop:config&gt; &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt; 其中，id 用来定义该切面的唯一表示名称，ref 用于引用普通的 Spring Bean。 定义切入点&lt;aop:pointcut&gt;&lt;aop:pointcut&gt; 用来定义一个切入点， 当 &lt;aop:pointcut&gt;元素作为 &lt;aop:config&gt; 元素的子元素定义时，表示该切入点是全局切入点，它可被多个切面所共享； 当 &lt;aop:pointcut&gt; 元素作为 &lt;aop:aspect&gt; 元素的子元素时，表示该切入点只对当前切面有效。 1234&lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointCut&quot; expression=&quot;execution(* net.biancheng.service.*.*(..))&quot;/&gt;&lt;/aop:config&gt; 其中，id 用于指定切入点的唯一标识名称，execution 用于指定切入点关联的切入点表达式。 execution 格式为： 123execution(modifiers-pattern returning-type-pattern declaring-type-pattern name-pattern(param-pattern)throws-pattern)( * net.biancheng.service.*.* (..) )返回值类型 包名 方法名 所有参数 其中： returning-type-pattern、name-pattern、param-pattern 是必须的，其它参数为可选项。 modifiers-pattern：指定修饰符，如 private、public。 returning-type-pattern：指定返回值类型，*表示可以为任何返回值。如果返回值为对象，则需指定全路径的类名。 declaring-type-pattern：指定方法的包名。 name-pattern：指定方法名，*代表所有，**set* 代表以 set 开头的所有方法**。 param-pattern：指定方法参数（声明的类型），(..)代表所有参数，(*)代表一个参数，(*,String)代表第一个参数可以为任何值，第二个为 String 类型的值。 throws-pattern：指定抛出的异常类型。 例如：execution(* net.biancheng.*.*(..))表示匹配 net.biancheng 包中任意类的任意方法。 定义通知AspectJ 支持 5 种类型的 advice，如下。 12345678910111213&lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt; &lt;!-- 前置通知 --&gt; &lt;aop:before pointcut-ref=&quot;myPointCut&quot; method=&quot;...&quot;/&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after-returning pointcut-ref=&quot;myPointCut&quot; method=&quot;...&quot;/&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around pointcut-ref=&quot;myPointCut&quot; method=&quot;...&quot;/&gt; &lt;!-- 异常通知 --&gt; &lt;aop:after-throwing pointcut-ref=&quot;myPointCut&quot; method=&quot;...&quot;/&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after pointcut-ref=&quot;myPointCut&quot; method=&quot;...&quot;/&gt; .... &lt;/aop:aspect&gt; 示例Logging 类的代码如下，定义了在各个点要调用的方法。 123456789101112131415161718public class Logging &#123; // 前置通知 public void beforeAdvice() &#123; System.out.println(&quot;前置通知&quot;); &#125; // 后置通知 public void afterAdvice() &#123; System.out.println(&quot;后置通知&quot;); &#125; // 返回后通知 public void afterReturningAdvice(Object retVal) &#123; System.out.println(&quot;返回值为：&quot; + retVal.toString()); &#125; // 抛出异常通知 public void afterThrowingAdvice(IllegalArgumentException ex) &#123; System.out.println(&quot;这里的异常为：&quot; + ex.toString()); &#125;&#125; Man 类的代码如下。 123456789public class Man &#123; private String name; private int age; ... public void throwException() &#123; System.out.println(&quot;抛出异常&quot;); throw new IllegalArgumentException(); &#125;&#125; Beans.xml 代码如下。 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;log&quot; ref=&quot;logging&quot;&gt; &lt;aop:pointcut id=&quot;selectAll&quot; expression=&quot;execution(* net.biancheng.*.*(..))&quot; /&gt; &lt;aop:before pointcut-ref=&quot;selectAll&quot; method=&quot;beforeAdvice&quot; /&gt; &lt;aop:after pointcut-ref=&quot;selectAll&quot; method=&quot;afterAdvice&quot; /&gt; &lt;aop:after-returning pointcut-ref=&quot;selectAll&quot; returning=&quot;retVal&quot; method=&quot;afterReturningAdvice&quot; /&gt; &lt;aop:after-throwing pointcut-ref=&quot;selectAll&quot; throwing=&quot;ex&quot; method=&quot;afterThrowingAdvice&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;bianchengbang&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;logging&quot; class=&quot;net.biancheng.Logging&quot; /&gt;&lt;/beans&gt; MainApp 类代码如下。 123456789public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); Man man = (Man) context.getBean(&quot;man&quot;); man.getName(); man.getAge(); man.throwException(); &#125;&#125; 运行结果如下。 1234567891011前置通知后置通知返回值为：bianchengbang前置通知后置通知返回值为：12前置通知抛出异常后置通知这里的异常为：java.lang.IllegalArgumentExceptionException in thread &quot;main&quot; java.lang.IllegalArgumentException Spring AOP：基于AspectJ注解开发AspectJ 允许使用注解定义切面、切入点和增强处理，Spring 框架可以根据这些注解生成 AOP 代理。 名称 说明 @Aspect 用于定义一个切面。 @Pointcut 用于定义一个切入点。 @Before 用于定义前置通知，相当于 BeforeAdvice。 @AfterReturning 用于定义后置通知，相当于 AfterReturningAdvice。 @Around 用于定义环绕通知，相当于MethodInterceptor。 @AfterThrowing 用于定义抛出通知，相当于ThrowAdvice。 @After 用于定义最终final通知，不管是否异常，该通知都会执行。 @DeclareParents 用于定义引介通知，相当于IntroductionInterceptor（不要求掌握）。 启用 @AspectJ 注解有以下两种方法： 1）使用@Configuration和@EnableAspectJAutoProxy注解1234@Configuration @EnableAspectJAutoProxypublic class Appconfig &#123;&#125; 2）基于XML配置在 XML 文件中添加以下内容启用 @AspectJ。 1&lt;aop:aspectj-autoproxy&gt; 定义切面@AspectAspectJ 类和其它普通的 Bean 一样，可以有方法和字段，不同的是 AspectJ 类需要使用 @Aspect 注解，如下所示。 123@Aspectpublic class AspectModule &#123;&#125; AspectJ 类也可以像其它 Bean 一样在 XML 中配置，如下。 123&lt;bean id = &quot;myAspect&quot; class = &quot;net.biancheng.AspectModule&quot;&gt; ...&lt;/bean&gt; 定义切入点@Pointcut@Pointcut 注解用来定义一个切入点，如下。 1234// 要求：方法必须是private，返回值类型为void，名称自定义，没有参数@Pointcut(&quot;execution(* net.biancheng.*.*(..))&quot;)private void myPointCut() &#123;&#125; 相当于以下代码 1&lt;aop:pointcut expression=&quot;execution(* net.biancheng.*.*(..))&quot; id=&quot;myPointCut&quot;/&gt; 定义通知advice@AspectJ 支持 5 种类型的 advice，以下为使用 @Before 的示例。 1234@Before(&quot;myPointCut()&quot;)public void beforeAdvice()&#123; ...&#125; 示例Logging 类代码如下。 123456789101112131415161718192021222324252627@Aspectpublic class Logging &#123; // 定义切入点 @Pointcut(&quot;execution(* net.biancheng.*.*(..))&quot;) private void selectAll() &#123; &#125; // 前置通知 @Before(&quot;selectAll()&quot;) public void beforeAdvice() &#123; System.out.println(&quot;前置通知&quot;); &#125; // 后置通知 @After(&quot;selectAll()&quot;) public void afterAdvice() &#123; System.out.println(&quot;后置通知&quot;); &#125; // 返回后通知 @AfterReturning(pointcut = &quot;selectAll()&quot;, returning = &quot;retVal&quot;) public void afterReturningAdvice(Object retVal) &#123; System.out.println(&quot;返回值为：&quot; + retVal.toString()); &#125; // 抛出异常通知 @AfterThrowing(pointcut = &quot;selectAll()&quot;, throwing = &quot;ex&quot;) public void afterThrowingAdvice(IllegalArgumentException ex) &#123; System.out.println(&quot;这里的异常为：&quot; + ex.toString()); &#125;&#125; Man 类代码如下。 123456789public class Man &#123; private String name; private int age; ... public void throwException() &#123; System.out.println(&quot;抛出异常&quot;); throw new IllegalArgumentException(); &#125;&#125; Beans.xml 代码如下。 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean id=&quot;man&quot; class=&quot;net.biancheng.Man&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;bianchengbang&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;logging&quot; class=&quot;net.biancheng.Logging&quot; /&gt;&lt;/beans&gt; MainApp 类代码如下。 123456789public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); Man man = (Man) context.getBean(&quot;man&quot;); man.getName(); man.getAge(); man.throwException(); &#125;&#125; 运行结果如下。 12345678910前置通知后置通知返回值为：bianchengbang前置通知后置通知返回值为：12前置通知抛出异常后置通知这里的异常为：java.lang.IllegalArgumentException Spring JdbcTemplate类Spring 针对数据库开发提供了 JdbcTemplate 类，该类封装了 JDBC，支持对数据库的所有操作。 JdbcTemplate 位于 spring-jdbc-x.x.x.jar 包中，其全限定命名为 org.springframework.jdbc.core.JdbcTemplate。此外使用 JdbcTemplate 还需要导入 spring-tx-x.x.x.jar 包，该包用来处理事务和异常。 在 Spring 中，JDBC 的相关信息在配置文件中完成，其配置模板如下所示。 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http:/www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--连接数据库的url--&gt; &lt;property name= &quot;url&quot; value=&quot;jdbc:mysql://localhost/xx&quot; /&gt; &lt;!--连接数据库的用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;!--连接数据库的密码--&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--默认必须使用数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--配置注入类--&gt; &lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt; ...&lt;/beans&gt; 上述代码中定义了 3 个 Bean，分别是 dataSource、jdbcTemplate 和需要注入类的 Bean。 其中 dataSource 对应的是 DriverManagerDataSource 类，用于对数据源进行配置； jdbcTemplate 对应 JdbcTemplate 类，该类中定义了 JdbcTemplate 的相关配置。 在 dataSource 中，定义了 4 个连接数据库的属性，如下表所示。 属性名 说明 driverClassName 所使用的驱动名称，对应驱动 JAR 包中的 Driver 类 url 数据源所在地址 username 访问数据库的用户名 password 访问数据库的密码 如果数据库不在本地，则需要将 localhost 替换成相应的主机 IP。 在定义 JdbcTemplate 时，需要将 dataSource 注入到 JdbcTemplate 中。而在其他的类中要使用 JdbcTemplate，也需要将 JdbcTemplate 注入到使用类中（通常注入 dao 类中）。 在 JdbcTemplate 类中，提供了大量的查询和更新数据库的方法，如 query()、update() 等，如下表所示。 方法 说明 public int update(String sql) 用于执行新增、修改、删除等语句 args 表示需要传入到 query 中的参数 public int update(String sql,Object… args) public void execute(String sql) 可以执行任意 SQL，一般用于执行 DDL 语句 action 表示执行完 SQL 语句后，要调用的函数 public T execute(String sql, PreparedStatementCallback action) public T query(String sql, ResultSetExtractor rse) 用于执行查询语句 以 ResultSetExtractor 作为参数的 query 方法返回值为 Object，使用查询结果需要对其进行强制转型 以 RowMapper 作为参数的 query 方法返回值为 List public List query(String sql, RowMapper rse) 示例User 类代码如下。 12345678public class User &#123; private int id; private String name; private int age; public User() &#123;&#125; public User(String name, Integer age) &#123;this.name = name;this.age = age;&#125; // 省略set和get方法&#125; UserDao 代码如下。 12345678public interface UserDao &#123; // 初始化User表 void createUserTable(); // 保存用户 void saveUser(User user); // 查询用户 List&lt;User&gt; listUser();&#125; UserDaoImpl 代码如下。 1234567891011121314151617181920212223242526272829303132333435public class UserDaoImpl implements UserDao &#123; private JdbcTemplate jdbcTemplate; private UserDao userDao; public JdbcTemplate getJdbcTemplate() &#123;return jdbcTemplate;&#125; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public UserDao getUserDao() &#123;return userDao;&#125; public void setUserDao(UserDao userDao) &#123;this.userDao = userDao;&#125; public void setDataSource(DataSource datasource) &#123; this.jdbcTemplate = new JdbcTemplate(datasource); &#125; @Override public void createUserTable() &#123; this.jdbcTemplate.execute(&quot;CREATE TABLE `user` (\\r &quot; + &quot; `id` int(11) NOT NULL AUTO_INCREMENT,\\r &quot; + &quot; `name` varchar(50) DEFAULT NULL,\\r &quot; + &quot; `age` int(11) DEFAULT NULL,\\r &quot; + &quot; PRIMARY KEY (`id`)\\r &quot; + &quot;) ENGINE=MyISAM DEFAULT CHARSET=utf8;&quot;); &#125; @Override public void saveUser(User user) &#123; this.jdbcTemplate.update(&quot;INSERT INTO USER(NAME,age) VALUES (?,?)&quot;, user.getName(), user.getAge()); &#125; @Override public List&lt;User&gt; listUser() &#123; List&lt;User&gt; users = this.jdbcTemplate.query(&quot;SELECT NAME,age FROM USER&quot;, new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setName(rs.getString(&quot;name&quot;)); user.setAge(rs.getInt(&quot;age&quot;)); return user; &#125; &#125;); return users; &#125;&#125; Beans.xml 代码如下。 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--数据库驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--连接数据库的url --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/test&quot; /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--默认必须使用数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;userdao&quot; class=&quot;net.biancheng.UserDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp 类代码如下。 12345678910111213public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserDao dao = (UserDao) ctx.getBean(&quot;userdao&quot;); dao.createUserTable(); dao.saveUser(new User(&quot;bianchengbang&quot;, 12)); dao.saveUser(new User(&quot;baidu&quot;, 18)); List&lt;User&gt; users = dao.listUser(); for (User user : users) &#123; System.out.println(&quot;姓名：&quot; + user.getName() + &quot;\\t年龄：&quot; + user.getAge()); &#125; &#125;&#125; 运行结果如下。 12姓名：bianchengbang 年龄：12姓名：baidu 年龄：18 Spring集成Log4J日志是应用软件中不可缺少的部分，Apache 的开源项目 Log4J 是一个功能强大的日志组件。在 Spring 中使用 Log4J 是非常容易的，下面通过例子演示 Log4J 和 Spring 的集成。 使用 Log4J 之前，需要先导入 log4j-x.y.z.jar 包 示例HelloWorld 类代码如下。 12345public class HelloWorld &#123; private String message; public void setMessage(String message) &#123;this.message = message;&#125; public void getMessage() &#123;System.out.println(&quot;消息：&quot; + message);&#125;&#125; MainApp 类代码如下。 12345678910public class MainApp &#123; static Logger log = Logger.getLogger(MainApp.class.getName()); public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); log.info(&quot;Going to create HelloWord Obj&quot;); HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;); obj.getMessage(); log.info(&quot;Exiting the program&quot;); &#125;&#125; Beans.xml 代码如下。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;net.biancheng.HelloWorld&quot;&gt; &lt;property name=&quot;message&quot; value=&quot;Hello,bianchengbang!&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; log4j.properties 内容如下。 123456789101112131415# Define the root logger with appender filelog4j.rootLogger = DEBUG, FILE# Define the file appenderlog4j.appender.FILE=org.apache.log4j.FileAppender# Set the name of the filelog4j.appender.FILE.File=D:\\\\log.out# Set the immediate flush to true (default)log4j.appender.FILE.ImmediateFlush=true# Set the threshold to debug modelog4j.appender.FILE.Threshold=debug# Set the append to false, overwritelog4j.appender.FILE.Append=false# Define the layout for file appenderlog4j.appender.FILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.FILE.layout.conversionPattern=%m%n 运行结果如下。 1消息：Hello,bianchengbang! log.out 文件内容如下。 12Going to create HelloWord ObjExiting the program Spring事务（Transaction）事务（Transaction）是面向关系型数据库（RDBMS）企业应用程序的重要组成部分，用来确保数据的完整性和一致性。 事务具有以下 4 个特性，即原子性、一致性、隔离性和持久性，这 4 个属性称为 ACID 特性。 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。 一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。 隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。 持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。 编程式和声明式Spring 的事务管理有 2 种方式： 传统的编程式事务管理，即通过编写代码实现的事务管理； 基于 AOP 技术实现的声明式事务管理。 1. 编程式事务管理编程式事务管理是通过编写代码实现的事务管理，灵活性高，但难以维护。 2. 声明式事务管理Spring 声明式事务管理在底层采用了 AOP 技术，其最大的优点在于无须通过编程的方式管理事务，只需要在配置文件中进行相关的规则声明，就可以将事务规则应用到业务逻辑中。 Spring 实现声明式事务管理主要有 2 种方式： 基于 XML 方式的声明式事务管理。 通过 Annotation 注解方式的事务管理。 显然声明式事务管理要优于编程式事务管理。 事务管理接口PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 是事务的 3 个核心接口。 PlatformTransactionManager接口PlatformTransactionManager 接口用于管理事务，接口定义如下： 12345public interface PlatformTransactionManager &#123; TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException;&#125; 该接口中方法说明如下： 名称 说明 TransactionStatus getTransaction(TransactionDefinition definition) 用于获取事务的状态信息 void commit(TransactionStatus status) 用于提交事务 void rollback(TransactionStatus status) 用于回滚事务 在项目中，Spring 将 xml 中配置的事务信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。 TransactionDefinition接口TransactionDefinition 接口提供了获取事务相关信息的方法，接口定义如下。 1234567public interface TransactionDefinition &#123; int getPropagationBehavior(); int getIsolationLevel(); String getName(); int getTimeout(); boolean isReadOnly();&#125; 该接口中方法说明如下。 方法 说明 String getName() 获取事务的名称 int getIsolationLevel() 获取事务的隔离级别 int getPropagationBehavior() 获取事务的传播行为 int getTimeout() 获取事务的超时时间 boolean isReadOnly() 获取事务是否只读 以下是隔离级别的值。 方法 说明 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 允许读取尚未提交的更改，可能导致脏读、幻读和不可重复读 ISOLATION_READ_COMMITTED （Oracle 默认级别）允许读取已提交的并发事务，防止脏读，可能出现幻读和不可重复读 ISOLATION_REPEATABLE_READ （MySQL 默认级别），多次读取相同字段的结果是一致的，防止脏读和不可重复读，可能出现幻读 ISOLATION_SERIALIZABLE 完全服从 ACID 的隔离级别，防止脏读、不可重复读和幻读 以下是传播行为的可能值，传播行为用来控制是否需要创建事务以及如何创建事务。 名称 说明 PROPAGATION_MANDATORY 支持当前事务，如果不存在当前事务，则引发异常 PROPAGATION_NESTED 如果当前事务存在，则在嵌套事务中执行 PROPAGATION_NEVER 不支持当前事务，如果当前事务存在，则引发异常 PROPAGATION_NOT_SUPPORTED 不支持当前事务，始终以非事务方式执行 PROPAGATION_REQUIRED 默认传播行为，支持当前事务，如果不存在，则创建一个新的 PROPAGATION_REQUIRES_NEW 创建新事务，如果已经存在事务则暂停当前事务 PROPAGATION_SUPPORTS 支持当前事务，如果不存在事务，则以非事务方式执行 TransactionStatus接口TransactionStatus 接口提供了一些简单的方法来控制事务的执行和查询事务的状态，接口定义如下。 1234567public interface TransactionStatus extends SavepointManager &#123; boolean isNewTransaction(); boolean hasSavepoint(); void setRollbackOnly(); boolean isRollbackOnly(); boolean isCompleted();&#125; 该接口中方法说明如下。 名称 说明 boolean hasSavepoint() 获取是否存在保存点 boolean isCompleted() 获取事务是否完成 boolean isNewTransaction() 获取是否是新事务 boolean isRollbackOnly() 获取事务是否回滚 void setRollbackOnly() 设置事务回滚 Spring编程式事务管理编程式事务管理是通过编写代码实现的事务管理，包括定义事务的开始、正常执行后的事务提交和异常时的事务回滚。 Spring 出现以前，编程式事务管理是基于 POJO 应用的唯一选择。在 Hibernate 中，我们需要在代码中显式调用 beginTransaction()、commit()、rollback() 等事务管理相关的方法，这就是编程式事务管理。而通过 Spring 提供的事务管理 API，我们可以在代码中灵活控制事务的执行。 示例User 类代码如下。 12345678public class User &#123; private int id; private String name; private int age; public User() &#123;&#125; public User(String name, Integer age) &#123;this.name = name;this.age = age;&#125; // 省略set和get方法&#125; UserDao 代码如下。 12345678public interface UserDao &#123; // 初始化User表 void createUserTable(); // 保存用户 void saveUser(User user); // 查询用户 List&lt;User&gt; listUser();&#125; UserDaoImpl 代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UserDaoImpl implements UserDao &#123; private JdbcTemplate jdbcTemplate; private UserDao userDao; private PlatformTransactionManager transactionManager; public JdbcTemplate getJdbcTemplate() &#123;return jdbcTemplate;&#125; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public UserDao getUserDao() &#123;return userDao;&#125; public void setUserDao(UserDao userDao) &#123;this.userDao = userDao;&#125; public void setDataSource(DataSource datasource) &#123; this.jdbcTemplate = new JdbcTemplate(datasource); &#125; public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;this.transactionManager = transactionManager;&#125; @Override public void createUserTable() &#123; this.jdbcTemplate.execute(&quot;CREATE TABLE `user` (\\r &quot; + &quot; `id` int(11) NOT NULL AUTO_INCREMENT,\\r &quot; + &quot; `name` varchar(50) DEFAULT NULL,\\r &quot; + &quot; `age` int(11) DEFAULT NULL,\\r &quot; + &quot; PRIMARY KEY (`id`)\\r &quot; + &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;); &#125; @Override public void saveUser(User user) &#123; TransactionDefinition def = new DefaultTransactionDefinition(); // getTransaction()用于启动事务，返回TransactionStatus实例对象 TransactionStatus status = transactionManager.getTransaction(def); try &#123; this.jdbcTemplate.update(&quot;INSERT INTO USER(NAME,age) VALUES (?,?)&quot;, user.getName(), user.getAge()); transactionManager.commit(status); System.out.println(&quot;commit!&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;Error in creating record, rolling back&quot;); transactionManager.rollback(status); throw e; &#125; &#125; @Override public List&lt;User&gt; listUser() &#123; List&lt;User&gt; users = this.jdbcTemplate.query(&quot;SELECT NAME,age FROM USER&quot;, new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setName(rs.getString(&quot;name&quot;)); user.setAge(rs.getInt(&quot;age&quot;)); return user; &#125; &#125;); return users; &#125;&#125; Beans.xml 代码如下。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--数据库驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--连接数据库的url --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/test&quot; /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--默认必须使用数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;userdao&quot; class=&quot;net.biancheng.UserDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp 类代码如下。 12345678910111213public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserDao dao = (UserDao) ctx.getBean(&quot;userdao&quot;); dao.createUserTable(); dao.saveUser(new User(&quot;bianchengbang&quot;, 12)); dao.saveUser(new User(&quot;baidu&quot;, 18)); List&lt;User&gt; users = dao.listUser(); for (User user : users) &#123; System.out.println(&quot;姓名：&quot; + user.getName() + &quot;\\t年龄：&quot; + user.getAge()); &#125; &#125;&#125; 事务提交，运行结果如下。 1234commit!commit!姓名：bianchengbang 年龄：12姓名：baidu 年龄：18 Spring基于XML实现事务管理Spring 声明式事务管理是通过 AOP 实现的，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 声明式事务最大的优点就是不需要通过编程的方式管理事务，可以将业务逻辑代码和事务管理代码很好的分开。 Spring 实现声明式事务管理主要有 2 种方式： 基于 XML 方式的声明式事务管理。 通过 Annotation 注解方式的事务管理。 下面介绍如何通过 XML 的方式实现声明式事务管理，步骤如下。 示例User 类代码如下。 12345678public class User &#123; private int id; private String name; private int age; public User() &#123;&#125; public User(String name, Integer age) &#123;this.name = name;this.age = age;&#125; // 省略set和get方法&#125; UserDao 代码如下。 12345678public interface UserDao &#123; // 初始化User表 void createUserTable(); // 保存用户 void saveUser(User user); // 查询用户 List&lt;User&gt; listUser();&#125; UserDaoImpl 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041public class UserDaoImpl implements UserDao &#123; private JdbcTemplate jdbcTemplate; private UserDao userDao; public JdbcTemplate getJdbcTemplate() &#123;return jdbcTemplate;&#125; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public UserDao getUserDao() &#123; return userDao;&#125; public void setUserDao(UserDao userDao) &#123;this.userDao = userDao;&#125; public void setDataSource(DataSource datasource) &#123; this.jdbcTemplate = new JdbcTemplate(datasource); &#125; @Override public void createUserTable() &#123; this.jdbcTemplate.execute(&quot;CREATE TABLE `user` (\\r &quot; + &quot; `id` int(11) NOT NULL AUTO_INCREMENT,\\r &quot; + &quot; `name` varchar(50) DEFAULT NULL,\\r &quot; + &quot; `age` int(4) DEFAULT NULL,\\r &quot; + &quot; PRIMARY KEY (`id`)\\r &quot; + &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;); &#125; @Override public void saveUser(User user) &#123; try &#123; this.jdbcTemplate.update(&quot;INSERT INTO USER(NAME,age) VALUES (?,?)&quot;, user.getName(), user.getAge()); throw new RuntimeException(&quot;simulate Error condition&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;Error in creating record, rolling back&quot;); throw e; &#125; &#125; @Override public List&lt;User&gt; listUser() &#123; List&lt;User&gt; users = this.jdbcTemplate.query(&quot;SELECT NAME,age FROM USER&quot;, new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setName(rs.getString(&quot;name&quot;)); user.setAge(rs.getInt(&quot;age&quot;)); return user; &#125; &#125;); return users; &#125;&#125; Beans.xml 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--数据库驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--连接数据库的url --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/test&quot; /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; readOnly = &quot;false&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt; &lt;aop:config&gt; &lt;!-- 切入点，execution 定义的表达式表示net.biencheng包下的所有类所有方法都应用该是事务 --&gt; &lt;aop:pointcut id=&quot;createOperation&quot; expression=&quot;execution(* net.biancheng.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;createOperation&quot; /&gt; &lt;/aop:config&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;userdao&quot; class=&quot;net.biancheng.UserDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp 类代码如下。 12345678910111213public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserDao dao = (UserDao) ctx.getBean(&quot;userdao&quot;); dao.createUserTable(); dao.saveUser(new User(&quot;bianchengbang&quot;, 12)); dao.saveUser(new User(&quot;baidu&quot;, 18)); List&lt;User&gt; users = dao.listUser(); for (User user : users) &#123; System.out.println(&quot;姓名：&quot; + user.getName() + &quot;\\t年龄：&quot; + user.getAge()); &#125; &#125;&#125; 运行结果如下。 123Error in creating record, rolling backException in thread &quot;main&quot; java.lang.RuntimeException: simulate Error condition... Spring基于注解实现事务管理在 Spring 中，声明式事务除了可以使用 XML 实现外，还可以使用 Annotation 注解。使用注解实现可以减少代码之间的耦合度。 使用 Annotation 的方式非常简单，只需要在项目中做两件事，具体如下。 1）在 Spring 容器中注册驱动，代码如下所示：1&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; 2）在需要使用事务的业务类或者方法中添加注解 @Transactional，并配置 @Transactional 的参数。 常用属性说明如下： propagation：设置事务的传播行为； isolation：设置事务的隔离级别； readOnly：设置是读写事务还是只读事务； timeout：事务超时事件（单位：s）。 示例User 类代码如下。 12345678public class User &#123; private int id; private String name; private int age; public User() &#123;&#125; public User(String name, Integer age) &#123;this.name = name;this.age = age;&#125; // 省略set和get方法&#125; UserDao 代码如下。 12345678public interface UserDao &#123; // 初始化User表 void createUserTable(); // 保存用户 void saveUser(User user); // 查询用户 List&lt;User&gt; listUser();&#125; UserDaoImpl 代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)public class UserDaoImpl implements UserDao &#123; private JdbcTemplate jdbcTemplate; private UserDao userDao; public JdbcTemplate getJdbcTemplate() &#123;return jdbcTemplate;&#125; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public UserDao getUserDao() &#123;return userDao;&#125; public void setUserDao(UserDao userDao) &#123;this.userDao = userDao;&#125; public void setDataSource(DataSource datasource) &#123; this.jdbcTemplate = new JdbcTemplate(datasource); &#125; @Override public void createUserTable() &#123; this.jdbcTemplate.execute(&quot;CREATE TABLE `user` (\\r &quot; + &quot; `id` int(11) NOT NULL AUTO_INCREMENT,\\r &quot; + &quot; `name` varchar(50) DEFAULT NULL,\\r &quot; + &quot; `age` int(4) DEFAULT NULL,\\r &quot; + &quot; PRIMARY KEY (`id`)\\r &quot; + &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;); &#125; @Override public void saveUser(User user) &#123; try &#123; this.jdbcTemplate.update(&quot;INSERT INTO USER(NAME,age) VALUES (?,?)&quot;, user.getName(), user.getAge()); this.jdbcTemplate.update(&quot;INSERT INTO USER(NAME,age) VALUES (?,?)&quot;, &quot;google&quot;, 16); throw new RuntimeException(&quot;simulate Error condition&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;Error in creating record, rolling back&quot;); throw e; &#125; &#125; @Override public List&lt;User&gt; listUser() &#123; List&lt;User&gt; users = this.jdbcTemplate.query(&quot;SELECT NAME,age FROM USER&quot;, new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setName(rs.getString(&quot;name&quot;)); user.setAge(rs.getInt(&quot;age&quot;)); return user; &#125; &#125;); return users; &#125;&#125; @Transactional 注解的参数之间用“，”进行分隔 Beans.xml 代码如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--数据库驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--连接数据库的url --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/test&quot; /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;userdao&quot; class=&quot;net.biancheng.UserDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt; &lt;!-- 注册事务管理驱动 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;&lt;/beans&gt; MainApp 类代码如下。 12345678910111213public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserDao dao = (UserDao) ctx.getBean(&quot;userdao&quot;); dao.createUserTable(); dao.saveUser(new User(&quot;bianchengbang&quot;, 12)); dao.saveUser(new User(&quot;baidu&quot;, 18)); List&lt;User&gt; users = dao.listUser(); for (User user : users) &#123; System.out.println(&quot;姓名：&quot; + user.getName() + &quot;\\t年龄：&quot; + user.getAge()); &#125; &#125;&#125; 运行结果如下。 123Error in creating record, rolling backException in thread &quot;main&quot; java.lang.RuntimeException: simulate Error condition... SpEL表达式语言（Spring）Spring Expression Language（简称 SpEL）是一种功能强大的表达式语言，支持运行时查询和操作对象图 。表达式语言一般是用最简单的形式完成最主要的工作，以此减少工作量。 Java 有许多可用的表达式语言，例如 JSP EL，OGNL，MVEL 和 JBoss EL，SpEL 语法类似于 JSP EL，功能类似于 Struts2 中的 OGNL，能在运行时构建复杂表达式、存取对象图属性、调用对象方法等，并且能与 Spring 功能完美整合，如 SpEL 可以用来配置 Bean 定义。 SpEL 并不与 Spring 直接相关，可以被独立使用。SpEL 表达式的创建是为了向 Spring 社区提供一种受良好支持的表达式语言，该语言适用于 Spring 家族中的所有产品。也就是说，SpEL 是一种与技术无关的 API，可以集成其它表达式语言。 SpEL 提供了以下接口和类： Expression interface：该接口负责评估表达式字符串 ExpressionParser interface：该接口负责解析字符串 EvaluationContext interface：该接口负责定义上下文环境 SpEL 支持如下表达式： 1. 基本表达式字面量表达式、关系、逻辑与算术运算表达式、字符串连接及截取表达式、三目运算表达式、正则表达式、括号优先级表达式； 2. 类相关表达式类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 3. 集合相关表达式内联 List、内联数组、集合、字典访问、列表、字典、数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义； 4. 其他表达式模板表达式。 注：SpEL 表达式中的关键字不区分大小写。 示例例 1下面使用 SpEL 输出一个简单的字符串“Hello，编程帮”。 12345678910111213public class Test &#123; public static void main(String[] args) &#123; // 构造解析器 ExpressionParser parser = new SpelExpressionParser(); // 解析器解析字符串表达式 Expression exp = parser.parseExpression(&quot;&#x27;Hello，编程帮&#x27;&quot;); // 获取表达式的值 String message = (String) exp.getValue(); System.out.println(message); // OR // System.out.println(parser.parseExpression(&quot;&#x27;Hello，编程帮&#x27;&quot;).getValue()); &#125;&#125; 输出结果如下。 1Hello，编程帮 SpEL 还可以调用方法、访问属性和调用构造函数。 例 2使用 SpEL 调用 concat() 方法，代码如下。 12345678public class Test &#123; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(&quot;&#x27;Welcome，编程帮&#x27;.concat(&#x27;！&#x27;)&quot;); String message = (String) exp.getValue(); System.out.println(message); &#125;&#125; 输出结果如下。 1Welcome，编程帮！ 例 3使用 SpEL 调用 String 的属性 bytes，将字符串转换为字节数组，代码如下。 12345678910public class Test &#123; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(&quot;&#x27;Hello 编程帮&#x27;.bytes&quot;); byte[] bytes = (byte[]) exp.getValue(); for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.print(bytes[i] + &quot; &quot;); &#125; &#125;&#125; 输出结果如下。 172 101 108 108 111 32 -79 -32 -77 -52 -80 -17 例 4SpEL 还支持使用嵌套属性，下面将字符串转换为字节后获取长度，代码如下。 12345678public class Test &#123; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(&quot;&#x27;Hello 编程帮&#x27;.bytes.length&quot;); int length = (Integer) exp.getValue(); System.out.println(length); &#125;&#125; 输出结果如下。 112 例 5字符串的构造函数可以被调用，而不是使用字符串文本，下面将字符串内容转换为大写字母，代码如下。 1234567891011public class Test &#123; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(&quot;new String(&#x27;hello bianchengbang&#x27;).toUpperCase()&quot;); String message = exp.getValue(String.class); System.out.println(message); // OR // System.out.println(parser.parseExpression(&quot;&#x27;hello // bianchengbang&#x27;.toUpperCase()&quot;).getValue()); &#125;&#125; 输出结果如下。 1HELLO BIANCHENGBANG SpEL对Bean定义的支持SpEL 表达式可以与 XML 或基于注解的配置元数据一起使用，SpEL 表达式以#&#123;开头，以&#125;结尾，如#&#123;&#39;Hello&#39;&#125;。 1. 基于XML的配置可以使用以下表达式来设置属性或构造函数的参数值。 123&lt;bean id=&quot;number&quot; class=&quot;net.biancheng.Number&quot;&gt; &lt;property name=&quot;randomNumber&quot; value=&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;/&gt;&lt;/bean&gt; 也可以通过名称引用其它 Bean 属性，如以下代码。 123&lt;bean id=&quot;shapeGuess&quot; class=&quot;net.biancheng.ShapeGuess&quot;&gt; &lt;property name=&quot;shapSeed&quot; value=&quot;#&#123;number.randomNumber&#125;&quot;/&gt;&lt;/bean&gt; 2. 基于注解的配置@Value 注解可以放在字段、方法、以及构造函数参数上，以指定默认值。 以下是一个设置字段变量默认值的例子。 12345678public static class FieldValueTestBean @value(&quot;#&#123; systemProperties[ &#x27;user.region&#x27;] &#125;&quot;) private String defaultLocale; public void setDefaultLocale (String defaultLocale) &#123; this.defaultLocale = defaultLocale; &#125; public string getDefaultLocale() &#123;return this.defaultLocale;&#125;&#125; SpEL中的运算符我们可以在 SpEL 中使用运算符，例如算术运算符、关系运算符、逻辑运算符。 例 612345678910111213public class Test &#123; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); // 算术运算符 System.out.println(parser.parseExpression(&quot;&#x27;Hello SPEL&#x27;+&#x27;!&#x27;&quot;).getValue()); System.out.println(parser.parseExpression(&quot;10 * 10/2&quot;).getValue()); System.out.println(parser.parseExpression(&quot;&#x27;今天是：&#x27;+ new java.util.Date()&quot;).getValue()); // 逻辑运算符 System.out.println(parser.parseExpression(&quot;true and true&quot;).getValue()); // 关系运算符 System.out.println(parser.parseExpression(&quot;&#x27;sonoo&#x27;.length()==5&quot;).getValue()); &#125;&#125; 输出结果为 12345Hello SPEL!50今天是：Fri Feb 05 09:31:46 CST 2021truetrue SpEL中的变量在 SpEL 中，我们可以定义变量，并在方法中使用。定义变量需要用到 StandardEvaluationContext 类。 例 7Calculation 类代码如下。 123456public class Calculation &#123; private int number; public int getNumber() &#123;return number;&#125; public void setNumber(int number) &#123;this.number = number;&#125; public int cube() &#123;return number * number * number;&#125;&#125; Test 类代码如下。 123456789public class Test &#123; public static void main(String[] args) &#123; Calculation calculation = new Calculation(); StandardEvaluationContext context = new StandardEvaluationContext(calculation); ExpressionParser parser = new SpelExpressionParser(); parser.parseExpression(&quot;number&quot;).setValue(context, &quot;5&quot;); System.out.println(calculation.cube()); &#125;&#125; Spring的优缺点Spring的优点1.降低了组件之间的耦合性,实现了软件各层之间的解耦.2.可以使用容器提供的众多服务,如事务管理,消息服务等.3.容器提供单利模式支持.4.容器提供了AOP技术,利用它可以很容易实现的一些拦截,如权限拦截,运行期监控等.5.容器提供了AOP技术,利用它可以很容易实现运行拦截,如权限拦截,运行期监控等.6.spring对于主流的应用框架提供了很好的支持,例如mybatis等.7.spring属于低入侵设计8.独立各种应用服务器9.spring的DI机制减低了业务对象替换的复杂性.10.spring的高开放性,并不强制应用于完全依赖于它,开发者可以自由选择spring的部分或者全部. Spring的缺点使用了大量的反射机制，反射机制非常占用内存。 SpringIoc实现机制我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。 1. 依赖倒置假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。 这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改。 同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。 这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。 2. 控制反转（Inversion of Control）就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。其实这些概念初次接触都会感到云里雾里的。说穿了，这几种概念的关系大概如下： 为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class：车、车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下： 这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改： 由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动： 由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要修改整个上层所有类的构造函数！在软件工程中，这样的设计几乎是不可维护的——在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。所以我们需要进行控制反转（IOC），及上层控制下层，而不是下层控制着上层。 我们用依赖注入（Dependency Injection）这种方式来实现控制反转。所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。这里我们用构造方法传递的依赖注入方式重新写车类的定义： 这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改： 看到没？这里我只需要修改轮胎类就行了，不用修改其他任何上层类。这显然是更容易维护的代码。不仅如此，在实际的工程中，这种设计模式还有利于不同组的协同合作和单元测试：比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，四个不同的组可以同时进行开发而不相互受限制。 对于单元测试，如果我们要写Car类的单元测试，就只需要Mock一下Framework类传入Car就行了，而不用把Framework、Bottom、Tire全部new一遍再来构造Car。这里我们是采用的构造函数传入的方式进行的依赖注入。其实还有另外两种方法：Setter传递和接口传递。这里就不多讲了，核心思路都是一样的，都是为了实现控制反转。 3. 控制反转容器(IOC Container)其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。 显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IOC容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码。这是引入IOC Container的第一个好处。IOC Container的第二个好处是：我们在创建实例的时候不需要了解其中的细节。在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的： 这个过程中，我们需要了解整个Car&#x2F;Framework&#x2F;Bottom&#x2F;Tire类构造函数是怎么定义的，才能一步一步new注入。而IOC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）： 注解1.@Configuration注解该类等价与XML中配置beans，相当于Ioc容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean，与xml中配置的bean意思一样。 @Configuration注解的类必需使用&lt;context:component-scan base-package&#x3D;”XXX” &#x2F;&gt;扫描.如下： 12345678910111213@Configurationpublic class MainConfig &#123;//在properties文件里配置 @Value(&quot;$&#123;wx_appid&#125;&quot;)public String appid; protected MainConfig()&#123;&#125; @Bean public WxMpService wxMpService() &#123; WxMpService wxMpService = new WxMpServiceImpl(); wxMpService.setWxMpConfigStorage(wxMpConfigStorage()); return wxMpService;&#125;&#125; 定义一个MainConfig，用@Configuration注解，那MainConfig相当于xml里的beans,里面用@Bean注解的和xml里定义的bean等价，用&lt;context:component-scanbase-package&#x3D;”XXX”&#x2F;&gt;扫描该类，最终我们可以在程序里用@AutoWired或@Resource注解取得用@Bean注解的bean，和用xml先配置bean然后在程序里自动注入一样。目的是减少xml里配置。 2.@Value注解为了简化从properties里取配置，可以使用@Value, 可以properties文件中的配置值。 在dispatcher-servlet.xml里引入properties文件。 1&lt;context:property-placeholder location=&quot;classpath:test.properties&quot; /&gt; 在程序里使用@Value: @Value(“${wx_appid}”) public String appid; 即使给变量赋了初值也会以配置文件的值为准。 3.@Controller, @Service, @Repository,@Component目前4种注解意思是一样，并没有什么区别，区别只是名字不同。使用方法： 1.使用&lt;context:component-scanbase-package&#x3D;”XXX”&#x2F;&gt;扫描被注解的类 2.在类上写注解： @Controller public class TestController { } 4.@PostConstruct 和 @PreDestory实现初始化和销毁bean之前进行的操作，只能有一个方法可以用此注释进行注释，方法不能有参数，返回值必需是void,方法需要是非静态的。 12345678910public class TestService &#123; @PostConstruct public void init()&#123; System.out.println(&quot;初始化&quot;); &#125; @PreDestroy public void dostory()&#123; System.out.println(&quot;销毁&quot;); &#125; &#125; @PostConstruct：在构造方法和init方法（如果有的话）之间得到调用，且只会执行一次。 @PreDestory：注解的方法在destory()方法调用后得到执行。 引深一点，Spring 容器中的 Bean 是有生命周期的，Spring 允许在 Bean 在初始化完成后以及 Bean 销毁前执行特定的操作，常用的设定方式有以下三种： 1.通过实现 InitializingBean&#x2F;DisposableBean 接口来定制初始化之后&#x2F;销毁之前的操作方法； 2.通过 &lt;bean&gt; 元素的 init-method&#x2F;destroy-method属性指定初始化之后 &#x2F;销毁之前调用的操作方法； 3.在指定方法上加上@PostConstruct 或@PreDestroy注解来制定该方法是在初始化之后还是销毁之前调用 但他们之前并不等价。即使3个方法都用上了，也有先后顺序. Constructor &gt; @PostConstruct &gt;InitializingBean &gt; init-method 5.@Primary自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。 123456789101112131415161718192021222324@Component public class Apple implements Fruit&#123; @Override public String hello() &#123; return &quot;我是苹果&quot;; &#125; &#125;@Component @Primarypublic class Pear implements Fruit&#123; @Override public String hello(String lyrics) &#123; return &quot;梨子&quot;; &#125; &#125;public class FruitService &#123; //Fruit有2个实例子类，因为梨子用@Primary，那么会使用Pear注入 @Autowired private Fruit fruit; public String hello()&#123; return fruit.hello(); &#125; &#125; 6.@Lazy(true) 用于指定该Bean是否取消预初始化，用于注解类，延迟初始化。 7.@AutowiredAutowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。 1.可以手动指定按byName方式注入，使用@Qualifier。 &#x2F;&#x2F;通过此注解完成从spring配置文件中 查找满足Fruit的bean,然后按&#x2F;&#x2F;@Qualifier指定pean @Autowired @Qualifier(“pean”) public Fruit fruit; 2.如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required&#x3D;false) public Fruit fruit; 8.@Resource默认按 byName自动注入,如果找不到再按byType找bean,如果还是找不到则抛异常，无论按byName还是byType如果找到多个，则抛异常。 可以手动指定bean,它有2个属性分别是name和type，使用name属性，则使用byName的自动注入，而使用type属性时则使用byType自动注入。 @Resource(name&#x3D;”bean名字”)或@Resource(type&#x3D;”bean的class”) 这个注解是属于J2EE的，减少了与spring的耦合。 9.@Async java里使用线程用3种方法： 继承Thread，重写run方法 实现Runnable,重写run方法 使用Callable和Future接口创建线程，并能得到返回值。 前2种简单，第3种方式特别提示一下，例子如下： 12345678910111213class MyCallable implements Callable&lt;Integer&gt; &#123; private int i = 0; // 与run()方法不同的是，call()方法具有返回值 @Override public Integer call() &#123; int sum = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); sum += i; &#125; return sum; &#125;&#125; main方法： 1234567891011121314151617181920public static void main(String[] args) &#123; Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30) &#123; Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程 thread.start(); //线程进入到就绪状态 &#125; &#125; System.out.println(&quot;主线程for循环执行完毕..&quot;); try &#123; int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果 System.out.println(&quot;sum = &quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; 而使用**@Async可视为第4种方法。基于@Async标注的方法，称之为异步方法**,这个注解用于标注某个方法或某个类里面的所有方法都是需要异步处理的。 被注解的方法被调用的时候，会在新线程中执行，而调用它的方法会在原来的线程中执行。 application.xml形势的配置： 123456&lt;!--扫描注解，其中包括@Async --&gt;&lt;context:component-scan base-package=&quot;com.test&quot;/&gt;&lt;!-- 支持异步方法执行, 指定一个缺省的executor给@Async使用--&gt;&lt;task:annotation-driven executor=&quot;defaultAsyncExecutor&quot; /&gt; &lt;!—配置一个线程执行器--&gt;&lt;task:executor id=&quot; defaultAsyncExecutor &quot;pool-size=&quot;100-10000&quot; queue-capacity=&quot;10&quot; keep-alive =”5”/&gt; 参数解读： &lt;task:executor &#x2F;&gt;配置参数： id：当配置多个executor时，被@Async(“id”)指定使用；也被作为线程名的前缀。 pool-size： core size：最小的线程数，缺省：1 max size：最大的线程数，缺省：Integer.MAX_VALUE queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这时系统会拒绝这个任务并抛出TaskRejectedException异常（缺省配置的情况下，可以通过rejection-policy来决定如何处理这种情况）。缺省值为：Integer.MAX_VALUE keep-alive：超过core size的那些线程，任务完成后，再经过这个时长（秒）会被结束掉 rejection-policy：当pool已经达到max size的时候，如何处理新任务 ABORT（缺省）：抛出TaskRejectedException异常，然后不执行DISCARD：不执行，也不抛出异常 DISCARD_OLDEST：丢弃queue中最旧的那个任务 CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 第二步在类或方法上添加@Async，当调用该方法时，则该方法即是用异常执行的方法单独开个新线程执行。 12345678910@Async(“可以指定执行器id，也可以不指定”) public static void testAsyncVoid ()&#123; try &#123; //让程序暂停100秒，相当于执行一个很耗时的任务\tSystem.out.println(“异常执行打印字符串”); Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 上面方法是无返回值的情况，还有异常方法有返回值的例子。 123456789101112@Asyncpublic Future&lt;String&gt; testAsyncReturn () &#123; System.out.println(&quot;Execute method asynchronously - &quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(5000); return new AsyncResult&lt;String&gt;(&quot;hello world !!!!&quot;); &#125; catch (InterruptedException e) &#123; // &#125; return null; &#125; 返回的数据类型为Future类型，接口实现类是AsyncResult. 调用方法如下： 1234567891011public void test()&#123;\tFuture&lt;String&gt; future = cc.testAsyncReturn(); while (true) &#123; ///这里使用了循环判断，等待获取结果信息 if (future.isDone()) &#123; //判断是否执行完毕 System.out.println(&quot;Result from asynchronous process - &quot; + future.get()); break; &#125; System.out.println(&quot;Continue doing something else. &quot;); Thread.sleep(1000); &#125; &#125; 通过不停的检查Future的状态来获取当前的异步方法是否执行完毕 编程的方式使用@Async: 123456789101112131415161718192021@Configuration @EnableAsync public class SpringConfig &#123; private int corePoolSize = 10; private int maxPoolSize = 200; private int queueCapacity = 10; private String ThreadNamePrefix = &quot;MyLogExecutor-&quot;; @Bean public Executor logExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.setMaxPoolSize(maxPoolSize); executor.setQueueCapacity(queueCapacity); executor.setThreadNamePrefix(ThreadNamePrefix); // rejection-policy：当pool已经达到max size的时候，如何处理新任务 // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125; 10.@Named@Named和Spring的@Component功能相同。@Named可以有值，如果没有值生成的Bean名称默认和类名相同。比如 @Named public class Person 或@Named(“cc”) public class Person 11.@Inject使用@Inject需要引用javax.inject.jar，它与Spring没有关系，是jsr330规范。与@Autowired有互换性。 12.@Singleton只要在类上加上这个注解，就可以实现一个单例类，不需要自己手动编写单例实现类。 13.@Valid,@Valided@Valid网上一大片使用@Valid失效不能用的情况。为什么呢？ 1.@Valid必需使用在以@RequestBody接收参数的情况下。 2.使用ajax以POST方式提示数据，禁止用Fiddler以及浏览器直接访问的方式测试接口 3.用&lt;mvc:annotation-driven &#x2F;&gt;添加注解驱动。 4.@Valid是应用在javabean上的校验。 123456789101112131415161718&lt;groupId&gt;org.hibernate&lt;/groupId&gt;&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;version&gt;4.2.0.Final&lt;/version&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt;&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;&lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;&lt;version&gt;1.9.8&lt;/version&gt;&lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;&lt;artifactId&gt;jackson-module-jaxb-annotations&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt; 5.这些jar包是需要的。@Valid是使用hibernate validation的时候使用，可参数下面介绍的@RequestBody 6.@Valid下后面紧跟BindingResult result，验证结果保存在result 例如： 12345678910@RequestMapping(&quot;/test&quot;) public String testValid(@Valid User user, BindingResult result)&#123; if (result.hasErrors())&#123; List&lt;ObjectError&gt; errorList = result.getAllErrors(); for(ObjectError error : errorList)&#123; System.out.println(error.getDefaultMessage()); &#125; &#125; return &quot;test&quot;;&#125; 在入参User上添加了@Valid做校验，在User类里属性上实行实际的特定校验。 例如在User的name属性上加 @NotBlank private String name; 全部参数校验如下：空检查@Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查@AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查@Size(min&#x3D;, max&#x3D;) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min&#x3D;, max&#x3D;)验证注解的元素值长度在min和max区间内 日期检查@Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 数值检查建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为””,Integer为null @Min(value&#x3D;””) 验证 Number 和 String 对象是否大等于指定的值 @Max(value&#x3D;””) 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax(value&#x3D;值) 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin(value&#x3D;值) 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer&#x3D;,fraction&#x3D;)验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 @Range(min&#x3D;, max&#x3D;) 检查数字是否介于min和max之间. @Range(min&#x3D;10000,max&#x3D;50000,message&#x3D;”range.bean.wage”) private BigDecimal wage; @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang&#x3D;,script&#x3D;, alias&#x3D;) @URL(protocol&#x3D;,host&#x3D;,port&#x3D;,regexp&#x3D;, flags&#x3D;) @Validated@Valid是对javabean的校验，如果想对使用**@RequestParam方式接收参数方式校验使用@Validated** 使用@Validated的步骤： 第一步：定义全局异常，让该全局异常处理器能处理所以验证失败的情况，并返回给前台失败提示数据。如下，该类不用在任何xml里配置。 123456789101112131415@ControllerAdvice@Componentpublic class GlobalExceptionHandler &#123;\t@Bean\tpublic MethodValidationPostProcessor methodValidationPostProcessor() &#123; return new MethodValidationPostProcessor();\t&#125;\t@ExceptionHandler\t@ResponseBody\t@ResponseStatus(HttpStatus.BAD_REQUEST)\tpublic String handle(ValidationException exception) &#123; System.out.println(&quot;bad request, &quot; + exception.getMessage()); return &quot;bad request, &quot; + exception.getMessage();\t&#125;&#125; 第二步。在XXController.java头上添加@Validated，然后在@RequestParam后台使用上面介绍的验证注解，比如@NotBlank,@Rank. 如下： 12345678910111213141516@Controller@RequestMapping(&quot;/test&quot;)@Validatedpublic class TestController extends BaseController &#123;\t@RequestMapping(value = &quot;testValidated&quot;, method = RequestMethod.GET)\t@ResponseBody\t@ResponseStatus(HttpStatus.BAD_REQUEST)\tpublic Object testValidated(@RequestParam(value = &quot;pk&quot;, required = true) @Size(min = 1, max = 3) String pk, @RequestParam(value = &quot;age&quot;, required = false) @Range(min = 1, max = 3) String age) &#123; try &#123; return &quot;pk:&quot; + pk + &quot;,age=&quot; + age; &#125; catch (Throwable t) &#123; return buildFailure(&quot;消息列表查询失败&quot;); &#125;\t&#125;&#125; 当入非法参数是，会被全局处理器拦截到，（Spring切面编程方式），如果参数非法即刻给前台返回错误数据。 注意@Valid是使用hibernate Validation.jar做校验 @Validated是只用spring Validator校验机制使用 @Validated与@RequestBody结合使用时，在接口方法里要增加@Valid。例如： 1public Object edit(@Valid @RequestBody AddrRo addrRo) &#123;.....&#125; 14.@RequestBody@RequestBody（required&#x3D;true）：有个默认属性required,默认是true,当body里没内容时抛异常。 application&#x2F;x-www-form-urlencoded：窗体数据被编码为名称&#x2F;值对。这是标准的编码格式。这是默认的方式 multipart&#x2F;form-data：窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。二进制数据传输方式，主要用于上传文件 注意：必需使用POST方式提交参数，需要使用ajax方式请求，用Fiddler去模拟post请求不能。 引用jar包： Spring相关jar包。 以及 123456789&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.5.3&lt;/version&gt; dispatchServlet-mvc.xml配置第一种，直接配置MappingJackson2HttpMessageCoverter： 123456&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 第二种：&lt;mvc:annotation-driven&#x2F;&gt; 就不用配置上面bean,默认会配好。 Ajax请求： 1234567891011121314151617181920function testRequestBody() &#123;\tvar o = &#123;&quot;status&quot;:9&#125;; jQuery.ajax(&#123; type: &quot;POST&quot;, url: &quot;http://127.0.0.1:8080/TestValidate/test/testValid&quot;, xhrFields:&#123; withCredentials:true &#125;, data: JSON.stringify(o), contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, async: false, success:function (data) &#123; console.log(data); &#125;, error: function(res) &#123; console.log(res); &#125; &#125;);&#125; 后台XXXcontroller.java: 123456@RequestMapping(value=&quot;/testValid &quot;,method=RequestMethod.POST)@ResponseBodypublic Object setOrderInfo(@RequestBody InfoVO infoVO,HttpServletRequest request, HttpServletResponse response)&#123; InfoVO cVo = getInfoVo(infoVO); return &quot;success&quot;;\t&#125; 开发时，不是报415，就是400错误，头都大了。还是细节没做到位，注意下面几个要点： Content-Type必需是application&#x2F;json 需要jackson-databind.jar &lt;mvc:annotation-driven&#x2F;&gt;要配置或直接配置bean XXXController.jar在post方式接收数据 最最重要的，使用ajax以post方式请求。不能用Fiddler模拟,不然会出错。 15.@CrossOrigin是Cross-Origin ResourceSharing（跨域资源共享）的简写 作用是解决跨域访问的问题，在Spring4.2以上的版本可直接使用。在类上或方法上添加该注解 例如： 12@CrossOriginpublic class TestController extends BaseController &#123;XXXX&#125; 如果失效则可能方法没解决是GET还是POST方式，指定即可解决问题。 16.@RequestParam作用是提取和解析请求中的参数。@RequestParam支持类型转换，类型转换目前支持所有的基本Java类型 @RequestParam([value&#x3D;”number”], [required&#x3D;false]) String number 将请求中参数为number映射到方法的number上。required&#x3D;false表示该参数不是必需的，请求上可带可不带。 17. @PathVariable，@RequestHeader，@CookieValue，@RequestParam, @RequestBody，@SessionAttributes, @ModelAttribute@PathVariable：处理requet uri部分,当使用@RequestMapping URI template 样式映射时， 即someUrl&#x2F;{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上 例如： 12345678@Controller @RequestMapping(&quot;/owners/&#123;a&#125;&quot;) public class RelativePathUriTemplateController &#123; @RequestMapping(&quot;/pets/&#123;b&#125;&quot;) public void findPet(@PathVariable(&quot;a&quot;) String a,@PathVariable String b, Model model) &#123; // implementation omitted &#125; &#125; @RequestHeader，@CookieValue: 处理request header部分的注解 将头部信息绑定到方法参数上： 12345@RequestMapping(&quot;/test&quot;) public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;)long keepAlive) &#123; //... &#125; 将cookie里JSESSIONID绑定到方法参数上 1234@RequestMapping(&quot;/test&quot;) public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; //...&#125; @RequestParam, @RequestBody: 处理request body部分的注解,已经介绍过，不用介绍了。 @SessionAttributes,@ModelAttribute：处理attribute类型是注解。XXXX 18.@Scope配置bean的作用域。 @Controller @RequestMapping(“&#x2F;test”) @Scope(“prototype”) public class TestController {} 默认是单例模式，即@Scope(“singleton”), singleton：单例，即容器里只有一个实例对象。 prototype：多对象，每一次请求都会产生一个新的bean实例，Spring不无法对一个prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，由程序员负责销毁该对象，不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用 request：对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 web.xml增加如下配置： 12345678&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt;session：该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效。也要在web.xml配置如下代码：&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt;global session：作用不大，可不用管他。 19.@ResponseStatus@ResponseStatus用于修饰一个类或者一个方法，修饰一个类的时候，一般修饰的是一个异常类,当处理器的方法被调用时，@ResponseStatus指定的code和reason会被返回给前端。value属性是http状态码，比如404，500等。reason是错误信息 当修改类或方法时，只要该类得到调用，那么value和reason都会被添加到response里 例如： 1234@ResponseStatus(value=HttpStatus.FORBIDDEN, reason=&quot;出现了错误&quot;)public class UserException extends RuntimeException&#123;\tXXXXX&#125; 当某处抛出UserException时，则会把value和reason返回给前端。 123456@RequestMapping(&quot;/testResponseStatus&quot;) public String testResponseStatus(int i)&#123; if(i==0) throw new UserNotMatchException(); return &quot;hello&quot;;&#125; 修改方法： 123456789101112131415@ControllerAdvice@Componentpublic class GlobalExceptionHandler &#123;\t@Bean\tpublic MethodValidationPostProcessor methodValidationPostProcessor() &#123; return new MethodValidationPostProcessor();\t&#125;\t@ExceptionHandler\t@ResponseBody\t@ResponseStatus(value=HttpStatus.BAD_REQUEST,reason=&quot;哈哈&quot;)\tpublic String handle(ValidationException exception) &#123; System.out.println(&quot;bad request, &quot; + exception.getMessage()); return &quot;bad request, &quot; + exception.getMessage();\t&#125;&#125; 正如上面所说，该方法得到调用，不论是否抛异常，都会把value和reason添加到response里。 总结：@ResponseStatus是为了在方法或类得到调用时将指定的code和reason添加到response里返前端，就像服务器常给我们报的404错误一样，我们可以自己指定高逼格错误提示。 20.@RestController@RestController &#x3D; @Controller + @ResponseBody。 是2个注解的合并效果，即指定了该controller是组件，又指定方法返回的是String或json类型数据，不会解决成jsp页面，注定不够灵活，如果一个Controller即有SpringMVC返回视图的方法，又有返回json数据的方法即使用@RestController太死板。 灵活的作法是：定义controller的时候，直接使用@Controller，如果需要返回json可以直接在方法中添加@ResponseBody 21.@ControllerAdvice官方解释是：It is typically used todefine@ExceptionHandler, @InitBinder, and@ModelAttribute methods that apply to all@RequestMapping methods 意思是：即把@ControllerAdvice注解内部使用@ExceptionHandler、@InitBinder、@ModelAttribute注解的方法应用到所有的 @RequestMapping注解的方法。非常简单，不过只有当使用@ExceptionHandler最有用，另外两个用处不大。 12345678910@ControllerAdvice public class GlobalExceptionHandler &#123; @ExceptionHandler(SQLException.class) @ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR,reason=”sql查询错误”) @ResponseBody public ExceptionResponse handleSQLException(HttpServletRequest request, Exception ex) &#123; String message = ex.getMessage(); return ExceptionResponse.create(HttpStatus.INTERNAL_SERVER_ERROR.value(), message); &#125; &#125; 即表示让Spring捕获到所有抛出的SQLException异常，并交由这个被注解的handleSQLException方法处理，同时使用@ResponseStatus指定了code和reason写到response上，返回给前端。 22.元注解包括 @Retention @Target @Document @Inherited四种 元注解是指注解的注解，比如我们看到的 ControllerAdvice 注解定义如下。 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface ControllerAdvice &#123;\tXXX&#125; @Retention: 定义注解的保留策略：@Retention(RetentionPolicy.SOURCE) &#x2F;&#x2F;注解仅存在于源码中，在class字节码文件中不包含 @Retention(RetentionPolicy.CLASS) &#x2F;&#x2F;默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得， @Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F;注解会在class字节码文件中存在，在运行时可以通过反射获取到 @Target：定义注解的作用目标:@Target(ElementType.TYPE) &#x2F;&#x2F;接口、类、枚举、注解 @Target(ElementType.FIELD) &#x2F;&#x2F;字段、枚举的常量 @Target(ElementType.METHOD) &#x2F;&#x2F;方法 @Target(ElementType.PARAMETER) &#x2F;&#x2F;方法参数 @Target(ElementType.CONSTRUCTOR) &#x2F;&#x2F;构造函数 @Target(ElementType.LOCAL_VARIABLE)&#x2F;&#x2F;局部变量 @Target(ElementType.ANNOTATION_TYPE)&#x2F;&#x2F;注解 @Target(ElementType.PACKAGE) &#x2F;&#x2F;&#x2F;包 由以上的源码可以知道，他的elementType 可以有多个，一个注解可以为类的，方法的，字段的等等 @Document：说明该注解将被包含在javadoc中@Inherited：说明子类可以继承父类中的该注解比如@Valid注解定义,表示该注解只能用在方法，属性，构造函数及方法参数上。该注解会被编译到class里可通过反射得到。 23.@RequestMapping处理映射请求的注解。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。有6个属性。 value， method: value：指定请求的实际地址，指定的地址可以是URI Template 模式； method：指定请求的method类型， GET、POST、PUT、DELETE等； 比如： 12345@RequestMapping(value = &quot;/testValid&quot;, method = RequestMethod.POST)@ResponseBodypublic Object testValid(@RequestBody @Valid Test test,BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;\tXXX&#125; value的uri值为以下三类：A) 可以指定为普通的具体值；如@RequestMapping(value &#x3D;”&#x2F;testValid”)B) 可以指定为含有某变量的一类值;如@RequestMapping(value&#x3D;”&#x2F;{day}”)C) 可以指定为含正则表达式的一类值;如@RequestMapping(value&#x3D;”&#x2F;{textualPart:[a-z-]+}.{numericPart:[\\\\d]+}”) 可以匹配..&#x2F;chenyuan122912请求。 consumes，produces：consumes： 指定处理请求的提交内容类型（Content-Type），例如@RequestMapping(value &#x3D; “&#x2F;test”, consumes&#x3D;”application&#x2F;json”)处理application&#x2F;json内容类型produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params、headers： params： 指定request中必须包含某些参数值是，才让该方法处理。 1234@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, params=&quot;name=chenyuan&quot;) public void findOrd(String name) &#123; // implementation omitted &#125; 仅处理请求中包含了名为“name”，值为“chenyuan”的请求. headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 1234@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, headers=&quot;Referer=www.baidu.com&quot;) public void findOrd(String name) &#123; // implementation omitted &#125; 仅处理request的header中包含了指定“Refer”请求头和对应值为“www.baidu.com”的请求 24@GetMapping和@PostMapping @GetMapping(value &#x3D; “page”)等价于@RequestMapping(value &#x3D; “page”, method &#x3D; RequestMethod.GET) @PostMapping(value &#x3D; “page”)等价于@RequestMapping(value &#x3D; “page”, method &#x3D; RequestMethod.POST) Spring事务失效 1.数据库引擎不支持事务 这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。 2.没有被 Spring 管理 如果把 @Service 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。 3.方法不是 public 的 @Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。 4.自身调用问题 12345678910@Servicepublic class OrderServiceImpl implements OrderService &#123; public void update(Order order) &#123; updateOrder(order); &#125; @Transactional public void updateOrder(Order order) &#123; // update order &#125;&#125; update方法上面没有加 @Transactional 注解，调用有 @Transactional 注解的 updateOrder 方法，updateOrder 方法上的事务管用吗？ 1234567891011@Servicepublic class OrderServiceImpl implements OrderService &#123; @Transactional public void update(Order order) &#123; updateOrder(order); &#125; @Transactional(propagation = Propagation.REQUIRES_NEW) public void updateOrder(Order order) &#123; // update order &#125;&#125; 这次在 update 方法上加了 @Transactional，updateOrder 加了 REQUIRES_NEW 新开启一个事务，那么新开的事务管用么？ 这两个例子的答案是：不管用！ 因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效，这也是老生常谈的经典问题了。 5.数据源没有配置事务管理器 1234@Beanpublic PlatformTransactionManager transactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource);&#125; 如上面所示，当前数据源若没有配置事务管理器，那也是白搭！ 6.不支持事务 1234567891011@Servicepublic class OrderServiceImpl implements OrderService &#123; @Transactional public void update(Order order) &#123; updateOrder(order); &#125; @Transactional(propagation = Propagation.NOT_SUPPORTED) public void updateOrder(Order order) &#123; // update order &#125;&#125; Propagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起 7.异常被吃了 12345678910// @Servicepublic class OrderServiceImpl implements OrderService &#123; @Transactional public void updateOrder(Order order) &#123; try &#123; // update order &#125; catch &#123; &#125; &#125;&#125; 把异常吃了，然后又不抛出来，事务怎么回滚吧！ 8.异常类型错误 1234567891011// @Servicepublic class OrderServiceImpl implements OrderService &#123; @Transactional public void updateOrder(Order order) &#123; try &#123; // update order &#125; catch &#123; throw new Exception(&quot;更新错误&quot;); &#125; &#125;&#125; 这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如： 1@Transactional(rollbackFor = Exception.class) 这个配置仅限于 Throwable 异常类及其子类。 1．非public方法失效 @Transactional只有标注在public级别的方法上才能生效，对于非public方法将不会生效。这是由于Spring AOP不支持对private、protect方法进行拦截。声明 @Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，再由这个代理对象来统一管理。声明式事务原理是Spring事务会为@Transaction标注的方法的类生成AOP增强的动态代理类对象，并且在调用目标方法的拦截链中加入TransactionInterceptor进行环绕增加，实现事务管理。从原理上来说，动态代理是通过接口实现，所以自然不能支持private和protect方法的。而CGLIB是通过继承实现，其实是可以支持protect方法的拦截的，但Spring AOP中并不支持这样使用。如果需要对protect或private方法拦截则建议使用AspectJ。 2．自调用失效当通过在同一个类的内部方法直接调用带有@Transactional的方法时，@Transactional将失效，例如： 12345678public void saveAB(A a, B b)&#123;saveA(a);saveB(b);&#125;@Transactionalpublic void saveA(A a)&#123;dao.saveA(a);&#125;@Transactionalpublic void saveB(B b)&#123;dao.saveB(b);&#125; 在saveAB中调用saveA和saveB方法，两者的@Transactional都将失效。这是因为Spring事务的实现基于代理类，当在内部直接调用方法时，将不会经过代理对象，而是直接调用目标对象的方法，无法被TransactionInterceptor拦截处理。解决办法： （1）ApplicationContextAware通过ApplicationContextAware注入的上下文获得代理对象。 1234public void saveAB(A a, B b)&#123;\tTest self = (Test) applicationContext.getBean(&quot;Test&quot;); self.saveA(a); self.saveB(b);&#125; （2）AopContext通过AopContext获得代理对象。 1234public void saveAB(A a, B b)&#123; Test self = (Test)AopContext.currentProxy(); self.saveA(a); self.saveB(b);&#125; （3）@Autowired通过@Autowired注解注入代理对象。 12345678@Componentpublic class Test &#123; @Autowired Test self; public void saveAB(A a, B b) &#123;self.saveA(a);self.saveB(b); &#125; // ...&#125; （4）拆分将saveA、saveB方法拆分到另一个类中。 12public void saveAB(A a, B b)&#123;txOperate.saveA(a);txOperate.saveB(b);&#125; 3. 不同类中调用方未开始事务 在不同类之间的方法调用中，如果 A 方法开启了事务，B 方法没有开启事务，B 方法调用了 A 方法。如果 B 方法中发生异常，但不是调用的 A 方法产生的，则异常不会使 A 方法的事务回滚，此时事务无效。如果 B 方法中发生异常，异常是调用的 A 方法产生的，则 A 方法的事务回滚，此时事务有效。 在 B 方法上加上注解 @Trasactional，这样 A 和 B 方法就在同一个事务里了，不管异常产生在哪里，事务都是有效的。简单地说，不同类之间方法调用时，异常发生在无事务的方法中，但不是被调用的方法产生的，被调用的方法的事务无效。只有异常发生在开启事务的方法内，事务才有效。 4. 数据库引擎选用不当如果使用 MySQL 且引擎是 MyISAM，则事务会不起作用，原因是 MyISAM 不支持事务，改成 InnoDB 引擎则支持事务。 5．检查异常默认不回滚 在默认情况下，抛出非检查异常会触发回滚，而检查异常不会。根据invokeWithinTransaction方法，我们可以知道异常处理逻辑在completeTransactionAfterThrowing方法中，其实现如下：根据rollbackOn判断异常是否为回滚异常。只有RuntimeException和Error的实例，即非检查异常，或者在@Transaction中通过rollbackFor属性指定的回滚异常类型，才会回滚事务。否则将继续提交事务。所以如果需要对检查异常进行回滚，需要记得指定rollbackFor属性，不然将回滚失效。 检查异常是Exception的本身或者子类：例如：IOException（输入输出异常）、FileNotFoundException（文件没发现异常）、SQLException（SQL异常）非检查异常是RuntimeException的本身或子类：例如：算数异常（ArithmeticException）、空指针异常（NullPointerException），数组越界异常（ArrayIndexOutOfBoundException） 6．catch异常无法回滚我们说只有抛出非检查异常或是rollbackFor中指定的异常才能触发回滚。如果我们把异常catch住，而且没抛出，则会导致无法触发回滚，这也是开发中常犯的错误。例如： 12345678910111213@Transactionalpublic void insert(List&lt;User&gt; users) &#123; try &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); for (User user : users) &#123; String insertUserSql = &quot;insert into User (id, name) values (?,?)&quot;; jdbcTemplate.update(insertUserSql, new Object[] &#123; user.getId(), user.getName() &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这里由于catch住了所有Exception，并且没抛出。当插入发生异常时，将不会触发回滚。但同时我们也可以利用这种机制，用try-catch包裹不用参与事务的数据操作，例如对于写入一些不重要的日志，我们可将其用try-catch包裹，避免抛出异常，则能避免写日志失败而影响事务的提交。 1、spring的事务注解@Transactional只能放在public修饰的方法上才起作用，如果放在其他非public（private，protected）方法上，虽然不报错，但是事务不起作用 2、如果采用spring+spring mvc，则context:component-scan重复扫描问题可能会引起事务失败。 如果spring和mvc的配置文件中都扫描了service层，那么事务就会失效。 原因：因为按照spring配置文件的加载顺序来讲，先加载springmvc配置文件，再加载spring配置文件，我们的事物一般都在spring配置文件中进行配置，如果此时在加载springMVC配置文件的时候，把servlce也给注册了，但是此时事物还没加载，也就导致后面的事物无法成功注入到service中。所以把对service的扫描放在spring配置文件中或是其他配置文件中。 3、如使用mysql且引擎是MyISAM，则事务会不起作用，原因是MyISAM不支持事务，可以改成InnoDB引擎 4、在业务代码中如果抛出RuntimeException异常，事务回滚；但是抛出Exception，事务不回滚； 解决方法@Transactional改为@Transactional(rollbackFor &#x3D; Exception.class) 5、如果在加有事务的方法内，使用了try…catch..语句块对异常进行了捕获，而catch语句块没有throw new RuntimeExecption异常，事务也不会回滚 6、在类A里面有方法a 和方法b， 然后方法b上面用 @Transactional加了方法级别的事务，在方法a里面 调用了方法b， 方法b里面的事务不会生效。原因是在同一个类之中，方法互相调用，切面无效 ，而不仅仅是事务。这里事务之所以无效，是因为spring的事务是通过aop实现的。 @Transactional 注解开启配置，必须放到listener里加载，如果放到DispatcherServlet的配置里，事务也是不起作用的。 Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。 注解@Transactional配置的方法非public权限修饰；注解@Transactional所在类非Spring容器管理的bean；注解@Transactional所在类中，注解修饰的方法被类内部方法调用；业务代码抛出异常类型非RuntimeException，事务失效；业务代码中存在异常时，使用try…catch…语句块捕获，而catch语句块没有throw new RuntimeExecption异常;（最难被排查到问题且容易忽略）注解@Transactional中Propagation属性值设置错误即Propagation.NOT_SUPPORTED（一般不会设置此种传播机制）mysql关系型数据库，且存储引擎是MyISAM而非InnoDB，则事务会不起作用(基本开发中不会遇到)；","tags":["Java","Spring"],"categories":["学习"]},{"title":"数据库","path":"/14ea6df7/","content":"主从同步是单线程 inno_buff_set 看io io top 看sql跑的慢 **&#x3D;&#x3D;explain&#x3D;&#x3D;**执行计划，慢sql，慢日志，链路，information_schema sleep 死锁 锁表 update 转移表到其他地方：数据目录，表空间，刷盘flushtable。拷贝表结构 自增上限 没走索引就会进行表锁。 元数据与表结构相关 select含有元数据读锁 update锁，走索引是行，不走是表 排它锁 建立索引会有元数据锁，影子表加索引 并发事务有什么影响：死锁，数据安全，锁表，不能进行大事务。拆成小事务。 LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。 用通配符进行过滤mysql在使用like查询的时候只有使用后面的%时，才会使用到索引。 为了找出所有以词jet起头的产品 123select prod_id, prod_namefrom productswhere prod_name like &#x27;jet%&#x27;; 检索列prod_name包含 文本1000的所有行 123456789select prod_namefrom productswhere prod_name regexp &#x27;1000&#x27;order by prod_name;select prod_namefrom productswhere prod_name regexp &#x27;.000&#x27;order by prod_name; 用正则表达式 进行搜索binary关键字正则表达式使用binary关键字区分大小写。如：WHERE prod_name REGEXP BINARY ‘JetPack .000’。 12345[]括号的使用select prod_namefrom productswhere prod_name regexp &#x27;[123] Ton&#x27;order by prod_name; 1234select prod_namefrom productswhere prod_name regexp &#x27;[1-5] Ton&#x27;order by prod_name; 特殊字符匹配特殊字符使用\\\\ 1234select vend_namefrom vendorswhere vend_name regexp &#x27;\\\\.&#x27;order by vend_name; 如果你想找出以一个数（包括以小数点开始的数）开始的所 有产品，怎么办？简单搜索[0-9\\.]（或[[:digit:]\\.]）不行，因为它将在文本内任意位置查找匹配。解决办法是使用^定位符。 1234select prod_namefrom productswhere prod_name regexp &#x27;^[0-9\\\\.]&#x27;order by prod_name; 简单的正则表达式测试：可以在不使用数据库表的情况下用 SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配） 或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试 验它们。相应的语法如下： 1select &#x27;hello&#x27; regexp &#x27;[0-9]&#x27; 这个例子显然将返回0（因为文本hello中没有数字） 创建计算字段拼接字段拼接（concatenate） 将值联结到一起构成单个值。 在MySQL的SELECT语句中，可使用 **Concat()**函数来拼接两个列 123select Concat(vend_name,&#x27;(&#x27;,vend_country,&#x27;)&#x27;)from vendorsorder by vend_name; 多余的空格删除数据右侧多余的空格可以 使用MySQL的RTrim()函数来完成,LTrim()（去掉串左边的空格）以及 Trim()（去掉串左右两边的空格） 123select Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;)from vendorsorder by vend_name; 使用数据处理函数Now()函数而SELECT Now()利用Now()函数返回当前日期和时间 Now()函数 文本处理函数 SOUNDEX是一个将任何文 本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似 的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然 SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对 SOUNDEX的支持。 customers表中有一个顾 客Coyote Inc.，其联系名为Y.Lee。但如果这是输入错误，此联系名实 际应该是Y.Lie，怎么办？显然，按正确的联系名搜索不会返回数据，如 下所示： 123select cust_name, cust_contactfrom customerswhere cust_contact = &#x27;Y. Lie&#x27;; 现在试一下使用Soundex()函数进行搜索，它匹配所有发音类似于 Y.Lie的联系名： 123select cust_name, cust_contactfrom customerswhere Soundex(cust_contact) = Soundex(&#x27;Y Lie&#x27;); 日期和时间处理函数 如果你想检索出2005年9月下的 所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天 数。有几种解决办法，其中之一如下所示： 123select cust_id, order_numfrom orderswhere Date(order_date) between &#x27;2005-09-01&#x27; and &#x27;2005-09-30&#x27;; 还有另外一种办法（一种不需要记住每个月中有多少天或不需要操 心闰年2月的办法）： 123select cust_id, order_numfrom orderswhere Year(order_date) = 2005 and Month(order_date) = 9; 流程控制函数流程控制类函数可以进行条件操作，用来实现SQL的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台，列举如下： IF(test,t,f) 如果test是真，返回t；否则返回f IFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2 NULLIF(arg1,arg2) 如果arg1&#x3D;arg2返回NULL；否则返回arg1 CASE WHEN[test1] THEN [result1]…ELSE [default] END 如果testN是真，则返回resultN，否则返回default CASE [test] WHEN[val1] THEN [result]…ELSE [default]END 如果test和valN相等，则返回resultN，否则返回default 汇总数据聚集函数 AVG()函数忽略列值为NULL的行COUNT()函数COUNT(*)不忽略列值为NULL的行COUNT(column)忽略列值为NULL的行MAX()函数与MIN()函数忽略列值为NULL的行max在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行 min在用于文本数据时，如果数据按相应的列排序， 则MIN()返回最前面的行。 SUM()函数忽略列值为NULL的行。DISTINCT参数返回特定供应商提供的产品的平均价格 123select AVG(distinct prod_price) AS avg_pricefrom productswhere vend_id = 1003; 如果指定列名，则DISTINCT只能用于COUNT()。 DISTINCT 不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT） DISTINCT必须使用列名，不能用 于计算或表达式 分组数据123select vend_id, count(*) as num_prodsfrom productsgroup by vend_id; ROLLUP使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以 及每个分组汇总级别（针对每个分组）的值，如下所示： 123select vend_id, count(*) as num_prodsfrom productsgroup by vend_id with rollup; 过滤分组HAVING子句唯一的差别是 WHERE过滤行，而HAVING过滤分组。 WHERE在数据 分组前进行过滤，HAVING在数据分组后进行过滤 1234select cust_id, count(*) AS ordersfrom ordersgroup by cust_idhaving count(*) &gt;= 2; 它过滤COUNT(*) &gt;&#x3D;2（两个以上的订单）的那些 分组。 同时使用where和having子句 它列出具有2个（含）以上、价格 为10（含）以上的产品的供应商： 12345select vend_id, count(*) AS num_prodsfrom productswhere prod_price &gt;= 10group by vend_idhaving count(*) &gt;= 2; 分组与排序 一般在使用GROUP BY子句时，应该也给 出ORDER BY子句 它检索总计订单价格大于等于50的订 单的订单号和总计订单价格 1234select order_num,sum(quantity*item_price) AS ordertotalfrom orderitemsgroup by order_numhaving sum(quantity*item_price) &gt;= 50; 为按总计订单价格排序输出，需要添加ORDER BY子句 12345select order_num,sum(quantity*item_price) AS ordertotalfrom orderitemsgroup by order_numhaving sum(quantity*item_price) &gt;= 50order by ordertotal; 使用子查询SELECT子句顺序 联结表等值联结（也称为内部联结）123456789select vend_name, prod_name, prod_pricefrom vendors, productswhere vendors.vend_id = products.vend_idorder by vend_name, prod_name;或select vend_name, prod_name, prod_pricefrom vendors inner join productson vendors.vend_id = products.vend_idorder by vend_name, prod_name; 自联结12345678910select prod_id, prod_namefrom productswhere vend_id = (select vend_id from products where prod_id = &#x27;DTNTR&#x27;);或select p1.prod_id, p2.prod_namefrom products AS p1, products AS p2where p1.vend_id = p2.vend_id\tand p2.prod_id = &#x27;DTNTR&#x27;; 自然联结自然联结排除多次出现，使每个列只返回一次。 12345select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_pricefrom customers As c, orders As o, orderitems As oiwhere c.cust_id = o.cust_idand oi.order_num = o.order_numand prod_id = &#x27;FB&#x27;; 外部联结下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其 订单： 123select customers.cust_id, orders.order_numfrom customers inner join orderson customers.cust_id = orders.cust_id; 外部联结语法类似。为了检索所有客户，包括那些没有订单的客户， 可如下进行： 123select customers.cust_id, orders.order_numfrom customers left join orderson customers.cust_id = orders.cust_id; 外部联结还包括没 有关联行的行 使用带聚集函数的联结如果要检索所有客户及每个客户所 下的订单数，下面使用了COUNT()函数的代码可完成此工作： 1234select customers.cust_name,customers.cust_id,count(orders.order_num) AS num_ordfrom customers inner join orderson customers.cust_id = orders.cust_idgroup by customers.cust_id; 聚集函数也可以方便地与其他联结一起使用 1234select customers.cust_name,customers.cust_id,count(orders.order_num) AS num_ordfrom customers left join orderson customers.cust_id = orders.cust_idgroup by customers.cust_id; join的类别 inner join：内连接最后返回的数据行数是在inner join前后两张表中同时存在的数据行数。任何一条只存在于某一张表中的数据，都不会返回。 对于inner join而言，MySQL会选择小表作为驱动表，大表作为被驱动表。 left join：左连接又称为left outer join，我们平时都把outer省略。简写为left join left左边的表为主表，left右边的表为从表。返回结果行数以left左边的表的行数为最后的数据行，对于左表中有些数据行在右表中找不到它所匹配的数据行记录时候，返回结果的时候这些行后面通常会以null来填充。 right join：右连接又称为right outer join，我们平时都把outer省略。简写为right join right右边的表为主表，right左边的表为从表。返回结果行数以right右边的表的行数为左后的数据行，对于主表中有些数据行在从表中找不到它所匹配的数据行记录时候，返回结果的时候这些行后面通常会以null来填充。 full join：全连接。最后返回的数据行数是full join前后两张表的数行数的笛卡尔积。但是在MySQL中没有这种写法，它直接使用select * from A,B;这样的写法就可以实现全连接。 Oracle中有full join这种写法。 straight_join功能是可以指定在straight_join前面的表作为驱动表，在straight_joion后面的表作为被驱动表。 驱动表和被驱动表驱动表在SQL语句执行的过程中，总是先读取。而被驱动表在SQL语句执行的过程中，总是后读取。 在驱动表数据读取后，放入到join_buffer后，再去读取被驱动表中的数据，来和驱动表中的数据进行匹配。如果匹配上则作为结果集返回，否则丢弃。 可以使用**&#x3D;&#x3D;explain&#x3D;&#x3D;**命令查看一下SQL语句的执行计划。在输出的执行计划中，排在第一行的表是驱动表，排在第二行的表是被驱动表。 两个表在进行关联查询的时候，是根据真正参与关联查询的数据行和列所占用的空间大小来确认谁作为驱动表谁作为被驱动表的。 这里对于大小的判断，是指真正参与关联查询的数据量所占用的join_buffer的大小来区分的，而不是根据表中所有的数据行数来判断的。 join buffer的概念join查询的时候，会把驱动表中的数据全部查询出来放入到内存中，而这个内存就是我们现在要说的：join buffer 它的大小是由参数join_buffer_size大小来决定的，默认值为262144字节，即为：256KB。而它所能设置的最小值为128字节，最大值为：4GB−1字节。 Index Nested-Loop JoinIndex Nested-Loop Join：索引嵌套循环连接。 我们采用如下SQL来解释Index Nested-Loop Join这种关联查询的执行过程。 1explain select * from A as a inner join B as b on a.id = b.id; 基于上面的查询计划，我们可以看出B表是驱动表，A表是被驱动表。接下来我们详细说明一下这个关联链接的具体执行过程是怎样的。 获取B表中的第一行数据，然后从这行中，获取出该行的id的值。 拿着id的值去A表中去查找满足该id值的行，此时使用了A表中的主键索引。找到后，把A表中的这个行和B表中的行拼接在一起，作为最后的结果集，返回给客户端。 这样就完成了B表中第一行数据和A表的inner join过程。 重复1、2、3步骤，直到把B表的所有行都遍历完成，就完成了此次的join过程。 以上的步骤就是Index Nested-Loop Join执行的过程。注意：它在去被驱动表A中获取数据的时候，使用到了A表中的索引，并不是把A表中的所有数据都扫描一遍，再去和B表中的数据去匹配。 Simple Nested-Loop JoinSimple Nested-Loop Join：简单嵌套循环连接。 我们这次把上面的使用的SQL简单修改一下，改为如下的这种写法。让其在关联的时候，不使用a.id = b.id的关联方式，而是使用a.code = b.code的关联方式。注意：此时在两个表上面的code字段都没有索引。 1explain select * from A as a inner join B as b on a.code = b.code; 执行计划如下，从中可以看出B表示驱动表，A表示被驱动表。 此时在去A表被驱动表中查找数据的时候，就不能通过A表中的索引来获取数据了。那么就需要把A表中所有的数据都扫描一遍，然后再和B表中的id值进行匹配。这样每处理B表中的一行，A表中的数据都要全部扫描一次。这样的效率比前面我们提到的Index Nested-Loop Join慢了很多。 但是，MySQL在这种情况下并没有采用这种慢的方式，而是采用了下面我们将要说的Block Nexted-Loop Join的关联方式。这就是为什么我们在上面的查询计划中没有看到Simple Nested-Loop Join的原因。 Block Nexted-Loop JoinBlock Nexted-Loop Join：基于块的嵌套循环连接。 因为在被驱动表A找那个没有索引，所以MySQL此时才去的关联方式是基于块的嵌套循环连接。 组合查询UNION举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且 还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以 利用WHERE子句来完成此工作，不过这次我们将使用UNION。 1234567select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5;select vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001,1002); 第一条SELECT检索价格不高于5的所有物品。第二条SELECT使 用IN找出供应商1001和1002生产的所有物品。 123456789101112select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5unionselect vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001,1002);使用多条WHERE子句而不是使用UNION的相同查询select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5 or vend_id in (1001,1002); union allUNION从查询结果集中自动去除了重复的行,如果 想返回所有匹配行，可使用UNION ALL而不是UNION。 1234567select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5union allselect vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001,1002); 对组合查询结果排序在用UNION组合查询时，只 能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后 12345678select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5unionselect vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001,1002)order by vend_id,prod_id; 全文本搜索使用全文本搜索一般在创建表时启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。 12345create table productontes(\t&#x27;&#x27;&#x27;&#x27; note_text text null,\tfulltext(note_text))engine=MyISAM; 这里的 FULLTEXT索引单个列，如果需要也可以指定多个列。 不要在导入数据时使用FULLTEXT，应该首先导入所有数据，然 后再修改表，定义FULLTEXT。 进行全文本搜索Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 123select note_textfrom productnoteswhere Match(note_text) Against(&#x27;rabbit&#x27;); 传递给 Match() 的值必须与 FULLTEXT()定义中的相同。如果指定多个列，则必须列出它 们（而且次序正确）。 搜索不区分大小写，除非使用BINARY方式 事实是刚才的搜索可以简单地用LIKE子句完成 123select note_textfrom productnoteswhere note_text like &#x27;%rabbit%&#x27;; 传递给 Match() 的值必须与 FULLTEXT()定义中的相同。如果指定多个列，则必须列出它 们（而且次序正确）。 搜索不区分大小写，除非使用BINARY方式 事实是刚才的搜索可以简单地用LIKE子句完成 123select note_textfrom productnoteswhere note_text like &#x27;%rabbit%&#x27;; 第3个词的行的等级比作为第20个词的行高。具有较高等级的行先返回。 为演示排序如何工作，请看以下例子： 12select note_text, Match(note_text) Against(&#x27;rabbit&#x27;) AS rankfrom productnotes; 按等级以降序排序 排序多个搜索项 如果指定多个搜索项，则包含多数匹配词的 那些行将具有比包含较少词（或仅有一个匹配）的那些行高的 等级值 使用查询扩展123select note_textfrom productnoteswhere Match(note_text) Against(&#x27;anvils&#x27; with query expansion); 布尔文本搜索即使没有FULLTEXT索引也可以使用，但这是一种非常缓慢的操作 为演示IN BOOLEAN MODE的作用，举一个简单的例子： 123select note_textfrom productnoteswhere Match(note_text) Against(&#x27;heavy&#x27; in boolean mode); 匹配包含heavy但不包含任意以rope开始的词的行 123select note_textfrom productnoteswhere Match(note_text) Against(&#x27;heavy -rope*&#x27; in boolean mode); 12345678910111213141516select note_textfrom productnoteswhere Match(note_text) Against(&#x27;+rabbit +bait&#x27; in boolean mode);这个搜索匹配包含词rabbit和bait的行。where Match(note_text) Against(&#x27;rabbit bait&#x27; in boolean mode);没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行。、where Match(note_text) Against(&#x27;&quot;rabbit bait&quot;&#x27; in boolean mode);这个搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。where Match(note_text) Against(&#x27;&gt;rabbit &lt;bait&#x27; in boolean mode);匹配rabbit和carrot，增加前者的等级，降低后者的等级。where Match(note_text) Against(&#x27;+safe +(&lt;combination)&#x27; in boolean mode);这个搜索匹配词safe和combination，降低后者的等级。 排列而不排序 在布尔方式中，不按等级值降序排序返回的 行 MySQL全文本搜索现在还 不支持邻近操作符 插入数据12insert into Customersvalues(null,&#x27;...&#x27;,&#x27;...&#x27;...); 编写INSERT语句的更安全（不过更烦琐）的方法如下： 12insert into Customers(cust_name,cust_address,cust_city)values(null,&#x27;...&#x27;,&#x27;...&#x27;...); 即使表的结构改变， 此INSERT语句仍然能正确工作 如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示： 这也适用于UPDATE和DELETE语句 1insert low priority into 插入多个行123insert into Customers(cust_name,cust_address,cust_city)values(null,&#x27;...&#x27;,&#x27;...&#x27;...),values(null,&#x27;...&#x27;,&#x27;...&#x27;...); 插入检索出的数据可以利用它将一条SELECT语句的结果插入表中。这就是所 谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT 语句组成的 123insert into Customers(cust_name,cust_address,cust_city)select cust_name,cust_address,cust_city from custenw; 为简单起见，这个例子在INSERT和 SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置。 更新和删除数据不要省略WHERE子句 客户10005现在有了电子邮件地址，因此他的记录 需要更新 1234update customersset cust_name = &#x27;The Fudds&#x27;,set cust_mail = &#x27;q@q.com&#x27;where cust_id = 10005; IGNORE关键字如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）为即使是发 生错误，也继续进行更新，可使用IGNORE关键字 1update ignore custoemrs... 为了删除某个列的值，可设置它为NULL 123update customersset cust_mail = nullwhere cust_id = 10005; 删除数据DELETE12delete from customerswhere cust_id = 10006; DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了 删除指定的列，请使用UPDATE语句。 TRUNCATE更快的删除 如果想从表中删除所有行，不要使用DELETE。 可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更 快（TRUNCATE实际是删除原来的表并重新创建一个表，而不 是逐行删除表中的数据） 创建和操纵表CREATE TABLE语句12345678910111213CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL , cust_address char(50) NULL , cust_city char(50) NULL , cust_state char(5) NULL , cust_zip char(10) NULL , cust_country char(50) NULL , cust_contact char(50) NULL , cust_email char(255) NULL , PRIMARY KEY (cust_id)) ENGINE=InnoDB; if not exists理解NULL不要把NULL值与空串相混淆。NULL值是没有值， 它不是空串。如果指定’’（两个单引号，其间没有字符），这 在NOT NULL列中是允许的。空串是一个有效的值，它不是无 值。NULL值用关键字NULL而不是空串指定。 使用AUTO_INCREMENTAUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通 过使它成为主键）。 last_insert_id()函数1select last_insert_id(); 此语句返回最后一个AUTO_INCREMENT值 指定默认值DEFAULT123456789CREATE TABLE orderitems( order_num int NOT NULL , order_item int NOT NULL , prod_id char(10) NOT NULL , quantity int NOT NULL DEFAULT 1, item_price decimal(8,2) NOT NULL , PRIMARY KEY (order_num, order_item)) ENGINE=InnoDB; 不允许函数 MySQL不允许使用函 数作为默认值，它只支持常量 使用默认值而不是NULL值 许多数据库开发人员使用默认 值而不是NULL列，特别是对用于计算或数据分组的列更是如 此 引擎类型以下是几个需要知道的引擎： InnoDB是一个可靠的事务处理引擎，它不支持全文 本搜索； MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）； MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章）， 但不支持事务处理。 引擎类型可以混用。外键不能跨引擎混用引擎类型有一个大缺陷。外键（用于 强制实施引用完整性）不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。 更新表ALTER TABLE语句 123456alter table vendorsadd vend_phone char(20);删除刚刚添加的列alter table vendorsdrop column vend_phone; ALTER TABLE的一种常见用途是定义外键 123456789101112131415alter table orderitemsadd constraint fk_orderitems_ordersforeign key(order_num) references orders(order_num);alter table orderitemsadd constraint fk_orderitems_productsforeign key(prod_id) references products(prod_id);alter table ordersadd constraint fk_orders_customersforeign key(cust_id) references customers(cust_id);alter table productsadd constraint fk_products_vendorsforeign key(vend_id) references vendors(vend_id); 小心使用ALTER TABLE使用ALTER TABLE要极为小心，应该 在进行改动前做一个完整的备份（模式和数据的备份）。数据 库表的更改不能撤销，如果增加了不需要的列，可能不能删 除它们。类似地，如果删除了不应该删除的列，可能会丢失 该列中的所有数据。 删除表DROP TABLE语 句 1drop table customers2; 重命名表RENAME TABLE语句 123456rename table customers2 to customers;多个表重命名rename table backup_customers to customers, backup_vendors to vendors, backup_products to products, 管理事务处理开启事务我们可以使用下边两种语句之一来开启一个事务： BEGIN [WORK]; BEGIN 语句代表开启一个事务，后边的单词 WORK 可有可无。开启事务后，就可以继续写若干条语句，这些 语句都属于刚刚开启的这个事务。 START TRANSACTION; START TRANSACTION 语句和 BEGIN 语句有着相同的功效，都标志着开启一个事务 不过比 BEGIN 语句牛逼一点儿的是，可以在 START TRANSACTION 语句后边跟随几个 修饰符 ，就是它们几 个： READ ONLY ：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修 改数据。 READ WRITE ：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可 以修改数据。 WITH CONSISTENT SNAPSHOT ：启动一致性读 提交事务COMMIT [WORK] 手动中止事务如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事 务执行之前的样子： ROLLBACK [WORK] 这里需要强调一下， ROLLBACK 语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到 了某些错误而无法继续执行的话，事务自身会自动的回滚。 自动提交MySQL 中有一个系统变量 autocommit ： 可以看到它的默认值为 ON ，也就是说默认情况下，如果我们不显式的使用 START TRANSACTION 或者 BEGIN 语句 开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的 自动提交 隐式提交如果我们输入了某些语句之后就会 悄悄的 提交掉，就像我们输入了 COMMIT 语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为 隐式提交 ，这些会导致事务隐式提交 的语句包括： 定义或修改数据库对象的数据定义语言（Data definition language，缩写为： DDL ）。 所谓的数据库对象，指的就是 数据库 、 表 、 视图 、 存储过程 等等这些东西。当我们使用 CREATE 、 ALTER 、 DROP 等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务 隐式使用或修改 mysql 数据库中的表 当我们使用 ALTER USER 、 CREATE USER 、 DROP USER 、 GRANT 、 RENAME USER 、 REVOKE 、 SET PASSWORD 等语句时也会隐式的提交前边语句所属于的事务。 事务控制或关于锁定的语句 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时， 会隐式的提交上一个事务。或者使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事务。 加载数据的语句 比如我们使用 LOAD DATA 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。 关于 MySQL 复制的一些语句 使用 START SLAVE 、 STOP SLAVE 、 RESET SLAVE 、 CHANGE MASTER TO 等语句时也会隐式的提交前边语句 所属的事务。 其它的一些语句 使用 ANALYZE TABLE 、 CACHE INDEX 、 CHECK TABLE 、 FLUSH 、 LOAD INDEX INTO CACHE 、 OPTIMIZE TABLE 、 REPAIR TABLE 、 RESET 等语句也会隐式的提交前边语句所属的事务。 保存点SAVEPOINT 保存点名称; ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称; 如果我们想删除某个保存点，可以使用这个语句： RELEASE SAVEPOINT 保存点名称; 事务处理事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作要么完全执行，要么完全不执行。 在使用事务和事务处理时，有几个关键词汇反复出现。下面是关于 事务处理需要知道的几个术语： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 控制事务处理MySQL使用下面的语句来标识事务的开始： 1start transaction; 使用ROLLBACKMySQL的ROLLBACK命令用来回退（撤销）MySQL语句，请看下面的 语句： 123456select * from ordertotals;start transaction;delete from ordertotals;select * from ordertotals;rollback;select * from ordertotals; ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后） 哪些语句可以回退？事务处理用来管理INSERT、UPDATE和 DELETE语句。你不能回退SELECT语句。（这样做也没有什么意 义。）你**&#x3D;&#x3D;不能回退CREATE或DROP操作&#x3D;&#x3D;**。事务处理块中可以使用 这两条语句，但如果你执行回退，它们不会被撤销。 使用COMMIT一般的MySQL语句都是直接针对数据库表执行和编写的。这就是 所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动 进行的 1234start transaction;delete from orderitems where order_num = 20010;delete from orders where order_num = 20010;commit; 使用保留点更复杂的事务处理可能需要部 分提交或回退。 为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置占位符。这样，如果需要回退，可以回退到某个占位符。 这些占位符称为保留点，为了创建占位符，可如下使用SAVEPOINT。 1savepoint delete1; 每个保留点都取标识它的唯一名字 1rollback to delete1; 保留点越多越好 可以在MySQL代码中设置任意多的保留 点，越多越好。为什么呢？因为保留点越多，你就越能按自己 的意愿灵活地进行回退。 释放保留点 保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。自MySQL 5以来，也可以用**&#x3D;&#x3D;RELEASE SAVEPOINT&#x3D;&#x3D;**明确地释放保留点。 更改默认的提交行为默认的MySQL行为是自动提交所有更改。为指示MySQL不自动提交更改 1set autocommit = 0; 标志为连接专用autocommit标志是针对每个连接而不是服务器的。 安全管理访问控制MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当 的访问权，既不能多也不能少。 管理用户MySQL用户账号和信息存储在名为mysql的MySQL数据库中。 需要直接访问它的时机之一是在需要获得所有用户账号列表 时 12use mysql;select user from user; 创建用户账号CREATE USER语句 1create user ben identified by &#x27;123&#x27; 指定散列口令: IDENTIFIED BY指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密。为了作为散列值指定口 令，使用IDENTIFIED BY PASSWORD。 使用GRANT或INSERT : GRANT语句（稍后介绍）也可以创建用 户账号。也可以通过直接插入行到user表来增加用户。 重新命名RENAME USER语句 1rename user ben to bforta; 删除用户账号DROP USER语句 1drop user bforta; 自MySQL 5以来，DROP USER删除用户账号和 所有相关的账号权限。 在MySQL 5以前，先用**&#x3D;&#x3D;REVOKE&#x3D;&#x3D;**删除与账号相关的权限，然后 再用DROP USER删除账号 设置访问权限分配访问权限，新创建的用户账号没有访 问权限。 为看到赋予用户账号的权限，使用SHOW GRANTS FOR 1show grants for bforta; 用户bforta有一个权限USAGE ON . **&#x3D;&#x3D;USAGE&#x3D;&#x3D;**表示根本没有权限usage GRANT语句为设置权限，使用GRANT语句。 12grant select on crashcourse.* to bforta;show grants for bforta; 每个GRANT添加（或更新）用户的一个权限。MySQL读取所有 授权，并根据它们确定权限。 REVOKE语句GRANT的反操作为REVOKE。用它来撤销特定的权限 1revoke select on crashcourse.* from bforta; GRANT和REVOKE可在几个层次上控制访问权限： 整个服务器，使用GRANT ALL和REVOKE ALL； 整个数据库，使用ON database.*； 特定的表，使用ON database.table； 特定的列； 特定的存储过程。 简化多次授权可通过列出各权限并用逗号分隔，将多条 GRANT语句串在一起 1grant select, insert, on crashcourse.* to bforta; 更改口令SET PASSWORD语句 1set password for bforta = Password(&#x27;123&#x27;); Password()函 数进行加密 SET PASSWORD还可以用来设置你自己的口令 1set password = Password(&#x27;123&#x27;) 改善性能 首先，MySQL（与所有DBMS一样）具有特定的硬件建议。在学 习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但 对用于生产的服务器来说，应该坚持遵循这些硬件建议。 一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 MySQL是用一系列的默认设置预先配置的，从这些设置开始通常 是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大 小等。（为查看当前设置，可使用**SHOW VARIABLES;和SHOW STATUS;**。） MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多 个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执 行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登 录） 总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、 子查询等，找出最佳的方法。 使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。 应该总是使用正确的数据类型。 决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）。 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果 使用它，将把控制立即返回给调用程序，并且一旦有可能就实际 执行该操作。 在导入数据时，应该关闭自动提交。你可能还想删除索引（包括 FULLTEXT索引），然后在导入完成后再重建它们。 必须索引数据库表以改善数据检索的性能。确定索引什么不是一 件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花 的时间太长，则可以断定其中使用的列（或几个列）就是需要索 引的对象。 你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条 SELECT语句和连接它们的UNION语句，你能看到极大的性能改 进。 索引改善数据检索的性能，但损害数据插入、删除和更新的性能。 如果你有一些表，它们收集数据且不经常被搜索，则在有必要之 前不要索引它们。（索引可根据需要添加和删除。） LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会 改变。 最重要的规则就是，每条规则在某些条件下都会被打破。 MySQL数据类型串数据类型有两种基本的串类型，分别为定长串和变长串 MySQL不 允许对变长列（或一个列的可变部分）进行索引。 使用引号 不管使用何种形式的串数据类型，串值都必须括在 引号内（通常单引号更好） 数值数据类型数值数据类型存储数值。 UNSIGNED关键字有符号或无符号： 所有数值数据类型（除BIT和BOOLEAN外） 都可以有符号或无符号。有符号数值列可以存储正或负的数 值，无符号数值列只能存储正数。默认情况为有符号，但如 果你知道自己不需要存储负值，可以使用**&#x3D;&#x3D;UNSIGNED关键字&#x3D;&#x3D;**， 这样做将允许你存储两倍大小的值。 存储货币数据类型MySQL中没有专门存储货币的数据类 型，一般情况下使用**&#x3D;&#x3D;DECIMAL(8, 2)&#x3D;&#x3D;** 日期和时间数据类型 二进制数据类型二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、 多媒体、字处理文档等 InnoDBInnoDB页简介 InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？ 不，那样会慢死，InnoDB 采取的方式是：**&#x3D;&#x3D;将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 16 KB。&#x3D;&#x3D;** InnoDB行格式我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。 设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、 Dynamic 和 Compressed 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理 上大体都是相同的。 指定行格式的语法12345CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称ALTER TABLE 表名 ROW_FORMAT=行格式名称指定了这个表的字符集为 asciiCHARSET=ascii ROW_FORMAT=COMPACT; 因为 ascii 字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这 个表里的 COMPACT行格式 一条完整的记录其实可以被分为 &#x3D;&#x3D;记录的额外信息&#x3D;&#x3D; 和 &#x3D;&#x3D;记录的真实数据&#x3D;&#x3D; 两大部分 记录的额外信息：服务器为了描述这条记录而不得不额外添加的一些信息。分别是 变长字段 长度列表 、 NULL值列表 和 记录头信息 变长字段长度列表变长字段占用的存储空间分为两部分：1. 真正的数据内容 2. 占用的字节数。 在 Compact 行格式中，**&#x3D;&#x3D;把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，&#x3D;&#x3D;我们再次强调一遍，是&#x3D;&#x3D;逆序&#x3D;&#x3D;**存放！ NULL值列表 首先统计表中允许存储 NULL 的列有哪些 如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个 二进制位，二进制位按照列的顺序**&#x3D;&#x3D;逆序&#x3D;&#x3D;**排列，二进制位表示的意义如下： 二进制位的值为 1 时，代表该列的值为 NULL 。 二进制位的值为 0 时，代表该列的值不为 NULL 。 记录头信息除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组 成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图： 记录的真实数据 MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ） 列名 是否必须 占用空间 描述 row_id 否 6字节 行ID，唯一标识一条记录 transaction_id 是 6字节 事务ID roll_pointer 是 7字节 回滚指针 这里需要提一下 InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则 选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。 &#x3D;&#x3D;InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。&#x3D;&#x3D; CHAR(M)列的存储格式我们说在 Compact 行格式下只会把变长类型的列的长度**&#x3D;&#x3D;逆序&#x3D;&#x3D;**存到 变长字段长度列表 中 对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字 段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。 行溢出数据VARCHAR(M)最多能存储的数据对于 VARCHAR(M) 类型的列最多可以占用 65535 个字节。比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间： 真实数据 真实数据占用字节的长度 NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间 如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能 占用2个字节， NULL 值标识需要占用1个字节 如果 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2个字节，不需要 NULL 值标识 行溢出的临界点MySQL 中规定一个页中至少存放两行记录 总结Redundant行格式 Dynamic和Compressed行格式这两种行格式类似于 COMPACT行格式 ，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实 数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存 储其他页面的地址。 另外， Compressed 行格式会采用压缩算法对页面进行压缩。 一个页一般是 16KB ，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种 现象称为 行溢出 。 数据页结构 B+树索引InnoDB 数据页的7个组成部分，知道了各个数据页可以组成一个 双向链表，而每个数据页 中的记录会按照主键值从小到大的顺序组成一个 单向链表，每个数据页都会为存储在它里边儿的记录生成一个 页目录 ，在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对 应分组中的记录即可快速找到指定的记录，页和记录的关系示意图如下： 其中页a、页b、页c … 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。 B+树索引适用的条件123456789CREATE TABLE person_info( id INT NOT NULL auto_increment, name VARCHAR(100) NOT NULL, birthday DATE NOT NULL, phone_number CHAR(11) NOT NULL, country varchar(100) NOT NULL, PRIMARY KEY (id), KEY idx_name_birthday_phone_number (name, birthday, phone_number)); 先按照 name 列的值进行排序。 如果 name 列的值相同，则按照 birthday 列的值进行排序。 如果 birthday 列的值也相同，则按照 phone_number 的值进行排序。 这个排序方式**&#x3D;&#x3D;十分、特别、非常、巨、very very very重要&#x3D;&#x3D;**，因为只要页面和记录是排好序的，我们就可以通过二 分法来快速定位查找。 全值匹配如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句： 1SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27; AND phone_number = &#x27;15123983239&#x27;; 匹配左边的列其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句： 1SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27;; 或者包含多个左边的列也行： 1SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27;; 那为什么搜索条件中必须出现左边的列才可以使用到这个 B+ 树索引呢？比如下边的语句就用不到这个 B+ 树索引 么？ 1SELECT * FROM person_info WHERE birthday = &#x27;1990-09-27&#x27;; 如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列。 匹配列前缀对于字符串类型的索引列来说，我们只匹配 它的前缀也是可以快速定位记录的，比方说我们想查询名字以 ‘As’ 开头的记录，那就可以这么写查询语句： 1SELECT * FROM person_info WHERE name LIKE &#x27;As%&#x27;; 但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样： 1SELECT * FROM person_info WHERE name LIKE &#x27;%As%&#x27;; MySQL 就无法快速定位记录位置了，因为字符串中间有 ‘As’ 的字符串并没有排好序，所以只能全表扫描了。 有 时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个 url 列，该列中存储了许多url： url www.baidu.com www.google.com 假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件： WHERE url LIKE ‘%com’ ，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可 以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据： url moc.udiab.www moc.elgoog.www 这样再查找以 com 为后缀的网址时搜索条件便可以这么写： WHERE url LIKE ‘moc%’ ，这样就可以用到索引了。 匹配范围值所有记录都是按照索引列的值从小到大的顺 序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句： 1SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27;; 找到 name 值为 Asa 的记录。 找到 name 值为 Barlow 的记录。 &#x3D;&#x3D;记录之间用单链表，数据页之间用双链表&#x3D;&#x3D; 找到这些记录的主键值，再到 聚簇索引 中 回表 查找完整的记录。 如果对多个列同时进行范围查找的话，只有对索引最左边的那个 列进行范围查找的时候才能用到 B+ 树索引，比方说这样： 1SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; AND birthday &gt; &#x27;1980-01-01&#x27;; 通过 name 进行范围查 找的记录中可能并不是按照 birthday 列进行排序的 精确匹配某一列并范围匹配另外一列如果左边的列是精 确查找，则右边的列可以进行范围查找 1SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday &gt; &#x27;1980-01-01&#x27; AND birthday&lt; &#x27;2000-12-31&#x27; AND phone_number &gt; &#x27;15100000000&#x27;; 这个查询的条件可以分为3个部分： name &#x3D; ‘Ashburn’ ，对 name 列进行精确查找，当然可以使用 B+ 树索引了 birthday &gt; ‘1980-01-01’ AND birthday &lt; ‘2000-12-31’ ，由于 name 列是精确查找，所以通过 name &#x3D; ‘Ashburn’ 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序。所以此时 对 birthday 列进行范围查找是可以用到 B+ 树索引的。 phone_number &gt; ‘15100000000’ ，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个 条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。 用于排序在 MySQL 中，把这种在内存中或者磁 盘上进行排序的方式统称为文件排序（英文名： filesort ），跟 文件 这个词儿一沾边儿，就显得这些排序操作 非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果 ORDER BY 子句里使用到了我们的 索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句： 1SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10; 使用联合索引进行排序注意事项ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 ORDER BY phone_number, birthday, name 的顺序，那也是用不了 B+ 树索引 ORDER BY name 、 ORDER BY name, birthday 这种匹配索引左边的列的形式可以使用部分的 B+ 树索引。 当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样： 1SELECT * FROM person_info WHERE name = &#x27;A&#x27; ORDER BY birthday, phone_number LIMIT 10; 不可以使用索引进行排序的几种情况ASC、DESC混用 对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 ASC 规则 排序，要么都是 DESC 规则排序。 但是如果我们查询的需求是先按照 name 列进行升序排列，再按照 birthday 列进行降序排列的话，比如说这样的 查询语句： 1SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10; WHERE子句中出现非排序使用到的索引列如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样： 1SELECT * FROM person_info WHERE country = &#x27;China&#x27; ORDER BY name LIMIT 10; 这个查询只能先把符合搜索条件 country &#x3D; ‘China’ 的记录提取出来后再进行排序，是使用不到索引。注意和下 边这个查询作区别： 1SELECT * FROM person_info WHERE name = &#x27;A&#x27; ORDER BY birthday, phone_number LIMIT 10; 虽然这个查询也有搜索条件，但是 name &#x3D; ‘A’ 可以使用到索引 idx_name_birthday_phone_number ，而且过滤剩 下的记录还是按照 birthday 、 phone_number 列排序的，所以还是可以使用索引进行排序的。 排序列包含非同一个索引的列有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说： 1SELECT * FROM person_info ORDER BY name, country LIMIT 10; name 和 country 并不属于一个联合索引中的列，所以无法使用索引进行排序 排序列使用了复杂的表达式要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样： 1SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10; 使用了 UPPER 函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。 用于分组有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询： 1SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number 索引什么时候没用1.有or必全有索引;2.复合索引未用左列字段;3.like以%开头;4.需要类型转换;5.where中索引列有运算;6.where中索引列使用了函数;7.如果mysql觉得全表扫描更快时（数据少）（区间太大）; 索引什么时没必要用1.唯一性差;2.频繁更新的字段不用（更新索引消耗）;3.where中不用的字段;4.索引使用&lt;&gt;时，效果一般; 回表的代价1SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27;; 而查询列表是 * ，意味着要查询表中所有字段，也就是还要包括 country 字段。这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的 B+ 树中找到完整的用户记 录，也就是我们通常所说的 回表 ，然后把完整的用户记录返回给查询用户。 一般情况下，顺序I&#x2F;O比随机I&#x2F;O的性能高很多 会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。 访问二级索引使用 顺序I&#x2F;O ，访问聚簇索引使用 随机I&#x2F;O 。 &#x3D;&#x3D;需要回表的记录越多，使用二级索引的性能就越低&#x3D;&#x3D; 查询优化器：查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的 条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索 引 + 回表 的方式。 因为回表的记录越少， 性能提升就越高，比方说上边的查询可以改写成这样： 1SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; LIMIT 10 添加了 LIMIT 10 的查询更容易让优化器采用 二级索引 + 回表 的方式进行查询。 覆盖索引为了彻底告别 回表 操作带来的性能损耗，我们建议：**&#x3D;&#x3D;最好在查询列表里只包含索引列&#x3D;&#x3D;**，比如这样： 1SELECT name, birthday, phone_number FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; 不必到 聚簇索引 中再查找记录的剩余列，也就是 country 列的值了，这样就省去了 回表 操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为 索引 覆盖 。排序操作也优先使用 覆盖索引 的方式进行查询，比方说这个查询： 1SELECT name, birthday, phone_number FROM person_info ORDER BY name, birthday, phone_number; 总结在使用索引时需要注意下边这些事项： 只为用于搜索、排序或分组的列创建索引 为列的基数大的列创建索引 索引列的类型尽量小 可以只对字符串值的前缀建立索引 只有索引列在比较表达式中单独出现才可以适用索引 为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。 定位并删除表中的重复和冗余索引 尽量使用 覆盖索引 进行查询，避免 回表 带来的性能损耗。 索引目录项 其实长得跟我们的用户记录差不多，只不过 目录项 中的两个列是 主键 和 页号 而已，所以他们复用了之前存储 用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为 目录项记录 一个简单的索引方案我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？ 因为各个页中的记录并没有 规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 不得不 依次遍历所有的数据页。 **&#x3D;&#x3D;实际用户记录其实都存放在B+树的最底层的节点 上&#x3D;&#x3D;**，这些节点也被称为 叶子节点 或 叶节点 ，其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点 ，其 中 B+ 树最上边的那个节点也称为 根节点 。 那 InnoDB 怎么区分一条记录是普通的 用户记录 还是 目录项记录 呢？别忘了记录头信息里的 record_type 属性，它的各个取值代表的意思如下： 0 ：普通的用户记录 1 ：目录项记录 2 ：最小记录 3 ：最大记录 聚簇索引B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点： 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内的记录是按照主键的大小顺序排成一个单向链表。 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成 一个双向链表。 B+ 树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 我们把具有这两种特性的 B+ 树称为 &#x3D;&#x3D;聚簇索引&#x3D;&#x3D;，所有完整的用户记录都存放在这个 聚簇索引 的叶子节点处。这 种 聚簇索引 并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句）， InnoDB 存储引擎会&#x3D;&#x3D;自动的为我们创建聚簇索引&#x3D;&#x3D;。另外有趣的一点是，在 InnoDB 存储引擎中， 聚簇索引 就是数 据的存储方式（所有的用户记录都存储在了 叶子节点 ），也就是所谓的**&#x3D;&#x3D;索引即数据，数据即索引&#x3D;&#x3D;**。 二级索引我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。 这个 B+ 树与上边介绍的聚簇索引有几处不同： 使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义： 页内的记录是按照 c2 列的大小顺序排成一个单向链表。 各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排 成一个双向链表。 B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值。 目录项记录中不再是 主键+页号 的搭配，而变成了 c2列+页号 的搭配。 联合索引我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义： 先把各个记录和页按照 c2 列进行排序。 在记录的 c2 列相同的情况下，采用 c3 列进行排序 为 c2 和 c3 列建立的索引的示意图如下： 如图所示，我们需要注意一下几点： 每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录 的 c2 列相同，则按照 c3 列的值进行排序。 B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。 千万要注意一点，**&#x3D;&#x3D;以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思 与分别为c2和c3列分别建立索引的表述是不同的&#x3D;&#x3D;**，不同点如下： 建立 联合索引 只会建立如上图一样的1棵 B+ 树。 为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。 索引（csdn）索引的优缺点优点 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。 索引可以帮助服务器避免排序和创建临时表 索引可以将随机IO变成顺序IO索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁） 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 缺点 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 对于非常小的表，大部分情况下简单的全表扫描更高效； 创建索引准则应该创建索引的列 在经常需要搜索的列上，可以加快搜索的速度 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构 在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度 在经常需要根据范围（&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的 在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 不该创建索引的列 对于那些在查询中很少使用或者参考的列不应该创建索引。若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有很少数据值或者重复值多的列也不应该增加索引。这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为text, image和bit数据类型的列不应该增加索引。这些列的数据量要么相当大，要么取值很少。 当该列修改性能要求远远高于检索性能时，不应该创建索引。（修改性能和检索性能是互相矛盾的） 索引分类MySQL 的索引有两种分类方式：逻辑分类和物理分类。 逻辑分类按功能划分 主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL； 1ALTER TABLE TableName ADD PRIMARY KEY(column_list); 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 123CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));# 或者ALTER TABLE TableName ADD UNIQUE (column_list); 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入； 123CREATE INDEX IndexName ON `TableName`(`字段名`(length));# 或者ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length)); 全文索引：它查找的是文本中的关键词，主要用于全文检索。 按列数划分 单例索引：一个索引只包含一个列，一个表可以有多个单例索引。 组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。 物理分类分为聚簇索引和非聚簇索引（有时也称辅助索引或二级索引） 聚簇索引和非聚簇索引 聚簇是为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为聚簇码)上具有相同值的元组集中存放在连续的物理块。 聚簇索引（clustered index）不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。 非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。 虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的**&#x3D;&#x3D;主键索引才是聚簇索引&#x3D;&#x3D;**，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。每张表最多只能拥有一个聚簇索引。 聚簇索引优缺点优点： 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的排序查找和范围查找速度非常快 缺点： 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能） 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。 InnoDB索引实现InnoDB使用B+TREE存储数据，除了主键索引为聚簇索引，其它索引均为非聚簇索引。 一个表中只能存在一个聚簇索引（主键索引），但可以存在多个非聚簇索引。 InnoDB表的索引和数据是存储在一起的，&#x3D;&#x3D;.idb&#x3D;&#x3D;表数据和索引的文件 聚簇索引（主键索引）B+树 叶子节点包含数据表中行记录就是聚簇索引（索引和数据是存放在一块的） 可以看到叶子节点包含了完整的数据记录，这就是聚簇索引。因为InnoDB的数据文件（.idb）按主键聚集，所以InnoDB必须有主键（MyISAM可以没有），如果没有显示指定主键，则选取首个为唯一且非空的列作为主键索引，如果还没具备，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 主键索引结构分析： B+树单个叶子节点内的行数据按主键顺序排列，物理空间是连续的（聚簇索引的数据的物理存放顺序与索引顺序是一致的）； 叶子节点之间是通过指针连接，相邻叶子节点的数据在逻辑上也是连续的（根据主键值排序），实际存储时的数据页（叶子节点）可能相距甚远。 非聚簇索引（辅助索引或二级索引）在聚簇索引之外创建的索引（不是根据主键创建的）称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行数据记录，而是主键值。首先通过辅助索引找到主键值，然后到主键索引树中通过主键值找到数据行。 InnoDB索引优化 InnoDB中主键不宜定义太大，因为辅助索引也会包含主键列，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。 InnoDB中尽量不使用非单调字段作主键（不使用多列），因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 聚簇索引和非聚簇索引的区别 聚簇索引的叶子节点存放的是数据行（主键值也是行内数据），支持覆盖索引；而二级索引的叶子节点存放的是主键值或指向数据行的指针。 由于叶子节点(数据页)只能按照一棵B+树排序，故一张表只能有一个聚簇索引。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引。 操作索引创建索引索引名称 index_name 是可以省略的，省略后，索引的名称和索引列名相同。 1234567891011-- 创建普通索引 CREATE INDEX index_name ON table_name(col_name);-- 创建唯一索引CREATE UNIQUE INDEX index_name ON table_name(col_name);-- 创建普通组合索引CREATE INDEX index_name ON table_name(col_name_1,col_name_2);-- 创建唯一组合索引CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2); 修改表结构创建索引 1ALTER TABLE table_name ADD INDEX index_name(col_name); 创建表时直接指定索引 12345CREATE TABLE table_name ( ID INT NOT NULL, col_name VARCHAR (16) NOT NULL, INDEX index_name (col_name)); 删除索引12345-- 直接删除索引DROP INDEX index_name ON table_name;-- 修改表结构删除索引ALTER TABLE table_name DROP INDEX index_name; 其它相关命令12345678910111213-- 查看表结构desc table_name;-- 查看生成表的SQLshow create table table_name;-- 查看索引信息（包括索引结构等）show index from table_name;-- 查看SQL执行时间（精确到小数点后8位）set profiling = 1;SQL...show profiles; 索引实战使用EXPLAIN关键字可以模拟优化器执行SQL查询语句 explain使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句。 使用格式：**EXPLAIN SQL...;** EXPLAIN 查询结果包含的字段 id:选择标识符 select_type:表示查询的类型。table:输出结果集的表 partitions:匹配的分区 type:表示表的连接类型 possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引 key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数) filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明 Extra 探究Using index，Using index condition，Using where，其中Using index 表示使用了覆盖索引 最左前缀原则组合索引满足最左前缀原则就会生效。即最左优先（查询条件精确匹配索引的左边连续一列或几列，则构建对应列的组合索引树），在检索数据时也从联合索引的最左边开始匹配。 组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配。 只要筛选条件中含有组合索引最左边的列但不含有主键搜索键的时候，至少会构建包含组合索引最左列的索引树。（如：index(a)） 查询列都是组合索引列且筛选条件全是组合索引列时，会构建满列组合索引树（index(a,b,c) ）【覆盖索引】 筛选条件包含普通搜索键但没包含组合索引列最左键，不会构建组合索引树 如果筛选条件全是组合索引最左连续列作为搜索键，将构建连续列组合索引树。（比如：index(a,b)却不能index(a,c)） MySQL查询优化器会优化and连接，将组合索引列规则排号。（比如：b and a 等同于 a and b） 覆盖索引与回表上文我们介绍过索引可以划分为聚簇索引和辅助索引。在InnoDB中的主键索引就是聚簇索引，主键索引的查询效率也是非常高的，除此之外，还有非聚簇索引，其查询效率稍逊。覆盖索引其形式就是，搜索的索引键中的字段恰好是查询的字段（或是组合索引键中的其它字段）。覆盖索引的查询效率极高，原因在与其不用做回表查询。 回表查询的列数据作为索引树的键值，直接在索引树中得到反馈（存在于索引节点），不用遍历如InnoDB中的叶子节点（存放数据表各行数据）就可得到查询的数据（不用回表）。 ##索引的应用场景 123456789101112131415CREATE TABLE demo_info( id INT NOT NULL auto_increment, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY uk_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3))ENGINE = INNODB CHARSET=utf8mb4; 全值匹配如果我们的搜索条件中的列和索引列对应的话（列的字段和个数要相同），这种情况就称为全值匹配 1SELECT * FROM demo_info WHERE key_part_1 = &#x27;a&#x27; AND key_part_2 = &#x27;b&#x27; AND key_part_3 = &#x27;c&#x27;; 有的同学也许有个疑问，WHERE子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换key_part_1、key_part_2、key_part_3这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样 1SELECT * FROM demo_info WHERE key_part_2 = &#x27;b&#x27; AND key_part_3 = &#x27;c&#x27; AND key_part_1 = &#x27;a&#x27;; 答案是没有影响。只要你把联合索引的每个索引列都用到了，随意更换顺序是没有影响的，查询优化器会自动调整。 但是如果没有全部用到，那么就必须按照最左前缀原则使用。 最左前缀原则在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句： 1SELECT * FROM demo_info WHERE key_part_1 = &#x27;a&#x27;; 或者包含多个左边的列也行 1SELECT * FROM demo_info WHERE key_part_1 = &#x27;a&#x27; AND key_part_2 = &#x27;b&#x27;; 匹配列的前缀(比如like ‘a%’)匹配列的中间字符或者后缀(比如like ‘%a%’，like ‘%com’)如果查询中间包含的某个字符串，比如 1SELECT * FROM demo_info WHERE name LIKE &#x27;%a%&#x27;; MySQL就无法快速定位记录位置了，因为字符串中间有&#39;a&#39;的字符串并没有排好序，所以只能全表扫描了。 匹配范围查找，确定扫描区间和边界并不是所有的搜索条件都可以成为边界条件的，如下 1select * from demo_info where key1 &lt; &#x27;a&#x27; and key3 &gt; &#x27;z&#x27; and common_field = &#x27;abc&#x27; 注意：对于B+树索引来说，只要索引列和常数使用了=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（也就是&lt;&gt;）或者LIKE操作符连接起来，就可以产生所谓的扫描区间。 IS NULL、IS NOT NULL、!&#x3D;、BETWEEN、IN等等不能用索引吗？必须辟谣！IS NULL的例子 1explain select * from demo_info where key1 is null 虽然没有key1为null的记录，但还是走了索引。 IS NOT NULL的例子 1explain select * from demo_info where key1 is not null limit 5; !&#x3D; 的例子 1explain select * from demo_info where key1 != &#x27;a&#x27; limit 5; 这里也走了索引 between的例子 1explain select * from demo_info where key1 between &#x27;a&#x27; and &#x27;d&#x27; limit 5; 走索引 结论：对于B+树索引来说，只要索引列使用了&#x3D;、&lt;&#x3D;&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、BETWEEN、!&#x3D;（也就是&lt;&gt;）或者LIKE（只能是’a%’前缀字符形式）操作符连接起来，就可以使用到索引，如果你发现没走索引，请检查自己的结果集是否过多，限制一下结果集数量。 隐式转换导致全表扫描不走索引(这个坑容易忽视)这也是开发中经常可能遇到的坑。比如，你明明想利用索引查询key1=&#39;1&#39;的记录 1explain select * from demo_info where key1 = &#x27;1&#x27;; 结果！你却写成了key1 = 1;这个1可是number类型，不是varchar了，当字段类型和查询条件数据类型不一致的时候，如果没有函数转换，则会隐式转换，如果不能隐式转换则报错。这里varchar的&#39;1&#39;可以顺利转换number类型的1，**&#x3D;&#x3D;结果转换了类型，所以用不到索引。&#x3D;&#x3D;** 注意: Server层包括连接器、查询缓存（MySQL 8.0剔除）、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现。 而非聚集索引的查询和回表是在存储引擎层，如果要用函数判断，必须等到把完整记录返回给Server层，这里隐式转换用到函数就在Server层，在Server层就用不到索引了，所以是全表扫描。 使用联合索引的场景我们前面说了，有联合索引KEY idx_key_part(key_part1, key_part2, key_part3) eg1： 1select * from demo_info where key_part1 = &#x27;a&#x27; and key_part2 = &#x27;b&#x27;; 对于这个联合索引，先按照key_part1排序，在key_part1列的值相等的情况下再按照key_part2列进行排序，所以符合key_part1 &#x3D; ‘a’ and key_part2 &#x3D; ‘b’条件的非聚集索引记录一定是相邻的。 我们可以定位到符合key_part1 &#x3D; ‘a’ and key_part2 &#x3D; ‘b’条件的第一条记录，然后回表，接着定位满足key_part1 &#x3D; ‘a’ and key_part2 &#x3D; ‘b’的第二条记录，然后回表，就这样沿着记录所在的单链表往后扫描，直到不满足key_part1 &#x3D; ‘a’ 或者key_part2 &#x3D; ‘b’条件为止。（每找到一条满足条件的记录都会进行回表操作） eg2： 1select * from demo_info where key_part1 = &#x27;a&#x27; and key_part2 = &#x27;b&#x27; and key_part3 = &#x27;c&#x27;; eg3: 1select * from demo_info where key_part2 = &#x27;a&#x27;; 非聚集索引不是按照key_part2的值进行排序的。无法通过key_part2 = &#39;a&#39;这个条件来减少扫描的记录数量，只能全表扫描，不会使用 idx_key_part这个联合索引。 索引条件下推（Index Condition Pushdown，简称ICP）索引下推表象理解1select * from demo_info where key_part1 = &#x27;a&#x27; and key_part3 = &#x27;c&#x27; 在使用idx_key_part联合索引执行查询时，虽然不能直接用到key_part3，但是还是包含key_part3列的。因此每当从idx_key_part索引的扫描区间[‘a’, ‘a’]中获取到一条非聚集索引记录时，我们可以先判断这条二级索引记录是否符合key_part3&#x3D;’c’条件。如果符合该条件再执行回表操作，不符合就不回表，然后跳到下一条非聚集索引记录继续上述判断。这样可能减少因回表操作而带来的性能损耗，这种优化方式称为索引条件下推（Index Condition Pushdown，简称ICP）。 索引下推在存储引擎层和server层深入分析有联合索引KEY idx_key_part(key_part1, key_part2, key_part3)和普通索引KEY idx_key1 (key1) 1explain select * from demo_info where key_part1 = &#x27;a&#x27; and key_part3 = &#x27;c&#x27; and key1 &lt; &#x27;b&#x27;; 注意：筛选到一条非聚集索引记录后就去回表，而不是把所有满足条件的非聚集索引记录都拿到后去回表 范围查找也会使用到Using index condition，需要注意！1explain select * from demo_info where key_part1 &lt;= &#x27;a&#x27; limit 1; 我们可以看到这里的Extra有Using index condition。但是将范围查询改为等值查询后，结果就变了 1explain select * from demo_info where key_part1 = &#x27;a&#x27; limit 1 因为在InnoDB存储引擎层有特殊的处理方案，是不作为ICP条件进行处理的，所以不会用到Using index condition。 索引用于排序(explain分析案例，精华！！)在使用联合索引时需要注意，order by子句后面的列的顺序也必须按照索引的顺序来。对于联合索引KEY idx_key_part(key_part1, key_part2, key_part3)，如下查询是用不到索引的 12-- 用不到联合索引的例子explain select * from demo_info where key_part3 &lt;= &#x27;b&#x27; order by key_part1, key_part2; 不管是where子句还是order by子句，想要用到索引，就得按照规则来，如下 1explain select * from demo_info where key_part1 = &#x27;a&#x27; and key_part2 = &#x27;b&#x27; order by key_part3 limit 10; 当记录数很多却不用limit限制查询返回的记录数时，极有可能不走索引当我使用联合索引的条件去进行order by排序，结果却没有走索引，而是全表扫描 1explain select * from demo_info order by key_part1, key_part2; 当我限制只返回一条记录的时候，一下就走到了联合索引 1explain select * from demo_info order by key_part1, key_part2 limit 1; 其实这是查询优化器搞的鬼。如果需要回表的记录越多，查询优化器就越倾向于全表扫描，反之则使用非聚集索引+回表的方式。 **&#x3D;&#x3D;注意&#x3D;&#x3D;：当你&#x3D;&#x3D;order by 主键id&#x3D;&#x3D;的时候，&#x3D;&#x3D;一定是走索引的&#x3D;&#x3D;**，而且是走的PRIMARY索引，因为在聚集索引上就不存在回表了，不会使用全表扫描。 asc、desc混用无法完全利用索引，除非你的数据库是MySQL 8.0+首先说下asc和desc排序 asc升序排列大家知道，沿着页中单链表遍历即可。 desc降序排列就要注意了，你需要知道页中有Infimum+Supremum记录，可以先简单理解为头指针和尾指针。首先从头指针处遍历到最后一条用户记录，接着从头指针遍历到倒数第二条记录，从头指针遍历到倒数第三条记录… 这样就能获取到倒序排列的结果集了，很显然，asc升序排列获取结果集要快于desc降序排列。 实际上，一个页中的记录分了很多组，页中有一块Page Directory的空间存放了叫”槽“的东西，槽中存放着每个分组内最后一条记录在页面中的地址偏移量。只要找到了最后一条记录，然后找到分组的第一条记录(上一个槽的下一条记录)，就可以在这个分组内小范围的遍历获取倒序的结果。这可比从页中第一条记录开始遍历获取倒序结果好的多，大大减少遍历时间。 如果非要asc和desc混合排序，我们来分析一下 1explain select * from demo_info where key_part1 = &#x27;a&#x27; order by key_part2, key_part3 desc; MySQL 8.0 引入了Descending Index的特性，允许利用索引直接asc和desc混合排序。 索引声明是升序的，降序排列一定提示Using filesort 如果在MySQL 8.0+将key_part3为desc，这里索引改为KEY idx_key_part(key_part1, key_part2, key_part3 desc)，再次执行 1如果在MySQL 8.0+将key_part3为desc，这里索引改为KEY idx_key_part(key_part1, key_part2, key_part3 desc)，再次执行 结果是asc和desc完美的利用索引进行混合排序。而在MySQL8.0以下，索引声明desc是直接被忽略的。 排序中不能包含非同一索引的列，否则不走索引排序中用来排序的多个列不是同一索引是不能使用索引排序的。 前面说过，key1和key2不是联合索引KEY idx_key1 (key1)UNIQUE KEY uk_key2 (key2) 1explain select * from demo_info order by key1, key2 LIMIT 1; 排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续，则不走索引1explain select * from demo_info order by key_part1, key_part3 LIMIT 1; 如果你的排序条件换成连续的，马上就能用到索引了 1explain select * from demo_info order by key_part1, key_part2 LIMIT 1; 排序列是索引列，但是使用了函数，则不走索引1explain select * from demo_info order by UPPER(key1) limit 1; 因为key1列是以UPPER(key1)函数调用的形式出现在order by子句中，所以不能使用idx_key1执行上述查询。 索引的查询和回表是在存储引擎层，如果要用函数判断，必须等到把完整记录返回给Server层，在Server层就用不到索引了，所以是全表扫描。 索引用于分组有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询： 1explain select key_part1, key_part2, key_part3, count(*) from demo_info group by key_part1, key_part2, key_part3; 这个查询语句相当于做了3次分组操作 如果没有idx_key_part索引，就得建立一个用于统计的临时表，在扫描聚集索引的记录时将统计的中间结果填入这个临时表。当记录扫描完毕后，再把临时表中的结果作为结果集发送给客户端。 如果有了索引idx_key_part，恰巧这个分组顺序又与idx_key_part的索引列的顺序是一致的，而idx_key_part的非聚集索引记录又是按照索引列的值排好序的，所以可以直接使用索引进行分组，不用再建立临时表了。 如何更好的创建和使用索引只为用于搜索、排序或分组的列创建索引只为出现在where子句中的列、连接子句中的连接列，或者出现在order by或group by子句中的列创建索引。而出现在select查询列表中的列就没必要建立索引了： 1select common_field, key_part3 from demo_info where key1 = &#x27;a&#x27;; 像查询列表中的common_field、key_part3这两个列就没必要建立索引，我们只需要为出现在where子句中的key1 列创建索引就可以了。 考虑索引列中不重复值的个数不重复值的个数越多，可以称为区分度高或者筛选性好，区分度或者筛选性就是不重复值的个数与总个数的比值。 所以结论就是：最好为不重复值的个数多的列建立索引，区分度低说明该列包含过多重复值，那么在非聚集索引+回表的方式执行查询时，就有可能执行太多回表操作，导致查询优化器选择全表扫描。 索引列的类型尽量小以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT这么几种，它们占用的存储空间依次递增，能表示的整数范围依次递增。比如我们能使用INT就不要使用BIGINT，能使用MEDIUMINT就不要使用INT。因为数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以存放更多的记录，磁盘I/O带来的性能损耗就越小（一次页面I/O能将更多记录加载到内存中），读写效率就越高。 这个建议对于表的主键来说更加适用。因为不仅是聚集索引中会存储主键值，其他所有的非聚集索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着能节省更多的存储空间。 为索引字符串值的前缀建立索引只对字符串的前几个字符放到索引中，也就是说在非聚集索引的记录中只保留字符串前几个字符。如下： 1234-- 先删除原有索引alter table demo_info drop index idx_key1;-- 创建新的索引,保留前10个字符alter table demo_info add index idx_key1(key1(10)); 然后再执行下面查询语句 1select * from demo_info where key1 = &#x27;abcdefghijklmnop&#x27;; 在只对列前缀建立索引的情况下，就不能使用索引来完成排序需求了。 1select * from demo_info order by key1 LIMIT 10; 因为非聚集索引中不包含完整的key1 列信息，所以无法对key1列前10个字符相同但其余字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能全表扫描+文件排序的方式来执行了。 让索引在where子句的一侧单独出现表中有一个整数列key2，这个列建立了唯一索引。下边的两个where子句虽然语义是一致的，但是在效率上却有很大差别： 1explain select * from demo_info where key2 &lt; 4 - 1; 但是表达式调整之后 1explain select * from demo_info where key2 + 1 &lt; 4; 后者key2列并不是以单独出现的，而是以key2 + 1这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，所以这种情况下是使用不到key2列建立的B+树索引的。 所以结论就是：如果where子句中表达式的一侧的索引不是单独的形式出现，而是经过计算或者函数调用形式出现的话，是用不到索引的。 注意：索引树有key2的值，而不是key2 + 1的值，像这种计算不会在存储引擎层完成，而是在server层。 保证主键的插入顺序对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚集索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插入，如果新插入的主键值忽大忽小，这就比较麻烦了 可这个数据页已经满了啊，新纪录该插入到哪里呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的页中。页面分裂和记录移位有一定的性能损耗。 如有必要，尽量考虑使用索引覆盖我个人在某业务场景中，需要查询根据**会话id(session_id)和场景id(scene_id)**去查询有没有这条记录，从而继续下一步插入或者更新操作，但是session_id对应多个scene_id，所以session_id无法设置唯一索引。就不能使用存在则更新，不存在则插入的语法 1insert into 表名(字段1,字段2,...) values(值1, 值2,...) on duplicate key update 字段1=values(字段1), 字段2=values(字段2) 所以，我只查一查这条记录有没有，再去判断插入还是更新。建立联合索引idx_sessionid_sceneid(session_id, scene_id) 只需要如下 1select id from 表名 where session_id = &#x27;1212213&#x27; and scene_id = &#x27;scene123&#x27;; 这里只查询id，因为这样可以利用到索引覆盖 前面demo_info表中有KEY idx_key1 (key1) 1select key1 from demo_info order by key1; 这里虽然没有limit子句，但是由于可以采用索引覆盖，查询优化器会直接在非聚集索引进行排序，不需要回表操作。 避免创建冗余重复的索引我们有联合索引KEY idx_key_part(key_part1, key_part2, key_part3)。 如果你还单独建立一个key_part1索引，那就是多此一举，因为根据联合索引的最左前缀原则就已经可以用到key_part1索引了，索引的建立和维护也是需要时间和空间的，这种不必要的开销应该避免。 学习事务与隔离级别事务四要素：ACID 原子性（Atomicity）：要么全部完成，要么全部不完成； 一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见； 隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的隔离级别，通过适度的破坏一致性，得以提高性能； 持久性（Durability）：事务提交后即持久化到磁盘不会丢失。 事务并发存在的问题脏读（dirty read）没有提交的事务被其他事务读取到了，这叫做 脏读 。 不可重复读（unrepeatable read）同一个事务对同一条记录读取两遍，两次读出来的结果竟然不一样。 不可重复读和脏读的区别在于，脏读是读取了另一个事务未提交的修改，而不可重复读是读取了另一个事务提交之后的修改，本质上都是其他事务的修改影响了本事务的读取。 幻读（phantom read）于幻读，最简单的解释就是：同样的条件，第一次和第二次读出来的记录数不一样。 因为可能存在另一个事务先插入一条记录然后再删除一条记录的情况，这个时候两次查询得到的记录数也是一样的，但这也是幻读，所以严格点的说法应该是：两次读取得到的结果集不一样 不可重复读是因为其他事务进行了 UPDATE 操作，幻读是因为其他事务进行了 INSERT 或者 DELETE 操作。 丢失更新（lost update）那么如果两个事务都是写，又会发生什么呢？ 假设两个事务同时对 A 的余额进行修改，他们都查出 A 的当前余额为 1000，然后事务 2 修改 A 的余额，将 A 的余额加 100 变成 1100 并提交，这个时候 A 的余额应该是 1100，但是这个时候事务 1 并不知道 A 的余额已经变动，而是继续在 1000 的基础上进行减 100 的操作并提交事务，就这样事务 2 的提交被覆盖掉了，事务 1 提交之后 A 的余额变成了 900 元。这就是说事务 1 的提交覆盖了事务 2 的提交，事务 2 的 UPDATE 操作完全丢失了， 这就是经典的 丢失更新 问题，由于最后一步是提交操作，所以又叫做 提交覆盖，有时候又叫 Read-Modify-Write 问题。一个典型的场景是并发对某个变量进行自增或自减 有时候我们把回滚覆盖称之为 第一类丢失更新 问题，提交覆盖称为 第二类丢失更新 问题。 隔离级别 读未提交（Read Uncommitted）：可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到； 读已提交（Read Committed）：事务中只能看到已提交的修改，不会出现脏读现象，但是会出现幻读，不可重复读；（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR） 可重复读（Repeatable Read）：MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是任然存在幻读问题；（MySQL 的实现有差异，后面介绍） 序列化（Serializable）：最高隔离级别，啥并发问题都没有。 InnoDb 通过 MVCC 实现了读写并行，但是在不同的隔离级别下，读的方式也是有所区别的。 首先要特别指出的是，在 read uncommit 隔离级别下，每次都是读取最新版本的数据行，所以不能用 MVCC 的多版本，而 serializable 隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC。 RC 总是读取记录的最新版本，如果该记录被锁住，则读取该记录最新的一次快照，而 RR 是读取该记录事务开始时的那个版本。 快照读（Snapshot Read），有时候也叫做 非阻塞读（Nonlocking Read），RR 隔离级别下的叫做 一致性非阻塞读（Consistent Nonlocking Read）除了 快照读 ，MySQL 还提供了另一种读取方式：当前读（Current Read），有时候又叫做 加锁读（Locking Read） 或者 阻塞读（Blocking Read） &#x3D;&#x3D;RC 只加记录锁，RR 除了加记录锁，还会加间隙锁，用于解决幻读问题&#x3D;&#x3D; 查看和设置 MySQL 的隔离级别MySQL 中的系统变量 tx_isolation 的值来确定当前 MySQL 正在使用什么隔离级别。 用户变量 和 系统变量，用户变量的变量名格式为 @variable，而系统变量的格式为 @@variable，tx_isolation 是系统变量，所以变量名为 @@tx_isolation。其中，系统变量又可以分为 全局变量 和 会话变量，默认情况下使用 select @@variable 查询出来的是会话变量的值，也可以写作 select @@session.variable 或者 select @@local.variable，如果要查询全局变量的值，则使用 select @@global.variable。 另外可以使用 SET TRANSACTION命令修改 MySQL 的隔离级别， 了解常见的锁类型表锁 vs. 行锁表锁指的是对一整张表加锁，一般是 DDL 处理时使用，也可以自己在 SQL 中指定； 而行锁指的是锁定某一行数据或某几行，或行和行之间的间隙。 行锁的加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，通常都是用行锁来处理并发事务。 表锁由 MySQL 服务器实现，行锁由存储引擎实现，常见的就是 InnoDb，而 MyISAM 存储引擎只能使用表锁。 表锁一般在执行 DDL 语句时，譬如 ALTER TABLE 就会对整个表进行加锁。在执行 SQL 语句时，也可以明确对某个表加锁，譬如下面的例子： 1234567mysql&gt; lock table products read;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from products where id = 100; mysql&gt; unlock tables;Query OK, 0 rows affected (0.00 sec) 上面的 SQL 首先对 products 表加一个表锁，然后执行查询语句，最后释放表锁。表锁可以细分成两种：读锁和写锁，如果是加写锁，则是 lock table products write 关于表锁，我们要了解它的加锁和解锁原则，要注意的是它使用的是 一次封锁 技术，也就是说，我们会在会话开始的地方使用 lock 命令将后面所有要用到的表加上锁，在锁释放之前，我们只能访问这些加锁的表，不能访问其他的表，最后通过 unlock tables 释放所有表锁。这样的好处是，不会发生死锁！所以我们在 MyISAM 存储引擎中，是不可能看到死锁场景的。对多个表加锁的例子如下： 123456789101112131415mysql&gt; lock table products read, orders read;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from products where id = 100; mysql&gt; select * from orders where id = 200; mysql&gt; select * from users where id = 300;ERROR 1100 (HY000): Table &#x27;users&#x27; was not locked with LOCK TABLES mysql&gt; update orders set price = 5000 where id = 200;ERROR 1099 (HY000): Table &#x27;orders&#x27; was locked with a READ lock and can&#x27;t be updated mysql&gt; unlock tables;Query OK, 0 rows affected (0.00 sec) 可以看到由于没有对 users 表加锁，在持有表锁的情况下是不能读取的，另外，由于加的是读锁，所以后面也不能对 orders 表进行更新。 MySQL 表锁的加锁规则如下： 对于读锁 持有读锁的会话可以读表，但不能写表； 允许多个会话同时持有读锁； 其他会话就算没有给表加读锁，也是可以读表的，但是不能写表； 其他会话申请该表写锁时会阻塞，直到锁释放。 对于写锁 持有写锁的会话既可以读表，也可以写表； 只有持有写锁的会话才可以访问该表，其他会话访问该表会被阻塞，直到锁释放； 其他会话无论申请该表的读锁或写锁，都会阻塞，直到锁释放。 锁的释放规则如下： 使用 UNLOCK TABLES 语句可以显示释放表锁； 如果会话在持有表锁的情况下执行 LOCK TABLES 语句，将会释放该会话之前持有的锁； 如果会话在持有表锁的情况下执行 START TRANSACTION 或 BEGIN 开启一个事务，将会释放该会话之前持有的锁； 如果会话连接断开，将会释放该会话所有的锁。 行锁表锁不仅实现和使用都很简单，而且占用的系统资源少，如 MyISAM、MEMORY、MERGE 等，MyISAM 存储引擎几乎完全依赖 MySQL 服务器提供的表锁机制，查询自动加表级读锁，更新自动加表级写锁，以此来解决可能的并发问题。表锁的粒度太粗，导致数据库的并发性能降低，为了提高数据库的并发能力，InnoDb 引入了行锁的概念。 行锁和表锁对比如下： 表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 行锁和表锁一样，也分成两种类型：读锁和写锁。常见的增删改（INSERT、DELETE、UPDATE）语句会自动对操作的数据行加写锁，查询的时候也可以明确指定锁的类型， &#x3D;&#x3D;SELECT … LOCK IN SHARE MODE(lock in share mode) 语句加的是读锁，&#x3D;&#x3D; &#x3D;&#x3D;SELECT … FOR UPDATE(for update) 语句加的是写锁。&#x3D;&#x3D; 在 MySQL 中，行锁是加在索引上的。所以要深入了解行锁，还需要先了解下 MySQL 中索引的结构。 MySQL 有两种索引类型：主键索引（Primary Index）和非主键索引（Secondary Index，又称为二级索引、辅助索引）。InnoDb 的主键索引有时候又被称为 聚簇索引（Clustered Index），二级索引被称为 非聚簇索引（Nonclustered Index） 当执行下面的 SQL 时（id 为 students 表的主键），我们要知道，InnoDb 存储引擎会在 id &#x3D; 49 这个主键索引上加一把 &#x3D;&#x3D;X 锁(排它锁)。S锁(共享锁)&#x3D;&#x3D; 1mysql&gt; update students set score = 100 where id = 49; 当执行下面的 SQL 时（name 为 students 表的二级索引），InnoDb 存储引擎会在 name &#x3D; ‘Tom’ 这个索引上加一把 X 锁，同时会通过 name &#x3D; ‘Tom’ 这个二级索引定位到 id &#x3D; 49 这个主键索引，并在 id &#x3D; 49 这个主键索引上加一把 X 锁。 1mysql&gt; update students set score = 100 where name = &#x27;Tom&#x27;; 譬如下面的 SQL（假设 score 字段为二级索引）： 1mysql&gt; update students set level = 3 where score &gt;= 60; 下图展示了当用户执行这条 SQL 时，MySQL Server 和 InnoDb 之间的执行流程： 从图中可以看到当 UPDATE 语句被发给 MySQL 后，MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁（current read），待 MySQL Server 收到这条加锁的记录之后，会再发起一个 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，MySQL 在操作多条记录时 InnoDB 与 MySQL Server 的交互是一条一条进行的，加锁也是一条一条依次进行的，先对一条满足条件的记录加锁，返回给 MySQL Server，做一些 DML 操作，然后在读取下一条加锁，直至读取完毕。 行锁种类12345678#define LOCK_TABLE 16 /* table lock */#define LOCK_REC 32 /* record lock *//* Precise modes */#define LOCK_ORDINARY 0 #define LOCK_GAP 512 #define LOCK_REC_NOT_GAP 1024 #define LOCK_INSERT_INTENTION 2048 LOCK_ORDINARY：也称为 Next-Key Lock，锁一条记录及其之前的间隙，这是 RR 隔离级别用的最多的锁，从名字也能看出来； LOCK_GAP：间隙锁，锁两个记录之间的 GAP，防止记录插入； LOCK_REC_NOT_GAP：只锁记录； LOCK_INSERT_INTENSION：插入意向 GAP 锁，插入记录时使用，是 LOCK_GAP 的一种特例。 读锁 vs. 写锁MySQL 将锁分成两类：锁类型（lock_type）和锁模式（lock_mode）。 锁类型就是上文中介绍的表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方； 而锁模式描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的，锁模式在 MySQL 的源码中定义如下： 123456789/* Basic lock modes */enum` `lock_mode &#123; ``LOCK_IS = 0, ``/* intention shared */ ``LOCK_IX, ``/* intention exclusive */ ``LOCK_S, ``/* shared */ ``LOCK_X, ``/* exclusive */ ``LOCK_AUTO_INC, ``/* locks the auto-inc counter of a table in an exclusive mode*/ ``...&#125;; LOCK_IS：读意向锁； LOCK_IX：写意向锁； LOCK_S：读锁； LOCK_X：写锁； LOCK_AUTO_INC：自增锁； 将锁分为读锁和写锁主要是为了提高读的并发，如果不区分读写锁，那么数据库将没办法并发读，并发性将大大降低。而 IS（读意向）、IX（写意向）只会应用在表锁上，方便表锁和行锁之间的冲突检测。LOCK_AUTO_INC 是一种特殊的表锁。 读写锁读锁，又称共享锁（Share locks，简称 S 锁），加了读锁的记录，所有的事务都可以读取，但是不能修改，并且可同时有多个事务对记录加读锁。写锁，又称排他锁（Exclusive locks，简称 X 锁），或独占锁，对记录加了排他锁之后，只有拥有该锁的事务可以读取和修改，其他事务都不可以读取和修改，并且同一时间只能有一个事务加写锁。（注意：这里说的读都是当前读，快照读是无需加锁的，记录上无论有没有锁，都可以快照读） 在其他的数据库系统中（譬如 MSSQL），我们可能还会看到一种基本的锁模式：更新锁（Update locks，简称 U 锁），MySQL 暂时不支持 U 锁，所以这里只是稍微了解一下。这个锁主要是用来防止死锁的，因为多数数据库在加 X 锁的时候是先获取 S 锁，获取成功之后再升级成 X 锁，如果有两个事务同时获取了 S 锁，然后又同时尝试升级 X 锁，就会发生死锁。增加 U 锁表示有事务对该行有更新意向，只允许一个事务拿到 U 锁，该事务在发生写后 U 锁变 X 锁，未写时看做 S 锁。（疑问：MySQL 更新的时候是直接申请 X 锁么？） 读写意向锁表锁锁定了整张表，而行锁是锁定表中的某条记录，它们俩锁定的范围有交集，因此表锁和行锁之间是有冲突的。为了方便检测表锁和行锁的冲突，从而引入了意向锁。 意向锁为表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。 当事务试图读或写某一条记录时，会先在表上加上意向锁，然后才在要操作的记录上加上读锁或写锁。这样判断表中是否有记录加锁就很简单了，只要看下表上是否有意向锁就行了。意向锁之间是不会产生冲突的，也不和 AUTO_INC 表锁冲突，它只会阻塞表级读锁或表级写锁，另外，意向锁也不会和行锁冲突，行锁只会和行锁冲突。 下面是各个表锁之间的兼容矩阵： 因为是斜对称的，所以我们用一条斜线把表格分割成两个部分，只需要看左下角的一半即可。总结起来有下面几点： 意向锁之间互不冲突； S 锁只和 S&#x2F;IS 锁兼容，和其他锁都冲突； X 锁和其他所有锁都冲突； AI 锁只和意向锁兼容； AUTO_INC 锁AUTO_INC 锁又叫自增锁（一般简写成 AI 锁），它是一种特殊类型的表锁，当插入的表中有自增列（AUTO_INCREMENT）的时候可能会遇到。 当插入表中有自增列时，数据库需要自动生成自增值，在生成之前，它会先为该表加 AUTO_INC 表锁，其他事务的插入操作阻塞，这样保证生成的自增值肯定是唯一的。AUTO_INC 锁具有如下特点： AUTO_INC 锁互不兼容，也就是说同一张表同时只允许有一个自增锁； 自增锁不遵循二段锁协议，它并不是事务结束时释放，而是在 INSERT 语句执行结束时释放，这样可以提高并发插入的性能。 自增值一旦分配了就会 +1，如果事务回滚，自增值也不会减回去，所以自增值可能会出现中断的情况。 显然，AUTO_INC 表锁会导致并发插入的效率降低，为了提高插入的并发性，MySQL 从 5.1.22 版本开始，引入了一种可选的轻量级锁（mutex）机制来代替 AUTO_INC 锁，我们可以通过参数 innodb_autoinc_lock_mode 控制分配自增值时的并发策略。参数 innodb_autoinc_lock_mode 可以取下列值： innodb_autoinc_lock_mode &#x3D; 0 （traditional lock mode） 使用传统的 AUTO_INC 表锁，并发性比较差。 innodb_autoinc_lock_mode &#x3D; 1 （consecutive lock mode） MySQL 默认采用这种方式，是一种比较折中的方法。 MySQL 将插入语句分成三类：Simple inserts、Bulk inserts、Mixed-mode inserts。通过分析 INSERT 语句可以明确知道插入数量的叫做 Simple inserts；通过分析 INSERT 语句无法确定插入数量的叫做 Bulk inserts；还有一种是不确定是否需要分配自增值的 Bulk inserts 不能确定插入数使用表锁；Simple inserts 和 Mixed-mode inserts 使用轻量级锁 mutex，只锁住预分配自增值的过程，不锁整张表。 Bulk inserts 不能确定插入数使用表锁；Simple inserts 和 Mixed-mode inserts 使用轻量级锁 mutex，只锁住预分配自增值的过程，不锁整张表。 innodb_autoinc_lock_mode &#x3D; 2 （interleaved lock mode） 全部都用轻量级锁 mutex，并发性能最高，按顺序依次分配自增值，不会预分配。 缺点是不能保证同一条 INSERT 语句内的自增值是连续的，这样在复制（replication）时，如果 binlog_format 为 statement-based（基于语句的复制）就会存在问题，因为是来一个分配一个，同一条 INSERT 语句内获得的自增值可能不连续，主从数据集会出现数据不一致。所以在做数据库同步时要特别注意这个配置。 细说 MySQL 锁类型行锁也有可能并不是锁在行上而是行与行之间的间隙上，事实上，我理解的这种锁是最简单的行锁模式：记录锁。 记录锁（Record Locks）记录锁是最简单的行锁，并没有什么好说的。譬如下面的 SQL 语句（id 为主键）： 1mysql&gt; UPDATE accounts SET level = 100 WHERE id = 5; 这条 SQL 语句就会在 id &#x3D; 5 这条记录上加上记录锁，防止其他事务对 id &#x3D; 5 这条记录进行修改或删除。记录锁永远都是加在索引上的。如果 WHERE 条件中指定的列是个二级索引，那么记录锁不仅会加在这个二级索引上，还会加在这个二级索引所对应的聚簇索引上。 注意，如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。 间隙锁（Gap Locks）还是看上面的那个例子，如果 id &#x3D; 5 这条记录不存在，这个 SQL 语句还会加锁吗？答案是可能有，这取决于数据库的隔离级别。 间隙锁 是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。有时候又称为范围锁（Range Locks）。这个范围可以跨一个索引记录，多个索引记录，甚至是空的。这个范围可以跨一个索引记录，多个索引记录，甚至是空的。这个范围可以跨一个索引记录，多个索引记录，甚至是空的。 回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id &#x3D; 5 前后两个索引之间加上间隙锁。 回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id &#x3D; 5 前后两个索引之间加上间隙锁。 Next-Key LocksNext-key 锁 是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。 插入意向锁（Insert Intention Locks）插入意向锁 是一种特殊的间隙锁（所以有的地方把它简写成 II GAP），这个锁表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混淆了。插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。 插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，那么间隙锁是如何防止幻读的呢？正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。 行锁的兼容矩阵下面我们对这四种行锁做一个总结，它们之间的兼容矩阵如下图所示： 其中，第一行表示已有的锁，第一列表示要加的锁。 插入意向锁做个总结: 插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的； 插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。 了解插入意向锁的特点之后，我们将它从矩阵中移去，兼容矩阵就变成了下面这个样子： 这个看起来就非常简单了，可以得出下面的结论： 间隙锁不和其他锁（不包括插入意向锁）冲突； 记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突； 在 MySQL 中观察行锁有两种方式可以在 MySQL 中观察行锁，第一种是通过下面的 SQL 语句： 1mysql&gt; select * from information_schema.innodb_locks; 这个命令会打印出 InnoDb 的所有锁信息，包括锁 ID、事务 ID、以及每个锁的类型和模式等其他信息。第二种是使用下面的 SQL 语句： 1mysql&gt; show engine innodb status\\G 这个命令并不是专门用来查看锁信息的，而是用于输出当前 InnoDb 引擎的状态信息，包括：BACKGROUND THREAD、SEMAPHORES、TRANSACTIONS、FILE I&#x2F;O、INSERT BUFFER AND ADAPTIVE HASH INDEX、LOG、BUFFER POOL AND MEMORY、ROW OPERATIONS 等等。其中 TRANSACTIONS 部分会打印当前 MySQL 所有的事务，如果某个事务有加锁，还会显示加锁的详细信息。如果发生死锁，也可以通过这个命令来定位死锁发生的原因。不过在这之前需要先打开 Innodb 的锁监控： 12mysql&gt; set global innodb_status_output = ON;mysql&gt; set global innodb_status_output_locks = ON; 打开锁监控之后，使用 show engine innodb status 命令，会输出大量的信息，我们在其中可以找到 TRANSACTIONS 部分，这里面就包含了每个事务及相关锁的信息，如下所示： show engine innodb status 的输出比较晦涩，要读懂它还需要学习一些其他知识，我们这里暂且不提，后面再专门对其进行介绍。这里使用 information_schema.innodb_locks 表来体验一下 MySQL 中不同的行锁。 要注意的是，只有在两个事务出现锁竞争时才能在这个表中看到锁信息，譬如你执行一条 UPDATE 语句，它会对某条记录加 X 锁，这个时候 information_schema.innodb_locks 表里是没有任何记录的。 另外，只看这个表只能得到当前持有锁的事务，至于是哪个事务被阻塞，可以通过 information_schema.innodb_lock_waits 表来查看。 ###记录锁 根据上面的行锁兼容矩阵，记录锁和记录锁或 Next-key 锁冲突，所以想观察到记录锁，可以让两个事务都对同一条记录加记录锁，或者一个事务加记录锁另一个事务加 Next-key 锁。 事务 A 执行： 12345678mysql&gt; begin;mysql&gt; select * from accounts where id = 5 for update;+----+----------+-------+| id | name | level |+----+----------+-------+| 5 | zhangsan | 7 |+----+----------+-------+1 row in set (0.00 sec) 事务 B 执行： 12mysql&gt; begin;mysql&gt; select * from accounts where id = 5 lock in share mode; 事务 B 阻塞，出现锁竞争，查看锁状态： 12345678mysql&gt; select * from information_schema.innodb_locks;+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+| lock_id | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+| 3108:53:3:4 | 3108 | S | RECORD | `accounts` | PRIMARY | 53 | 3 | 4 | 5 || 3107:53:3:4 | 3107 | X | RECORD | `accounts` | PRIMARY | 53 | 3 | 4 | 5 |+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+2 rows in set, 1 warning (0.00 sec) 间隙锁根据兼容矩阵，间隙锁只和插入意向锁冲突，而且是先加间隙锁，然后加插入意向锁时才会冲突。 事务 A 执行（id 为主键，且 id &#x3D; 3 这条记录不存在）： 123mysql&gt; begin;mysql&gt; select * from accounts where id = 3 lock in share mode;Empty set (0.00 sec) 事务 B 执行： 12mysql&gt; begin;mysql&gt; insert into accounts(id, name, level) value(3, &#x27;lisi&#x27;, 10); 事务 B 阻塞，出现锁竞争，查看锁状态： 12345678mysql&gt; select * from information_schema.innodb_locks;+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+| lock_id | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+| 3110:53:3:4 | 3110 | X,GAP | RECORD | `accounts` | PRIMARY | 53 | 3 | 4 | 3 || 3109:53:3:4 | 3109 | S,GAP | RECORD | `accounts` | PRIMARY | 53 | 3 | 4 | 3 |+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+2 rows in set, 1 warning (0.00 sec) Next-key 锁根据兼容矩阵，Next-key 锁和记录锁、Next-key 锁或插入意向锁冲突，但是貌似很难制造 Next-key 锁和记录锁冲突的场景，也很难制造 Next-key 锁和 Next-key 锁冲突的场景（如果你能找到这样的例子，还望不吝赐教）。所以还是用 Next-key 锁和插入意向锁冲突的例子，和上面间隙锁的例子几乎一样。 事务 A 执行（level 为二级索引）： 123456789mysql&gt; begin;mysql&gt; select * from accounts where level = 7 lock in share mode;+----+----------+-------+| id | name | level |+----+----------+-------+| 5 | zhangsan | 7 || 9 | liusan | 7 |+----+----------+-------+2 rows in set (0.00 sec) 事务 B 执行： 12mysql&gt; begin;mysql&gt; insert into accounts(name, level) value(&#x27;lisi&#x27;, 7); 事务 B 阻塞，出现锁竞争，查看锁状态： 12345678mysql&gt; select * from information_schema.innodb_locks;+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+| lock_id | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+| 3114:53:5:5 | 3114 | X,GAP | RECORD | `accounts` | level | 53 | 5 | 5 | 0x5A119FA1, 10 || 3113:53:5:5 | 3113 | S,GAP | RECORD | `accounts` | level | 53 | 5 | 5 | 0x5A119FA1, 10 |+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+2 rows in set, 1 warning (0.00 sec) 可以看到除了锁住的索引不同之外，Next-key 锁和间隙锁之间几乎看不出任何差异。 乐观锁 vs. 悲观锁锁的思想 其实在讲 MVCC 的时候也提到过，解决并发问题的方式除了锁，还可以利用时间戳或者版本号等等手段。前一种处理数据的方式通常叫做 悲观锁（Pessimistic Lock），第二种无锁方式叫做 乐观锁（Optimistic Lock）。 悲观锁，顾名思义就是很悲观，每次拿数据时都假设有别人会来修改，所以每次在拿数据的时候都会给数据加上锁，用这种方式来避免跟别人冲突，虽然很有效，但是可能会出现大量的锁冲突，导致性能低下。 乐观锁则是完全相反，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有改过这个数据，可以使用版本号等机制来判断。 总的来说，悲观锁需要使用数据库的锁机制来实现，而乐观锁是通过程序的手段来实现 像乐观锁适用于读多写少的情况下，即冲突真的很少发生，这样可以省去锁的开销，加大系统的吞吐量。但如果经常产生冲突，上层应用不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁更合适。虽然使用带版本检查的乐观锁能够同时保持高并发和高可伸缩性，但它也不是万能的，譬如它不能解决脏读问题，所以在实际应用中还是会和数据库的隔离级别一起使用。 常见 SQL 语句的加锁分析总体来说，MySQL 中的锁可以分成两个粒度：表锁和行锁，表锁有：表级读锁，表级写锁，读意向锁，写意向锁，自增锁；行锁有：读记录锁，写记录锁，间隙锁，Next-key 锁，插入意向锁。 不同的隔离级别加锁也是不一样的，譬如 RR 隔离级别下有间隙锁和 Next-key 锁，这在 RC 隔离级别下是没有的（也有例外） 基本的加锁规则快照读是不加锁的，更新语句肯定是加排它锁的，RC 隔离级别是没有间隙锁的等等。这些规则整理如下，后面就不再重复介绍了： 常见语句的加锁 SELECT … 语句正常情况下为快照读，不加锁； SELECT … LOCK IN SHARE MODE 语句为当前读，加 S 锁； SELECT … FOR UPDATE 语句为当前读，加 X 锁； 常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁； 常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚； 表锁 表锁（分 S 锁和 X 锁） 意向锁（分 IS 锁和 IX 锁） 自增锁（一般见不到，只有在 innodb_autoinc_lock_mode &#x3D; 0 或者 Bulk inserts 时才可能有） 行锁 记录锁（分 S 锁和 X 锁） 间隙锁（分 S 锁和 X 锁） Next-key 锁（分 S 锁和 X 锁） 插入意向锁 行锁分析 行锁都是加在索引上的，最终都会落在聚簇索引上； 加行锁的过程是一条一条记录加的； 锁冲突 S 锁和 S 锁兼容，X 锁和 X 锁冲突，X 锁和 S 锁冲突； 表锁和行锁的冲突矩阵 不同隔离级别下的锁 上面说 SELECT … 语句正常情况下为快照读，不加锁；但是在 Serializable 隔离级别下为当前读，加 S 锁； RC 隔离级别下没有间隙锁和 Next-key 锁（特殊情况下也会有：purge + unique key）； 不同隔离级别下锁的区别 简单 SQL 的加锁分析我们使用下面这张 students 表作为实例，其中 id 为主键，no（学号）为二级唯一索引，name（姓名）和 age（年龄）为二级非唯一索引，score（学分）无索引。 这一节我们只分析最简单的一种 SQL，它只包含一个 WHERE 条件，等值查询或范围查询。虽然 SQL 非常简单，但是针对不同类型的列，我们还是会面对各种情况： 聚簇索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 15; 聚簇索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 16; 二级唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0003’; 二级唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0008’; 二级非唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘Tom’; 二级非唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘John’; 无索引：UPDATE students SET score &#x3D; 100 WHERE score &#x3D; 22; 聚簇索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE id &lt;&#x3D; 20; 二级索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE age &lt;&#x3D; 23; 修改索引值：UPDATE students SET name &#x3D; ‘John’ WHERE id &#x3D; 15; 聚簇索引，查询命中语句 UPDATE students SET score = 100 WHERE id = 15 在 RC 和 RR 隔离级别下加锁情况一样，都是对 id 这个聚簇索引加 X 锁，如下： 聚簇索引，查询未命中如果查询未命中纪录，在 RC 和 RR 隔离级别下加锁是不一样的，因为 RR 有 GAP 锁。语句 UPDATE students SET score = 100 WHERE id = 16 在 RC 和 RR 隔离级别下的加锁情况如下（RC 不加锁）： 二级唯一索引，查询命中语句 UPDATE students SET score = 100 WHERE no = &#39;S0003&#39; 命中二级唯一索引，上一篇博客中我们介绍了索引的结构，我们知道二级索引的叶子节点中保存了主键索引的位置，在给二级索引加锁的时候，主键索引也会一并加锁。这个在 RC 和 RR 两种隔离级别下没有区别： 那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 students 表进行更新，如：UPDATE students SET score = 100 WHERE id = 20，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。 二级唯一索引，查询未命中如果查询未命中纪录，和 2.2 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 UPDATE students SET score = 100 WHERE no = &#39;S0008&#39; 加锁情况如下： 这种情况下只会在二级索引加锁，不会在聚簇索引上加锁。 二级非唯一索引，查询命中如果查询命中的是二级非唯一索引，在 RR 隔离级别下，还会加 GAP 锁。语句 UPDATE students SET score = 100 WHERE name = &#39;Tom&#39; 加锁如下： 为什么非唯一索引会加 GAP 锁，而唯一索引不用加 GAP 锁呢？原因很简单，GAP 锁的作用是为了解决幻读，防止其他事务插入相同索引值的记录，而唯一索引和主键约束都已经保证了该索引值肯定只有一条记录，所以无需加 GAP 锁。 这里还有一点要注意一下，数一数右图中的锁你可能会觉得一共加了 7 把锁，实际情况不是，要注意的是 (Tom, 37) 上的**&#x3D;&#x3D;记录锁和它前面的 GAP 锁合起来是一个 Next-key 锁&#x3D;&#x3D;**，这个锁加在 (Tom, 37) 这个索引上，另外 (Tom, 49) 上也有一把 Next-key 锁。那么最右边的 GAP 锁加在哪呢？右边已经没有任何记录了啊。其实，在 InnoDb 存储引擎里，每个数据页中都会有两个虚拟的行记录，用来限定记录的边界，分别是：Infimum Record 和 Supremum Record，Infimum 是比该页中任何记录都要小的值，而 Supremum 比该页中最大的记录值还要大，这两条记录在创建页的时候就有了，并且不会删除。上面右边的 GAP 锁就是加在 Supremum Record 上。所以说，上面右图中共有 2 把 Next-key 锁，1 把 GAP 锁，2 把记录锁，一共 5 把锁。 二级非唯一索引，查询未命中如果查询未命中纪录，RR 隔离级别会加 GAP 锁，RC 无锁。语句 UPDATE students SET score = 100 WHERE name = &#39;John&#39; 加锁情况如下： 无索引如果 WHERE 条件不能走索引，MySQL 会如何加锁呢？有的人说会在表上加 X 锁，也有人说会根据 WHERE 条件将筛选出来的记录在聚簇索引上加上 X 锁，那么究竟如何，我们看下图： 在没有索引的时候，只能走聚簇索引，对表中的记录进行全表扫描。在 RC 隔离级别下会给所有记录加行锁，在 RR 隔离级别下，不仅会给所有记录加行锁，所有聚簇索引和聚簇索引之间还会加上 GAP 锁。 语句 UPDATE students SET score = 100 WHERE score = 22 满足条件的虽然只有 1 条记录，但是聚簇索引上所有的记录，都被加上了 X 锁。那么，为什么不是只在满足条件的记录上加锁呢？这是由于 MySQL 的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 MySQL Server 层进行过滤，因此也就把所有的记录都锁上了。 不过在实际的实现中，MySQL 有一些改进，如果是 RC 隔离级别，在 MySQL Server 过滤条件发现不满足后，会调用 unlock_row 方法，把不满足条件的记录锁释放掉（违背了 2PL 的约束）。这样做可以保证最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。如果是 RR 隔离级别，一般情况下 MySQL 是不能这样优化的，除非设置了 innodb_locks_unsafe_for_binlog 参数，这时也会提前释放锁，并且不加 GAP 锁，这就是所谓的 semi-consistent read。 聚簇索引，范围查询 SQL 语句为 UPDATE students SET score = 100 WHERE id &lt;= 20，按理说我们只需要将 id &#x3D; 20、18、15 三条记录锁住即可，但是看右边的图，在 RR 隔离级别下，我们还把 id &#x3D; 30 这条记录以及 (20, 30] 之间的间隙也锁起来了，很显然这是一个 Next-key 锁。如果 WHERE 条件是 id &lt; 20，则会把 id &#x3D; 20 这条记录锁住。 所以对于范围查询，如果 WHERE 条件是 id &lt;&#x3D; N，那么 N 后一条记录也会被加上 Next-key 锁；如果条件是 id &lt; N，那么 N 这条记录会被加上 Next-key 锁。另外，如果 WHERE 条件是 id &gt;&#x3D; N，只会给 N 加上记录锁，以及给比 N 大的记录加锁，不会给 N 前一条记录加锁；如果条件是 id &gt; N，也不会锁前一条记录，连 N 这条记录都不会锁。 二级索引，范围查询然后我们把范围查询应用到二级非唯一索引上来，SQL 语句为：UPDATE students SET score = 100 WHERE age &lt;= 23，加锁情况如下图所示： 可以看出和聚簇索引的范围查询一样，除了 WHERE 条件范围内的记录加锁之外，后面一条记录也会加上 Next-key 锁，这里有意思的一点是，尽管满足 age &#x3D; 24 的记录有两条，但只有第一条被加锁，第二条没有加锁，并且第一条和第二条之间也没有加锁。 复杂条件加锁分析这里就只是学习一下在对复杂 SQL 加锁分析之前如何先对索引进行分析。譬如下面这样的 SQL： 1mysql&gt; DELETE FROM students WHERE name = &#x27;Tom&#x27; AND age = 22; 其中 name 和 age 两个字段都是索引，那么该如何加锁？ DELETE 语句加锁分析一般来说，DELETE 的加锁和 SELECT FOR UPDATE 或 UPDATE 并没有太大的差异，DELETE 语句一样会有下面这些情况： 聚簇索引，查询命中：DELETE FROM students WHERE id &#x3D; 15; 聚簇索引，查询未命中：DELETE FROM students WHERE id &#x3D; 16; 二级唯一索引，查询命中：DELETE FROM students WHERE no &#x3D; ‘S0003’; 二级唯一索引，查询未命中：DELETE FROM students WHERE no &#x3D; ‘S0008’; 二级非唯一索引，查询命中：DELETE FROM students WHERE name &#x3D; ‘Tom’; 二级非唯一索引，查询未命中：DELETE FROM students WHERE name &#x3D; ‘John’; 无索引：DELETE FROM students WHERE score &#x3D; 22; 聚簇索引，范围查询：DELETE FROM students WHERE id &lt;&#x3D; 20; 二级索引，范围查询：DELETE FROM students WHERE age &lt;&#x3D; 23; 针对这些情况的加锁分析和上文一致，这里不再赘述。 那么 DELETE 语句和 UPDATE 语句的加锁到底会有什么不同呢？我们知道，在 MySQL 数据库中，执行 DELETE 语句其实并没有直接删除记录，而是在记录上打上一个删除标记，然后通过后台的一个叫做 &#x3D;&#x3D;purge&#x3D;&#x3D; 的线程来清理。 标记为删除的记录，对于这种类型记录，它的加锁和其他记录的加锁机制不一样。所以这一节的标题叫做 标记为删除的记录的加锁分析 可能更合适。 那么问题又来了：什么情况下会对已标记为删除的记录加锁呢？我总结下来会有两种情况：阻塞后加锁 和 快照读后加锁（自己取得名字），下面分别介绍。 阻塞后加锁 事务 A 删除 id &#x3D; 18 这条记录，同时事务 B 也删除 id &#x3D; 18 这条记录，很显然，id 为主键，DELETE 语句需要获取 X 记录锁，事务 B 阻塞。事务 A 提交之后，id &#x3D; 18 这条记录被标记为删除，此时事务 B 就需要对已删除记录进行加锁。 快照读后加锁 事务 A 删除 id &#x3D; 18 这条记录，并提交。事务 B 在事务 A 提交之前有一次 id &#x3D; 18 的快照读，所以在后面删除 id &#x3D; 18 这条记录的时候就需要对已删除记录加锁了。如果没有事务开头的这个快照读，DELETE 语句就只是简单的删除一条不存在的记录。 注意，上面的事务 B 不限于 DELETE 语句，换成 UPDATE 或 SELECT FOR UPDATE 同样适用。 我通过自己做的实验，得到了下面这些结论，如有不正确的地方，欢迎斧正。（实验环境，MySQL 版本：5.7，隔离级别：RR） 删除记录为聚簇索引 阻塞后加锁：在删除记录上加 X 记录锁（rec but not gap），并在删除的后一条记录上加间隙锁（gap before rec） 快照读后加锁：在删除记录上加 X 记录锁（rec but not gap） 删除记录为二级索引（唯一索引和非唯一索引都适用） 阻塞后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁 快照读后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁 INSERT 语句加锁分析还是用 students 表来实验，譬如我们执行下面的 SQL： 1mysql&gt; insert into students(no, name, age, score) value(&#x27;S0008&#x27;, &#x27;John&#x27;, 26, 87); 然后我们用 show engine innodb status\\G 查询事务的锁情况： 1234---TRANSACTION 3774, ACTIVE 2 sec1 lock struct(s), heap size 1136, 0 row lock(s), undo log entries 1MySQL thread id 150, OS thread handle 10420, query id 3125 localhost ::1 rootTABLE LOCK table `sys`.`t3` trx id 3774 lock mode IX INSERT 语句是插入一条新的纪录，这条记录表中本来就没有，那是不是就不需要加锁了？显然不是，至少有两个原因可以说明 INSERT 加了锁： 为了防止幻读，如果记录之间加有 GAP 锁，此时不能 INSERT； 如果 INSERT 的记录和已有记录造成唯一键冲突，此时不能 INSERT； 要解决这两个问题，都是靠锁来解决的（第一个加插入意向锁，第二个加 S 锁进行当前读），只是在 INSERT 的时候如果没有出现这两种情况，那么锁就是隐式的，只是我们看不到而已。这里我们不得不提一个概念叫 隐式锁（Implicit Lock），它对我们分析 INSERT 语句的加锁过程至关重要。 锁是一种悲观的顺序化机制，它假设很可能发生冲突，因此在操作数据时，就加锁，如果冲突的可能性很小，多数的锁都是不必要的。Innodb 实现了一个延迟加锁的机制来减少加锁的数量，这被称为隐式锁。 隐式锁中有个重要的元素：事务ID（trx_id）。隐式锁的逻辑过程如下： A. InnoDB 的每条记录中都有一个隐含的 trx_id 字段，这个字段存在于簇索引的 B+Tree 中;B. 在操作一条记录前，首先根据记录中的 trx_id 检查该事务是否是活动的事务（未提交或回滚），如果是活动的事务，首先将隐式锁转换为显式锁（就是为该事务添加一个锁）；C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为 waiting 状态；如果没有冲突不加锁，跳到 E；D. 等待加锁成功，被唤醒，或者超时；E. 写数据，并将自己的 trx_id 写入 trx_id 字段。 隐式锁的特点是只有在可能发生冲突时才加锁，减少了锁的数量。另外，隐式锁是针对被修改的 B+Tree 记录，因此都是 Record 类型的锁，不可能是 Gap 或 Next-Key 类型。 INSERT 操作只加隐式锁，不需要显示加锁； UPDATE、DELETE 在查询时，直接对查询用的 Index 和主键使用显示锁，其他索引上使用隐式锁。 理论上说，可以对主键使用隐式锁的。提前使用显示锁应该是为了减少死锁的可能性。INSERT，UPDATE，DELETE 对 B+Tree 们的操作都是从主键的 B+Tree 开始，因此对主键加锁可以有效的阻止死锁。 再见死锁开启锁监控在遇到线上死锁问题时，我们应该第一时间获取相关的死锁日志。我们可以通过 show engine innodb status 命令来获取死锁信息，但是它有个限制，只能拿到最近一次的死锁日志。MySQL 提供了一套 InnoDb 的监控机制，用于周期性（每隔 15 秒）输出 InnoDb 的运行状态到 mysqld 服务的标准错误输出（stderr）。默认情况下监控是关闭的，只有当需要分析问题时再开启，并且在分析问题之后，建议将监控关闭，因为它对数据库的性能有一定影响，另外每 15 秒输出一次日志，会使日志文件变得特别大。 InnoDb 的监控主要分为四种：标准监控（Standard InnoDB Monitor）、锁监控（InnoDB Lock Monitor）、表空间监控（InnoDB Tablespace Monitor）和表监控（InnoDB Table Monitor）。后两种监控已经基本上废弃了 要获取死锁日志，我们需要开启 InnoDb 的标准监控，我推荐将锁监控也打开，它可以提供一些额外的锁信息，在分析死锁问题时会很有用。开启监控的方法有两种： 基于系统表比如在数据库中创建一个表名为 innodb_monitor 的表开启标准监控，创建一个表名为 innodb_lock_monitor 的表开启锁监控。MySQL 通过检测是否存在这个表名来决定是否开启监控，至于表的结构和表里的内容无所谓。相反的，如果要关闭监控，则将这两个表删除即可。这种方法有点奇怪，在 5.6.16 版本之后，推荐使用系统参数的形式开启监控。 12345678-- 开启标准监控CREATE` `TABLE` `innodb_monitor (a ``INT``) ENGINE=INNODB;-- 关闭标准监控DROP` `TABLE` `innodb_monitor;-- 开启锁监控CREATE` `TABLE` `innodb_lock_monitor (a ``INT``) ENGINE=INNODB;-- 关闭锁监控DROP` `TABLE` `innodb_lock_monitor; 基于系统参数在 MySQL 5.6.16 之后，可以通过设置系统参数来开启锁监控，如下： 12345678-- 开启标准监控set GLOBAL innodb_status_output=ON;-- 关闭标准监控set GLOBAL innodb_status_output=OFF;-- 开启锁监控set GLOBAL innodb_status_output_locks=ON;-- 关闭锁监控set GLOBAL innodb_status_output_locks=OFF; 另外，MySQL 提供了一个系统参数 innodb_print_all_deadlocks 专门用于记录死锁日志，当发生死锁时，死锁日志会记录到 MySQL 的错误日志文件中。 1set GLOBAL innodb_print_all_deadlocks=ON; 除了 MySQL 自带的监控机制，还有一些有趣的监控工具也很有用，比如 Innotop 和 Percona Toolkit 里的小工具 pt-deadlock-logger。 读懂死锁日志日志中列出了死锁发生的时间，以及导致死锁的事务信息（只显示两个事务，如果由多个事务导致的死锁也只显示两个），并显示出每个事务正在执行的 SQL 语句、等待的锁以及持有的锁信息等。下面我们就来研究下这份死锁日志，看看从这份死锁日志中能不能发现死锁的原因？ 首先看事务一的信息： *** (1) TRANSACTION:TRANSACTION 182335752, ACTIVE 0 sec inserting ACTIVE 0 sec 表示事务活动时间，inserting 为事务当前正在运行的状态，可能的事务状态有：fetching rows，updating，deleting，inserting 等。 mysql tables in use 1, locked 1LOCK WAIT 11 lock struct(s), heap size 1184, 2 row lock(s), undo log entries 15 tables in use 1 表示有一个表被使用，locked 1 表示有一个表锁。LOCK WAIT 表示事务正在等待锁，11 lock struct(s) 表示该事务的锁链表的长度为 11，每个链表节点代表该事务持有的一个锁结构，包括表锁，记录锁以及 autoinc 锁等。heap size 1184 为事务分配的锁堆内存大小。2 row lock(s) 表示当前事务持有的行锁个数，通过遍历上面提到的 11 个锁结构，找出其中类型为 LOCK_REC 的记录数。undo log entries 15 表示当前事务有 15 个 undo log 记录，因为二级索引不记 undo log，说明该事务已经更新了 15 条聚集索引记录。 MySQL thread id 12032077, OS thread handle 0x7ff35ebf6700, query id 196418265 10.40.191.57 RW_bok_db update 事务的线程信息，以及数据库 IP 地址和数据库名，对我们分析死锁用处不大。 INSERT INTO bok_task 1( order_id ... 这里显示的是正在等待锁的 SQL 语句，死锁日志里每个事务都只显示一条 SQL 语句，这对我们分析死锁很不方便，我们必须要结合应用程序去具体分析这个 SQL 之前还执行了哪些其他的 SQL 语句，或者根据 binlog 也可以大致找到一个事务执行的 SQL 语句。 *** (1) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 300 page no 5480 n bits 552 index order_id_un of table bok_db.bok_task trx id 182335752 lock_mode X insert intention waiting 这里显示的是事务正在等待什么锁。RECORD LOCKS 表示记录锁（并且可以看出要加锁的索引为 order_id_un），space id 为 300，page no 为 5480，n bits 552 表示这个记录锁结构上留有 552 个 bit 位（该 page 上的记录数 + 64）。lock_mode X 表示该记录锁为排他锁，insert intention waiting 表示要加的锁为插入意向锁，并处于锁等待状态。 在上面有提到 innodb_status_output_locks 这个系统变量可以开启 InnoDb 的锁监控，如果开启了，这个地方还会显示出锁的一些额外信息，包括索引记录的 info bits 和数据信息等： 123Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000002; asc ;; 1: len 4; hex 80000001; asc ;; 一共有四种类型的行锁：记录锁，间隙锁，Next-key 锁和插入意向锁。这四种锁对应的死锁日志各不相同，如下： 记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap 间隙锁（LOCK_GAP）: lock_mode X locks gap before rec Next-key 锁（LOCK_ORNIDARY）: lock_mode X 插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention 这里有一点要注意的是，并不是在日志里看到 lock_mode X 就认为这是 Next-key 锁，因为还有一个例外：如果在 supremum record 上加锁，locks gap before rec 会省略掉，间隙锁会显示成 lock_mode X，插入意向锁会显示成 lock_mode X insert intention。譬如下面这个： 12RECORD LOCKS space id 0 page no 307 n bits 72 index `PRIMARY` of table `test`.`test` trx id 50F lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 看起来像是 Next-key 锁，但是看下面的 heap no 1 表示这个记录是 supremum record（另外，infimum record 的 heap no 为 0），所以这个锁应该看作是一个间隙锁。 看完第一个事务，再来看看第二个事务： *** (2) TRANSACTION: TRANSACTION 182335756, ACTIVE 0 sec insertingmysql tables in use 1, locked 111 lock struct(s), heap size 1184, 2 row lock(s), undo log entries 15MySQL thread id 12032049, OS thread handle 0x7ff35f5dd700, query id 196418268 10.40.189.132 RW_bok_db updateINSERT INTO bok_task ** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 300 page no 5480 n bits 552 index order_id_un of table bok_db.bok_task trx id 182335756 lock_mode X**(2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 300 page no 5480 n bits 552 index order_id_un of table bok_db.bok_task trx id 182335756 lock_mode X insert intention waiting 事务二和事务一的日志基本类似，不过它多了一部分 HOLDS THE LOCK(S)，表示事务二持有什么锁，这个锁往往就是事务一处于锁等待的原因。这里可以看到事务二正在等待索引 order_id_un 上的插入意向锁，并且它已经持有了一个 X 锁（Next-key 锁，也有可能是 supremum 上的间隙锁）。 到这里为止，我们得到了很多关键信息，此时我们可以逆推出死锁发生的原因吗？这可能也是每个开发人员和 DBA 最关心的问题，如何通过死锁日志来诊断死锁的成因？实际上这是非常困难的。 如果每个事务都只有一条 SQL 语句，这种情况的死锁成因还算比较好分析，因为我们可以从死锁日志里找到每个事务执行的 SQL 语句，只要对这两条 SQL 语句的加锁过程有一定的了解，死锁原因一般不难定位。但也有可能死锁的成因非常隐蔽，这时需要我们对这两条 SQL 语句的加锁流程做非常深入的研究才有可能分析出死锁的根源。 不过大多数情况下，每个事务都不止一条 SQL 语句，譬如上面的死锁日志里显示的 undo log entries 15，说明执行 INSERT 语句之前肯定还执行了其他的 SQL 语句，但是具体是什么，我们不得而知，我们只能根据 HOLDS THE LOCK(S) 部分知道有某个 SQL 语句对 order_id_un 索引加了 Next-key 锁（或间隙锁）。另外事务二在 WAITING FOR 插入意向锁，至于它和事务一的哪个锁冲突也不得而知，因为事务一的死锁日志里并没有 HOLDS THE LOCK(S) 部分。 所以，对死锁的诊断不能仅仅靠死锁日志，还应该结合应用程序的代码来进行分析，如果实在接触不到应用代码，还可以通过数据库的 binlog 来分析（只要你的死锁不是 100% 必现，那么 binlog 日志里肯定能找到一份完整的事务一和事务二的 SQL 语句）。通过应用代码或 binlog 理出每个事务的 SQL 执行顺序，这样分析死锁时就会容易很多。 常见死锁分析死锁案例一 死锁的根本原因是有两个或多个事务之间加锁顺序的不一致导致的，这个死锁案例其实是最经典的死锁场景。 首先，事务 A 获取 id &#x3D; 20 的锁（lock_mode X locks rec but not gap），事务 B 获取 id &#x3D; 30 的锁；然后，事务 A 试图获取 id &#x3D; 30 的锁，而该锁已经被事务 B 持有，所以事务 A 等待事务 B 释放该锁，然后事务 B 又试图获取 id &#x3D; 20 的锁，这个锁被事务 A 占有，于是两个事务之间相互等待，导致死锁。 死锁案例二 首先事务 A 和事务 B 执行了两条 UPDATE 语句，但是由于 id &#x3D; 25 和 id &#x3D; 26 记录都不存在，事务 A 和 事务 B 并没有更新任何记录，但是由于数据库隔离级别为 RR，所以会在 (20, 30) 之间加上间隙锁（lock_mode X locks gap before rec），间隙锁和间隙锁并不冲突。之后事务 A 和事务 B 分别执行 INSERT 语句要插入记录 id &#x3D; 25 和 id &#x3D; 26，需要在 (20, 30) 之间加插入意向锁（lock_mode X locks gap before rec insert intention），插入意向锁和间隙锁冲突，所以两个事务互相等待，最后形成死锁。 要解决这个死锁很简单，显然，前面两条 UPDATE 语句是无效的，将其删除即可。另外也可以将数据库隔离级别改成 RC，这样在 UPDATE 的时候就不会有间隙锁了。这个案例正是文章开头提到的死锁日志中的死锁场景，别看这个 UPDATE 语句是无效的，看起来很傻，但是确实是真实的场景，因为在真实的项目中代码会非常复杂，比如采用了 ORM 框架，应用层和数据层代码分离，一般开发人员写代码时都不知道会生成什么样的 SQL 语句，我也是从 DBA 那里拿到了 binlog，然后从里面找到了事务执行的所有 SQL 语句，发现其中竟然有一行无效的 UPDATE 语句，最后追本溯源，找到对应的应用代码，将其删除，从而修复了这个死锁。 死锁案例三 别看这个案例里每个事务都只有一条 SQL 语句，但是却实实在在可能会导致死锁问题，其实说起来，这个死锁和案例一并没有什么区别，只不过理解起来要更深入一点。要知道在范围查询时，加锁是一条记录一条记录挨个加锁的，所以虽然只有一条 SQL 语句，如果两条 SQL 语句的加锁顺序不一样，也会导致死锁。 在案例一中，事务 A 的加锁顺序为： id &#x3D; 20 -&gt; 30，事务 B 的加锁顺序为：id &#x3D; 30 -&gt; 20，正好相反，所以会导致死锁。这里的情景也是一样，事务 A 的范围条件为 id &lt; 30，加锁顺序为：id &#x3D; 15 -&gt; 18 -&gt; 20，事务 B 走的是二级索引 age，加锁顺序为：(age, id) &#x3D; (24, 18) -&gt; (24, 20) -&gt; (25, 15) -&gt; (25, 49)，其中，对 id 的加锁顺序为 id &#x3D; 18 -&gt; 20 -&gt; 15 -&gt; 49。可以看到事务 A 先锁 15，再锁 18，而事务 B 先锁 18，再锁 15，从而形成死锁。 如何避免死锁在工作过程中偶尔会遇到死锁问题，虽然这种问题遇到的概率不大，但每次遇到的时候要想彻底弄懂其原理并找到解决方案却并不容易。其实，对于 MySQL 的 InnoDb 存储引擎来说，死锁问题是避免不了的，没有哪种解决方案可以说完全解决死锁问题，但是我们可以通过一些可控的手段，降低出现死锁的概率。 如上面的案例一和案例三所示，对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能； 如上面的案例二所示，Gap 锁往往是程序中导致死锁的真凶，由于默认情况下 MySQL 的隔离级别是 RR，所以如果能确定幻读和不可重复读对应用的影响不大，可以考虑将隔离级别改成 RC，可以避免 Gap 锁导致的死锁； 为表添加合理的索引，如果不走索引将会为表的每一行记录加锁，死锁的概率就会大大增大； 我们知道 MyISAM 只支持表锁，它采用一次封锁技术来保证事务之间不会发生死锁，所以，我们也可以使用同样的思想，在事务中一次锁定所需要的所有资源，减少死锁概率； 避免大事务，尽量将大事务拆成多个小事务来处理；因为大事务占用资源多，耗时长，与其他事务冲突的概率也会变高； 避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行； 设置锁等待超时参数：innodb_lock_wait_timeout，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。 元数据锁当mysql运行一条SQL语句时，在你预期的时间内，没有完成时，我们都会登陆到mysql数据库上想查看是不是出了什么问题，通常会使用的一个命令就是 show processlist，看看有哪些session，这些session在做什么事情。就从这个命令开始，显示如下： 图中看到了显示了几处信息： id：为session_id，也就是processlist_id user：该session使用什么用户登陆的mysql数据库 host：客户端登陆的ip地址（这里我都是本地登陆的） db：连接了哪个数据库（这里我只是连接上了数据库，并没有其他操作，所以都是NULL） command：当前session执行命令的类型 Time：处于当前命令类型持续的时间 State：当前命令类型的状态 Info：具体命令信息 元数据锁是server层的锁，表级锁，主要用于隔离DML和DDL操作之间的干扰。 每执行一条DML、DDL语句时都会申请MDL锁，DML操作需要MDL读锁，DDL操作需要MDL写锁（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥），申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放（这里有种特殊情况如果事务中包含DDL操作，mysql会在DDL操作语句执行后，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放，例如id 44的语句改为&lt;begin;alter table testok add z varchar(10) not Null;select * from testok;&gt;，此时一旦alter语句执行完成会马上提交事务（autocommit&#x3D;1），后面的select就在本次事务之外，其执行完成后不会持有读锁） 表级锁有两种，一种是针对于表记录数据的锁，另外一种就是MDL(metadata lock)的锁，它是基于表元数据(表结构)的锁，MDL锁是为了保证并发环境下元数据和表数据的结构一致性。如果有其它事务对表加了MDL锁，那么其它事务就不能对表结构进行变更，同样对于正在进行表结构变更的时候也不允许其它事务对表数据进行增删改查。 什么时候会加MDL锁MDL读锁：在我们对表数据进行增删改查的的时候都需要对表加MDL读锁。 MDL写锁：当我们对表结构进行修改的时候会加MDL写锁。","tags":["数据库","MySQL"],"categories":["学习"]},{"title":"Java基础","path":"/f7ede91d/","content":"Java基础Java 基础语法一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。 123低 ------------------------------------&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如： 12int i =128; byte b = (byte)i; 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如： 12(int)23.7 == 23; (int)-45.89f == -45 Java 变量类型Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 Java 局部变量 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 类变量（静态变量） 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public&#x2F;private，final 和 static 类型的变量。静态变量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。 Java 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y&#x2F;N N default Y Y Y N N private Y N N N N 请注意以下方法继承的规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被子类继承。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。 final 修饰符final 变量： final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 abstract 修饰符抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法 抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：**public abstract sample();**。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。 Java 运算符instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。instanceof运算符使用格式如下： 1( Object reference variable ) instanceof (class/interface type) 如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。 下面是一个例子： 12String name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真 如果被比较的对象兼容于右侧类型,该运算符仍然返回true。看下面的例子： 123456789class Vehicle &#123;&#125; public class Car extends Vehicle &#123; public static void main(String[] args)&#123; Vehicle a = new Car(); boolean result = a instanceof Car; System.out.println( result); &#125;&#125; 以上实例编译运行结果如下： 1true Java运算符优先级当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。再如，x &#x3D; 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。 下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 expr++ expr– 从左到右 一元 ++expr –expr + - ～ ！ 从右到左 乘性 * &#x2F;％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 左到右 相等 &#x3D;&#x3D; !&#x3D; 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 | 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 | | 左到右 条件 ？： 从右到左 赋值 &#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D; 从右到左 逗号 ， 左到右 Java 增强 for 循环Java5 引入了一种主要用于数组的增强型 for 循环。Java 增强 for 循环语法格式如下: 1234for(声明语句 : 表达式)&#123; //代码句子&#125; 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 实例 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(&quot;,&quot;); &#125; System.out.print(&quot; &quot;); String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(&quot;,&quot;); &#125; &#125;&#125; 以上实例编译运行结果如下： 1210,20,30,40,50,James,Larry,Tom,Lacy, Java Number &amp; Math 类所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 包装类 基本数据类型 Boolean boolean Byte byte Short short Integer int Long long Character char Float float Double double 这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。 下面的表中列出的是 Number &amp; Math 类常用的一些方法： 序号 方法与描述 1 xxxValue()将 Number 对象转换为xxx数据类型的值并返回。 2 compareTo()将number对象与参数比较。 3 equals()判断number对象是否与参数相等。 4 valueOf()返回一个 Number 对象指定的内置数据类型 5 toString()以字符串形式返回值。 6 parseInt()将字符串解析为int类型。 7 abs()返回参数的绝对值。 8 ceil()返回大于等于( &gt;&#x3D; )给定参数的的最小整数，类型为双精度浮点型。 9 floor()返回小于等于（&lt;&#x3D;）给定参数的最大整数 。 10 rint()返回与参数最接近的整数。返回类型为double。 11 round()它表示四舍五入，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 12 min()返回两个参数中的最小值。 13 max()返回两个参数中的最大值。 14 exp()返回自然数底数e的参数次方。 15 log()返回参数的自然数底数的对数值。 16 pow()返回第一个参数的第二个参数次方。 17 sqrt()求参数的算术平方根。 18 sin()求指定double类型参数的正弦值。 19 cos()求指定double类型参数的余弦值。 20 tan()求指定double类型参数的正切值。 21 asin()求指定double类型参数的反正弦值。 22 acos()求指定double类型参数的反余弦值。 23 atan()求指定double类型参数的反正切值。 24 atan2()将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 25 toDegrees()将参数转化为角度。 26 toRadians()将角度转换为弧度。 27 random()返回一个随机数。 Java Character 类转义序列前面有反斜杠（\\）的字符代表转义字符，它对编译器来说是有特殊含义的。下面列表展示了Java的转义序列： 转义序列 描述 \\t 在文中该处插入一个tab键 \\b 在文中该处插入一个后退键 在文中该处换行 \\r 在文中该处插入回车 \\f 在文中该处插入换页符 &#39; 在文中该处插入单引号 &quot; 在文中该处插入双引号 \\ 在文中该处插入反斜杠 ###Character 方法 序号 方法与描述 1 isLetter() 是否是一个字母 2 isDigit()是否是一个数字字符 3 isWhitespace()是否是一个空白字符 4 isUpperCase()是否是大写字母 5 isLowerCase()是否是小写字母 6 toUpperCase()指定字母的大写形式 7 toLowerCase指定字母的小写形式 8 toString返回字符的字符串形式，字符串的长度仅为1 Java String 类String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上： **注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 字符串长度用于获取有关对象的信息的方法称为访问器方法。 String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。 连接字符串String 类提供了连接两个字符串的方法： 1string1.concat(string2); 返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如： 1&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;); 更常用的是使用’+’操作符来连接字符串，如： 1&quot;Hello,&quot; + &quot; runoob&quot; + &quot;!&quot; 创建格式化字符串我们知道输出格式化数字可以使用 printf() 和 format() 方法。 String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。 String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 如下所示： 1234System.out.printf(&quot;浮点型变量的值为 &quot; + &quot;%f, 整型变量的值为 &quot; + &quot; %d, 字符串变量的值为 &quot; + &quot;is %s&quot;, floatVar, intVar, stringVar); 你也可以这样写 12345String fs;fs = String.format(&quot;浮点型变量的值为 &quot; + &quot;%f, 整型变量的值为 &quot; + &quot; %d, 字符串变量的值为 &quot; + &quot; %s&quot;, floatVar, intVar, stringVar); String 方法下面是 String 类支持的方法，更多详细，参看 Java String API 文档: SN(序号) 方法描述 1 char charAt(int index)返回指定索引处的 char 值。 2 int compareTo(Object o)把这个字符串和另一个对象比较。 3 int compareTo(String anotherString)按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str)按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str)将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb)当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data)返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count)返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix)测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject)将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString)将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes()使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName)使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此字符串复制到目标字符数组。 15 int hashCode()返回此字符串的哈希码。 16 int indexOf(int ch)返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex)返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str)返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex)返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern()返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch)返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex)返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex)返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length()返回此字符串的长度。 26 boolean matches(String regex)告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar)返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement)使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement)使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit)根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix)测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset)测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex)返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex)返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray()将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale)使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 [tring toString()返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase()使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale)使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim()返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x)返回给定data type类型x参数的字符串表示形式。 47 contains(CharSequence chars)判断是否包含指定的字符系列。 48 isEmpty()判断字符串是否为空。 Java StringBuffer 和 StringBuilder 类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 StringBuffer 方法 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 insert(int offset, String str) 将 str 参数的字符串插入此序列中。 6 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 Java 数组For-Each 循环JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。语法格式如下： 1234for(type element: array)&#123; System.out.println(element);&#125; Java 日期时间java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 第一个构造函数使用当前日期和时间来初始化对象。 1Date( ) 第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。 1Date(long millisec) Date 对象创建以后，可以调用下面的方法。 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 2 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 3 Object clone( ) 返回此对象的副本。 4 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 5 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 6 boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 7 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 8 int hashCode( ) 返回此对象的哈希码值。 9 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 10 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 日期比较Java使用以下三种方法来比较两个日期： 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 使用 SimpleDateFormat 格式化日期SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如： 123456789101112import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String[] args) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(&quot;当前时间为: &quot; + ft.format(dNow)); &#125;&#125; 注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。 以上实例编译运行结果如下: 1当前时间为: 2018-09-06 10:16:34 日期和时间的格式化编码时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下： 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M.&#x2F;P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M.&#x2F;P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M.&#x2F;P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 &#96; 使用printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 转 换 符 说 明 示 例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月&#x2F;日&#x2F;年”格式 10&#x2F;27&#x2F;07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 解析字符串为时间SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如： 12345678910111213141516171819202122import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String[] args) &#123; SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;); String input = args.length == 0 ? &quot;1818-11-11&quot; : args[0]; System.out.print(input + &quot; Parses as &quot;); Date t; try &#123; t = ft.parse(input); System.out.println(t); &#125; catch (ParseException e) &#123; System.out.println(&quot;Unparseable using &quot; + ft); &#125; &#125;&#125; Java 休眠(sleep)sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。 你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒： 12345678910111213import java.util.*; public class SleepDemo &#123; public static void main(String[] args) &#123; try &#123; System.out.println(new Date( ) + &quot; &quot;); Thread.sleep(1000*3); // 休眠3秒 System.out.println(new Date( ) + &quot; &quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;Got an exception!&quot;); &#125; &#125;&#125; 测量时间下面的一个例子表明如何测量时间间隔（以毫秒为单位）： 123456789101112131415161718import java.util.*; public class DiffDemo &#123; public static void main(String[] args) &#123; try &#123; long start = System.currentTimeMillis( ); System.out.println(new Date( ) + &quot; &quot;); Thread.sleep(5*60*10); System.out.println(new Date( ) + &quot; &quot;); long end = System.currentTimeMillis( ); long diff = end - start; System.out.println(&quot;Difference is : &quot; + diff); &#125; catch (Exception e) &#123; System.out.println(&quot;Got an exception!&quot;); &#125; &#125;&#125; Java 正则表达式正则表达式定义了字符串的模式。 正则表达式可以用来搜索、编辑或处理文本。 正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。 Java 正则表达式和 Perl 的是最为相似的。 java.util.regex 包主要包括以下三个类： Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 12345678910111213import java.util.regex.*; class RegexExample1&#123; public static void main(String[] args)&#123; String content = &quot;I am noob &quot; + &quot;from runoob.com.&quot;; String pattern = &quot;.*runoob.*&quot;; boolean isMatch = Pattern.matches(pattern, content); System.out.println(&quot;字符串中是否包含了 &#x27;runoob&#x27; 子字符串? &quot; + isMatch); &#125;&#125; 实例输出结果为：字符串中是否包含了 &#39;runoob&#39; 子字符串? true 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 例如，正则表达式 (dog) 创建了单一分组，组里包含”d”，”o”，和”g”。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。 还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。 下面的例子说明如何从一个给定的字符串中找到数字串： 12345678910111213141516171819202122232425262728293031import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; public static void main( String[] args )&#123; // 按指定模式在字符串查找 String line = &quot;This order was placed for QT3000! OK?&quot;; String pattern = &quot;(\\\\D*)(\\\\d+)(.*)&quot;; // 创建 Pattern 对象 Pattern r = Pattern.compile(pattern); // 现在创建 matcher 对象 Matcher m = r.matcher(line); if (m.find( )) &#123; System.out.println(&quot;Found value: &quot; + m.group(0) ); System.out.println(&quot;Found value: &quot; + m.group(1) ); System.out.println(&quot;Found value: &quot; + m.group(2) ); System.out.println(&quot;Found value: &quot; + m.group(3) ); &#125; else &#123; System.out.println(&quot;NO MATCH&quot;); &#125; &#125;&#125;Found value: This order was placed for QT3000! OK?Found value: This order was placed for QTFound value: 3000Found value: ! OK? 正则表达式语法在其他语言中，\\\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。在 Java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 所以，在其他的语言中（如 Perl），一个反斜杠 \\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\\\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\。 12System.out.print(&quot;\\\\&quot;); // 输出为 \\System.out.print(&quot;\\\\\\\\&quot;); // 输出为 \\\\ 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， n匹配字符 n。 匹配换行符。序列 \\\\\\\\ 匹配 \\\\ ，\\\\( 匹配 **(**。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与” ”或”\\r”之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与” ”或”\\r”之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} m 和 n 是非负整数，其中 n &lt;&#x3D; m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。 . 匹配除”\\r ”之外的任何单个字符。若要匹配包括”\\r ”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。 (?&#x3D;pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 x|y 匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。 [xyz] 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f \\r\\t\\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f \\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 um 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 标识一个八进制转义码或反向引用。如果 *n* 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 m 标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 *nm* 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 ml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\\b” 与单个退格字符匹配，而 “\\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\\(hello\\)”。 Matcher 类的方法索引方法索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配： 序号 方法及说明 1 public int start() 返回以前匹配的初始索引。 2 public int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引 3 public int end() 返回最后匹配字符之后的偏移量。 4 public int end(int group) 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。 查找方法查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式： 序号 方法及说明 1 public boolean lookingAt() 尝试将从区域开头开始的输入序列与该模式匹配。 2 public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。 3 public boolean find(int start****） 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 4 public boolean matches() 尝试将整个区域与模式匹配。 替换方法替换方法是替换输入字符串里文本的方法： 序号 方法及说明 1 public Matcher appendReplacement(StringBuffer sb, String replacement) 实现非终端添加和替换步骤。 2 public StringBuffer appendTail(StringBuffer sb) 实现终端添加和替换步骤。 3 public String replaceAll(String replacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。 4 public String replaceFirst(String replacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。 5 public static String quoteReplacement(String s) 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。 matches 和 lookingAt 方法matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。 lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。 这两个方法经常在输入字符串的开始使用。 12345678910111213141516171819202122232425262728import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static final String REGEX = &quot;foo&quot;; private static final String INPUT = &quot;fooooooooooooooooo&quot;; private static final String INPUT2 = &quot;ooooofoooooooooooo&quot;; private static Pattern pattern; private static Matcher matcher; private static Matcher matcher2; public static void main( String[] args )&#123; pattern = Pattern.compile(REGEX); matcher = pattern.matcher(INPUT); matcher2 = pattern.matcher(INPUT2); System.out.println(&quot;Current REGEX is: &quot;+REGEX); System.out.println(&quot;Current INPUT is: &quot;+INPUT); System.out.println(&quot;Current INPUT2 is: &quot;+INPUT2); System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt()); System.out.println(&quot;matches(): &quot;+matcher.matches()); System.out.println(&quot;lookingAt(): &quot;+matcher2.lookingAt()); &#125;&#125; 123456Current REGEX is: fooCurrent INPUT is: foooooooooooooooooCurrent INPUT2 is: ooooofoooooooooooolookingAt(): truematches(): falselookingAt(): false replaceFirst 和 replaceAll 方法replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。 1234567891011121314151617181920import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static String REGEX = &quot;dog&quot;; private static String INPUT = &quot;The dog says meow. &quot; + &quot;All dogs say meow.&quot;; private static String REPLACE = &quot;cat&quot;; public static void main(String[] args) &#123; Pattern p = Pattern.compile(REGEX); // get a matcher object Matcher m = p.matcher(INPUT); INPUT = m.replaceAll(REPLACE); System.out.println(INPUT); &#125;&#125;The cat says meow. All cats say meow. appendReplacement 和 appendTail 方法Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换： 123456789101112131415161718192021import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static String REGEX = &quot;a*b&quot;; private static String INPUT = &quot;aabfooaabfooabfoobkkk&quot;; private static String REPLACE = &quot;-&quot;; public static void main(String[] args) &#123; Pattern p = Pattern.compile(REGEX); // 获取 matcher 对象 Matcher m = p.matcher(INPUT); StringBuffer sb = new StringBuffer(); while(m.find())&#123; m.appendReplacement(sb,REPLACE); &#125; m.appendTail(sb); System.out.println(sb.toString()); &#125;&#125;-foo-foo-foo-kkk PatternSyntaxException 类的方法PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。 PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。 序号 方法及说明 1 public String getDescription() 获取错误的描述。 2 public int getIndex() 获取错误的索引。 3 public String getPattern() 获取错误的正则表达式模式。 4 public String getMessage() 返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。 Java 方法那么什么是方法呢？Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 方法的优点 使程序变得更简短而清晰。 有利于程序维护。 可以提高程序开发的效率。 提高了代码的重用性。 方法的定义一般情况下，定义一个方法包含以下语法： 123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 方法包含一个方法头和一个方法体。下面是一个方法的所有部分： 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 方法的重载如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用； 如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载； 就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。 Java编译器根据方法签名判断哪个方法应该被调用。 方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。 重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。 构造方法当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。一旦你定义了自己的构造方法，默认构造方法就会失效。 可变参数JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。 方法的可变参数的声明如下所示： typeName... parameterName 1234567891011121314151617181920212223242526public class VarargsDemo &#123; public static void main(String args[]) &#123; // 调用可变参数的方法 printMax(34, 3, 3, 2, 56.5); printMax(new double[]&#123;1, 2, 3&#125;); &#125; public static void printMax( double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println(&quot;No argument passed&quot;); return; &#125; double result = numbers[0]; for (int i = 1; i &lt; numbers.length; i++)&#123; if (numbers[i] &gt; result) &#123; result = numbers[i]; &#125; &#125; System.out.println(&quot;The max value is &quot; + result); &#125;&#125;The max value is 56.5The max value is 3.0 finalize() 方法Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。 例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。 在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。 finalize() 一般格式是： 1234protected void finalize()&#123; // 在这里终结代码&#125; 关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。 当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。 Java 流(Stream)、文件(File)和IOJava.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。 Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 Java 为 I&#x2F;O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。 读取控制台输入Java 的控制台输入由 System.in 完成。 为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。下面是创建 BufferedReader 的基本语法： 12BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。 从控制台读取多字符输入从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下： 1int read( ) throws IOException 每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。 下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 q。 1234567891011121314151617//使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead &#123; public static void main(String[] args) throws IOException &#123; char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;输入字符, 按下 &#x27;q&#x27; 键退出。&quot;); // 读取字符 do &#123; c = (char) br.read(); System.out.println(c); &#125; while (c != &#x27;q&#x27;); &#125;&#125; 从控制台读取字符串从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。 它的一般格式是： 1String readLine( ) throws IOException 下面的程序读取和显示字符行直到你输入了单词”end”。 12345678910111213141516//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRReadLines &#123; public static void main(String[] args) throws IOException &#123; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; System.out.println(&quot;Enter lines of text.&quot;); System.out.println(&quot;Enter &#x27;end&#x27; to quit.&quot;); do &#123; str = br.readLine(); System.out.println(str); &#125; while (!str.equals(&quot;end&quot;)); &#125;&#125; JDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入。 控制台输出在此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。 PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。 PrintStream 定义 write() 的最简单格式如下所示： 1void write(int byteval) 该方法将 byteval 的低八位字节写到流中。 下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕： 1234567891011import java.io.*; //演示 System.out.write().public class WriteDemo &#123; public static void main(String[] args) &#123; int b; b = &#x27;A&#x27;; System.out.write(b); System.out.write(&#x27; &#x27;); &#125;&#125; 注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。 读写文件如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 下图是一个描述输入流和输出流的类层次图。 FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建。 有多种构造方法可用来创建对象。 可以使用字符串类型的文件名来创建一个输入流对象来读取文件： 1InputStream f = new FileInputStream(&quot;C:/java/hello&quot;); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象： 12File f = new File(&quot;C:/java/hello&quot;);InputStream in = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 4 public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 5 public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 除了 InputStream 外，还有一些其他的输入流，更多的细节参考下面链接： ByteArrayInputStream DataInputStream FileOutputStream该类用来创建一个文件并向文件中写数据。 如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。 有两个构造方法可以用来创建 FileOutputStream 对象。 使用字符串类型的文件名来创建一个输出流对象： 1OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;) 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： 1File f = new File(&quot;C:/java/hello&quot;); OutputStream fOut = new FileOutputStream(f); 创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。 4 public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。 除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接： ByteArrayOutputStream DataOutputStream 123456789101112131415161718192021222324import java.io.*; public class fileStreamTest &#123; public static void main(String[] args) &#123; try &#123; byte bWrite[] = &#123; 11, 21, 3, 40, 5 &#125;; OutputStream os = new FileOutputStream(&quot;test.txt&quot;); for (int x = 0; x &lt; bWrite.length; x++) &#123; os.write(bWrite[x]); // writes the bytes &#125; os.close(); InputStream is = new FileInputStream(&quot;test.txt&quot;); int size = is.available(); for (int i = 0; i &lt; size; i++) &#123; System.out.print((char) is.read() + &quot; &quot;); &#125; is.close(); &#125; catch (IOException e) &#123; System.out.print(&quot;Exception&quot;); &#125; &#125;&#125; 上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。 以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//文件名 :fileStreamTest2.javaimport java.io.*; public class fileStreamTest2 &#123; public static void main(String[] args) throws IOException &#123; File f = new File(&quot;a.txt&quot;); FileOutputStream fop = new FileOutputStream(f); // 构建FileOutputStream对象,文件不存在会自动新建 OutputStreamWriter writer = new OutputStreamWriter(fop, &quot;UTF-8&quot;); // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk writer.append(&quot;中文输入&quot;); // 写入到缓冲区 writer.append(&quot;\\r &quot;); // 换行 writer.append(&quot;English&quot;); // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入 writer.close(); // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉 fop.close(); // 关闭输出流,释放系统资源 FileInputStream fip = new FileInputStream(f); // 构建FileInputStream对象 InputStreamReader reader = new InputStreamReader(fip, &quot;UTF-8&quot;); // 构建InputStreamReader对象,编码与写入相同 StringBuffer sb = new StringBuffer(); while (reader.ready()) &#123; sb.append((char) reader.read()); // 转成char加到StringBuffer对象中 &#125; System.out.println(sb.toString()); reader.close(); // 关闭读取流 fip.close(); // 关闭输入流,释放系统资源 &#125;&#125; 文件和I&#x2F;OJava中的目录创建目录：File类中有两个方法可以用来创建文件夹： **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 **mkdirs()**方法创建一个文件夹和它的所有父文件夹。 注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (&#x2F;) ，路径依然能够被正确解析。 读取目录一个目录其实就是一个 File 对象，它包含其他文件和文件夹。 如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。 可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。 下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容： 123456789101112131415161718192021222324252627282930import java.io.File; public class DirList &#123; public static void main(String args[]) &#123; String dirname = &quot;/tmp&quot;; File f1 = new File(dirname); if (f1.isDirectory()) &#123; System.out.println(&quot;目录 &quot; + dirname); String s[] = f1.list(); for (int i = 0; i &lt; s.length; i++) &#123; File f = new File(dirname + &quot;/&quot; + s[i]); if (f.isDirectory()) &#123; System.out.println(s[i] + &quot; 是一个目录&quot;); &#125; else &#123; System.out.println(s[i] + &quot; 是一个文件&quot;); &#125; &#125; &#125; else &#123; System.out.println(dirname + &quot; 不是一个目录&quot;); &#125; &#125;&#125;目录 /tmpbin 是一个目录lib 是一个目录demo 是一个目录test.txt 是一个文件README 是一个文件index.html 是一个文件include 是一个目录 删除目录或文件删除文件可以使用 java.io.File.delete() 方法。 以下代码会删除目录 **&#x2F;tmp&#x2F;java&#x2F;**，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。 测试目录结构： 123/tmp/java/|-- 1.log|-- test 123456789101112131415161718192021222324import java.io.File; public class DeleteFileDemo &#123; public static void main(String[] args) &#123; // 这里修改为自己的测试目录 File folder = new File(&quot;/tmp/java/&quot;); deleteFolder(folder); &#125; // 删除文件及目录 public static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if (files != null) &#123; for (File f : files) &#123; if (f.isDirectory()) &#123; deleteFolder(f); &#125; else &#123; f.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125; Java Scanner 类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： 1Scanner s = new Scanner(System.in); 接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 使用 next 方法：12345678910111213141516171819202122import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(&quot;next方式接收：&quot;); // 判断是否还有输入 if (scan.hasNext()) &#123; String str1 = scan.next(); System.out.println(&quot;输入的数据为：&quot; + str1); &#125; scan.close(); &#125;&#125;$ javac ScannerDemo.java$ java ScannerDemonext方式接收：runoob com输入的数据为：runoob 可以看到 com 字符串并未输出，接下来我们看 nextLine。 使用 nextLine 方法：12345678910111213141516171819202122import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(&quot;nextLine方式接收：&quot;); // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str2 = scan.nextLine(); System.out.println(&quot;输入的数据为：&quot; + str2); &#125; scan.close(); &#125;&#125;$ javac ScannerDemo.java$ java ScannerDemonextLine方式接收：runoob com输入的数据为：runoob com 可以看到 com 字符串输出。 next() 与 nextLine() 区别next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。 如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 int i = 0; float f = 0.0f; System.out.print(&quot;输入整数：&quot;); if (scan.hasNextInt()) &#123; // 判断输入的是否是整数 i = scan.nextInt(); // 接收整数 System.out.println(&quot;整数数据：&quot; + i); &#125; else &#123; // 输入错误的信息 System.out.println(&quot;输入的不是整数！&quot;); &#125; System.out.print(&quot;输入小数：&quot;); if (scan.hasNextFloat()) &#123; // 判断输入的是否是小数 f = scan.nextFloat(); // 接收小数 System.out.println(&quot;小数数据：&quot; + f); &#125; else &#123; // 输入错误的信息 System.out.println(&quot;输入的不是小数！&quot;); &#125; scan.close(); &#125;&#125;$ javac ScannerDemo.java$ java ScannerDemo输入整数：12整数数据：12输入小数：1.2小数数据：1.2 以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果： 12345678910111213141516171819202122232425262728293031import java.util.Scanner; class RunoobTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;请输入数字：&quot;); Scanner scan = new Scanner(System.in); double sum = 0; int m = 0; while (scan.hasNextDouble()) &#123; double x = scan.nextDouble(); m = m + 1; sum = sum + x; &#125; System.out.println(m + &quot;个数的和为&quot; + sum); System.out.println(m + &quot;个数的平均值是&quot; + (sum / m)); scan.close(); &#125;&#125;$ javac ScannerDemo.java$ java ScannerDemo请输入数字：12231521.4end4个数的和为71.44个数的平均值是17.85 Java 异常处理异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 Exception 类的层次所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。 Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。 Error 用来指示运行时环境发生的错误。 例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 Java 内置异常类标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。 Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。 异常 描述 ArithmeticException 当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。 ArrayIndexOutOfBoundsException 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 ArrayStoreException 试图将错误类型的对象存储到一个对象数组时抛出的异常。 ClassCastException 当试图将对象强制转换为不是实例的子类时，抛出该异常。 IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。 IllegalMonitorStateException 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 IllegalStateException 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 IllegalThreadStateException 线程没有处于请求操作所要求的适当状态时抛出的异常。 IndexOutOfBoundsException 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 NegativeArraySizeException 如果应用程序试图创建大小为负的数组，则抛出该异常。 NullPointerException 当应用程序试图在需要对象的地方使用 null 时，抛出该异常 NumberFormatException 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 SecurityException 由安全管理器抛出的异常，指示存在安全侵犯。 StringIndexOutOfBoundsException 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。 UnsupportedOperationException 当不支持请求的操作时，抛出该异常。 下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。 异常 描述 ClassNotFoundException 应用程序试图加载类时，找不到相应的类，抛出该异常。 CloneNotSupportedException 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。 IllegalAccessException 拒绝访问一个类的时候，抛出该异常。 InstantiationException 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 InterruptedException 一个线程被另一个线程中断，抛出该异常。 NoSuchFieldException 请求的变量不存在 NoSuchMethodException 请求的方法不存在 异常方法下面的列表是 Throwable 类的主要方法: 序号 方法及说明 1 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 2 public Throwable getCause() 返回一个Throwable 对象代表异常原因。 3 public String toString() 使用getMessage()的结果返回类的串级名字。 4 public void printStackTrace() 打印toString()结果和栈层次到System.err，即错误输出流。 5 public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 6 public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 捕获异常使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。 try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下： 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 throws&#x2F;throw 关键字：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。 finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 注意下面事项： catch 不能独立于 try 存在。 在 try&#x2F;catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码。 声明自定义异常在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。 可以像下面这样定义自己的异常类： 1class MyException extends Exception&#123; &#125; 只继承Exception 类来创建的异常类是检查性异常类。 下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。 一个异常类和其它任何类一样，包含有变量和方法。 通用异常在Java中定义了两种类型的异常和错误。 JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。 Java面向对象Java 继承类的继承格式在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 类的继承格式12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承关键字继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 super 与 this 关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 final关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 声明类： 1final class 类名 &#123;//类体&#125; 声明方法： 1修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 构造器子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 Java 重写(Override)与重载(Overload)重写(Override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。 方法的重写规则 参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个类，则不能重写该类的方法。 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 总结方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 Java 多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作。 多态性是对象多种表现形式的体现。 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象：Parent p &#x3D; new Child(); 虚函数虚函数的存在是为了多态。 Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。 多态的实现方式多态的实现方式方式一：重写：方式二：接口方式三：抽象类和抽象方法Java 抽象类抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 继承抽象类抽象方法声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 Java 封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 Java 接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 注：JDK 1.8 以后，接口里可以有静态方法和方法体了。 注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。 注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法。 接口的声明接口的声明语法格式如下： 1234[可见度] interface 接口名称 [extends 其他的接口名] &#123; // 声明变量 // 抽象方法&#125; 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： 接口语法： 1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 接口的多继承在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可以定义或是继承相同的方法 标记接口最常用的继承接口是没有包含任何方法的接口。 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 123package java.util;public interface EventListener&#123;&#125; 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 Java 枚举(enum)Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。 Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。 例如定义一个颜色的枚举类。 1234enum Color &#123; RED, GREEN, BLUE; &#125; 内部类中使用枚举1234567891011121314public class Test&#123; enum Color &#123; RED, GREEN, BLUE; &#125; // 执行输出结果 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); &#125;&#125; 每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。 以上的枚举类 Color 转化在内部类实现： 123456class Color&#123; public static final Color RED = new Color(); public static final Color BLUE = new Color(); public static final Color GREEN = new Color();&#125; 迭代枚举元素可以使用 for 语句来迭代枚举元素： 1234567891011121314enum Color&#123; RED, GREEN, BLUE;&#125;public class MyClass &#123; public static void main(String[] args) &#123; for (Color myVar : Color.values()) &#123; System.out.println(myVar); &#125; &#125;&#125;REDGREENBLUE 在 switch 中使用枚举类123456789101112131415161718192021enum Color&#123; RED, GREEN, BLUE;&#125;public class MyClass &#123; public static void main(String[] args) &#123; Color myVar = Color.BLUE; switch(myVar) &#123; case RED: System.out.println(&quot;红色&quot;); break; case GREEN: System.out.println(&quot;绿色&quot;); break; case BLUE: System.out.println(&quot;蓝色&quot;); break; &#125; &#125;&#125; values(), ordinal() 和 valueOf() 方法enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。 values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中： values() 返回枚举类中所有的值。 ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。 valueOf()方法返回指定字符串值的枚举常量。 枚举类成员枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。 枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。 12345678910111213141516171819202122232425262728293031enum Color&#123; RED, GREEN, BLUE; // 构造函数 private Color() &#123; System.out.println(&quot;Constructor called for : &quot; + this.toString()); &#125; public void colorInfo() &#123; System.out.println(&quot;Universal Color&quot;); &#125;&#125; public class Test&#123; // 输出 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); c1.colorInfo(); &#125;&#125;Constructor called for : REDConstructor called for : GREENConstructor called for : BLUEREDUniversal Color Java 包(package)为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 包的作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1package pkg1[．pkg2[．pkg3…]]; 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 import 关键字为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 注意：类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 package 的目录结构类放在包中会有两种主要的结果： 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。 设置 CLASSPATH 系统变量用下面的命令显示当前的CLASSPATH变量： Windows 平台（DOS 命令行下）：C:&gt; set CLASSPATH UNIX 平台（Bourne shell 下）：# echo $CLASSPATH 删除当前CLASSPATH变量内容： Windows 平台（DOS 命令行下）：C:&gt; set CLASSPATH&#x3D; UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量: Windows 平台（DOS 命令行下）： C:&gt; set CLASSPATH&#x3D;C:\\users\\jack\\java\\classes UNIX 平台（Bourne shell 下）：# CLASSPATH&#x3D;&#x2F;home&#x2F;jack&#x2F;java&#x2F;classes; export CLASSPATH Java 高级Java 数据结构Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类： 枚举（Enumeration） 位集合（BitSet） 向量（Vector） 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties） 以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。 枚举（Enumeration）枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。 例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。 关于枚举接口的更多信息，请参见枚举（Enumeration）。 位集合（BitSet）位集合类实现了一组可以单独设置和清除的位或标志。 该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。 关于该类的更多信息，请参见位集合（BitSet）。 向量（Vector）向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。 和数组一样，Vector对象的元素也能通过索引访问。 使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。 关于该类的更多信息，请参见向量(Vector) 栈（Stack）栈（Stack）实现了一个后进先出（LIFO）的数据结构。 你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。 当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。 关于该类的更多信息，请参见栈（Stack）。 字典（Dictionary）字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。 当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。 由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。 关于该类的更多信息，请参见字典（ Dictionary）。 哈希表（Hashtable）Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。 例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。 哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。 关于该类的更多信息，请参见哈希表（HashTable）。 属性（Properties）Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。 Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。 关于该类的更多信息，请参见属性（Properties）。 Java 集合框架早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。 集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键&#x2F;值对。尽管 Map 不是集合，但是它们完全整合在集合中。 集合框架体系如图所示 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。 集合接口集合框架定义了一些接口。本节提供了每个接口的概述： 序号 接口描述 1 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。 2 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 3 Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 4 SortedSet 继承于Set保存有序的集合。 5 Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 6 Map.Entry 描述在一个Map中的一个元素（键&#x2F;值对）。是一个 Map 的内部接口。 7 SortedMap 继承于 Map，使 Key 保持在升序排列。 8 Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 集合实现类（集合类）Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。 标准集合类汇总于下表： 序号 类描述 1 AbstractCollection 实现了大部分的集合接口。 2 AbstractList 继承于AbstractCollection 并且实现了大部分List接口。 3 AbstractSequentialList 继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。 4 LinkedList该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：List list=Collections.synchronizedList(newLinkedList(...));LinkedList 查找效率低。 5 ArrayList该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。 6 AbstractSet 继承于AbstractCollection 并且实现了大部分Set接口。 7 HashSet该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。 8 LinkedHashSet 具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。 9 TreeSet 该类实现了Set接口，可以实现排序等功能。 10 AbstractMap 实现了大部分的Map接口。 11 HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 12 TreeMap 继承了AbstractMap，并且使用一颗树。 13 WeakHashMap 继承AbstractMap类，使用弱密钥的哈希表。 14 LinkedHashMap 继承于HashMap，使用元素的自然顺序对元素进行排序. 15 IdentityHashMap 继承AbstractMap类，比较文档时使用引用相等。 在前面的教程中已经讨论通过java.util包中定义的类，如下所示： 序号 类描述 1 Vector 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。 2 Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。 3 Dictionary Dictionary 类是一个抽象类，用来存储键&#x2F;值对，作用和Map类相似。 4 Hashtable Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。 5 Properties Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。 6 BitSet 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。 集合算法集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。 在尝试比较不兼容的类型时，一些方法能够抛出 ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。 集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变。 序号 算法描述 1 Collection Algorithms 这里是一个列表中的所有算法实现。 如何使用迭代器通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。 一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或 ListIterator接口。 迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了 Iterator，以允许双向遍历列表和修改元素。 序号 迭代器方法描述 1 使用 Java Iterator 这里通过实例列出 Iterator 和 ListIterator 接口提供的所有方法。 遍历 ArrayList123456789101112131415161718192021222324252627282930import java.util.*; public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;HAHAHAHA&quot;); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) &#123; //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式 System.out.println(str); &#125; //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 &#123; System.out.println(ite.next()); &#125; &#125;&#125; 解析：三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。 遍历 Map123456789101112131415161718192021222324252627282930313233343536import java.util.*; public class Test&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;, &quot;value2&quot;); map.put(&quot;3&quot;, &quot;value3&quot;); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value：&quot;); for (String key : map.keySet()) &#123; System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key)); &#125; //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第四种 System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) &#123; System.out.println(&quot;value= &quot; + v); &#125; &#125;&#125; 如何使用比较器TreeSet和TreeMap的按照排序顺序来存储元素. 然而，这是通过比较器来精确定义按照什么样的排序顺序。 这个接口可以让我们以不同的方式来排序一个集合。 序号 比较器方法描述 1 使用 Java Comparator 这里通过实例列出Comparator接口提供的所有方法 总结Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 Java ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。ArrayList 继承了 AbstractList ，并实现了 List 接口。 ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下： 123import java.util.ArrayList; // 引入 ArrayList 类ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化 E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。 objectName: 对象名。 ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 添加元素ArrayList 类提供了很多有用的方法，添加元素到 ArrayList 可以使用 add() 方法: 访问元素访问 ArrayList 中的元素可以使用 get() 方法： 注意：数组的索引值从 0 开始。 修改元素如果要修改 ArrayList 中的元素可以使用 set() 方法： sites.set(2, &quot;Wiki&quot;); 删除元素如果要删除 ArrayList 中的元素可以使用 remove() 方法： 计算大小如果要计算 ArrayList 中的元素数量可以使用 size() 方法： 迭代数组列表我们可以使用 for 来迭代数组列表中的元素： 123for (int i = 0; i &lt; sites.size(); i++) &#123; System.out.println(sites.get(i)); &#125; 也可以使用 for-each 来迭代元素： 123for (String i : sites) &#123; System.out.println(i); &#125; 其他的引用类型ArrayList 中的元素实际上是对象，在以上实例中，数组列表元素都是字符串 String 类型。 如果我们要存储其他类型，而 只能为引用数据类型，这时我们就需要使用到基本类型的包装类。 基本类型对应的包装类表如下： 基本类型 引用类型 boolean Boolean byte Byte short Short int Integer long Long float Float double Double char Character 此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。 12ArrayList&lt;Integer&gt; li=new Arraylist&lt;&gt;(); // 存放整数元素ArrayList&lt;Character&gt; li=new Arraylist&lt;&gt;(); // 存放字符元素 ArrayList 排序Collections 类也是一个非常有用的类，位于 java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序。 以下实例对字母进行排序： 1234567891011121314151617import java.util.ArrayList;import java.util.Collections; // 引入 Collections 类public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Taobao&quot;); sites.add(&quot;Wiki&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Weibo&quot;); sites.add(&quot;Google&quot;); Collections.sort(sites); // 字母排序 for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; 以下实例对数字进行排序： 1234567891011121314151617181920import java.util.ArrayList;import java.util.Collections; // 引入 Collections 类public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; myNumbers = new ArrayList&lt;Integer&gt;(); myNumbers.add(33); myNumbers.add(15); myNumbers.add(20); myNumbers.add(34); myNumbers.add(8); myNumbers.add(12); Collections.sort(myNumbers); // 数字排序 for (int i : myNumbers) &#123; System.out.println(i); &#125; &#125;&#125; Java ArrayList 方法Java ArrayList 常用方法列表如下： 方法 描述 add() 将元素插入到指定位置的 arraylist 中 addAll() 添加集合中的所有元素到 arraylist 中 clear() 删除 arraylist 中的所有元素 clone() 复制一份 arraylist contains() 判断元素是否在 arraylist get() 通过索引值获取 arraylist 中的元素 indexOf() 返回 arraylist 中元素的索引值 removeAll() 删除存在于指定集合中的 arraylist 里的所有元素 remove() 删除 arraylist 里的单个元素 size() 返回 arraylist 里元素数量 isEmpty() 判断 arraylist 是否为空 subList() 截取部分 arraylist 的元素 set() 替换 arraylist 中指定索引的元素 sort() 对 arraylist 元素进行排序 toArray() 将 arraylist 转换为数组 toString() 将 arraylist 转换为字符串 ensureCapacity 设置指定容量大小的 arraylist lastIndexOf() 返回指定元素在 arraylist 中最后一次出现的位置 retainAll() 保留 arraylist 中在指定集合中也存在的那些元素 containsAll() 查看 arraylist 是否包含指定集合中的所有元素 trimToSize() 将 arraylist 中的容量调整为数组中的元素个数 removeRange() 删除 arraylist 中指定索引之间存在的元素 replaceAll() 将给定的操作内容替换掉数组中每一个元素 removeIf() 删除所有满足特定条件的 arraylist 元素 forEach() 遍历 arraylist 中每一个元素并执行特定操作 Java LinkedList链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。 链表可分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。 与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。 以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 LinkedList 继承了 AbstractSequentialList 类。 LinkedList 实现了 Queue 接口，可作为队列使用。 LinkedList 实现了 List 接口，可进行列表的相关操作。 LinkedList 实现了 Deque 接口，可作为队列使用。 LinkedList 实现了 Cloneable 接口，可实现克隆。 LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。 LinkedList 类位于 java.util 包中，使用前需要引入它，语法格式如下： 123456// 引入 LinkedList 类import java.util.LinkedList; LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); // 普通创建方法或者LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表 更多的情况下我们使用 ArrayList 访问列表中的随机元素更加高效，但以下几种情况 LinkedList 提供了更高效的方法。 在列表开头添加元素： 12// 使用 addFirst() 在头部添加元素 sites.addFirst(&quot;Wiki&quot;); 在列表结尾添加元素： 12// 使用 addLast() 在尾部添加元素 sites.addLast(&quot;Wiki&quot;); 在列表开头移除元素： 12// 使用 removeFirst() 移除头部元素 sites.removeFirst(); 在列表结尾移除元素： 12// 使用 removeLast() 移除尾部元素 sites.removeLast(); 获取列表开头的元素： 12// 使用 getFirst() 获取头部元素 System.out.println(sites.getFirst()); 获取列表结尾的元素： 12// 使用 getLast() 获取尾部元素 System.out.println(sites.getLast()); 迭代元素我们可以使用 for 配合 size() 方法来迭代列表中的元素： 123for (int size = sites.size(), i = 0; i &lt; size; i++) &#123; System.out.println(sites.get(i)); &#125; 也可以使用 for-each 来迭代元素： 123for (String i : sites) &#123; System.out.println(i); &#125; 常用方法 方法 描述 public boolean add(E e) 链表末尾添加元素，返回是否成功，成功为 true，失败为 false。 public void add(int index, E element) 向指定位置插入元素。 public boolean addAll(Collection c) 将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。 public boolean addAll(int index, Collection c) 将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。 public void addFirst(E e) 元素添加到头部。 public void addLast(E e) 元素添加到尾部。 public boolean offer(E e) 向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。 public boolean offerFirst(E e) 头部插入元素，返回是否成功，成功为 true，失败为 false。 public boolean offerLast(E e) 尾部插入元素，返回是否成功，成功为 true，失败为 false。 public void clear() 清空链表。 public E removeFirst() 删除并返回第一个元素。 public E removeLast() 删除并返回最后一个元素。 public boolean remove(Object o) 删除某一元素，返回是否成功，成功为 true，失败为 false。 public E remove(int index) 删除指定位置的元素。 public E poll() 删除并返回第一个元素。 public E remove() 删除并返回第一个元素。 public boolean contains(Object o) 判断是否含有某一元素。 public E get(int index) 返回指定位置的元素。 public E getFirst() 返回第一个元素。 public E getLast() 返回最后一个元素。 public int indexOf(Object o) 查找指定元素从前往后第一次出现的索引。 public int lastIndexOf(Object o) 查找指定元素最后一次出现的索引。 public E peek() 返回第一个元素。 public E element() 返回第一个元素。 public E peekFirst() 返回头部元素。 public E peekLast() 返回尾部元素。 public E set(int index, E element) 设置指定位置的元素。 public Object clone() 克隆该列表。 public Iterator descendingIterator() 返回倒序迭代器。 public int size() 返回链表元素个数。 public ListIterator listIterator(int index) 返回从指定位置开始到末尾的迭代器。 public Object[] toArray() 返回一个由链表元素组成的数组。 public T[] toArray(T[] a) 返回一个由链表元素转换类型而成的数组。 Java HashSetHashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。 HashSet 实现了 Set 接口。 添加元素HashSet 类提供类很多有用的方法，添加元素可以使用 add() 方法: 被添加了两次，它在集合中也只会出现一次，因为集合中的每个元素都必须是唯一的。 判断元素是否存在我们可以使用 contains() 方法来判断元素是否存在于集合当中: 删除元素我们可以使用 remove() 方法来删除集合中的元素: 删除集合中所有元素可以使用 clear 方法： 计算大小如果要计算 HashSet 中的元素数量可以使用 size() 方法： 迭代 HashSet可以使用 for-each 来迭代 HashSet 中的元素。 Java TreeSetTreeSet介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152TreeSet简介TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable接口。TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。TreeSet 实现了Cloneable接口，意味着它能被克隆。TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。 TreeSet的构造函数// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。TreeSet()// 创建的TreeSet包含collectionTreeSet(Collection&lt;? extends E&gt; collection)// 指定TreeSet的比较器TreeSet(Comparator&lt;? super E&gt; comparator)// 创建的TreeSet包含setTreeSet(SortedSet&lt;E&gt; set)TreeSet的APIboolean add(E object)boolean addAll(Collection&lt;? extends E&gt; collection)void clear()Object clone()boolean contains(Object object)E first()boolean isEmpty()E last()E pollFirst()E pollLast()E lower(E e)E floor(E e)E ceiling(E e)E higher(E e)boolean remove(Object object)int size()Comparator&lt;? super E&gt; comparator()Iterator&lt;E&gt; iterator()Iterator&lt;E&gt; descendingIterator()SortedSet&lt;E&gt; headSet(E end)NavigableSet&lt;E&gt; descendingSet()NavigableSet&lt;E&gt; headSet(E end, boolean endInclusive)SortedSet&lt;E&gt; subSet(E start, E end)NavigableSet&lt;E&gt; subSet(E start, boolean startInclusive, E end, boolean endInclusive)NavigableSet&lt;E&gt; tailSet(E start, boolean startInclusive)SortedSet&lt;E&gt; tailSet(E start) 说明：(1) TreeSet是有序的Set集合，因此支持add、remove、get等方法。(2) 和NavigableSet一样，TreeSet的导航方法大致可以区分为两类，一类时提供元素项的导航方法，返回某个元素；另一类时提供集合的导航方法，返回某个集合。lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。 TreeSet数据结构TreeSet的继承关系 1234567java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.TreeSet&lt;E&gt;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125; TreeSet与Collection关系如下图： 从图中可以看出：(1) TreeSet继承于AbstractSet，并且实现了NavigableSet接口。(2) TreeSet的本质是一个”有序的，并且没有重复元素”的集合，它是通过TreeMap实现的。TreeSet中含有一个”NavigableMap类型的成员变量”m，而m实际上是”TreeMap的实例”。 总结：(1) TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。(2) TreeSet是非线程安全的。(3) TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。 TreeSet遍历方式Iterator顺序遍历123for(Iterator iter = set.iterator(); iter.hasNext(); ) &#123; iter.next();&#125; Iterator顺序遍历&#x2F;&#x2F; 假设set是TreeSet对象 123for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) &#123; iter.next();&#125; for-each遍历HashSet&#x2F;&#x2F; 假设set是TreeSet对象，并且set中元素是String类型 123String[] arr = (String[])set.toArray(new String[0]);for (String str:arr) System.out.printf(&quot;for each : %s &quot;, str); TreeSet不支持快速随机遍历，只能通过迭代器进行遍历！ TreeSet遍历测试程序如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class TreeSetIteratorTest &#123; public static void main(String[] args) &#123; TreeSet set = new TreeSet(); set.add(&quot;aaa&quot;); set.add(&quot;aaa&quot;); set.add(&quot;bbb&quot;); set.add(&quot;eee&quot;); set.add(&quot;ddd&quot;); set.add(&quot;ccc&quot;); // 顺序遍历TreeSet ascIteratorThroughIterator(set) ; // 逆序遍历TreeSet descIteratorThroughIterator(set); // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 foreachTreeSet(set); &#125; // 顺序遍历TreeSet public static void ascIteratorThroughIterator(TreeSet set) &#123; System.out.print(&quot; ---- Ascend Iterator ---- &quot;); for(Iterator iter = set.iterator(); iter.hasNext(); ) &#123; System.out.printf(&quot;asc : %s &quot;, iter.next()); &#125; &#125; // 逆序遍历TreeSet public static void descIteratorThroughIterator(TreeSet set) &#123; System.out.printf(&quot; ---- Descend Iterator ---- &quot;); for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) System.out.printf(&quot;desc : %s &quot;, (String)iter.next()); &#125; // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 private static void foreachTreeSet(TreeSet set) &#123; System.out.printf(&quot; ---- For-each ---- &quot;); String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s &quot;, str); &#125; &#125; Java HashMapHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。 HashMap 是无序的，即不会记录插入的顺序。 HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 添加元素HashMap 类提供了很多有用的方法，添加键值对(key-value)可以使用 put() 方法: Sites.put(1, &quot;Google&quot;); 以下实例创建一个字符串（String）类型的 key 和字符串（String）类型的 value： Sites.put(&quot;one&quot;, &quot;Google&quot;); 访问元素我们可以使用 get(key) 方法来获取 key 对应的 value: System.out.println(Sites.get(3)); 删除元素我们可以使用 remove(key) 方法来删除 key 对应的键值对(key-value): 删除所有键值对(key-value)可以使用 clear 方法： 计算大小如果要计算 HashMap 中的元素数量可以使用 size() 方法： 迭代 HashMap可以使用 for-each 来迭代 HashMap 中的元素。 如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。 1234567891011121314151617181920212223// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); // 输出 key 和 value for (Integer i : Sites.keySet()) &#123; System.out.println(&quot;key: &quot; + i + &quot; value: &quot; + Sites.get(i)); &#125; // 返回所有 value 值 for(String value: Sites.values()) &#123; // 输出每一个value System.out.print(value + &quot;, &quot;); &#125; &#125;&#125; Java HashMap 方法hashmap Java HashMap 常用方法列表如下： 方法 描述 clear() 删除 hashMap 中的所有键&#x2F;值对 clone() 复制一份 hashMap isEmpty() 判断 hashMap 是否为空 size() 计算 hashMap 中键&#x2F;值对的数量 put() 将键&#x2F;值对添加到 hashMap 中 putAll() 将所有键&#x2F;值对添加到 hashMap 中 putIfAbsent() 如果 hashMap 中不存在指定的键，则将指定的键&#x2F;值对插入到 hashMap 中。 remove() 删除 hashMap 中指定键 key 的映射关系 containsKey() 检查 hashMap 中是否存在指定的 key 对应的映射关系。 containsValue() 检查 hashMap 中是否存在指定的 value 对应的映射关系。 replace() 替换 hashMap 中是指定的 key 对应的 value。 replaceAll() 将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。 get() 获取指定 key 对应对 value getOrDefault() 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 forEach() 对 hashMap 中的每个映射执行指定的操作。 entrySet() 返回 hashMap 中所有映射项的集合集合视图。 keySet 返回 hashMap 中所有 key 组成的集合视图。 values() 返回 hashMap 中存在的所有 value 值。 merge() 添加键值对到 hashMap 中 compute() 对 hashMap 中指定 key 的值进行重新计算 computeIfAbsent() 对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中 computeIfPresent() 对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。 Java TreeMapTreeMap的基本概念TreeMap集合是基于红黑树（Red-Black tree）的 NavigableMap实现。该集合最重要的特点就是可排序，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。这句话是什么意思呢？就是说TreeMap可以对添加进来的元素进行排序，可以按照默认的排序方式，也可以自己指定排序方式。 根据上一条，我们要想使用TreeMap存储并排序我们自定义的类（如User类），那么必须自己定义比较机制：一种方式是User类去实现java.lang.Comparable接口，并实现其compareTo()方法。另一种方式是写一个类（如MyCompatator）去实现java.util.Comparator接口，并实现compare()方法，然后将MyCompatator类实例对象作为TreeMap的构造方法参数进行传参（当然也可以使用匿名内部类），这些比较方法是怎么被调用的将在源码中讲解。 下图是Map集合体系类图。 TreeMap源码分析类名及类成员变量1234567891011121314151617181920212223242526public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; // 比较器对象 private final Comparator&lt;? super K&gt; comparator; // 根节点 private transient Entry&lt;K,V&gt; root; // 集合大小 private transient int size = 0; // 树结构被修改的次数 private transient int modCount = 0; // 静态内部类用来表示节点类型 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; // 键 V value; // 值 Entry&lt;K,V&gt; left; // 指向左子树的引用（指针） Entry&lt;K,V&gt; right; // 指向右子树的引用（指针） Entry&lt;K,V&gt; parent; // 指向父节点的引用（指针） boolean color = BLACK; // &#125;&#125; 类构造方法123456789101112131415161718192021public TreeMap() &#123; // 1,无参构造方法 comparator = null; // 默认比较机制 &#125; public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; // 2，自定义比较器的构造方法 this.comparator = comparator; &#125; public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 3，构造已知Map对象为TreeMap comparator = null; // 默认比较机制 putAll(m); &#125; public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; // 4，构造已知的SortedMap对象为TreeMap comparator = m.comparator(); // 使用已知对象的构造器 try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; &#125; put()方法详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // 获取根节点 // 如果根节点为空，则该元素置为根节点 if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; // 集合大小为1 modCount++; // 结构修改次数自增 return null; &#125; int cmp; Entry&lt;K,V&gt; parent; Comparator&lt;? super K&gt; cpr = comparator; // 比较器对象 // 如果比较器对象不为空，也就是自定义了比较器 if (cpr != null) &#123; do &#123; // 循环比较并确定元素应插入的位置(也就是找到该元素的父节点) parent = t; // t就是root // 调用比较器对象的compare()方法，该方法返回一个整数 cmp = cpr.compare(key, t.key); if (cmp &lt; 0) // 待插入元素的key&quot;小于&quot;当前位置元素的key，则查询左子树 t = t.left; else if (cmp &gt; 0) // 待插入元素的key&quot;大于&quot;当前位置元素的key，则查询右子树 t = t.right; else // &quot;相等&quot;则替换其value。 return t.setValue(value); &#125; while (t != null); &#125; // 如果比较器对象为空，使用默认的比较机制 else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 取出比较器对象 do &#123; // 同样是循环比较并确定元素应插入的位置(也就是找到该元素的父节点) parent = t; cmp = k.compareTo(t.key); // 同样调用比较方法并返回一个整数 if (cmp &lt; 0) // 待插入元素的key&quot;小于&quot;当前位置元素的key，则查询左子树 t = t.left; else if (cmp &gt; 0) // 待插入元素的key&quot;大于&quot;当前位置元素的key，则查询右子树 t = t.right; else // &quot;相等&quot;则替换其value。 return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 根据key找到父节点后新建一个节点 if (cmp &lt; 0) // 根据比较的结果来确定放在左子树还是右子树 parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; // 集合大小+1 modCount++; // 集合结构被修改次数+1 return null; &#125; 自定义比较器的使用说了这么多关于比较器的内容，不上手试试这么能行？ 先来看下面这段代码 1234567891011121314151617181920import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.TreeMap;public class TreeMapDemo2 &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new TreeMap&lt;&gt;(); map.put(&quot;ddd&quot;, &quot;444&quot;); map.put(&quot;ccc&quot;, &quot;333&quot;); map.put(&quot;bbb&quot;, &quot;222&quot;); map.put(&quot;aaa&quot;, &quot;111&quot;); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; each : entrySet) &#123; System.out.println(each.getKey()+&quot;::&quot;+each.getValue()); &#125; &#125;&#125; 输出结果如下，结果是排序过的，为什么呢？那是因为String类实现了Comparable接口并实现了compareTo()方法，该方法按字典顺序比较两个字符串，请自行查看其实现。 1234aaa::111bbb::222ccc::333ddd::444 下面我们写个自定义User类，使用2种方式将类对象按照age字段从小到大排序。 方式1，User实现Comparable接口并实现了compareTo()方法User类 12345678910111213141516171819public class User implements Comparable&lt;User&gt;&#123; private String username; private int age; public User(String username, int age) &#123; this.username = username; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;; &#125; @Override public int compareTo(User user) &#123; int temp = this.age - user.age; return temp == 0 ? this.username.compareTo(user.username) : temp; &#125; &#125; 测试代码 1234567891011121314151617181920import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.TreeMap;public class TreeMapDemo1 &#123; public static void main(String[] args) &#123; Map&lt;User, String&gt; map = new TreeMap&lt;&gt;(); map.put(new User(&quot;jimmy1&quot;, 30), &quot;hello&quot;); map.put(new User(&quot;jimmy2&quot;, 30), &quot;hello&quot;); map.put(new User(&quot;jimmy&quot;, 22), &quot;hello&quot;); map.put(new User(&quot;jimmy&quot;, 20), &quot;hello&quot;); Set&lt;Entry&lt;User, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;User, String&gt; each : entrySet) &#123; System.out.println(each.getKey()+&quot;::&quot;+each.getValue()); &#125; &#125;&#125; 输出结果如下，首先按age排序，若年龄相等则再按username的字母表顺序排序。 1234User [username=jimmy, age=20]::helloUser [username=jimmy, age=22]::helloUser [username=jimmy1, age=30]::helloUser [username=jimmy2, age=30]::hello 方式2，写一个类实现java.util.Comparator接口，并将该类对象传递给TreeMap的构造方法。这种方式将实体类和比较机制解耦合，可以写很多个不同的比较器对象。 实体类 123456789101112131415161718192021222324252627public class User3 &#123; // User对象不再实现任何接口 private String username; private int age; public User3(String username, int age) &#123; super(); this.username = username; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User3 [username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 比较器类 12345678910import java.util.Comparator;public class TreeMapComparator implements Comparator&lt;User3&gt;&#123; // 比较器类 @Override public int compare(User3 o1, User3 o2) &#123; int temp = o1.getAge() - o2.getAge(); return temp == 0 ? o1.getUsername().compareTo(o2.getUsername()) : temp; &#125;&#125; 测试代码 1234567891011121314151617181920import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.Map.Entry;public class TreeMapDemo3 &#123; public static void main(String[] args) &#123; Map&lt;User3, String&gt; map = new TreeMap&lt;&gt;(new TreeMapComparator()); map.put(new User3(&quot;jimmy1&quot;, 30), &quot;hello&quot;); map.put(new User3(&quot;jimmy2&quot;, 30), &quot;hello&quot;); map.put(new User3(&quot;jimmy&quot;, 22), &quot;hello&quot;); map.put(new User3(&quot;jimmy&quot;, 20), &quot;hello&quot;); Set&lt;Entry&lt;User3, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;User3, String&gt; each : entrySet) &#123; System.out.println(each.getKey()+&quot;::&quot;+each.getValue()); &#125; &#125;&#125; 当然，我们还可以不写比较器类，而是使用匿名内部类的形式来写比较器。 12345678910111213141516171819202122232425262728import java.util.Comparator;import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.Map.Entry;public class TreeMapDemo4 &#123; public static void main(String[] args) &#123; Map&lt;User3, String&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;User3&gt;() &#123; @Override public int compare(User3 o1, User3 o2) &#123; int temp = o1.getAge() - o2.getAge(); return temp == 0 ? o1.getUsername().compareTo(o2.getUsername()) : temp; &#125; &#125;); map.put(new User3(&quot;jimmy1&quot;, 30), &quot;hello&quot;); map.put(new User3(&quot;jimmy2&quot;, 30), &quot;hello&quot;); map.put(new User3(&quot;jimmy&quot;, 22), &quot;hello&quot;); map.put(new User3(&quot;jimmy&quot;, 20), &quot;hello&quot;); Set&lt;Entry&lt;User3, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;User3, String&gt; each : entrySet) &#123; System.out.println(each.getKey()+&quot;::&quot;+each.getValue()); &#125; &#125;&#125; 一般以getEntry()方法为基础的获取元素的方法，其中包括containsKey()，get()，remove()等。 1234567891011121314151617181920final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 如果有自定义比较器对象，就按照自定义规则遍历二叉树 if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; // 按照默认比较规则遍历二叉树 int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null; &#125; 一般以getFirstEntry()，getLastEntry()为基础的获取头和尾元素的方法，其中包括：firstKey()，lastKey()；firstEntry()，lastEntry()；pollFirstEntry()，pollLastEntry()； 123456789101112131415final Entry&lt;K,V&gt; getFirstEntry() &#123; // 获取第一个元素也就是最小的元素，一直遍历左子树 Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; &#125; final Entry&lt;K,V&gt; getLastEntry() &#123; // 获取最后个元素也就是最大的元素，一直遍历右子树 Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p; &#125; keySet()和entrySet()方法，在将HashMap的时候已经讲过了，Map没有迭代器，要将Map转化为Set，用Set的迭代器才能进行元素迭代。 总结TreeMap继承了Map的性质，同时其树结构又可以进行元素排序，用处很大。 Java Iterator（迭代器）Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。 Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。 迭代器 it 的两个基本操作是 next 、hasNext 和 remove。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 获取一个迭代器集合想获取一个迭代器可以使用 iterator() 方法: 123456789101112// 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的第一个元素 System.out.println(it.next()); 循环集合元素让迭代器 it 逐个返回集合中所有元素最简单的方法是使用 while 循环： 123while(it.hasNext()) &#123; System.out.println(it.next());&#125; Java Object 类Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。 Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。 类的方法 序号 方法 &amp; 描述 1 protected Object clone()创建并返回一个对象的拷贝 2 boolean equals(Object obj)比较两个对象是否相等 3 protected void finalize()当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。 4 Class getClass()获取对象的运行时对象的类 5 int hashCode()获取对象的 hash 值 6 void notify()唤醒在该对象上等待的某个线程 7 void notifyAll()唤醒在该对象上等待的所有线程 8 String toString()返回对象的字符串表示形式 9 void wait()让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 10 void wait(long timeout)让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。 11 void wait(long timeout, int nanos)与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 Java 泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。 泛型方法你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 ****）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等）。 java 中泛型标记符： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 下面的例子演示了如何使用泛型方法打印不同类型的数组元素： 1234567891011121314151617181920212223242526272829303132333435public class GenericMethodTest&#123; // 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ) &#123; // 输出数组元素 for ( E element : inputArray )&#123; System.out.printf( &quot;%s &quot;, element ); &#125; System.out.println(); &#125; public static void main( String args[] ) &#123; // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;; Double[] doubleArray = &#123; 1.1, 2.2, 3.3, 4.4 &#125;; Character[] charArray = &#123; &#x27;H&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;L&#x27;, &#x27;O&#x27; &#125;; System.out.println( &quot;整型数组元素为:&quot; ); printArray( intArray ); // 传递一个整型数组 System.out.println( &quot; 双精度型数组元素为:&quot; ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( &quot; 字符型数组元素为:&quot; ); printArray( charArray ); // 传递一个字符型数组 &#125; &#125;整型数组元素为:1 2 3 4 5 双精度型数组元素为:1.1 2.2 3.3 4.4 字符型数组元素为:H E L L O 有界的类型参数: 可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。 要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。 下面的例子演示了”extends”如何使用在一般意义上的意思”extends”（类）或者”implements”（接口）。该例子中的泛型方法返回三个可比较对象的最大值。 1234567891011121314151617181920212223242526272829public class MaximumTest&#123; // 比较三个值并返回最大值 public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) &#123; T max = x; // 假设x是初始最大值 if ( y.compareTo( max ) &gt; 0 )&#123; max = y; //y 更大 &#125; if ( z.compareTo( max ) &gt; 0 )&#123; max = z; // 现在 z 更大 &#125; return max; // 返回最大对象 &#125; public static void main( String args[] ) &#123; System.out.printf( &quot;%d, %d 和 %d 中最大的数为 %d &quot;, 3, 4, 5, maximum( 3, 4, 5 ) ); System.out.printf( &quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f &quot;, 6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) ); System.out.printf( &quot;%s, %s 和 %s 中最大的数为 %s &quot;,&quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot;, maximum( &quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot; ) ); &#125;&#125;3, 4 和 5 中最大的数为 56.6, 8.8 和 7.7 中最大的数为 8.8pear, apple 和 orange 中最大的数为 pear 泛型类泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 类型通配符1、类型通配符一般是使用 ? 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是 List,List等所有 List&lt;具体类型实参&gt; 的父类。 1234567891011121314151617181920212223242526import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(&quot;icon&quot;); age.add(18); number.add(314); getData(name); getData(age); getData(number); &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0)); &#125;&#125;data :icondata :18data :314 解析： 因为 getData() 方法的参数是 List&lt;?&gt; 类型的，所以 name，age，number 都可以作为这个方法的实参，这就是通配符的作用。 2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。 1234567891011121314151617181920212223242526272829import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(&quot;icon&quot;); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0)); &#125; public static void getUperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0)); &#125;&#125;data :18data :314 解析： 在 &#x2F;&#x2F;1 处会出现错误，因为 getUperNumber() 方法中的参数已经限定了参数泛型上限为 Number，所以泛型为 String 是不在这个范围之内，所以会报错。 3、类型通配符下限通过形如 List&lt;? super Number&gt; 来定义，表示类型只能接受 Number 及其上层父类类型，如 Object 类型的实例。 Java 序列化Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： 1public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： 12public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 123456789101112public class Employee implements java.io.Serializable&#123; public String name; public String address; public transient int SSN; public int number; public void mailCheck() &#123; System.out.println(&quot;Mailing a check to &quot; + name + &quot; &quot; + address); &#125;&#125; 请注意，一个类的对象要想序列化成功，必须满足两个条件： 该类必须实现 java.io.Serializable 接口。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。 序列化对象ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。 该程序执行后，就创建了一个名为 employee.ser 文件。该程序没有任何输出，但是你可以通过代码研读来理解程序的作用。 注意： 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名。 1234567891011121314151617181920212223242526import java.io.*; public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = &quot;Reyan Ali&quot;; e.address = &quot;Phokka Kuan, Ambehta Peer&quot;; e.SSN = 11122333; e.number = 101; try &#123; FileOutputStream fileOut = new FileOutputStream(&quot;/tmp/employee.ser&quot;); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf(&quot;Serialized data is saved in /tmp/employee.ser&quot;); &#125;catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125; 反序列化对象123456789101112131415161718192021222324252627282930313233343536import java.io.*; public class DeserializeDemo&#123; public static void main(String [] args) &#123; Employee e = null; try &#123; FileInputStream fileIn = new FileInputStream(&quot;/tmp/employee.ser&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); &#125;catch(IOException i) &#123; i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; System.out.println(&quot;Deserialized Employee...&quot;); System.out.println(&quot;Name: &quot; + e.name); System.out.println(&quot;Address: &quot; + e.address); System.out.println(&quot;SSN: &quot; + e.SSN); System.out.println(&quot;Number: &quot; + e.number); &#125;&#125;Deserialized Employee...Name: Reyan AliAddress:Phokka Kuan, Ambehta PeerSSN: 0Number:101 这里要注意以下要点： readObject() 方法中的 try&#x2F;catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 注意，readObject() 方法的返回值被转化成 Employee 引用。 当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。 Java 多线程编程Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 一个线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建一个线程Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现 Runnable 接口来创建线程创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： 1public void run() 你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是我们经常使用的： 1Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 1void start(); 下面是一个创建线程并开始让它执行的实例： 123456789101112131415161718192021222324252627282930313233343536373839404142class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;); R1.start(); RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;); R2.start(); &#125; &#125; 通过继承Thread来创建线程创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125; Thread 方法下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。 上述方法是被 Thread 对象调用的，下面表格的方法是 Thread 类的静态方法。 序号 方法描述 1 public static void yield() 暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 public static boolean holdsLock(Object x) 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 public static Thread currentThread() 返回对当前正在执行的线程对象的引用。 5 public static void dumpStack() 将当前线程的堆栈跟踪打印至标准错误流。 通过 Callable 和 Future 创建线程 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 123456789101112131415161718192021222324252627282930313233343536public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i); if(i==20) &#123; new Thread(ft,&quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot;+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; return i; &#125; &#125; 创建线程的三种方式的对比 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个主要概念在多线程编程时，你需要了解以下几个概念： 线程同步 线程间通信 线程死锁 线程控制：挂起、停止和恢复 多线程的使用有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。 通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。 请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！","tags":["Java"],"categories":["学习"]},{"title":"关于","path":"/about/index.html","content":""},{"title":"收藏","path":"/favorites/index.html","content":""},{"path":"/wiki/index.html","content":""}]