<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.0.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.22.1">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>数据库 - ZQ的博客</title>

  
    <meta name="description" content="主从同步是单线程 inno_buff_set 看io io top 看sql跑的慢 **&#x3D;&#x3D;explain&#x3D;&#x3D;**执行计划，慢sql，慢日志，链路，information_schema sleep 死锁 锁表 update 转移表到其他地方：数据目录，表空间，刷盘flushtable。拷贝表结构 自增上限 没走索引就会进行表锁。 元数据与表结构相关 sele">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="https://blog.forever520.top/14ea6df7/index.html">
<meta property="og:site_name" content="ZQ的博客">
<meta property="og:description" content="主从同步是单线程 inno_buff_set 看io io top 看sql跑的慢 **&#x3D;&#x3D;explain&#x3D;&#x3D;**执行计划，慢sql，慢日志，链路，information_schema sleep 死锁 锁表 update 转移表到其他地方：数据目录，表空间，刷盘flushtable。拷贝表结构 自增上限 没走索引就会进行表锁。 元数据与表结构相关 sele">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072303473.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072303785.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072304082.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072305084.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072305396.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072305813.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072306394.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072306287.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307144.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307555.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307706.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307710.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072311613.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072312931.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072312937.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072312275.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313076.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313080.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313387.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313940.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313954.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314606.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314327.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314460.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314932.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072315195.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072315088.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072315143.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072316707.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072316191.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072317595.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072317771.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318163.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318592.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318984.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318074.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319342.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319661.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319388.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320433.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319534.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320990.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320168.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320392.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321729.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321048.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321351.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321425.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072322679.png">
<meta property="og:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072322848.png">
<meta property="article:published_time" content="2022-02-11T13:22:36.000Z">
<meta property="article:modified_time" content="2023-11-07T13:41:06.450Z">
<meta property="article:author" content="Gentle Conspiracy">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072303473.png">
  
  
  
  <meta name="keywords" content="数据库,MySQL">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
    
      <script type="text/javascript" src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.6.4.min.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/hls.js@latest"></script>
    
      <script type="text/javascript" src="http://cdn.dashjs.org/latest/dash.all.min.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/flv.js@latest"></script>
    
      <link rel="shortcut icon" type="image/x-icon" href="https://pic.forever520.top/i/1/202312/uLuOlGS4OA/202204172211451.jpg" />
    
      <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures/imgs/kancss.css" >
    
      <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Everlasting16108/html/css/my.css" >
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures1/js/ag.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/qiehuan6.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/tiao3.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/myconsole.js"></script>
    
      <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/html/js/mydebug.js"></script>
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://pic.forever520.top/i/1/202312/uLuOlGS4OA/202204172211451.jpg" onerror="javascript:this.classList.add('error');this.src='https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">ZQ的博客</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/favorites/">收藏</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/about/">关于</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">数据库</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-text">用通配符进行过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="toc-text">用正则表达式 进行搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binary%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">binary关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-text">特殊字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="toc-text">创建计算字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="toc-text">拼接字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%BD%99%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="toc-text">多余的空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">使用数据处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Now-%E5%87%BD%E6%95%B0"><span class="toc-text">Now()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">文本处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOUNDEX"><span class="toc-text">SOUNDEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">日期和时间处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="toc-text">流程控制函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">汇总数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-text">聚集函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AVG-%E5%87%BD%E6%95%B0"><span class="toc-text">AVG()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%88%97%E5%80%BC%E4%B8%BANULL%E7%9A%84%E8%A1%8C"><span class="toc-text">忽略列值为NULL的行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-%E5%87%BD%E6%95%B0"><span class="toc-text">COUNT()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#COUNT-%E4%B8%8D%E5%BF%BD%E7%95%A5%E5%88%97%E5%80%BC%E4%B8%BANULL%E7%9A%84%E8%A1%8C"><span class="toc-text">COUNT(*)不忽略列值为NULL的行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COUNT-column-%E5%BF%BD%E7%95%A5%E5%88%97%E5%80%BC%E4%B8%BANULL%E7%9A%84%E8%A1%8C"><span class="toc-text">COUNT(column)忽略列值为NULL的行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAX-%E5%87%BD%E6%95%B0%E4%B8%8EMIN-%E5%87%BD%E6%95%B0"><span class="toc-text">MAX()函数与MIN()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%88%97%E5%80%BC%E4%B8%BANULL%E7%9A%84%E8%A1%8C-1"><span class="toc-text">忽略列值为NULL的行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SUM-%E5%87%BD%E6%95%B0"><span class="toc-text">SUM()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%88%97%E5%80%BC%E4%B8%BANULL%E7%9A%84%E8%A1%8C%E3%80%82"><span class="toc-text">忽略列值为NULL的行。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DISTINCT%E5%8F%82%E6%95%B0"><span class="toc-text">DISTINCT参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-text">分组数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ROLLUP"><span class="toc-text">ROLLUP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84"><span class="toc-text">过滤分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HAVING%E5%AD%90%E5%8F%A5"><span class="toc-text">HAVING子句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%B8%8E%E6%8E%92%E5%BA%8F"><span class="toc-text">分组与排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">使用子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SELECT%E5%AD%90%E5%8F%A5%E9%A1%BA%E5%BA%8F"><span class="toc-text">SELECT子句顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8"><span class="toc-text">联结表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E8%81%94%E7%BB%93%EF%BC%88%E4%B9%9F%E7%A7%B0%E4%B8%BA%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93%EF%BC%89"><span class="toc-text">等值联结（也称为内部联结）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%81%94%E7%BB%93"><span class="toc-text">自联结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93"><span class="toc-text">自然联结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93"><span class="toc-text">外部联结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%A6%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%94%E7%BB%93"><span class="toc-text">使用带聚集函数的联结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-text">join的类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inner-join%EF%BC%9A%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-text">inner join：内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#left-join%EF%BC%9A%E5%B7%A6%E8%BF%9E%E6%8E%A5"><span class="toc-text">left join：左连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#right-join%EF%BC%9A%E5%8F%B3%E8%BF%9E%E6%8E%A5"><span class="toc-text">right join：右连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#full-join%EF%BC%9A%E5%85%A8%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="toc-text">full join：全连接。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#straight-join"><span class="toc-text">straight_join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E8%A1%A8%E5%92%8C%E8%A2%AB%E9%A9%B1%E5%8A%A8%E8%A1%A8"><span class="toc-text">驱动表和被驱动表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-buffer%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">join buffer的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Index-Nested-Loop-Join"><span class="toc-text">Index Nested-Loop  Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simple-Nested-Loop-Join"><span class="toc-text">Simple Nested-Loop Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Block-Nexted-Loop-Join"><span class="toc-text">Block Nexted-Loop Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">组合查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION"><span class="toc-text">UNION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-all"><span class="toc-text">union all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F"><span class="toc-text">对组合查询结果排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="toc-text">全文本搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="toc-text">使用全文本搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="toc-text">进行全文本搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95"><span class="toc-text">使用查询扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="toc-text">布尔文本搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E8%A1%8C"><span class="toc-text">插入多个行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">插入检索出的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">更新和删除数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IGNORE%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">IGNORE关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">删除数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TRUNCATE"><span class="toc-text">TRUNCATE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="toc-text">创建和操纵表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CREATE-TABLE%E8%AF%AD%E5%8F%A5"><span class="toc-text">CREATE TABLE语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-not-exists"><span class="toc-text">if not exists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3NULL"><span class="toc-text">理解NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AUTO-INCREMENT"><span class="toc-text">使用AUTO_INCREMENT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#last-insert-id-%E5%87%BD%E6%95%B0"><span class="toc-text">last_insert_id()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BCDEFAULT"><span class="toc-text">指定默认值DEFAULT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B"><span class="toc-text">引擎类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%B7%B7%E7%94%A8%E3%80%82"><span class="toc-text">引擎类型可以混用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%BC%95%E6%93%8E"><span class="toc-text">外键不能跨引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="toc-text">更新表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%BF%83%E4%BD%BF%E7%94%A8ALTER-TABLE"><span class="toc-text">小心使用ALTER TABLE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="toc-text">删除表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="toc-text">重命名表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-text">管理事务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">开启事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-text">提交事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%B8%AD%E6%AD%A2%E4%BA%8B%E5%8A%A1"><span class="toc-text">手动中止事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-text">自动提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4"><span class="toc-text">隐式提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="toc-text">保存点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-text">事务处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-text">控制事务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ROLLBACK"><span class="toc-text">使用ROLLBACK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E8%AF%AD%E5%8F%A5%E5%8F%AF%E4%BB%A5%E5%9B%9E%E9%80%80%EF%BC%9F"><span class="toc-text">哪些语句可以回退？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8COMMIT"><span class="toc-text">使用COMMIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%9D%E7%95%99%E7%82%B9"><span class="toc-text">使用保留点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8F%90%E4%BA%A4%E8%A1%8C%E4%B8%BA"><span class="toc-text">更改默认的提交行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E4%B8%BA%E8%BF%9E%E6%8E%A5%E4%B8%93%E7%94%A8"><span class="toc-text">标志为连接专用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="toc-text">安全管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="toc-text">管理用户</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7"><span class="toc-text">创建用户账号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D"><span class="toc-text">重新命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7"><span class="toc-text">删除用户账号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">设置访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GRANT%E8%AF%AD%E5%8F%A5"><span class="toc-text">GRANT语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REVOKE%E8%AF%AD%E5%8F%A5"><span class="toc-text">REVOKE语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E5%A4%9A%E6%AC%A1%E6%8E%88%E6%9D%83"><span class="toc-text">简化多次授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%8F%A3%E4%BB%A4"><span class="toc-text">更改口令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD"><span class="toc-text">改善性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">MySQL数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">串数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数值数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UNSIGNED%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">UNSIGNED关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%B4%A7%E5%B8%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">存储货币数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">日期和时间数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">二进制数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E9%A1%B5%E7%AE%80%E4%BB%8B"><span class="toc-text">InnoDB页简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">InnoDB行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">指定行格式的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">COMPACT行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-text">变长字段长度列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NULL%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-text">NULL值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">记录头信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-text">记录的真实数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CHAR-M-%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">CHAR(M)列的存储格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-text">行溢出数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VARCHAR-M-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">VARCHAR(M)最多能存储的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9A%84%E4%B8%B4%E7%95%8C%E7%82%B9"><span class="toc-text">行溢出的临界点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">Redundant行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic%E5%92%8CCompressed%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">Dynamic和Compressed行格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-text">数据页结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-text">B+树索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E9%80%82%E7%94%A8%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">B+树索引适用的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%88%97"><span class="toc-text">匹配左边的列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%88%97%E5%89%8D%E7%BC%80"><span class="toc-text">匹配列前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%E5%80%BC"><span class="toc-text">匹配范围值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D%E6%9F%90%E4%B8%80%E5%88%97%E5%B9%B6%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D%E5%8F%A6%E5%A4%96%E4%B8%80%E5%88%97"><span class="toc-text">精确匹配某一列并范围匹配另外一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%8E%92%E5%BA%8F"><span class="toc-text">用于排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用联合索引进行排序注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">不可以使用索引进行排序的几种情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WHERE%E5%AD%90%E5%8F%A5%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%9D%9E%E6%8E%92%E5%BA%8F%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97"><span class="toc-text">WHERE子句中出现非排序使用到的索引列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%97%E5%8C%85%E5%90%AB%E9%9D%9E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97"><span class="toc-text">排序列包含非同一个索引的列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%97%E4%BD%BF%E7%94%A8%E4%BA%86%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">排序列使用了复杂的表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%88%86%E7%BB%84"><span class="toc-text">用于分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B2%A1%E7%94%A8"><span class="toc-text">索引什么时候没用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E6%B2%A1%E5%BF%85%E8%A6%81%E7%94%A8"><span class="toc-text">索引什么时没必要用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">回表的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">一个简单的索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88csdn%EF%BC%89"><span class="toc-text">索引（csdn）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">索引的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%87%86%E5%88%99"><span class="toc-text">创建索引准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97"><span class="toc-text">应该创建索引的列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%AF%A5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97"><span class="toc-text">不该创建索引的列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%88%86%E7%B1%BB"><span class="toc-text">逻辑分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%92%E5%88%86"><span class="toc-text">按功能划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%88%97%E6%95%B0%E5%88%92%E5%88%86"><span class="toc-text">按列数划分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%88%86%E7%B1%BB"><span class="toc-text">物理分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">聚簇索引优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">InnoDB索引实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-text">聚簇索引（主键索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%88%96%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-text">非聚簇索引（辅助索引或二级索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-text">InnoDB索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">聚簇索引和非聚簇索引的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95"><span class="toc-text">操作索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">删除索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">其它相关命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AE%9E%E6%88%98"><span class="toc-text">索引实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#explain"><span class="toc-text">explain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extra-%E6%8E%A2%E7%A9%B6"><span class="toc-text">Extra 探究</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%9B%9E%E8%A1%A8"><span class="toc-text">覆盖索引与回表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8"><span class="toc-text">回表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D-1"><span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99-1"><span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%88%97%E7%9A%84%E5%89%8D%E7%BC%80-%E6%AF%94%E5%A6%82like-%E2%80%98a-%E2%80%99"><span class="toc-text">匹配列的前缀(比如like ‘a%’)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%88%97%E7%9A%84%E4%B8%AD%E9%97%B4%E5%AD%97%E7%AC%A6%E6%88%96%E8%80%85%E5%90%8E%E7%BC%80-%E6%AF%94%E5%A6%82like-%E2%80%98-a-%E2%80%99%EF%BC%8Clike-%E2%80%98-com%E2%80%99"><span class="toc-text">匹配列的中间字符或者后缀(比如like ‘%a%’，like ‘%com’)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E5%92%8C%E8%BE%B9%E7%95%8C"><span class="toc-text">匹配范围查找，确定扫描区间和边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IS-NULL%E3%80%81IS-NOT-NULL%E3%80%81-%E3%80%81BETWEEN%E3%80%81IN%E7%AD%89%E7%AD%89%E4%B8%8D%E8%83%BD%E7%94%A8%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F%E5%BF%85%E9%A1%BB%E8%BE%9F%E8%B0%A3%EF%BC%81"><span class="toc-text">IS NULL、IS NOT NULL、!&#x3D;、BETWEEN、IN等等不能用索引吗？必须辟谣！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95-%E8%BF%99%E4%B8%AA%E5%9D%91%E5%AE%B9%E6%98%93%E5%BF%BD%E8%A7%86"><span class="toc-text">隐式转换导致全表扫描不走索引(这个坑容易忽视)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">使用联合索引的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8%EF%BC%88Index-Condition-Pushdown%EF%BC%8C%E7%AE%80%E7%A7%B0ICP%EF%BC%89"><span class="toc-text">索引条件下推（Index Condition Pushdown，简称ICP）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E8%A1%A8%E8%B1%A1%E7%90%86%E8%A7%A3"><span class="toc-text">索引下推表象理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E5%9C%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82%E5%92%8Cserver%E5%B1%82%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-text">索引下推在存储引擎层和server层深入分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE%E4%B9%9F%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0Using-index-condition%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%81"><span class="toc-text">范围查找也会使用到Using index condition，需要注意！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%94%A8%E4%BA%8E%E6%8E%92%E5%BA%8F-explain%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B%EF%BC%8C%E7%B2%BE%E5%8D%8E%EF%BC%81%EF%BC%81"><span class="toc-text">索引用于排序(explain分析案例，精华！！)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%8Corder-by%E5%AD%90%E5%8F%A5%E5%90%8E%E9%9D%A2%E7%9A%84%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B9%9F%E5%BF%85%E9%A1%BB%E6%8C%89%E7%85%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9D%A5%E3%80%82"><span class="toc-text">在使用联合索引时需要注意，order by子句后面的列的顺序也必须按照索引的顺序来。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E8%AE%B0%E5%BD%95%E6%95%B0%E5%BE%88%E5%A4%9A%E5%8D%B4%E4%B8%8D%E7%94%A8limit%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%9A%84%E8%AE%B0%E5%BD%95%E6%95%B0%E6%97%B6%EF%BC%8C%E6%9E%81%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95"><span class="toc-text">当记录数很多却不用limit限制查询返回的记录数时，极有可能不走索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asc%E3%80%81desc%E6%B7%B7%E7%94%A8%E6%97%A0%E6%B3%95%E5%AE%8C%E5%85%A8%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%99%A4%E9%9D%9E%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AFMySQL-8-0"><span class="toc-text">asc、desc混用无法完全利用索引，除非你的数据库是MySQL 8.0+</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%8C%85%E5%90%AB%E9%9D%9E%E5%90%8C%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%EF%BC%8C%E5%90%A6%E5%88%99%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95"><span class="toc-text">排序中不能包含非同一索引的列，否则不走索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%97%E6%98%AF%E6%9F%90%E4%B8%AA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%BA%9B%E6%8E%92%E5%BA%8F%E5%88%97%E5%9C%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%B9%B6%E4%B8%8D%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%88%99%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95"><span class="toc-text">排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续，则不走索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%97%E6%98%AF%E7%B4%A2%E5%BC%95%E5%88%97%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%86%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%99%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95"><span class="toc-text">排序列是索引列，但是使用了函数，则不走索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%94%A8%E4%BA%8E%E5%88%86%E7%BB%84"><span class="toc-text">索引用于分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">如何更好的创建和使用索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E4%B8%BA%E7%94%A8%E4%BA%8E%E6%90%9C%E7%B4%A2%E3%80%81%E6%8E%92%E5%BA%8F%E6%88%96%E5%88%86%E7%BB%84%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">只为用于搜索、排序或分组的列创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">考虑索引列中不重复值的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%BD%E9%87%8F%E5%B0%8F"><span class="toc-text">索引列的类型尽量小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E7%9A%84%E5%89%8D%E7%BC%80%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">为索引字符串值的前缀建立索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E7%B4%A2%E5%BC%95%E5%9C%A8where%E5%AD%90%E5%8F%A5%E7%9A%84%E4%B8%80%E4%BE%A7%E5%8D%95%E7%8B%AC%E5%87%BA%E7%8E%B0"><span class="toc-text">让索引在where子句的一侧单独出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E4%B8%BB%E9%94%AE%E7%9A%84%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-text">保证主键的插入顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9C%89%E5%BF%85%E8%A6%81%EF%BC%8C%E5%B0%BD%E9%87%8F%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-text">如有必要，尽量考虑使用索引覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E5%86%97%E4%BD%99%E9%87%8D%E5%A4%8D%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">避免创建冗余重复的索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">学习事务与隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E8%A6%81%E7%B4%A0%EF%BC%9AACID"><span class="toc-text">事务四要素：ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">事务并发存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB%EF%BC%88dirty-read%EF%BC%89"><span class="toc-text">脏读（dirty read）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88unrepeatable-read%EF%BC%89"><span class="toc-text">不可重复读（unrepeatable read）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%EF%BC%88phantom-read%EF%BC%89"><span class="toc-text">幻读（phantom read）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%EF%BC%88lost-update%EF%BC%89"><span class="toc-text">丢失更新（lost update）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AE-MySQL-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">查看和设置 MySQL 的隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">了解常见的锁类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81-vs-%E8%A1%8C%E9%94%81"><span class="toc-text">表锁 vs. 行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%A7%8D%E7%B1%BB"><span class="toc-text">行锁种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E9%94%81-vs-%E5%86%99%E9%94%81"><span class="toc-text">读锁 vs. 写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">读写意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AUTO-INC-%E9%94%81"><span class="toc-text">AUTO_INC 锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%AF%B4-MySQL-%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">细说 MySQL 锁类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-text">记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-text">间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next-Key-Locks"><span class="toc-text">Next-Key Locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="toc-text">插入意向锁（Insert Intention Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E7%9F%A9%E9%98%B5"><span class="toc-text">行锁的兼容矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-MySQL-%E4%B8%AD%E8%A7%82%E5%AF%9F%E8%A1%8C%E9%94%81"><span class="toc-text">在 MySQL 中观察行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next-key-%E9%94%81"><span class="toc-text">Next-key 锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-vs-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁 vs. 悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-SQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">常见 SQL 语句的加锁分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99"><span class="toc-text">基本的加锁规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95-SQL-%E7%9A%84%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">简单 SQL 的加锁分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD"><span class="toc-text">聚簇索引，查询命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="toc-text">聚簇索引，查询未命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD"><span class="toc-text">二级唯一索引，查询命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="toc-text">二级唯一索引，查询未命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD"><span class="toc-text">二级非唯一索引，查询命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="toc-text">二级非唯一索引，查询未命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="toc-text">无索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">聚簇索引，范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">二级索引，范围查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">复杂条件加锁分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DELETE-%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">DELETE 语句加锁分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INSERT-%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">INSERT 语句加锁分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%A7%81%E6%AD%BB%E9%94%81"><span class="toc-text">再见死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E9%94%81%E7%9B%91%E6%8E%A7"><span class="toc-text">开启锁监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B3%BB%E7%BB%9F%E8%A1%A8"><span class="toc-text">基于系统表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0"><span class="toc-text">基于系统参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%87%82%E6%AD%BB%E9%94%81%E6%97%A5%E5%BF%97"><span class="toc-text">读懂死锁日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-text">常见死锁分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="toc-text">死锁案例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="toc-text">死锁案例二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E4%B8%89"><span class="toc-text">死锁案例三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">如何避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-text">元数据锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8A%A0MDL%E9%94%81"><span class="toc-text">什么时候会加MDL锁</span></a></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></div><div id="post-meta">
    <span>发布于&nbsp;<time datetime="2022-02-11T13:22:36.000Z">2022-02-11</time></span>
    
    <span>更新于&nbsp;<time datetime="2023-11-07T13:41:06.450Z">2023-11-07</time></span>
    </div></div></div>

<article class='md-text content post reveal'>
<h1 class="article-title"><span>数据库</span></h1>
<p>主从同步是单线程</p>
<p>inno_buff_set</p>
<p>看io io top</p>
<p>看sql跑的慢 **&#x3D;&#x3D;explain&#x3D;&#x3D;**执行计划，慢sql，慢日志，链路，information_schema</p>
<p>sleep 死锁 锁表 update</p>
<p>转移表到其他地方：数据目录，表空间，刷盘flushtable。拷贝表结构</p>
<p>自增上限</p>
<p>没走索引就会进行表锁。</p>
<p>元数据与表结构相关</p>
<p>select含有元数据读锁</p>
<p>update锁，走索引是行，不走是表</p>
<p>排它锁</p>
<p>建立索引会有元数据锁，影子表加索引</p>
<p>并发事务有什么影响：死锁，数据安全，锁表，不能进行大事务。拆成小事务。</p>
<p>LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
<h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h2><p><strong>mysql在使用like查询的时候只有使用后面的%时，才会使用到索引。</strong></p>
<p>为了找出所有以词jet起头的产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">&#x27;jet%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>检索列prod_name包含 文本1000的所有行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name regexp <span class="string">&#x27;1000&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name regexp <span class="string">&#x27;.000&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>

<h2 id="用正则表达式-进行搜索"><a href="#用正则表达式-进行搜索" class="headerlink" title="用正则表达式 进行搜索"></a>用正则表达式 进行搜索</h2><h3 id="binary关键字"><a href="#binary关键字" class="headerlink" title="binary关键字"></a>binary关键字</h3><p>正则表达式使用<strong>binary</strong>关键字区分大小写。如：WHERE prod_name REGEXP  BINARY ‘JetPack .000’。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[]括号的使用</span><br><span class="line"><span class="keyword">select</span> prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name regexp <span class="string">&#x27;[123] Ton&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name regexp <span class="string">&#x27;[1-5] Ton&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>

<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>匹配特殊字符使用\\</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name</span><br><span class="line"><span class="keyword">from</span> vendors</span><br><span class="line"><span class="keyword">where</span> vend_name regexp <span class="string">&#x27;\\.&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072303473.png" alt="quan_2021-12-24_11-20-16"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072303785.png" alt="quan_2021-12-24_11-23-19"></p>
<p>如果你想找出以一个数（包括以小数点开始的数）开始的所 有产品，怎么办？简单搜索[0-9\.]（或[[:digit:]\.]）不行，因为它将在文本内任意位置查找匹配。解决办法是使用^定位符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_name regexp <span class="string">&#x27;^[0-9\\.]&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>简单的正则表达式测试：可以在不使用数据库表的情况下用 SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配） 或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试 验它们。相应的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;hello&#x27;</span> regexp <span class="string">&#x27;[0-9]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个例子显然将返回0（因为文本hello中没有数字）</p>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>拼接（concatenate） 将值联结到一起构成单个值。</p>
<p>在MySQL的SELECT语句中，可使用 **Concat()**函数来拼接两个列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Concat(vend_name,<span class="string">&#x27;(&#x27;</span>,vend_country,<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> vendors</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br></pre></td></tr></table></figure>

<h2 id="多余的空格"><a href="#多余的空格" class="headerlink" title="多余的空格"></a>多余的空格</h2><p>删除数据右侧多余的空格可以 使用MySQL的RTrim()函数来完成,LTrim()（去掉串左边的空格）以及 Trim()（去掉串左右两边的空格）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Concat(RTrim(vend_name),<span class="string">&#x27;(&#x27;</span>,RTrim(vend_country),<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> vendors</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br></pre></td></tr></table></figure>

<h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><h3 id="Now-函数"><a href="#Now-函数" class="headerlink" title="Now()函数"></a>Now()函数</h3><p>而SELECT  Now()利用Now()函数返回当前日期和时间</p>
<p>Now()函数</p>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072304082.png" alt="quan_2021-12-24_13-33-51"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072305084.png" alt="quan_2021-12-24_13-34-25"></p>
<h3 id="SOUNDEX"><a href="#SOUNDEX" class="headerlink" title="SOUNDEX"></a>SOUNDEX</h3><p>是一个将任何文 本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似 的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然 SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对 SOUNDEX的支持。</p>
<p>customers表中有一个顾 客Coyote Inc.，其联系名为Y.Lee。但如果这是输入错误，此联系名实 际应该是Y.Lie，怎么办？显然，按正确的联系名搜索不会返回数据，如 下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">from</span> customers</span><br><span class="line"><span class="keyword">where</span> cust_contact <span class="operator">=</span> <span class="string">&#x27;Y. Lie&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>现在试一下使用Soundex()函数进行搜索，它匹配所有发音类似于 Y.Lie的联系名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">from</span> customers</span><br><span class="line"><span class="keyword">where</span> Soundex(cust_contact) <span class="operator">=</span> Soundex(<span class="string">&#x27;Y Lie&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072305396.png" alt="quan_2021-12-24_13-44-21"></p>
<p>如果你想检索出2005年9月下的 所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天 数。有几种解决办法，其中之一如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id, order_num</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> <span class="type">Date</span>(order_date) <span class="keyword">between</span> <span class="string">&#x27;2005-09-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2005-09-30&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还有另外一种办法（一种不需要记住每个月中有多少天或不需要操 心闰年2月的办法）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id, order_num</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Year</span>(order_date) <span class="operator">=</span> <span class="number">2005</span> <span class="keyword">and</span> <span class="keyword">Month</span>(order_date) <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072305813.png" alt="quan_2021-12-24_13-55-09"></p>
<h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><p>流程控制类函数可以进行条件操作，用来实现SQL的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台，列举如下：</p>
<ul>
<li>IF(test,t,f)  如果test是真，返回t；否则返回f</li>
<li>IFNULL(arg1,arg2)  如果arg1不是空，返回arg1，否则返回arg2</li>
<li>NULLIF(arg1,arg2)  如果arg1&#x3D;arg2返回NULL；否则返回arg1</li>
<li>CASE WHEN[test1] THEN [result1]…ELSE [default] END  如果testN是真，则返回resultN，否则返回default</li>
<li>CASE [test] WHEN[val1] THEN [result]…ELSE [default]END  如果test和valN相等，则返回resultN，否则返回default</li>
</ul>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072306394.png" alt="quan_2021-12-24_13-57-38"></p>
<h4 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG()函数"></a>AVG()函数</h4><h5 id="忽略列值为NULL的行"><a href="#忽略列值为NULL的行" class="headerlink" title="忽略列值为NULL的行"></a>忽略列值为NULL的行</h5><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h4><h5 id="COUNT-不忽略列值为NULL的行"><a href="#COUNT-不忽略列值为NULL的行" class="headerlink" title="COUNT(*)不忽略列值为NULL的行"></a>COUNT(*)不忽略列值为NULL的行</h5><h5 id="COUNT-column-忽略列值为NULL的行"><a href="#COUNT-column-忽略列值为NULL的行" class="headerlink" title="COUNT(column)忽略列值为NULL的行"></a>COUNT(column)忽略列值为NULL的行</h5><h4 id="MAX-函数与MIN-函数"><a href="#MAX-函数与MIN-函数" class="headerlink" title="MAX()函数与MIN()函数"></a>MAX()函数与MIN()函数</h4><h5 id="忽略列值为NULL的行-1"><a href="#忽略列值为NULL的行-1" class="headerlink" title="忽略列值为NULL的行"></a>忽略列值为NULL的行</h5><p>max在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行</p>
<p>min在用于文本数据时，如果数据按相应的列排序， 则MIN()返回最前面的行。</p>
<h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a>SUM()函数</h4><h5 id="忽略列值为NULL的行。"><a href="#忽略列值为NULL的行。" class="headerlink" title="忽略列值为NULL的行。"></a>忽略列值为NULL的行。</h5><h3 id="DISTINCT参数"><a href="#DISTINCT参数" class="headerlink" title="DISTINCT参数"></a>DISTINCT参数</h3><p>返回特定供应商提供的产品的平均价格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(<span class="keyword">distinct</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<p>如果指定列名，则DISTINCT只能用于COUNT()。</p>
<p>DISTINCT 不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT）</p>
<p>DISTINCT必须使用列名，不能用 于计算或表达式</p>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072306287.png" alt="quan_2021-12-24_14-26-13"></p>
<h3 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h3><p>使用ROLLUP 使用<strong>WITH ROLLUP</strong>关键字，可以得到每个分组以 及每个分组汇总级别（针对每个分组）的值，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307144.png" alt="quan_2021-12-24_14-26-52"></p>
<h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><h4 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h4><p>唯一的差别是 <strong>WHERE过滤行</strong>，而<strong>HAVING过滤分组</strong>。</p>
<p>WHERE在数据 分组前进行过滤，HAVING在数据分组后进行过滤</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cust_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>它过滤COUNT(*) &gt;&#x3D;2（两个以上的订单）的那些 分组。</p>
<p>同时使用where和having子句</p>
<p>它列出具有2个（含）以上、价格 为10（含）以上的产品的供应商：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> vend_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分组与排序"><a href="#分组与排序" class="headerlink" title="分组与排序"></a>分组与排序</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307555.png" alt="quan_2021-12-24_14-38-54"></p>
<p>一般在使用GROUP BY子句时，应该也给 出ORDER BY子句</p>
<p>它检索总计订单价格大于等于50的订 单的订单号和总计订单价格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_num,<span class="built_in">sum</span>(quantity<span class="operator">*</span>item_price) <span class="keyword">AS</span> ordertotal</span><br><span class="line"><span class="keyword">from</span> orderitems</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> order_num</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(quantity<span class="operator">*</span>item_price) <span class="operator">&gt;=</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>为按总计订单价格排序输出，需要添加ORDER BY子句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_num,<span class="built_in">sum</span>(quantity<span class="operator">*</span>item_price) <span class="keyword">AS</span> ordertotal</span><br><span class="line"><span class="keyword">from</span> orderitems</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> order_num</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(quantity<span class="operator">*</span>item_price) <span class="operator">&gt;=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ordertotal;</span><br></pre></td></tr></table></figure>

<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307706.png" alt="quan_2021-12-24_14-55-22"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072307710.png" alt="quan_2021-12-24_14-56-50"></p>
<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><h3 id="等值联结（也称为内部联结）"><a href="#等值联结（也称为内部联结）" class="headerlink" title="等值联结（也称为内部联结）"></a>等值联结（也称为内部联结）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors, products</span><br><span class="line"><span class="keyword">where</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name, prod_name;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors <span class="keyword">inner</span> <span class="keyword">join</span> products</span><br><span class="line"><span class="keyword">on</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>

<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="operator">=</span> (<span class="keyword">select</span> vend_id</span><br><span class="line">                <span class="keyword">from</span> products</span><br><span class="line">                <span class="keyword">where</span> prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>);</span><br><span class="line">或</span><br><span class="line"><span class="keyword">select</span> p1.prod_id, p2.prod_name</span><br><span class="line"><span class="keyword">from</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">where</span> p1.vend_id <span class="operator">=</span> p2.vend_id</span><br><span class="line">	<span class="keyword">and</span> p2.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>自然联结排除多次出现，使每个列只返回一次。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.<span class="operator">*</span>, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">As</span> c, orders <span class="keyword">As</span> o, orderitems <span class="keyword">As</span> oi</span><br><span class="line"><span class="keyword">where</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">and</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line"><span class="keyword">and</span> prod_id <span class="operator">=</span> <span class="string">&#x27;FB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其 订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">inner</span> <span class="keyword">join</span> orders</span><br><span class="line"><span class="keyword">on</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>外部联结语法类似。为了检索所有客户，包括那些没有订单的客户， 可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">join</span> orders</span><br><span class="line"><span class="keyword">on</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>外部联结还包括没 有关联行的行</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>如果要检索所有客户及每个客户所 下的订单数，下面使用了COUNT()函数的代码可完成此工作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_name,customers.cust_id,<span class="built_in">count</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">inner</span> <span class="keyword">join</span> orders</span><br><span class="line"><span class="keyword">on</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<p>聚集函数也可以方便地与其他联结一起使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_name,customers.cust_id,<span class="built_in">count</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">join</span> orders</span><br><span class="line"><span class="keyword">on</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<h3 id="join的类别"><a href="#join的类别" class="headerlink" title="join的类别"></a>join的类别</h3><ul>
<li><h4 id="inner-join：内连接"><a href="#inner-join：内连接" class="headerlink" title="inner join：内连接"></a>inner join：内连接</h4><p>最后返回的数据行数是在inner join前后两张表中<strong>同时存在的数据行数</strong>。任何一条只存在于某一张表中的数据，都不会返回。</p>
<p>对于inner join而言，MySQL会选择<strong>小表作为驱动表</strong>，<strong>大表作为被驱动表</strong>。</p>
</li>
<li><h4 id="left-join：左连接"><a href="#left-join：左连接" class="headerlink" title="left join：左连接"></a>left join：左连接</h4><p>又称为left outer join，我们平时都把outer省略。简写为left join</p>
<p><strong>left左边的表为主表</strong>，<strong>left右边的表为从表</strong>。返回结果行数以left左边的表的行数为最后的数据行，对于左表中有些数据行在右表中找不到它所匹配的数据行记录时候，返回结果的时候这些行后面通常会以null来填充。</p>
</li>
<li><h4 id="right-join：右连接"><a href="#right-join：右连接" class="headerlink" title="right join：右连接"></a>right join：右连接</h4><p>又称为right outer join，我们平时都把outer省略。简写为right join</p>
<p><strong>right右边的表为主表</strong>，<strong>right左边的表为从表</strong>。返回结果行数以right右边的表的行数为左后的数据行，对于主表中有些数据行在从表中找不到它所匹配的数据行记录时候，返回结果的时候这些行后面通常会以null来填充。</p>
</li>
<li><h4 id="full-join：全连接。"><a href="#full-join：全连接。" class="headerlink" title="full join：全连接。"></a>full join：全连接。</h4><p>最后返回的数据行数是full join前后两张表的数行数的<strong>笛卡尔积</strong>。但是在MySQL中没有这种写法，它<strong>直接使用select * from A,B;这样的写法就可以实现全连接</strong>。 Oracle中有full join这种写法。</p>
</li>
</ul>
<h4 id="straight-join"><a href="#straight-join" class="headerlink" title="straight_join"></a>straight_join</h4><p>功能是可以指定在straight_join<strong>前面</strong>的表作为<strong>驱动表</strong>，在straight_joion<strong>后面</strong>的表作为<strong>被驱动表</strong>。</p>
<h2 id="驱动表和被驱动表"><a href="#驱动表和被驱动表" class="headerlink" title="驱动表和被驱动表"></a>驱动表和被驱动表</h2><p>驱动表在SQL语句执行的过程中，总是先读取。而被驱动表在SQL语句执行的过程中，总是后读取。</p>
<p>在驱动表数据读取后，放入到<code>join_buffer</code>后，再去读取被驱动表中的数据，来和驱动表中的数据进行匹配。如果匹配上则作为结果集返回，否则丢弃。</p>
<p>可以使用**&#x3D;&#x3D;explain&#x3D;&#x3D;**命令查看一下SQL语句的执行计划。在输出的执行计划中，排在第一行的表是驱动表，排在第二行的表是被驱动表。</p>
<p>两个表在进行关联查询的时候，是根据真正参与关联查询的数据行和列所占用的空间大小来确认谁作为驱动表谁作为被驱动表的。</p>
<p><strong>这里对于大小的判断，是指真正参与关联查询的数据量所占用的<code>join_buffer</code>的大小来区分的，而不是根据表中所有的数据行数来判断的。</strong></p>
<h2 id="join-buffer的概念"><a href="#join-buffer的概念" class="headerlink" title="join buffer的概念"></a>join buffer的概念</h2><p>join查询的时候，会把驱动表中的数据全部查询出来放入到内存中，而这个内存就是我们现在要说的：<strong>join buffer</strong></p>
<p>它的大小是由参数<code>join_buffer_size</code>大小来决定的，默认值为<code>262144</code>字节，即为：<code>256KB</code>。而它所能设置的最小值为<code>128</code>字节，最大值为：<code>4GB−1</code>字节。</p>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop  Join"></a>Index Nested-Loop  Join</h3><p><code>Index Nested-Loop Join</code>：索引嵌套循环连接。</p>
<p>我们采用如下SQL来解释<code>Index Nested-Loop Join</code>这种关联查询的执行过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">as</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>

<p>基于上面的查询计划，我们可以看出B表是驱动表，A表是被驱动表。接下来我们详细说明一下这个关联链接的具体执行过程是怎样的。</p>
<ol>
<li>获取B表中的第一行数据，然后从这行中，获取出该行的id的值。</li>
<li>拿着id的值去A表中去查找满足该id值的行，此时使用了A表中的<strong>主键索引</strong>。找到后，把A表中的这个行和B表中的行拼接在一起，作为最后的结果集，返回给客户端。</li>
<li>这样就完成了B表中第一行数据和A表的inner join过程。</li>
<li>重复1、2、3步骤，直到把B表的所有行都遍历完成，就完成了此次的join过程。</li>
</ol>
<p>以上的步骤就是<code>Index Nested-Loop Join</code>执行的过程。注意：它在去被驱动表A中获取数据的时候，使用到了A表中的索引，并不是把A表中的所有数据都扫描一遍，再去和B表中的数据去匹配。</p>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><p><code>Simple Nested-Loop Join</code>：简单嵌套循环连接。</p>
<p>我们这次把上面的使用的SQL简单修改一下，改为如下的这种写法。让其在关联的时候，不使用<code>a.id = b.id</code>的关联方式，而是使用<code>a.code = b.code</code>的关联方式。注意：此时在两个表上面的<code>code</code>字段都没有索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">as</span> b <span class="keyword">on</span> a.code <span class="operator">=</span> b.code;</span><br></pre></td></tr></table></figure>

<p>执行计划如下，从中可以看出B表示驱动表，A表示被驱动表。</p>
<p>此时在去A表被驱动表中查找数据的时候，就不能通过A表中的索引来获取数据了。那么就需要把A表中所有的数据都扫描一遍，然后再和B表中的id值进行匹配。这样每处理B表中的一行，A表中的数据都要全部扫描一次。这样的效率比前面我们提到的<code>Index Nested-Loop Join</code>慢了很多。</p>
<p>但是，<code>MySQL</code>在这种情况下并没有采用这种慢的方式，而是采用了下面我们将要说的<code>Block Nexted-Loop Join</code>的关联方式。这就是为什么我们在上面的查询计划中没有看到<code>Simple Nested-Loop Join</code>的原因。</p>
<h3 id="Block-Nexted-Loop-Join"><a href="#Block-Nexted-Loop-Join" class="headerlink" title="Block Nexted-Loop Join"></a>Block Nexted-Loop Join</h3><p><code>Block Nexted-Loop Join</code>：基于块的嵌套循环连接。</p>
<p>因为在被驱动表A找那个没有索引，所以MySQL此时才去的关联方式是基于块的嵌套循环连接。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且 还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以 利用WHERE子句来完成此工作，不过这次我们将使用UNION。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>

<p>第一条SELECT检索价格不高于5的所有物品。第二条SELECT使 用IN找出供应商1001和1002生产的所有物品。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line"></span><br><span class="line">使用多条<span class="keyword">WHERE</span>子句而不是使用<span class="keyword">UNION</span>的相同查询</span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span> <span class="keyword">or</span> vend_id <span class="keyword">in</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>

<h3 id="union-all"><a href="#union-all" class="headerlink" title="union all"></a>union all</h3><p>UNION从查询结果集中自动去除了重复的行,如果 想返回所有匹配行，可使用UNION ALL而不是UNION。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>

<h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><p>在用UNION组合查询时，只 能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1001</span>,<span class="number">1002</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_id,prod_id; </span><br></pre></td></tr></table></figure>

<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>一般在创建表时启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> productontes(</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line">    note_text text <span class="keyword">null</span>,</span><br><span class="line">	fulltext(note_text)</span><br><span class="line">)engine<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>这里的 FULLTEXT索引单个列，如果需要也可以指定多个列。</p>
<p>不要在导入数据时使用FULLTEXT，应该首先导入所有数据，然 后再修改表，定义FULLTEXT。</p>
<h3 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h3><p>Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>传递给 Match() 的值必须与 FULLTEXT()定义中的相同。如果指定多个列，则必须列出它 们（而且次序正确）。</p>
<p><strong>搜索不区分大小写，除非使用BINARY方式</strong></p>
<p>事实是刚才的搜索可以简单地用LIKE子句完成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> note_text <span class="keyword">like</span> <span class="string">&#x27;%rabbit%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>传递给 Match() 的值必须与 FULLTEXT()定义中的相同。如果指定多个列，则必须列出它 们（而且次序正确）。</p>
<p><strong>搜索不区分大小写，除非使用BINARY方式</strong></p>
<p>事实是刚才的搜索可以简单地用LIKE子句完成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> note_text <span class="keyword">like</span> <span class="string">&#x27;%rabbit%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>第3个词的行的等级比作为第20个词的行高。具有较高等级的行先返回。</p>
<p>为演示排序如何工作，请看以下例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text, <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit&#x27;</span>) <span class="keyword">AS</span> rank</span><br><span class="line"><span class="keyword">from</span> productnotes;</span><br></pre></td></tr></table></figure>

<p><strong>按等级以降序排序</strong></p>
<p>排序多个搜索项 如果指定多个搜索项，则包含多数匹配词的 那些行将具有比包含较少词（或仅有一个匹配）的那些行高的 等级值</p>
<h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">with</span> query expansion);</span><br></pre></td></tr></table></figure>

<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>即使没有FULLTEXT索引也可以使用，但这是一种非常缓慢的操作</p>
<p>为演示IN BOOLEAN MODE的作用，举一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;heavy&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br></pre></td></tr></table></figure>

<p>匹配包含heavy但不包含任意以rope开始的词的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;heavy -rope*&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072311613.png" alt="quan_2021-12-27_10-44-40"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text</span><br><span class="line"><span class="keyword">from</span> productnotes</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;+rabbit +bait&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">这个搜索匹配包含词rabbit和bait的行。</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit bait&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行。、</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;&quot;rabbit bait&quot;&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">这个搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;&gt;rabbit &lt;bait&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">匹配rabbit和carrot，增加前者的等级，降低后者的等级。</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;+safe +(&lt;combination)&#x27;</span> <span class="keyword">in</span> <span class="type">boolean</span> mode);</span><br><span class="line">这个搜索匹配词safe和combination，降低后者的等级。</span><br></pre></td></tr></table></figure>

<p>排列而不排序 在布尔方式中，不按等级值降序排序返回的 行</p>
<p>MySQL全文本搜索现在还 不支持邻近操作符</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;...&#x27;</span>,<span class="string">&#x27;...&#x27;</span>...);</span><br></pre></td></tr></table></figure>

<p>编写INSERT语句的更安全（不过更烦琐）的方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers(cust_name,cust_address,cust_city)</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;...&#x27;</span>,<span class="string">&#x27;...&#x27;</span>...);</span><br></pre></td></tr></table></figure>

<p>即使表的结构改变， 此INSERT语句仍然能正确工作</p>
<p>如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示： 这也适用于UPDATE和DELETE语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> low priority <span class="keyword">into</span> </span><br></pre></td></tr></table></figure>

<h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers(cust_name,cust_address,cust_city)</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;...&#x27;</span>,<span class="string">&#x27;...&#x27;</span>...),</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;...&#x27;</span>,<span class="string">&#x27;...&#x27;</span>...);</span><br></pre></td></tr></table></figure>

<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p>可以利用它将一条SELECT语句的结果插入表中。这就是所 谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT 语句组成的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers(cust_name,cust_address,cust_city)</span><br><span class="line"><span class="keyword">select</span> cust_name,cust_address,cust_city </span><br><span class="line"><span class="keyword">from</span> custenw;</span><br></pre></td></tr></table></figure>

<p>为简单起见，这个例子在INSERT和 SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置。</p>
<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><p>不要省略WHERE子句</p>
<p>客户10005现在有了电子邮件地址，因此他的记录 需要更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers</span><br><span class="line"><span class="keyword">set</span> cust_name <span class="operator">=</span> <span class="string">&#x27;The Fudds&#x27;</span>,</span><br><span class="line"><span class="keyword">set</span> cust_mail <span class="operator">=</span> <span class="string">&#x27;q@q.com&#x27;</span></span><br><span class="line"><span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><p>如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）为即使是发 生错误，也继续进行更新，可使用IGNORE关键字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> ignore custoemrs...</span><br></pre></td></tr></table></figure>

<p>为了删除某个列的值，可设置它为NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers</span><br><span class="line"><span class="keyword">set</span> cust_mail <span class="operator">=</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers</span><br><span class="line"><span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="number">10006</span>;</span><br></pre></td></tr></table></figure>

<p>DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了 删除指定的列，请使用UPDATE语句。</p>
<h4 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h4><p>更快的删除 如果想从表中删除所有行，不要使用DELETE。 可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更 快（TRUNCATE实际是删除原来的表并重新创建一个表，而不 是逐行删除表中的数据）</p>
<h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="CREATE-TABLE语句"><a href="#CREATE-TABLE语句" class="headerlink" title="CREATE TABLE语句"></a>CREATE TABLE语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">  cust_id      <span class="type">int</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  cust_name    <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_address <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_city    <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_state   <span class="type">char</span>(<span class="number">5</span>)   <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_zip     <span class="type">char</span>(<span class="number">10</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_country <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_contact <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_email   <span class="type">char</span>(<span class="number">255</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (cust_id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<h3 id="if-not-exists"><a href="#if-not-exists" class="headerlink" title="if not exists"></a>if not exists</h3><h3 id="理解NULL"><a href="#理解NULL" class="headerlink" title="理解NULL"></a>理解NULL</h3><p>不要把NULL值与空串相混淆。<strong>NULL值是没有值</strong>， <strong>它不是空串</strong>。如果指定’’（两个单引号，其间没有字符），这 在NOT NULL列中是允许的。空串是一个有效的值，它不是无 值。NULL值用关键字NULL而不是空串指定。</p>
<h3 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h3><p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。</p>
<p>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通 过使它成为主键）。</p>
<h4 id="last-insert-id-函数"><a href="#last-insert-id-函数" class="headerlink" title="last_insert_id()函数"></a>last_insert_id()函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_insert_id();</span><br></pre></td></tr></table></figure>

<p>此语句返回最后一个AUTO_INCREMENT值</p>
<h3 id="指定默认值DEFAULT"><a href="#指定默认值DEFAULT" class="headerlink" title="指定默认值DEFAULT"></a>指定默认值DEFAULT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">  order_num  <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  order_item <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_id    <span class="type">char</span>(<span class="number">10</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  quantity   <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  item_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (order_num, order_item)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>不允许函数 MySQL不允许使用函 数作为默认值，它只支持常量</p>
<p>使用<strong>默认值</strong>而不是<strong>NULL值</strong> 许多数据库开发人员使用默认 值而不是NULL列，特别是对用于<strong>计算或数据分组的列</strong>更是如 此</p>
<h3 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h3><p>以下是几个需要知道的引擎：</p>
<ul>
<li><p>InnoDB是一个可靠的事务处理引擎，它不支持全文 本搜索；</p>
</li>
<li><p>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）； </p>
</li>
<li><p>MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章）， 但不支持事务处理。</p>
</li>
</ul>
<h4 id="引擎类型可以混用。"><a href="#引擎类型可以混用。" class="headerlink" title="引擎类型可以混用。"></a>引擎类型可以混用。</h4><h4 id="外键不能跨引擎"><a href="#外键不能跨引擎" class="headerlink" title="外键不能跨引擎"></a>外键不能跨引擎</h4><p>混用引擎类型有一个大缺陷。外键（用于 强制实施引用完整性）不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。</p>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>ALTER TABLE语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> vendors</span><br><span class="line"><span class="keyword">add</span> vend_phone <span class="type">char</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">删除刚刚添加的列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> vendors</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> vend_phone;</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE的一种常见用途是定义外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orderitems</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">foreign</span> key(order_num) <span class="keyword">references</span> orders(order_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orderitems</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_orderitems_products</span><br><span class="line"><span class="keyword">foreign</span> key(prod_id) <span class="keyword">references</span> products(prod_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orders</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_orders_customers</span><br><span class="line"><span class="keyword">foreign</span> key(cust_id) <span class="keyword">references</span> customers(cust_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> products</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_products_vendors</span><br><span class="line"><span class="keyword">foreign</span> key(vend_id) <span class="keyword">references</span> vendors(vend_id);</span><br></pre></td></tr></table></figure>

<h4 id="小心使用ALTER-TABLE"><a href="#小心使用ALTER-TABLE" class="headerlink" title="小心使用ALTER TABLE"></a>小心使用ALTER TABLE</h4><p>使用ALTER TABLE要极为小心，应该 在进行改动前做一个<strong>完整的备份</strong>（模式和数据的备份）。数据 库表的更改不能撤销，如果增加了不需要的列，可能不能删 除它们。类似地，如果删除了不应该删除的列，可能会丢失 该列中的所有数据。</p>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>DROP TABLE语 句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> customers2;</span><br></pre></td></tr></table></figure>

<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>RENAME TABLE语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> customers2 <span class="keyword">to</span> customers;</span><br><span class="line"></span><br><span class="line">多个表重命名</span><br><span class="line">rename <span class="keyword">table</span> backup_customers <span class="keyword">to</span> customers,</span><br><span class="line">			backup_vendors <span class="keyword">to</span> vendors,</span><br><span class="line">			backup_products <span class="keyword">to</span> products,</span><br></pre></td></tr></table></figure>

<h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p>我们可以使用下边两种语句之一来开启一个事务： </p>
<ul>
<li>BEGIN [WORK];</li>
</ul>
<p>BEGIN 语句代表开启一个事务，后边的单词 WORK 可有可无。开启事务后，就可以继续写若干条语句，这些 语句都属于刚刚开启的这个事务。</p>
<ul>
<li>START TRANSACTION;</li>
</ul>
<p>START TRANSACTION 语句和 BEGIN 语句有着相同的功效，都标志着开启一个事务</p>
<p>不过比 BEGIN 语句牛逼一点儿的是，可以在 START TRANSACTION 语句后边跟随几个 修饰符 ，就是它们几 个：</p>
<pre><code>    READ ONLY ：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修 改数据。

    READ WRITE ：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可 以修改数据。 

    WITH CONSISTENT SNAPSHOT ：启动一致性读
</code></pre>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p>COMMIT [WORK]</p>
<h3 id="手动中止事务"><a href="#手动中止事务" class="headerlink" title="手动中止事务"></a>手动中止事务</h3><p>如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事 务执行之前的样子： </p>
<p>ROLLBACK [WORK]</p>
<p>这里需要强调一下， ROLLBACK 语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到 了某些错误而无法继续执行的话，事务自身会自动的回滚。</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>MySQL 中有一个系统变量 autocommit ：</p>
<p>可以看到它的默认值为 ON ，也就是说默认情况下，如果我们不显式的使用 START TRANSACTION 或者 BEGIN 语句 开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的 自动提交 </p>
<h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>如果我们输入了某些语句之后就会 悄悄的 提交掉，就像我们输入了 COMMIT 语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为 隐式提交 ，这些会导致事务隐式提交 的语句包括：</p>
<ul>
<li>定义或修改数据库对象的数据定义语言（Data definition language，缩写为： DDL ）。</li>
</ul>
<p>所谓的数据库对象，指的就是 数据库 、 表 、 视图 、 存储过程 等等这些东西。当我们使用 CREATE 、 ALTER 、 DROP 等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务</p>
<ul>
<li>隐式使用或修改 mysql 数据库中的表</li>
</ul>
<p>当我们使用 ALTER USER 、 CREATE USER 、 DROP USER 、 GRANT 、 RENAME USER 、 REVOKE 、 SET PASSWORD 等语句时也会隐式的提交前边语句所属于的事务。</p>
<ul>
<li>事务控制或关于锁定的语句</li>
</ul>
<p>当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时， 会隐式的提交上一个事务。或者使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
<ul>
<li>加载数据的语句</li>
</ul>
<p>比如我们使用 LOAD DATA 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
<ul>
<li>关于 MySQL 复制的一些语句</li>
</ul>
<p>使用 START SLAVE 、 STOP SLAVE 、 RESET SLAVE 、 CHANGE MASTER TO 等语句时也会隐式的提交前边语句 所属的事务。 </p>
<ul>
<li>其它的一些语句</li>
</ul>
<p>使用 ANALYZE TABLE 、 CACHE INDEX 、 CHECK TABLE 、 FLUSH 、 LOAD INDEX INTO CACHE 、 OPTIMIZE TABLE 、 REPAIR TABLE 、 RESET 等语句也会隐式的提交前边语句所属的事务。</p>
<h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>SAVEPOINT 保存点名称;</p>
<p>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</p>
<p>如果我们想删除某个保存点，可以使用这个语句：</p>
<p>RELEASE SAVEPOINT 保存点名称;</p>
<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
<p>在使用事务和事务处理时，有几个关键词汇反复出现。下面是关于 事务处理需要知道的几个术语：</p>
<ul>
<li>事务（transaction）指一组SQL语句； </li>
<li>回退（rollback）指撤销指定SQL语句的过程； </li>
<li>提交（commit）指将未存储的SQL语句结果写入数据库表； </li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<h3 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h3><p>MySQL使用下面的语句来标识事务的开始：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br></pre></td></tr></table></figure>

<h4 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h4><p>MySQL的ROLLBACK命令用来回退（撤销）MySQL语句，请看下面的 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ordertotals;</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> ordertotals;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ordertotals;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ordertotals;</span><br></pre></td></tr></table></figure>

<p>ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）</p>
<h3 id="哪些语句可以回退？"><a href="#哪些语句可以回退？" class="headerlink" title="哪些语句可以回退？"></a>哪些语句可以回退？</h3><p>事务处理用来管理<strong>INSERT、UPDATE和 DELETE</strong>语句。你不能回退SELECT语句。（这样做也没有什么意 义。）你**&#x3D;&#x3D;不能回退CREATE或DROP操作&#x3D;&#x3D;**。事务处理块中可以使用 这两条语句，但如果你执行回退，它们不会被撤销。</p>
<h3 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a>使用COMMIT</h3><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是 所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动 进行的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h3><p>更复杂的事务处理可能需要部 分提交或回退。</p>
<p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置占位符。这样，如果需要回退，可以回退到某个占位符。</p>
<p>这些占位符称为保留点，为了创建占位符，可如下使用SAVEPOINT。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">savepoint</span> delete1;</span><br></pre></td></tr></table></figure>

<p>每个保留点都取标识它的唯一名字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> delete1;</span><br></pre></td></tr></table></figure>

<p><strong>保留点越多越好</strong>  可以在MySQL代码中设置任意多的保留 点，越多越好。为什么呢？因为保留点越多，你就越能按自己 的意愿灵活地进行回退。</p>
<p><strong>释放保留点</strong>  保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。自MySQL 5以来，也可以用**&#x3D;&#x3D;RELEASE SAVEPOINT&#x3D;&#x3D;**明确地释放保留点。</p>
<h3 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h3><p>默认的MySQL行为是自动提交所有更改。为指示MySQL不自动提交更改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="标志为连接专用"><a href="#标志为连接专用" class="headerlink" title="标志为连接专用"></a>标志为连接专用</h4><p>autocommit标志是针对<strong>每个连接</strong>而不是<strong>服务器</strong>的。</p>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当 的访问权，既不能多也不能少。</p>
<h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中。</p>
<p>需要直接访问它的时机之一是在需要获得所有用户账号列表 时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h4><p>CREATE USER语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> ben identified <span class="keyword">by</span> <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>指定散列口令</strong>: IDENTIFIED BY指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密。为了作为散列值指定口 令，使用IDENTIFIED BY PASSWORD。</p>
<p><strong>使用GRANT或INSERT</strong> : GRANT语句（稍后介绍）也可以创建用 户账号。也可以通过直接插入行到user表来增加用户。</p>
<h4 id="重新命名"><a href="#重新命名" class="headerlink" title="重新命名"></a>重新命名</h4><p>RENAME USER语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">user</span> ben <span class="keyword">to</span> bforta;</span><br></pre></td></tr></table></figure>

<h4 id="删除用户账号"><a href="#删除用户账号" class="headerlink" title="删除用户账号"></a>删除用户账号</h4><p>DROP USER语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> bforta;</span><br></pre></td></tr></table></figure>

<p>自MySQL 5以来，DROP USER删除用户账号和 所有相关的账号权限。</p>
<p>在MySQL 5以前，先用**&#x3D;&#x3D;REVOKE&#x3D;&#x3D;**删除与账号相关的权限，然后 再用DROP USER删除账号</p>
<h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><p>分配访问权限，新创建的用户账号没有访 问权限。</p>
<p>为看到赋予用户账号的权限，使用SHOW GRANTS FOR</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> bforta;</span><br></pre></td></tr></table></figure>

<p>用户bforta有一个权限USAGE ON <em>.</em></p>
<p>**&#x3D;&#x3D;USAGE&#x3D;&#x3D;**表示根本没有权限usage</p>
<h4 id="GRANT语句"><a href="#GRANT语句" class="headerlink" title="GRANT语句"></a>GRANT语句</h4><p>为设置权限，使用GRANT语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> crashcourse.<span class="operator">*</span> <span class="keyword">to</span> bforta;</span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> bforta;</span><br></pre></td></tr></table></figure>

<p>每个GRANT添加（或更新）用户的一个权限。<strong>MySQL读取所有 授权</strong>，并根据它们确定权限。</p>
<h4 id="REVOKE语句"><a href="#REVOKE语句" class="headerlink" title="REVOKE语句"></a>REVOKE语句</h4><p><strong>GRANT的反操作为REVOKE</strong>。用它来撤销特定的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> crashcourse.<span class="operator">*</span> <span class="keyword">from</span> bforta;</span><br></pre></td></tr></table></figure>

<p>GRANT和REVOKE可在几个层次上控制访问权限：</p>
<ul>
<li><p>整个服务器，使用GRANT ALL和REVOKE ALL； </p>
</li>
<li><p>整个数据库，使用ON database.*； </p>
</li>
<li><p>特定的表，使用ON database.table；</p>
</li>
<li><p>特定的列； </p>
</li>
<li><p>特定的存储过程。</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072312931.png" alt="quan_2021-12-27_15-36-47"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072312937.png" alt="quan_2021-12-27_15-37-41"></p>
<h4 id="简化多次授权"><a href="#简化多次授权" class="headerlink" title="简化多次授权"></a>简化多次授权</h4><p>可通过列出各权限并用逗号分隔，将多条 GRANT语句串在一起</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">insert</span>, <span class="keyword">on</span> crashcourse.<span class="operator">*</span> <span class="keyword">to</span> bforta;</span><br></pre></td></tr></table></figure>

<h4 id="更改口令"><a href="#更改口令" class="headerlink" title="更改口令"></a>更改口令</h4><p>SET PASSWORD语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> bforta <span class="operator">=</span> Password(<span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Password()函 数进行加密</strong></p>
<p>SET PASSWORD还可以用来设置你自己的口令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="operator">=</span> Password(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h2><ol>
<li>首先，MySQL（与所有DBMS一样）具有特定的<strong>硬件建议</strong>。在学 习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但 对用于生产的服务器来说，应该坚持遵循这些硬件建议。 </li>
<li>一般来说，关键的生产DBMS应该运行在自己的<strong>专用服务器</strong>上。</li>
<li>MySQL是用一系列的<strong>默认设置预先配置</strong>的，从这些设置开始通常 是很好的。但过一段时间后你可能需要<strong>调整内存分配、缓冲区大 小</strong>等。（为查看当前设置，可使用**SHOW VARIABLES;和SHOW STATUS;**。） </li>
<li><strong>MySQL一个多用户多线程的DBMS</strong>，换言之，它经常<strong>同时执行多 个任务</strong>。如果这些任务中的某一个执行缓慢，则所有请求都会执 行缓慢。如果你遇到显著的性能不良，可使用<strong>SHOW PROCESSLIST</strong> 显示所有活动进程（<strong>以及它们的线程ID和执行时间</strong>）。你还可以用<strong>KILL命令</strong>终结某个特定的进程（使用这个命令需要作为管理员登 录）</li>
<li>总是有<strong>不止一种方法编写同一条SELECT语句</strong>。应该试验联结、并、 子查询等，找出最佳的方法。</li>
<li>使用<strong>EXPLAIN</strong>语句让MySQL解释它将如何执行一条SELECT语句。</li>
<li>一般来说，<strong>存储过程</strong>执行得比一条一条地执行其中的各条MySQL 语句快。</li>
<li>应该总是使用<strong>正确的数据类型</strong>。 </li>
<li><strong>决不要检索比需求还要多的数据</strong>。换言之，不要用SELECT *（除 非你真正需要每个列）。</li>
<li>有的操作（包括INSERT）支持一个可选的<strong>DELAYED</strong>关键字，如果 使用它，<strong>将把控制立即返回给调用程序</strong>，并且一旦有可能就实际 执行该操作。</li>
<li>在导入数据时，应该<strong>关闭自动提交</strong>。你可能还想删除索引（包括 <strong>FULLTEXT</strong>索引），然后在导入完成后再重建它们。 </li>
<li><strong>必须索引数据库表以改善数据检索的性能</strong>。确定索引什么不是一 件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。<strong>如果一个简单的WHERE子句返回结果所花 的时间太长，则可以断定其中使用的列（或几个列）就是需要索 引的对象。</strong> </li>
<li>你的SELECT语句中<strong>有一系列复杂的OR条件吗</strong>？通过使用多条 SELECT语句和连接它们的UNION语句，你能看到极大的性能改 进。</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。 如果你有一些表，它们收集数据且不经常被搜索，则在有必要之 前不要索引它们。（索引可根据需要添加和删除。）</li>
<li><strong>LIKE</strong>很慢。一般来说，<strong>最好是使用FULLTEXT而不是LIKE。</strong> </li>
<li>数据库是<strong>不断变化的实体</strong>。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会 改变。 </li>
<li>最重要的规则就是，<strong>每条规则在某些条件下都会被打破。</strong></li>
</ol>
<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="串数据类型"><a href="#串数据类型" class="headerlink" title="串数据类型"></a>串数据类型</h3><p>有两种基本的串类型，分别为定长串和变长串</p>
<p>MySQL不 允许对变长列（或一个列的可变部分）进行索引。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072312275.png" alt="quan_2021-12-27_15-51-35"></p>
<p><strong>使用引号</strong> 不管使用何种形式的串数据类型，串值都必须括在 引号内（通常单引号更好）</p>
<h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h3><p>数值数据类型存储数值。</p>
<h4 id="UNSIGNED关键字"><a href="#UNSIGNED关键字" class="headerlink" title="UNSIGNED关键字"></a>UNSIGNED关键字</h4><p><strong>有符号或无符号</strong>： 所有数值数据类型（除BIT和BOOLEAN外） 都可以有符号或无符号。有符号数值列可以存储正或负的数 值，无符号数值列只能存储正数。默认情况为有符号，但如 果你知道自己不需要存储负值，可以使用**&#x3D;&#x3D;UNSIGNED关键字&#x3D;&#x3D;**， 这样做将允许你存储两倍大小的值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313076.png" alt="quan_2021-12-27_15-58-12"></p>
<h3 id="存储货币数据类型"><a href="#存储货币数据类型" class="headerlink" title="存储货币数据类型"></a>存储货币数据类型</h3><p>MySQL中没有专门存储货币的数据类 型，一般情况下使用**&#x3D;&#x3D;DECIMAL(8, 2)&#x3D;&#x3D;**</p>
<h3 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313080.png" alt="quan_2021-12-27_16-02-34"></p>
<h3 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h3><p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、 多媒体、字处理文档等</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313387.png" alt="quan_2021-12-27_16-03-41"></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="InnoDB页简介"><a href="#InnoDB页简介" class="headerlink" title="InnoDB页简介"></a>InnoDB页简介</h3><p> InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？</p>
<p>不，那样会慢死，InnoDB 采取的方式是：**&#x3D;&#x3D;将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 16 KB。&#x3D;&#x3D;**</p>
<h3 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h3><p>我们平时是以<strong>记录</strong>为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 <strong>行格式</strong> 或者 <strong>记录格式</strong> 。 设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 <strong>Compact</strong> 、 <strong>Redundant</strong> 、 <strong>Dynamic</strong> 和 <strong>Compressed</strong> 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理 上大体都是相同的。</p>
<h4 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line"></span><br><span class="line">指定了这个表的字符集为 ascii</span><br><span class="line">CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure>

<p>因为 ascii 字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这 个表里的</p>
<h4 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313940.png" alt="quan_2021-12-28_08-48-14"></p>
<p>一条完整的记录其实可以被分为 <strong>&#x3D;&#x3D;记录的额外信息&#x3D;&#x3D;</strong> 和 &#x3D;&#x3D;<strong>记录的真实数据</strong>&#x3D;&#x3D; 两大部分</p>
<p>记录的额外信息：服务器为了描述这条记录而不得不额外添加的一些信息。分别是 <strong>变长字段</strong> <strong>长度列表</strong> 、 <strong>NULL值列表</strong> 和 <strong>记录头信息</strong></p>
<h5 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h5><p>变长字段占用的存储空间分为两部分：1. 真正的数据内容 2. 占用的字节数。</p>
<p>在 Compact 行格式中，**&#x3D;&#x3D;把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，&#x3D;&#x3D;<strong>我们再次强调一遍，是</strong>&#x3D;&#x3D;逆序&#x3D;&#x3D;**存放！</p>
<h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><ol>
<li><p>首先统计表中允许存储 NULL 的列有哪些</p>
</li>
<li><p>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个 二进制位，二进制位按照列的顺序**&#x3D;&#x3D;逆序&#x3D;&#x3D;**排列，二进制位表示的意义如下：</p>
</li>
</ol>
<ul>
<li>二进制位的值为 1 时，代表该列的值为 NULL 。 </li>
<li>二进制位的值为 0 时，代表该列的值不为 NULL 。</li>
</ul>
<h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组 成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072313954.png" alt="quan_2021-12-28_09-35-14"></p>
<h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p> MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ）</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>这里需要提一下 InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则 选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。</p>
<p><strong>&#x3D;&#x3D;InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。&#x3D;&#x3D;</strong></p>
<h4 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h4><p>我们说在 Compact 行格式下只会把变长类型的列的长度**&#x3D;&#x3D;逆序&#x3D;&#x3D;**存到 变长字段长度列表 中</p>
<p>对于 CHAR(M) 类型的列来说，当列采用的是<strong>定长字符集</strong>时，该列占用的字节数<strong>不会</strong>被加到<strong>变长字 段长度列表</strong>，而如果采用<strong>变长字符集</strong>时，该列占用的字节数也<strong>会被</strong>加到<strong>变长字段长度列表</strong>。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><h4 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h4><p>对于 VARCHAR(M) 类型的列最多可以占用 65535 个字节。比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间：</p>
<ul>
<li>真实数据 </li>
<li>真实数据占用字节的长度 </li>
<li>NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间</li>
</ul>
<p>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能 占用2个字节， NULL 值标识需要占用1个字节</p>
<p>如果 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2个字节，不需要 NULL 值标识</p>
<h4 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h4><p>MySQL 中规定一个页中至少存放两行记录</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314606.png" alt="quan_2021-12-28_09-50-03"></p>
<h4 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h4><p>这两种行格式类似于 COMPACT行格式 ，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实 数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存 储其他页面的地址。 </p>
<p>另外， Compressed 行格式会采用压缩算法对页面进行压缩。</p>
<p> 一个页一般是 16KB ，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种 现象称为 行溢出 。</p>
<h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314327.png" alt="quan_2021-12-28_09-52-28"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314460.png" alt="quan_2021-12-28_09-53-01"></p>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>InnoDB 数据页的7个组成部分，知道了各个数据页可以组成一个 双向链表，而每个数据页 中的记录会按照主键值从小到大的顺序组成一个 单向链表，每个数据页都会为存储在它里边儿的记录生成一个 页目录 ，在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对 应分组中的记录即可快速找到指定的记录，页和记录的关系示意图如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072314932.png" alt="quan_2021-12-28_09-56-31"></p>
<p>其中页a、页b、页c … 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。</p>
<h2 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line"> id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line"> name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line"> KEY idx_name_birthday_phone_number (name, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>先按照 name 列的值进行排序。 </li>
<li>如果 name 列的值相同，则按照 birthday 列的值进行排序。 </li>
<li>如果 birthday 列的值也相同，则按照 phone_number 的值进行排序。</li>
</ul>
<p>这个排序方式**&#x3D;&#x3D;十分、特别、非常、巨、very very very重要&#x3D;&#x3D;**，因为只要页面和记录是排好序的，我们就可以通过二 分法来快速定位查找。</p>
<h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">=</span> <span class="string">&#x27;15123983239&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h3><p>其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者包含多个左边的列也行： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那为什么搜索条件中必须出现左边的列才可以使用到这个 B+ 树索引呢？比如下边的语句就用不到这个 B+ 树索引 么？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列。</strong></p>
<h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>对于字符串类型的索引列来说，我们只匹配 它的前缀也是可以快速定位记录的，比方说我们想查询名字以 ‘As’ 开头的记录，那就可以这么写查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;As%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%As%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 就无法快速定位记录位置了，因为字符串中间有 ‘As’ 的字符串并没有排好序，所以只能全表扫描了。</p>
<p>有 时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个 url 列，该列中存储了许多url：</p>
<table>
<thead>
<tr>
<th>url</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a></td>
</tr>
</tbody></table>
<p>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件： <strong>WHERE url LIKE ‘%com’</strong> ，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可 以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：</p>
<table>
<thead>
<tr>
<th>url</th>
</tr>
</thead>
<tbody><tr>
<td>moc.udiab.www</td>
</tr>
<tr>
<td>moc.elgoog.www</td>
</tr>
</tbody></table>
<p>这样再查找以 com 为后缀的网址时搜索条件便可以这么写： <strong>WHERE url LIKE ‘moc%’</strong> ，这样就可以用到索引了。</p>
<h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p><strong>所有记录都是按照索引列的值从小到大的顺 序排好序的</strong>，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>找到 name 值为 Asa 的记录。</li>
<li>找到 name 值为 Barlow 的记录。</li>
<li><strong>&#x3D;&#x3D;记录之间用单链表，数据页之间用双链表&#x3D;&#x3D;</strong></li>
<li>找到这些记录的主键值，再到 聚簇索引 中 回表 查找完整的记录。</li>
</ul>
<p>如果对多个列同时进行范围查找的话，只有对索引<strong>最左边</strong>的那个 列进行范围查找的时候才能用到 B+ 树索引，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;1980-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过 name 进行范围查 找的记录中可能并不是按照 birthday 列进行排序的</p>
<h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>如果左边的列是精 确查找，则右边的列可以进行范围查找</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;1980-01-01&#x27;</span> <span class="keyword">AND</span> birthday<span class="operator">&lt;</span> <span class="string">&#x27;2000-12-31&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">&gt;</span> <span class="string">&#x27;15100000000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询的条件可以分为3个部分：</p>
<ul>
<li>name &#x3D; ‘Ashburn’ ，对 name 列进行精确查找，当然可以使用 B+ 树索引了</li>
<li>birthday &gt; ‘1980-01-01’ AND birthday &lt; ‘2000-12-31’ ，由于 name 列是精确查找，所以通过 name &#x3D; ‘Ashburn’ 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序。所以此时 对 birthday 列进行范围查找是可以用到 B+ 树索引的。</li>
<li>phone_number &gt; ‘15100000000’ ，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个 条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。</li>
</ul>
<h3 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h3><p>在 MySQL 中，把这种在内存中或者磁 盘上进行排序的方式统称为文件排序（英文名： filesort ），跟 文件 这个词儿一沾边儿，就显得这些排序操作 非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果 ORDER BY 子句里使用到了我们的 索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="使用联合索引进行排序注意事项"><a href="#使用联合索引进行排序注意事项" class="headerlink" title="使用联合索引进行排序注意事项"></a>使用联合索引进行排序注意事项</h4><p>ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 ORDER BY phone_number, birthday, name 的顺序，那也是用不了 B+ 树索引</p>
<p> ORDER BY name 、 ORDER BY name, birthday 这种匹配索引左边的列的形式可以使用部分的 B+ 树索引。</p>
<p>当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="不可以使用索引进行排序的几种情况"><a href="#不可以使用索引进行排序的几种情况" class="headerlink" title="不可以使用索引进行排序的几种情况"></a>不可以使用索引进行排序的几种情况</h4><p><strong>ASC、DESC混用</strong></p>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 ASC 规则 排序，要么都是 DESC 规则排序。</p>
<p>但是如果我们查询的需求是先按照 name 列进行升序排列，再按照 birthday 列进行降序排列的话，比如说这样的 查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="WHERE子句中出现非排序使用到的索引列"><a href="#WHERE子句中出现非排序使用到的索引列" class="headerlink" title="WHERE子句中出现非排序使用到的索引列"></a>WHERE子句中出现非排序使用到的索引列</h4><p>如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> country <span class="operator">=</span> <span class="string">&#x27;China&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> name LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询只能先把符合搜索条件 country &#x3D; ‘China’ 的记录提取出来后再进行排序，是<strong>使用不到索引</strong>。注意和下 边这个查询作区别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>虽然这个查询也有搜索条件，但是 name &#x3D; ‘A’ 可以使用到索引 idx_name_birthday_phone_number ，而且过滤剩 下的记录还是按照 birthday 、 phone_number 列排序的，所以还是<strong>可以使用索引</strong>进行排序的。</p>
<h4 id="排序列包含非同一个索引的列"><a href="#排序列包含非同一个索引的列" class="headerlink" title="排序列包含非同一个索引的列"></a>排序列包含非同一个索引的列</h4><p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, country LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>name 和 country 并不属于一个联合索引中的列，所以无法使用索引进行排序</p>
<h4 id="排序列使用了复杂的表达式"><a href="#排序列使用了复杂的表达式" class="headerlink" title="排序列使用了复杂的表达式"></a>排序列使用了复杂的表达式</h4><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">UPPER</span>(name) LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>使用了 UPPER 函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。</p>
<h3 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h3><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, birthday, phone_number, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> person_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> name, birthday, phone_number</span><br></pre></td></tr></table></figure>

<h2 id="索引什么时候没用"><a href="#索引什么时候没用" class="headerlink" title="索引什么时候没用"></a>索引什么时候没用</h2><p>1.有or必全有索引;<br>2.复合索引未用左列字段;<br>3.like以%开头;<br>4.需要类型转换;<br>5.where中索引列有运算;<br>6.where中索引列使用了函数;<br>7.如果mysql觉得全表扫描更快时（数据少）（区间太大）;</p>
<h2 id="索引什么时没必要用"><a href="#索引什么时没必要用" class="headerlink" title="索引什么时没必要用"></a>索引什么时没必要用</h2><p>1.唯一性差;<br>2.频繁更新的字段不用（更新索引消耗）;<br>3.where中不用的字段;<br>4.索引使用&lt;&gt;时，效果一般;</p>
<h2 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>而查询列表是 * ，意味着要查询表中所有字段，也就是还要包括 country 字段。这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的 B+ 树中找到完整的用户记 录，也就是我们通常所说的 回表 ，然后把完整的用户记录返回给查询用户。</p>
<p>一般情况下，顺序I&#x2F;O比随机I&#x2F;O的性能高很多</p>
<ul>
<li>会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。</li>
<li>访问二级索引使用 顺序I&#x2F;O ，访问聚簇索引使用 随机I&#x2F;O 。</li>
</ul>
<p><strong>&#x3D;&#x3D;需要回表的记录越多，使用二级索引的性能就越低&#x3D;&#x3D;</strong></p>
<p>查询优化器：查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的 条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索 引 + 回表 的方式。</p>
<p>因为回表的记录越少， 性能提升就越高，比方说上边的查询可以改写成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span> LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>添加了 LIMIT 10 的查询更容易让优化器采用 二级索引 + 回表 的方式进行查询。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>为了彻底告别 回表 操作带来的性能损耗，我们建议：**&#x3D;&#x3D;最好在查询列表里只包含索引列&#x3D;&#x3D;**，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, birthday, phone_number <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不必到 聚簇索引 中再查找记录的剩余列，也就是 country 列的值了，这样就省去了 回表 操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为 索引 覆盖 。排序操作也优先使用 覆盖索引 的方式进行查询，比方说这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, birthday, phone_number <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday, phone_number;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在使用索引时需要注意下边这些事项：</p>
<ul>
<li>只为用于搜索、排序或分组的列创建索引 </li>
<li>为列的基数大的列创建索引 </li>
<li>索引列的类型尽量小 </li>
<li>可以只对字符串值的前缀建立索引 </li>
<li>只有索引列在比较表达式中单独出现才可以适用索引 </li>
<li>为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。 </li>
<li>定位并删除表中的重复和冗余索引 尽量使用 </li>
<li>覆盖索引 进行查询，避免 回表 带来的性能损耗。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>目录项 其实长得跟我们的用户记录差不多，只不过 <strong>目录项</strong> 中的两个列是 <strong>主键</strong> 和 <strong>页号</strong> 而已，所以他们复用了之前存储 用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为 <strong>目录项记录</strong></p>
<h3 id="一个简单的索引方案"><a href="#一个简单的索引方案" class="headerlink" title="一个简单的索引方案"></a>一个简单的索引方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？</p>
<p>因为各个页中的记录并没有 规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 不得不 依次遍历所有的数据页。</p>
<p>**&#x3D;&#x3D;实际用户记录其实都存放在B+树的最底层的节点 上&#x3D;&#x3D;**，这些节点也被称为 叶子节点 或 叶节点 ，其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点 ，其 中 B+ 树最上边的那个节点也称为 根节点 。</p>
<p>那 InnoDB 怎么区分一条记录是普通的 用户记录 还是 目录项记录 呢？别忘了记录头信息里的 record_type 属性，它的各个取值代表的意思如下：</p>
<ul>
<li>0 ：普通的用户记录 </li>
<li>1 ：目录项记录 </li>
<li>2 ：最小记录 </li>
<li>3 ：最大记录</li>
</ul>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<ol>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</li>
</ol>
<ul>
<li><strong>页内</strong>的记录是按照主键的大小顺序排成一个<strong>单向链表</strong>。 </li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个<strong>双向链表</strong>。</li>
<li>存放<strong>目录项记录</strong>的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成 一个<strong>双向链表</strong>。</li>
</ul>
<ol start="2">
<li>B+ 树的叶子节点存储的是完整的用户记录。</li>
</ol>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p>我们把具有这<strong>两种特性</strong>的 <strong>B+ 树</strong>称为 <strong>&#x3D;&#x3D;聚簇索引&#x3D;&#x3D;<strong>，所有完整的用户记录都存放在这个 聚簇索引 的</strong>叶子节点</strong>处。这 种 聚簇索引 并不需要我们在 MySQL 语句中<strong>显式的</strong>使用 <strong>INDEX 语句</strong>去创建（后边会介绍索引相关的语句）， InnoDB 存储引擎会&#x3D;&#x3D;<strong>自动的</strong>为我们<strong>创建</strong>聚簇索引&#x3D;&#x3D;。另外有趣的一点是，在 InnoDB 存储引擎中， 聚簇索引 就是数 据的存储方式（所有的用户记录都存储在了 叶子节点 ），也就是所谓的**&#x3D;&#x3D;索引即数据，数据即索引&#x3D;&#x3D;**。</p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072315195.png" alt="quan_2021-12-28_10-20-28"></p>
<p>这个 B+ 树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li><p>使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><p>页内的记录是按照 c2 列的大小顺序排成一个单向链表。</p>
</li>
<li><p>各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。 </p>
</li>
<li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排 成一个双向链表。</p>
</li>
</ul>
</li>
<li><p>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值。 </p>
</li>
<li><p>目录项记录中不再是 主键+页号 的搭配，而变成了 c2列+页号 的搭配。</p>
</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照 c2 列进行排序。 </li>
<li>在记录的 c2 列相同的情况下，采用 c3 列进行排序</li>
</ul>
<p>为 c2 和 c3 列建立的索引的示意图如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072315088.png" alt="quan_2021-12-28_10-26-21"></p>
<p>如图所示，我们需要注意一下几点：</p>
<ul>
<li>每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录 的 c2 列相同，则按照 c3 列的值进行排序。 </li>
<li>B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。</li>
</ul>
<p>千万要注意一点，**&#x3D;&#x3D;以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思 与分别为c2和c3列分别建立索引的表述是不同的&#x3D;&#x3D;**，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵 B+ 树。 </li>
<li>为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。</li>
</ul>
<h2 id="索引（csdn）"><a href="#索引（csdn）" class="headerlink" title="索引（csdn）"></a>索引（csdn）</h2><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>索引可以帮助服务器避免排序和创建临时表</li>
<li>索引可以将随机IO变成顺序IO<br>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性</li>
<li>关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大</li>
<li>对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度</li>
<li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效；</li>
</ul>
<h3 id="创建索引准则"><a href="#创建索引准则" class="headerlink" title="创建索引准则"></a>创建索引准则</h3><h4 id="应该创建索引的列"><a href="#应该创建索引的列" class="headerlink" title="应该创建索引的列"></a>应该创建索引的列</h4><ul>
<li>在经常需要搜索的列上，可以加快搜索的速度</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
<li>在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度</li>
<li>在经常需要根据范围（&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
<li>在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ul>
<h4 id="不该创建索引的列"><a href="#不该创建索引的列" class="headerlink" title="不该创建索引的列"></a>不该创建索引的列</h4><ul>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。<br>若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有很少数据值或者重复值多的列也不应该增加索引。<br>这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。<br>这些列的数据量要么相当大，要么取值很少。</li>
<li>当该列修改性能要求远远高于检索性能时，不应该创建索引。（修改性能和检索性能是互相矛盾的）</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。</p>
<h4 id="逻辑分类"><a href="#逻辑分类" class="headerlink" title="逻辑分类"></a>逻辑分类</h4><h5 id="按功能划分"><a href="#按功能划分" class="headerlink" title="按功能划分"></a>按功能划分</h5><ul>
<li>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(column_list); </span><br></pre></td></tr></table></figure>

<ul>
<li>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX IndexName <span class="keyword">ON</span> `TableName`(`字段名`(length));</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list); </span><br></pre></td></tr></table></figure>

<ul>
<li>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IndexName <span class="keyword">ON</span> `TableName`(`字段名`(length));</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> INDEX IndexName(`字段名`(length));</span><br></pre></td></tr></table></figure>

<p>全文索引：它查找的是文本中的关键词，主要用于全文检索。</p>
<h5 id="按列数划分"><a href="#按列数划分" class="headerlink" title="按列数划分"></a>按列数划分</h5><ul>
<li>单例索引：一个索引只包含一个列，一个表可以有多个单例索引。</li>
<li>组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。</li>
</ul>
<h4 id="物理分类"><a href="#物理分类" class="headerlink" title="物理分类"></a>物理分类</h4><p>分为聚簇索引和非聚簇索引（有时也称辅助索引或二级索引）</p>
<p>聚簇索引和非聚簇索引</p>
<blockquote>
<p>聚簇是为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为聚簇码)上具有相同值的元组集中存放在连续的物理块。</p>
</blockquote>
<p>聚簇索引（clustered index）不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<p>非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。</p>
<p>虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的**&#x3D;&#x3D;主键索引才是聚簇索引&#x3D;&#x3D;**，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。每张表最多只能拥有一个聚簇索引。</p>
<h3 id="聚簇索引优缺点"><a href="#聚簇索引优缺点" class="headerlink" title="聚簇索引优缺点"></a>聚簇索引优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>InnoDB使用B+TREE存储数据，除了主键索引为聚簇索引，其它索引均为非聚簇索引。</p>
<p>一个表中只能存在一个聚簇索引（主键索引），但可以存在多个非聚簇索引。</p>
<p>InnoDB表的索引和数据是存储在一起的，&#x3D;&#x3D;<strong>.idb</strong>&#x3D;&#x3D;表数据和索引的文件</p>
<h4 id="聚簇索引（主键索引）"><a href="#聚簇索引（主键索引）" class="headerlink" title="聚簇索引（主键索引）"></a>聚簇索引（主键索引）</h4><p>B+树 叶子节点包含数据表中行记录就是聚簇索引（索引和数据是存放在一块的）</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072315143.png" alt="quan_2021-12-28_11-12-09"></p>
<p>可以看到叶子节点包含了完整的数据记录，这就是聚簇索引。因为InnoDB的数据文件（.idb）按主键聚集，所以InnoDB必须有主键（MyISAM可以没有），如果没有显示指定主键，则选取首个为唯一且非空的列作为主键索引，如果还没具备，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>主键索引结构分析：</p>
<ul>
<li>B+树单个叶子节点内的行数据按主键顺序排列，物理空间是连续的（聚簇索引的数据的物理存放顺序与索引顺序是一致的）；</li>
<li>叶子节点之间是通过指针连接，相邻叶子节点的数据在逻辑上也是连续的（根据主键值排序），实际存储时的数据页（叶子节点）可能相距甚远。</li>
</ul>
<h4 id="非聚簇索引（辅助索引或二级索引）"><a href="#非聚簇索引（辅助索引或二级索引）" class="headerlink" title="非聚簇索引（辅助索引或二级索引）"></a>非聚簇索引（辅助索引或二级索引）</h4><p>在聚簇索引之外创建的索引（不是根据主键创建的）称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行数据记录，而是主键值。首先通过辅助索引找到主键值，然后到主键索引树中通过主键值找到数据行。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072316707.png" alt="quan_2021-12-28_11-14-33"></p>
<h4 id="InnoDB索引优化"><a href="#InnoDB索引优化" class="headerlink" title="InnoDB索引优化"></a>InnoDB索引优化</h4><ul>
<li><p>InnoDB中主键不宜定义太大，因为辅助索引也会包含主键列，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。</p>
</li>
<li><p>InnoDB中尽量不使用非单调字段作主键（不使用多列），因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
</li>
</ul>
<h4 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h4><ul>
<li>聚簇索引的叶子节点存放的是数据行（主键值也是行内数据），支持覆盖索引；而二级索引的叶子节点存放的是主键值或指向数据行的指针。</li>
<li>由于叶子节点(数据页)只能按照一棵B+树排序，故一张表只能有一个聚簇索引。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引。</li>
</ul>
<h3 id="操作索引"><a href="#操作索引" class="headerlink" title="操作索引"></a>操作索引</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>索引名称 index_name 是可以省略的，省略后，索引的名称和索引列名相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建普通索引 </span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建普通组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name_1,col_name_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name_1,col_name_2);</span><br></pre></td></tr></table></figure>

<p>修改表结构创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(col_name);</span><br></pre></td></tr></table></figure>

<p>创建表时直接指定索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    col_name <span class="type">VARCHAR</span> (<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX index_name (col_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<h4 id="其它相关命令"><a href="#其它相关命令" class="headerlink" title="其它相关命令"></a>其它相关命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">desc</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看生成表的SQL</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引信息（包括索引结构等）</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span>  table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看SQL执行时间（精确到小数点后8位）</span></span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">SQL...</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>

<h3 id="索引实战"><a href="#索引实战" class="headerlink" title="索引实战"></a>索引实战</h3><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句</p>
<h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句。</p>
<p>使用格式：**<code>EXPLAIN SQL...;</code>**</p>
<p>EXPLAIN 查询结果包含的字段</p>
<ul>
<li>id:选择标识符</li>
<li>select_type:表示查询的类型。<br>table:输出结果集的表</li>
<li>partitions:匹配的分区</li>
<li>type:表示表的连接类型</li>
<li>possible_keys:表示查询时，可能使用的索引</li>
<li>key:表示实际使用的索引</li>
<li>key_len:索引字段的长度</li>
<li>ref:列与索引的比较</li>
<li>rows:扫描出的行数(估算的行数)</li>
<li>filtered:按表条件过滤的行百分比</li>
<li>Extra:执行情况的描述和说明</li>
</ul>
<h4 id="Extra-探究"><a href="#Extra-探究" class="headerlink" title="Extra 探究"></a>Extra 探究</h4><p>Using index，Using index condition，Using where，其中Using index 表示使用了覆盖索引</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>组合索引满足最左前缀原则就会生效。即最左优先（查询条件精确匹配索引的左边连续一列或几列，则构建对应列的组合索引树），在检索数据时也从联合索引的最左边开始匹配。</p>
<p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配。</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072316191.png" alt="20210203220425543"></p>
<ul>
<li>只要筛选条件中含有组合索引最左边的列但不含有主键搜索键的时候，至少会构建包含组合索引最左列的索引树。（如：index(a)）</li>
<li>查询列都是组合索引列且筛选条件全是组合索引列时，会构建满列组合索引树（index(a,b,c) ）【覆盖索引】</li>
<li>筛选条件包含普通搜索键但没包含组合索引列最左键，不会构建组合索引树</li>
<li>如果筛选条件全是组合索引最左连续列作为搜索键，将构建连续列组合索引树。（比如：index(a,b)却不能index(a,c)）</li>
<li>MySQL查询优化器会优化and连接，将组合索引列规则排号。（比如：b and a 等同于 a and b）</li>
</ul>
<h4 id="覆盖索引与回表"><a href="#覆盖索引与回表" class="headerlink" title="覆盖索引与回表"></a>覆盖索引与回表</h4><p>上文我们介绍过索引可以划分为聚簇索引和辅助索引。在InnoDB中的主键索引就是聚簇索引，主键索引的查询效率也是非常高的，除此之外，还有非聚簇索引，其查询效率稍逊。覆盖索引其形式就是，搜索的索引键中的字段恰好是查询的字段（或是组合索引键中的其它字段）。覆盖索引的查询效率极高，原因在与其不用做回表查询。</p>
<h5 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h5><p>查询的列数据作为索引树的键值，直接在索引树中得到反馈（存在于索引节点），不用遍历如InnoDB中的叶子节点（存放数据表各行数据）就可得到查询的数据（不用回表）。</p>
<p>##索引的应用场景</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_info(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY uk_key2 (key2),</span><br><span class="line">    KEY  idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<h3 id="全值匹配-1"><a href="#全值匹配-1" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>如果我们的搜索条件中的列和索引列对应的话（列的字段和个数要相同），这种情况就称为全值匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_info <span class="keyword">WHERE</span> key_part_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part_2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">AND</span> key_part_3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>有的同学也许有个疑问，<code>WHERE</code>子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换<code>key_part_1</code>、<code>key_part_2</code>、<code>key_part_3</code>这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_info <span class="keyword">WHERE</span> key_part_2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">AND</span> key_part_3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">AND</span> key_part_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>答案是没有影响。<strong>只要你把联合索引的每个索引列都用到了，随意更换顺序是没有影响的，查询优化器会自动调整。</strong> 但是如果没有全部用到，那么就必须按照最左前缀原则使用。</p>
<h3 id="最左前缀原则-1"><a href="#最左前缀原则-1" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_info <span class="keyword">WHERE</span> key_part_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者包含多个左边的列也行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_info <span class="keyword">WHERE</span> key_part_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part_2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="匹配列的前缀-比如like-‘a-’"><a href="#匹配列的前缀-比如like-‘a-’" class="headerlink" title="匹配列的前缀(比如like ‘a%’)"></a>匹配列的前缀(比如like ‘a%’)</h3><h3 id="匹配列的中间字符或者后缀-比如like-‘-a-’，like-‘-com’"><a href="#匹配列的中间字符或者后缀-比如like-‘-a-’，like-‘-com’" class="headerlink" title="匹配列的中间字符或者后缀(比如like ‘%a%’，like ‘%com’)"></a>匹配列的中间字符或者后缀(比如like ‘%a%’，like ‘%com’)</h3><p>如果查询中间包含的某个字符串，比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_info <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>MySQL</code>就无法快速定位记录位置了，因为字符串中间有<code>&#39;a&#39;</code>的字符串并没有排好序，所以只能全表扫描了。</p>
<h3 id="匹配范围查找，确定扫描区间和边界"><a href="#匹配范围查找，确定扫描区间和边界" class="headerlink" title="匹配范围查找，确定扫描区间和边界"></a>匹配范围查找，确定扫描区间和边界</h3><p>并不是所有的搜索条件都可以成为边界条件的，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">and</span> common_field <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：对于<code>B+</code>树索引来说，只要索引列和常数使用了<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（也就是<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生所谓的扫描区间。</p>
<h3 id="IS-NULL、IS-NOT-NULL、-、BETWEEN、IN等等不能用索引吗？必须辟谣！"><a href="#IS-NULL、IS-NOT-NULL、-、BETWEEN、IN等等不能用索引吗？必须辟谣！" class="headerlink" title="IS NULL、IS NOT NULL、!&#x3D;、BETWEEN、IN等等不能用索引吗？必须辟谣！"></a>IS NULL、IS NOT NULL、!&#x3D;、BETWEEN、IN等等不能用索引吗？必须辟谣！</h3><p><strong>IS NULL的例子</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>虽然没有<code>key1</code>为<code>null</code>的记录，但还是走了索引。</p>
<p><strong>IS NOT NULL的例子</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>!&#x3D; 的例子</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="operator">!=</span> <span class="string">&#x27;a&#x27;</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这里也走了索引</p>
<p><strong>between的例子</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="keyword">between</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;d&#x27;</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>走索引</p>
<p>结论：对于B+树索引来说，只要索引列使用了&#x3D;、&lt;&#x3D;&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、BETWEEN、!&#x3D;（也就是&lt;&gt;）或者LIKE（只能是’a%’前缀字符形式）操作符连接起来，就可以使用到索引，如果你发现没走索引，请检查自己的结果集是否过多，限制一下结果集数量。</p>
<h3 id="隐式转换导致全表扫描不走索引-这个坑容易忽视"><a href="#隐式转换导致全表扫描不走索引-这个坑容易忽视" class="headerlink" title="隐式转换导致全表扫描不走索引(这个坑容易忽视)"></a>隐式转换导致全表扫描不走索引(这个坑容易忽视)</h3><p>这也是开发中经常可能遇到的坑。<br>比如，你明明想利用索引查询<code>key1=&#39;1&#39;</code>的记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结果！你却写成了<code>key1 = 1</code>;这个<code>1</code>可是<code>number</code>类型，不是<code>varchar</code>了，当字段类型和查询条件数据类型不一致的时候，如果没有函数转换，则会隐式转换，如果不能隐式转换则报错。这里<code>varchar</code>的<code>&#39;1&#39;</code>可以顺利转换<code>number</code>类型的<code>1</code>，**&#x3D;&#x3D;结果转换了类型，所以用不到索引。&#x3D;&#x3D;**</p>
<p> 注意: Server层包括连接器、查询缓存（MySQL 8.0剔除）、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现。<br>  而非聚集索引的查询和回表是在存储引擎层，如果要用函数判断，必须等到把完整记录返回给Server层，这里隐式转换用到函数就在Server层，在Server层就用不到索引了，所以是全表扫描。</p>
<h3 id="使用联合索引的场景"><a href="#使用联合索引的场景" class="headerlink" title="使用联合索引的场景"></a>使用联合索引的场景</h3><p>我们前面说了，有联合索引<code>KEY idx_key_part(key_part1, key_part2, key_part3)</code></p>
<p><strong>eg1：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于这个联合索引，先按照key_part1排序，在key_part1列的值相等的情况下再按照key_part2列进行排序，所以符合key_part1 &#x3D; ‘a’ and key_part2 &#x3D; ‘b’条件的非聚集索引记录一定是相邻的。</p>
<p>我们可以定位到符合key_part1 &#x3D; ‘a’ and key_part2 &#x3D; ‘b’条件的第一条记录，然后回表，接着定位满足key_part1 &#x3D; ‘a’ and key_part2 &#x3D; ‘b’的第二条记录，然后回表，就这样沿着记录所在的单链表往后扫描，直到不满足key_part1 &#x3D; ‘a’ 或者key_part2 &#x3D; ‘b’条件为止。（每找到一条满足条件的记录都会进行回表操作）</p>
<p><strong>eg2：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">and</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>eg3:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>非聚集索引不是按照<code>key_part2</code>的值进行排序的。无法通过<code>key_part2 = &#39;a&#39;</code>这个条件来减少扫描的记录数量，只能全表扫描，不会使用 <code>idx_key_part</code>这个联合索引。</p>
<h3 id="索引条件下推（Index-Condition-Pushdown，简称ICP）"><a href="#索引条件下推（Index-Condition-Pushdown，简称ICP）" class="headerlink" title="索引条件下推（Index Condition Pushdown，简称ICP）"></a>索引条件下推（Index Condition Pushdown，简称ICP）</h3><h4 id="索引下推表象理解"><a href="#索引下推表象理解" class="headerlink" title="索引下推表象理解"></a>索引下推表象理解</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在使用idx_key_part联合索引执行查询时，虽然不能直接用到key_part3，但是还是包含key_part3列的。因此每当从idx_key_part索引的扫描区间[‘a’, ‘a’]中获取到一条非聚集索引记录时，我们可以先判断这条二级索引记录是否符合key_part3&#x3D;’c’条件。如果符合该条件再执行回表操作，不符合就不回表，然后跳到下一条非聚集索引记录继续上述判断。<strong>这样可能减少因回表操作而带来的性能损耗，这种优化方式称为索引条件下推（Index Condition Pushdown，简称ICP）。</strong></p>
<h4 id="索引下推在存储引擎层和server层深入分析"><a href="#索引下推在存储引擎层和server层深入分析" class="headerlink" title="索引下推在存储引擎层和server层深入分析"></a>索引下推在存储引擎层和server层深入分析</h4><p>有联合索引<code>KEY idx_key_part(key_part1, key_part2, key_part3)</code>和普通索引<code>KEY idx_key1 (key1)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：筛选到一条非聚集索引记录后就去回表，而不是把所有满足条件的非聚集索引记录都拿到后去回表</p>
<h4 id="范围查找也会使用到Using-index-condition，需要注意！"><a href="#范围查找也会使用到Using-index-condition，需要注意！" class="headerlink" title="范围查找也会使用到Using index condition，需要注意！"></a>范围查找也会使用到Using index condition，需要注意！</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">&lt;=</span> <span class="string">&#x27;a&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里的<code>Extra</code>有<code>Using index condition</code>。但是将范围查询改为等值查询后，结果就变了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>因为在<code>InnoDB</code>存储引擎层有特殊的处理方案，是不作为<code>ICP</code>条件进行处理的，所以不会用到<code>Using index condition</code>。</p>
<h3 id="索引用于排序-explain分析案例，精华！！"><a href="#索引用于排序-explain分析案例，精华！！" class="headerlink" title="索引用于排序(explain分析案例，精华！！)"></a>索引用于排序(explain分析案例，精华！！)</h3><h4 id="在使用联合索引时需要注意，order-by子句后面的列的顺序也必须按照索引的顺序来。"><a href="#在使用联合索引时需要注意，order-by子句后面的列的顺序也必须按照索引的顺序来。" class="headerlink" title="在使用联合索引时需要注意，order by子句后面的列的顺序也必须按照索引的顺序来。"></a>在使用联合索引时需要注意，order by子句后面的列的顺序也必须按照索引的顺序来。</h4><p>对于联合索引<code>KEY idx_key_part(key_part1, key_part2, key_part3)</code>，如下查询是用不到索引的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用不到联合索引的例子</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part3 <span class="operator">&lt;=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> key_part1, key_part2;</span><br></pre></td></tr></table></figure>

<p>不管是<code>where</code>子句还是<code>order by</code>子句，想要用到索引，就得按照规则来，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> key_part3 limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="当记录数很多却不用limit限制查询返回的记录数时，极有可能不走索引"><a href="#当记录数很多却不用limit限制查询返回的记录数时，极有可能不走索引" class="headerlink" title="当记录数很多却不用limit限制查询返回的记录数时，极有可能不走索引"></a>当记录数很多却不用limit限制查询返回的记录数时，极有可能不走索引</h4><p>当我使用联合索引的条件去进行<code>order by</code>排序，结果却没有走索引，而是全表扫描</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key_part1, key_part2;</span><br></pre></td></tr></table></figure>

<p>当我限制只返回一条记录的时候，一下就走到了联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key_part1, key_part2 limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其实这是查询优化器搞的鬼。<strong>如果需要回表的记录越多，查询优化器就越倾向于全表扫描，反之则使用非聚集索引+回表的方式。</strong></p>
<p>**&#x3D;&#x3D;注意&#x3D;&#x3D;<strong>：当你&#x3D;&#x3D;<code>order by</code> 主键<code>id</code>&#x3D;&#x3D;的时候，</strong>&#x3D;&#x3D;一定是走索引的&#x3D;&#x3D;**，而且是走的<code>PRIMARY</code>索引，因为在聚集索引上就不存在回表了，不会使用全表扫描。</p>
<h4 id="asc、desc混用无法完全利用索引，除非你的数据库是MySQL-8-0"><a href="#asc、desc混用无法完全利用索引，除非你的数据库是MySQL-8-0" class="headerlink" title="asc、desc混用无法完全利用索引，除非你的数据库是MySQL 8.0+"></a>asc、desc混用无法完全利用索引，除非你的数据库是MySQL 8.0+</h4><p>首先说下asc和desc排序</p>
<p>  asc升序排列大家知道，沿着页中单链表遍历即可。</p>
<p>  desc降序排列就要注意了，你需要知道页中有<strong>Infimum+Supremum</strong>记录，可以先简单理解为头指针和尾指针。首先从头指针处遍历到最后一条用户记录，接着从头指针遍历到倒数第二条记录，从头指针遍历到倒数第三条记录…</p>
<p>这样就能获取到倒序排列的结果集了，很显然，<code>asc</code>升序排列获取结果集要快于<code>desc</code>降序排列。</p>
<p>实际上，一个页中的记录分了很多组，页中有一块<strong>Page Directory</strong>的空间存放了叫”<strong>槽</strong>“的东西，槽中存放着每个分组内最后一条记录在页面中的<strong>地址偏移量</strong>。只要找到了最后一条记录，然后找到分组的第一条记录(上一个槽的下一条记录)，就可以在这个分组内小范围的遍历获取倒序的结果。这可比从页中第一条记录开始遍历获取倒序结果好的多，大大减少遍历时间。</p>
<p>如果非要<code>asc</code>和<code>desc</code>混合排序，我们来分析一下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> key_part2, key_part3 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><code>MySQL 8.0</code> 引入了<code>Descending Index</code>的特性，允许利用索引直接<code>asc</code>和<code>desc</code>混合排序。</p>
<p><strong>索引声明是升序的，降序排列一定提示<code>Using filesort</code></strong></p>
<p>如果在<code>MySQL 8.0+</code>将<code>key_part3</code>为<code>desc</code>，这里索引改为<code>KEY idx_key_part(key_part1, key_part2, key_part3 desc)</code>，再次执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在MySQL <span class="number">8.0</span><span class="operator">+</span>将key_part3为<span class="keyword">desc</span>，这里索引改为KEY idx_key_part(key_part1, key_part2, key_part3 <span class="keyword">desc</span>)，再次执行</span><br></pre></td></tr></table></figure>

<p>结果是<code>asc</code>和<code>desc</code>完美的利用索引进行混合排序。而在<code>MySQL8.0</code>以下，索引声明<code>desc</code>是直接被忽略的。</p>
<h4 id="排序中不能包含非同一索引的列，否则不走索引"><a href="#排序中不能包含非同一索引的列，否则不走索引" class="headerlink" title="排序中不能包含非同一索引的列，否则不走索引"></a>排序中不能包含非同一索引的列，否则不走索引</h4><p>排序中用来排序的多个列不是同一索引是不能使用索引排序的。</p>
<p>前面说过，<code>key1</code>和<code>key2</code>不是联合索引<br><code>KEY idx_key1 (key1)</code><br><code>UNIQUE KEY uk_key2 (key2)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key1, key2 LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续，则不走索引"><a href="#排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续，则不走索引" class="headerlink" title="排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续，则不走索引"></a>排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续，则不走索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key_part1, key_part3 LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果你的排序条件换成连续的，马上就能用到索引了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key_part1, key_part2 LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="排序列是索引列，但是使用了函数，则不走索引"><a href="#排序列是索引列，但是使用了函数，则不走索引" class="headerlink" title="排序列是索引列，但是使用了函数，则不走索引"></a>排序列是索引列，但是使用了函数，则不走索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">UPPER</span>(key1) limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为<code>key1</code>列是以<code>UPPER(key1)</code>函数调用的形式出现在<code>order by</code>子句中，所以不能使用<code>idx_key1</code>执行上述查询。</p>
<p>索引的查询和回表是在存储引擎层，如果要用函数判断，必须等到把完整记录返回给<code>Server</code>层，在<code>Server</code>层就用不到索引了，所以是全表扫描。</p>
<h3 id="索引用于分组"><a href="#索引用于分组" class="headerlink" title="索引用于分组"></a>索引用于分组</h3><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> key_part1, key_part2, key_part3, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> demo_info <span class="keyword">group</span> <span class="keyword">by</span> key_part1, key_part2, key_part3;</span><br></pre></td></tr></table></figure>

<p>这个查询语句相当于做了<code>3</code>次分组操作</p>
<p>如果没有idx_key_part索引，就得建立一个用于统计的临时表，在扫描聚集索引的记录时将统计的中间结果填入这个临时表。当记录扫描完毕后，再把临时表中的结果作为结果集发送给客户端。</p>
<p>如果有了索引idx_key_part，恰巧这个分组顺序又与idx_key_part的索引列的顺序是一致的，而idx_key_part的非聚集索引记录又是按照索引列的值排好序的，所以可以直接使用索引进行分组，不用再建立临时表了。</p>
<h2 id="如何更好的创建和使用索引"><a href="#如何更好的创建和使用索引" class="headerlink" title="如何更好的创建和使用索引"></a>如何更好的创建和使用索引</h2><h3 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h3><p>只为出现在<code>where</code>子句中的列、连接子句中的连接列，或者出现在<code>order by</code>或<code>group by</code>子句中的列创建索引。而出现在<code>select</code>查询列表中的列就没必要建立索引了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> common_field, key_part3 <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>像查询列表中的<code>common_field</code>、<code>key_part3</code>这两个列就没必要建立索引，我们只需要为出现在<code>where</code>子句中的<code>key1</code> 列创建索引就可以了。</p>
<h3 id="考虑索引列中不重复值的个数"><a href="#考虑索引列中不重复值的个数" class="headerlink" title="考虑索引列中不重复值的个数"></a>考虑索引列中不重复值的个数</h3><p><strong>不重复值的个数越多，可以称为区分度高或者筛选性好，区分度或者筛选性就是不重复值的个数与总个数的比值。</strong></p>
<p>所以结论就是：最好为不重复值的个数多的列建立索引，区分度低说明该列包含过多重复值，那么在非聚集索引+回表的方式执行查询时，就有可能执行太多回表操作，导致查询优化器选择全表扫描。</p>
<h3 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h3><p>以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>这么几种，它们占用的存储空间依次递增，能表示的整数范围依次递增。比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>。因为数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以存放更多的记录，磁盘<code>I/O</code>带来的性能损耗就越小（一次页面<code>I/O</code>能将更多记录加载到内存中），读写效率就越高。</p>
<p><strong>这个建议对于表的主键来说更加适用</strong>。因为不仅是聚集索引中会存储主键值，其他所有的非聚集索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着能节省更多的存储空间。</p>
<h3 id="为索引字符串值的前缀建立索引"><a href="#为索引字符串值的前缀建立索引" class="headerlink" title="为索引字符串值的前缀建立索引"></a>为索引字符串值的前缀建立索引</h3><p>只对字符串的前几个字符放到索引中，也就是说在非聚集索引的记录中只保留字符串前几个字符。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先删除原有索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo_info <span class="keyword">drop</span> index idx_key1;</span><br><span class="line"><span class="comment">-- 创建新的索引,保留前10个字符</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo_info <span class="keyword">add</span> index idx_key1(key1(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>然后再执行下面查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefghijklmnop&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>在只对列前缀建立索引的情况下，就不能使用索引来完成排序需求了。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key1 LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为非聚集索引中不包含完整的<code>key1</code> 列信息，所以无法对<code>key1</code>列前<code>10</code>个字符相同但其余字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能全表扫描+文件排序的方式来执行了。</p>
<h3 id="让索引在where子句的一侧单独出现"><a href="#让索引在where子句的一侧单独出现" class="headerlink" title="让索引在where子句的一侧单独出现"></a>让索引在where子句的一侧单独出现</h3><p>表中有一个整数列<code>key2</code>，这个列建立了唯一索引。下边的两个<code>where</code>子句虽然语义是一致的，但是在效率上却有很大差别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key2 <span class="operator">&lt;</span> <span class="number">4</span> <span class="operator">-</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但是表达式调整之后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo_info <span class="keyword">where</span> key2 <span class="operator">+</span> <span class="number">1</span> <span class="operator">&lt;</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>后者<code>key2</code>列并不是以单独出现的，而是以<code>key2 + 1</code>这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，所以这种情况下是使用不到<code>key2</code>列建立的<code>B+</code>树索引的。</p>
<p>所以结论就是：如果<code>where</code>子句中表达式的一侧的索引不是单独的形式出现，而是经过计算或者函数调用形式出现的话，<strong>是用不到索引的</strong>。</p>
<p>注意：索引树有<code>key2</code>的值，而不是<code>key2 + 1</code>的值，像这种计算不会在存储引擎层完成，而是在<code>server</code>层。</p>
<h3 id="保证主键的插入顺序"><a href="#保证主键的插入顺序" class="headerlink" title="保证主键的插入顺序"></a>保证主键的插入顺序</h3><p>对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚集索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插入，如果新插入的主键值忽大忽小，这就比较麻烦了</p>
<p>可这个数据页已经满了啊，新纪录该插入到哪里呢？我们需要<strong>把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的页中</strong>。页面分裂和记录移位有一定的性能损耗。</p>
<h3 id="如有必要，尽量考虑使用索引覆盖"><a href="#如有必要，尽量考虑使用索引覆盖" class="headerlink" title="如有必要，尽量考虑使用索引覆盖"></a>如有必要，尽量考虑使用索引覆盖</h3><p>我个人在某业务场景中，需要查询根据**会话id(session_id)<strong>和</strong>场景id(scene_id)**去查询有没有这条记录，从而继续下一步插入或者更新操作，但是session_id对应多个scene_id，所以session_id无法设置唯一索引。就不能使用存在则更新，不存在则插入的语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>, 值<span class="number">2</span>,...) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> 字段<span class="number">1</span><span class="operator">=</span><span class="keyword">values</span>(字段<span class="number">1</span>), 字段<span class="number">2</span><span class="operator">=</span><span class="keyword">values</span>(字段<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>所以，我只查一查这条记录有没有，再去判断插入还是更新。建立联合索引<code>idx_sessionid_sceneid(session_id, scene_id)</code></p>
<p>只需要如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> 表名 <span class="keyword">where</span> session_id <span class="operator">=</span> <span class="string">&#x27;1212213&#x27;</span> <span class="keyword">and</span> scene_id <span class="operator">=</span> <span class="string">&#x27;scene123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这里只查询<code>id</code>，因为这样可以利用到索引覆盖</p>
<p>前面<code>demo_info</code>表中有<code>KEY idx_key1 (key1)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> key1 <span class="keyword">from</span> demo_info <span class="keyword">order</span> <span class="keyword">by</span> key1;</span><br></pre></td></tr></table></figure>

<p>这里虽然没有<code>limit</code>子句，但是由于可以采用索引覆盖，查询优化器会直接在非聚集索引进行排序，不需要回表操作。</p>
<h3 id="避免创建冗余重复的索引"><a href="#避免创建冗余重复的索引" class="headerlink" title="避免创建冗余重复的索引"></a>避免创建冗余重复的索引</h3><p>我们有联合索引KEY idx_key_part(key_part1, key_part2, key_part3)。</p>
<p>  如果你还单独建立一个key_part1索引，那就是多此一举，因为根据联合索引的最左前缀原则就已经可以用到key_part1索引了，索引的建立和维护也是需要时间和空间的，这种不必要的开销应该避免。</p>
<h2 id="学习事务与隔离级别"><a href="#学习事务与隔离级别" class="headerlink" title="学习事务与隔离级别"></a>学习事务与隔离级别</h2><h3 id="事务四要素：ACID"><a href="#事务四要素：ACID" class="headerlink" title="事务四要素：ACID"></a>事务四要素：ACID</h3><ul>
<li>原子性（Atomicity）：要么全部完成，要么全部不完成；</li>
<li>一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见；</li>
<li>隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的隔离级别，通过适度的破坏一致性，得以提高性能；</li>
<li>持久性（Durability）：事务提交后即持久化到磁盘不会丢失。</li>
</ul>
<h3 id="事务并发存在的问题"><a href="#事务并发存在的问题" class="headerlink" title="事务并发存在的问题"></a>事务并发存在的问题</h3><h4 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h4><p>没有提交的事务被其他事务读取到了，这叫做 <strong>脏读</strong> 。</p>
<h4 id="不可重复读（unrepeatable-read）"><a href="#不可重复读（unrepeatable-read）" class="headerlink" title="不可重复读（unrepeatable read）"></a>不可重复读（unrepeatable read）</h4><p>同一个事务对同一条记录读取两遍，两次读出来的结果竟然不一样。</p>
<p>不可重复读和脏读的区别在于，脏读是读取了另一个事务<strong>未提交</strong>的修改，而不可重复读是读取了另一个事务<strong>提交</strong>之后的修改，本质上都是其他事务的修改影响了本事务的读取。</p>
<h4 id="幻读（phantom-read）"><a href="#幻读（phantom-read）" class="headerlink" title="幻读（phantom read）"></a>幻读（phantom read）</h4><p>于幻读，最简单的解释就是：<strong>同样的条件，第一次和第二次读出来的记录数不一样。</strong></p>
<p>因为可能存在另一个事务先插入一条记录然后再删除一条记录的情况，这个时候两次查询得到的记录数也是一样的，但这也是幻读，所以严格点的说法应该是：<strong>两次读取得到的结果集不一样</strong></p>
<p>不可重复读是因为其他事务进行了 <strong>UPDATE</strong> 操作，幻读是因为其他事务进行了 <strong>INSERT 或者 DELETE 操作</strong>。</p>
<h4 id="丢失更新（lost-update）"><a href="#丢失更新（lost-update）" class="headerlink" title="丢失更新（lost update）"></a>丢失更新（lost update）</h4><p>那么如果两个事务都是写，又会发生什么呢？</p>
<p>假设两个事务同时对 A 的余额进行修改，他们都查出 A 的当前余额为 1000，然后事务 2 修改 A 的余额，将 A 的余额加 100 变成 1100 并提交，这个时候 A 的余额应该是 1100，但是这个时候事务 1 并不知道 A 的余额已经变动，而是继续在 1000 的基础上进行减 100 的操作并提交事务，就这样事务 2 的提交被覆盖掉了，事务 1 提交之后 A 的余额变成了 900 元。这就是说事务 1 的提交覆盖了事务 2 的提交，事务 2 的 UPDATE 操作完全丢失了，</p>
<p>这就是经典的 <strong>丢失更新</strong> 问题，由于最后一步是提交操作，所以又叫做 <strong>提交覆盖</strong>，有时候又叫 <strong>Read-Modify-Write 问题</strong>。一个典型的场景是并发对某个变量进行自增或自减</p>
<p>有时候我们把回滚覆盖称之为 <strong>第一类丢失更新</strong> 问题，提交覆盖称为 <strong>第二类丢失更新</strong> 问题。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>读未提交（Read Uncommitted）：可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到；</li>
<li>读已提交（Read Committed）：事务中只能看到已提交的修改，不会出现脏读现象，但是会出现幻读，不可重复读；（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）</li>
<li>可重复读（Repeatable Read）：MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是任然存在幻读问题；（MySQL 的实现有差异，后面介绍）</li>
<li>序列化（Serializable）：最高隔离级别，啥并发问题都没有。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072317595.png" alt="quan_2021-12-28_14-47-04"></p>
<p>InnoDb 通过 MVCC 实现了读写并行，但是在不同的隔离级别下，读的方式也是有所区别的。</p>
<p>首先要特别指出的是，在 read uncommit 隔离级别下，每次都是读取最新版本的数据行，所以不能用 MVCC 的多版本，而 serializable 隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC。</p>
<p><strong>RC 总是读取记录的最新版本，如果该记录被锁住，则读取该记录最新的一次快照，而 RR 是读取该记录事务开始时的那个版本。</strong></p>
<p><strong>快照读（Snapshot Read）</strong>，有时候也叫做 <strong>非阻塞读（Nonlocking Read）</strong>，RR 隔离级别下的叫做 一致性非阻塞读（Consistent Nonlocking Read）除了 <strong>快照读</strong> ，MySQL 还提供了另一种读取方式：<strong>当前读（Current Read）</strong>，有时候又叫做 <strong>加锁读（Locking Read）</strong> 或者 <strong>阻塞读（Blocking Read）</strong></p>
<p>&#x3D;&#x3D;<strong>RC 只加记录锁，RR 除了加记录锁，还会加间隙锁，用于解决幻读问题</strong>&#x3D;&#x3D;</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072317771.png" alt="quan_2021-12-28_14-55-17"></p>
<h3 id="查看和设置-MySQL-的隔离级别"><a href="#查看和设置-MySQL-的隔离级别" class="headerlink" title="查看和设置 MySQL 的隔离级别"></a>查看和设置 MySQL 的隔离级别</h3><p>MySQL 中的系统变量 <code>tx_isolation</code> 的值来确定当前 MySQL 正在使用什么隔离级别。</p>
<p><strong>用户变量</strong> 和 <strong>系统变量</strong>，用户变量的变量名格式为 <code>@variable</code>，而系统变量的格式为 <code>@@variable</code>，<code>tx_isolation</code> 是系统变量，所以变量名为 <code>@@tx_isolation</code>。其中，系统变量又可以分为 <strong>全局变量</strong> 和 <strong>会话变量</strong>，默认情况下使用 <code>select @@variable</code> 查询出来的是会话变量的值，也可以写作 <code>select @@session.variable</code> 或者 <code>select @@local.variable</code>，如果要查询全局变量的值，则使用 <code>select @@global.variable</code>。</p>
<p>另外可以使用 <code>SET TRANSACTION</code>命令修改 MySQL 的隔离级别，</p>
<h2 id="了解常见的锁类型"><a href="#了解常见的锁类型" class="headerlink" title="了解常见的锁类型"></a>了解常见的锁类型</h2><h3 id="表锁-vs-行锁"><a href="#表锁-vs-行锁" class="headerlink" title="表锁 vs. 行锁"></a>表锁 vs. 行锁</h3><p>表锁指的是对一整张表加锁，一般是 DDL 处理时使用，也可以自己在 SQL 中指定；</p>
<p>而行锁指的是锁定某一行数据或某几行，或行和行之间的间隙。</p>
<p>行锁的加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，通常都是用行锁来处理并发事务。</p>
<p>表锁由 MySQL 服务器实现，行锁由存储引擎实现，常见的就是 InnoDb，而 MyISAM 存储引擎只能使用表锁。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>一般在执行 DDL 语句时，譬如 <strong>ALTER TABLE</strong> 就会对整个表进行加锁。在执行 SQL 语句时，也可以明确对某个表加锁，譬如下面的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> lock <span class="keyword">table</span> products read;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> products <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> unlock tables;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 首先对 products 表加一个表锁，然后执行查询语句，最后释放表锁。表锁可以细分成两种：读锁和写锁，如果是加写锁，则是 <code>lock table products write</code> </p>
<p>关于表锁，我们要了解它的加锁和解锁原则，要注意的是它使用的是 <strong>一次封锁</strong> 技术，也就是说，我们会在会话开始的地方使用 lock 命令将后面所有要用到的表加上锁，在锁释放之前，我们只能访问这些加锁的表，不能访问其他的表，最后通过 unlock tables 释放所有表锁。这样的好处是，不会发生死锁！所以我们在 MyISAM 存储引擎中，是不可能看到死锁场景的。对多个表加锁的例子如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> lock <span class="keyword">table</span> products read, orders read;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> products <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): <span class="keyword">Table</span> <span class="string">&#x27;users&#x27;</span> was <span class="keyword">not</span> locked <span class="keyword">with</span> LOCK TABLES</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> orders <span class="keyword">set</span> price <span class="operator">=</span> <span class="number">5000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): <span class="keyword">Table</span> <span class="string">&#x27;orders&#x27;</span> was locked <span class="keyword">with</span> a READ lock <span class="keyword">and</span> can<span class="string">&#x27;t be updated</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">mysql&gt; unlock tables;</span></span><br><span class="line"><span class="string">Query OK, 0 rows affected (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<p>可以看到由于没有对 users 表加锁，在持有表锁的情况下是不能读取的，另外，由于加的是读锁，所以后面也不能对 orders 表进行更新。</p>
<p>MySQL 表锁的加锁规则如下：</p>
<ul>
<li>对于读锁<ul>
<li>持有读锁的会话可以读表，但不能写表；</li>
<li><strong>允许多个会话同时持有读锁</strong>；</li>
<li>其他会话就算没有给表加读锁，也是可以读表的，但是不能写表；</li>
<li>其他会话申请该表写锁时会阻塞，直到锁释放。</li>
</ul>
</li>
<li>对于写锁<ul>
<li>持有写锁的会话既可以读表，也可以写表；</li>
<li><strong>只有持有写锁的会话才可以访问该表</strong>，其他会话访问该表会被阻塞，直到锁释放；</li>
<li>其他会话无论申请该表的读锁或写锁，都会阻塞，直到锁释放。</li>
</ul>
</li>
</ul>
<p>锁的释放规则如下：</p>
<ul>
<li>使用 <strong>UNLOCK TABLES</strong> 语句可以显示释放表锁；</li>
<li>如果会话在持有表锁的情况下执行 LOCK TABLES 语句，将会释放该会话之前持有的锁；</li>
<li>如果会话在持有表锁的情况下执行 START TRANSACTION 或 BEGIN 开启一个事务，将会释放该会话之前持有的锁；</li>
<li>如果会话连接断开，将会释放该会话所有的锁。</li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>表锁不仅实现和使用都很简单，而且占用的系统资源少，如 MyISAM、MEMORY、MERGE 等，MyISAM 存储引擎几乎完全依赖 MySQL 服务器提供的表锁机制，查询自动加表级读锁，更新自动加表级写锁，以此来解决可能的并发问题。表锁的粒度太粗，导致数据库的并发性能降低，为了提高数据库的并发能力，InnoDb 引入了行锁的概念。</p>
<p>行锁和表锁对比如下：</p>
<ul>
<li>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</li>
<li>行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
<p>行锁和表锁一样，也分成两种类型：读锁和写锁。常见的增删改（<strong>INSERT、DELETE、UPDATE</strong>）语句会自动对操作的数据行加<strong>写锁</strong>，查询的时候也可以明确指定锁的类型，</p>
<p><strong>&#x3D;&#x3D;SELECT … LOCK IN SHARE MODE(lock in share mode) 语句加的是读锁，&#x3D;&#x3D;</strong></p>
<p>&#x3D;&#x3D;<strong>SELECT … FOR UPDATE(for update) 语句加的是写锁。</strong>&#x3D;&#x3D;</p>
<p>在 MySQL 中，行锁是加在索引上的。所以要深入了解行锁，还需要先了解下 MySQL 中索引的结构。</p>
<p>MySQL 有两种索引类型：主键索引（Primary Index）和非主键索引（Secondary Index，又称为二级索引、辅助索引）。InnoDb 的主键索引有时候又被称为 <strong>聚簇索引（Clustered Index）</strong>，二级索引被称为 <strong>非聚簇索引（Nonclustered Index）</strong></p>
<p>当执行下面的 SQL 时（id 为 students 表的主键），我们要知道，InnoDb 存储引擎会在 id &#x3D; 49 这个主键索引上加一把 &#x3D;&#x3D;<strong>X 锁(排它锁)。S锁(共享锁)</strong>&#x3D;&#x3D;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> students <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">49</span>;</span><br></pre></td></tr></table></figure>

<p>当执行下面的 SQL 时（name 为 students 表的二级索引），InnoDb 存储引擎会在 name &#x3D; ‘Tom’ 这个索引上加一把 X 锁，同时会通过 name &#x3D; ‘Tom’ 这个二级索引定位到 id &#x3D; 49 这个主键索引，并在 id &#x3D; 49 这个主键索引上加一把 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> students <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>譬如下面的 SQL（假设 score 字段为二级索引）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> students <span class="keyword">set</span> level <span class="operator">=</span> <span class="number">3</span> <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p>下图展示了当用户执行这条 SQL 时，MySQL Server 和 InnoDb 之间的执行流程：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318163.png"></p>
<p>从图中可以看到当 UPDATE 语句被发给 MySQL 后，MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁（current read），待 MySQL Server 收到这条加锁的记录之后，会再发起一个 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，MySQL 在操作多条记录时 InnoDB 与 MySQL Server 的交互是一条一条进行的，加锁也是一条一条依次进行的，先对一条满足条件的记录加锁，返回给 MySQL Server，做一些 DML 操作，然后在读取下一条加锁，直至读取完毕。</p>
<h3 id="行锁种类"><a href="#行锁种类" class="headerlink" title="行锁种类"></a>行锁种类</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">define</span> LOCK_TABLE <span class="number">16</span> <span class="comment">/* table lock */</span></span><br><span class="line">#<span class="keyword">define</span> LOCK_REC  <span class="number">32</span> <span class="comment">/* record lock */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precise modes */</span></span><br><span class="line">#<span class="keyword">define</span> LOCK_ORDINARY  <span class="number">0</span>  </span><br><span class="line">#<span class="keyword">define</span> LOCK_GAP  <span class="number">512</span> </span><br><span class="line">#<span class="keyword">define</span> LOCK_REC_NOT_GAP <span class="number">1024</span>  </span><br><span class="line">#<span class="keyword">define</span> LOCK_INSERT_INTENTION <span class="number">2048</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LOCK_ORDINARY：也称为 <strong>Next-Key Lock</strong>，锁一条记录及其之前的间隙，这是 RR 隔离级别用的最多的锁，从名字也能看出来；</li>
<li>LOCK_GAP：间隙锁，锁两个记录之间的 GAP，防止记录插入；</li>
<li>LOCK_REC_NOT_GAP：只锁记录；</li>
<li>LOCK_INSERT_INTENSION：插入意向 GAP 锁，插入记录时使用，是 LOCK_GAP 的一种特例。</li>
</ul>
<h3 id="读锁-vs-写锁"><a href="#读锁-vs-写锁" class="headerlink" title="读锁 vs. 写锁"></a>读锁 vs. 写锁</h3><p>MySQL 将锁分成两类：锁类型（lock_type）和锁模式（lock_mode）。</p>
<p>锁类型就是上文中介绍的表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方；</p>
<p>而锁模式描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的，锁模式在 MySQL 的源码中定义如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic lock modes */</span></span><br><span class="line">enum` `lock_mode &#123;</span><br><span class="line">  ``LOCK_IS <span class="operator">=</span> <span class="number">0</span>, ``<span class="comment">/* intention shared */</span></span><br><span class="line">  ``LOCK_IX,  ``<span class="comment">/* intention exclusive */</span></span><br><span class="line">  ``LOCK_S,   ``<span class="comment">/* shared */</span></span><br><span class="line">  ``LOCK_X,   ``<span class="comment">/* exclusive */</span></span><br><span class="line">  ``LOCK_AUTO_INC, ``<span class="comment">/* locks the auto-inc counter of a table in an exclusive mode*/</span></span><br><span class="line">  ``...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>LOCK_IS：读意向锁；</li>
<li>LOCK_IX：写意向锁；</li>
<li>LOCK_S：读锁；</li>
<li>LOCK_X：写锁；</li>
<li>LOCK_AUTO_INC：自增锁；</li>
</ul>
<p>将锁分为读锁和写锁主要是为了提高读的并发，如果不区分读写锁，那么数据库将没办法并发读，并发性将大大降低。而 IS（读意向）、IX（写意向）只会应用在表锁上，方便表锁和行锁之间的冲突检测。LOCK_AUTO_INC 是一种特殊的表锁。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>读锁，又称共享锁（Share locks，简称 S 锁）</strong>，加了读锁的记录，<strong>所有的事务</strong>都可以读取，但是不能修改，并且可同时有多个事务对记录加读锁。写锁，又称<strong>排他锁（Exclusive locks，简称 X 锁）</strong>，或<strong>独占锁</strong>，对记录加了排他锁之后，只有<strong>拥有</strong>该锁的事务可以读取和修改，其他事务都不可以读取和修改，并且同一时间只能有一个事务加写锁。（注意：这里说的读都是<strong>当前读</strong>，<strong>快照读是无需加锁的</strong>，记录上无论有没有锁，都可以快照读）</p>
<p>在其他的数据库系统中（譬如 MSSQL），我们可能还会看到一种基本的锁模式：更新锁（Update locks，简称 U 锁），MySQL 暂时不支持 U 锁，所以这里只是稍微了解一下。这个锁主要是用来防止死锁的，因为多数数据库在加 X 锁的时候是先获取 S 锁，获取成功之后再升级成 X 锁，如果有两个事务同时获取了 S 锁，然后又同时尝试升级 X 锁，就会发生死锁。增加 U 锁表示有事务对该行有更新意向，只允许一个事务拿到 U 锁，该事务在发生写后 U 锁变 X 锁，未写时看做 S 锁。（疑问：MySQL 更新的时候是直接申请 X 锁么？）</p>
<h3 id="读写意向锁"><a href="#读写意向锁" class="headerlink" title="读写意向锁"></a>读写意向锁</h3><p>表锁锁定了整张表，而行锁是锁定表中的某条记录，它们俩锁定的范围有交集，因此表锁和行锁之间是有冲突的。为了方便检测表锁和行锁的冲突，从而引入了意向锁。</p>
<p>意向锁为表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。</p>
<p>当事务试图读或写某一条记录时，会先在表上加上意向锁，然后才在要操作的记录上加上读锁或写锁。这样判断表中是否有记录加锁就很简单了，只要看下表上是否有意向锁就行了。意向锁之间是不会产生冲突的，也不和 AUTO_INC 表锁冲突，它只会阻塞表级读锁或表级写锁，另外，意向锁也不会和行锁冲突，行锁只会和行锁冲突。</p>
<p>下面是各个表锁之间的兼容矩阵：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318592.png" alt="1431433403"></p>
<p>因为是斜对称的，所以我们用一条斜线把表格分割成两个部分，只需要看左下角的一半即可。总结起来有下面几点：</p>
<ul>
<li>意向锁之间互不冲突；</li>
<li>S 锁只和 S&#x2F;IS 锁兼容，和其他锁都冲突；</li>
<li>X 锁和其他所有锁都冲突；</li>
<li>AI 锁只和意向锁兼容；</li>
</ul>
<h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO_INC 锁"></a>AUTO_INC 锁</h3><p>AUTO_INC 锁又叫自增锁（一般简写成 AI 锁），它是一种特殊类型的表锁，当插入的表中有自增列（AUTO_INCREMENT）的时候可能会遇到。</p>
<p>当插入表中有自增列时，数据库需要自动生成自增值，在生成之前，它会先为该表加 AUTO_INC 表锁，其他事务的插入操作阻塞，这样保证生成的自增值肯定是唯一的。AUTO_INC 锁具有如下特点：</p>
<ul>
<li>AUTO_INC 锁互不兼容，也就是说同一张表同时只允许有一个自增锁；</li>
<li>自增锁不遵循二段锁协议，它并不是事务结束时释放，而是在 INSERT 语句执行结束时释放，这样可以提高并发插入的性能。</li>
<li>自增值一旦分配了就会 +1，如果事务回滚，自增值也不会减回去，所以自增值可能会出现中断的情况。</li>
</ul>
<p>显然，AUTO_INC 表锁会导致并发插入的效率降低，为了提高插入的并发性，MySQL 从 5.1.22 版本开始，引入了一种可选的<strong>轻量级锁（mutex）</strong>机制来代替 AUTO_INC 锁，我们可以通过参数 <code>innodb_autoinc_lock_mode</code> 控制分配自增值时的并发策略。参数 <code>innodb_autoinc_lock_mode</code> 可以取下列值：</p>
<ul>
<li>innodb_autoinc_lock_mode &#x3D; 0 （traditional lock mode）<ul>
<li>使用传统的 AUTO_INC 表锁，并发性比较差。</li>
</ul>
</li>
<li>innodb_autoinc_lock_mode &#x3D; 1 （consecutive lock mode）<ul>
<li>MySQL 默认采用这种方式，是一种比较折中的方法。</li>
<li>MySQL 将插入语句分成三类：<code>Simple inserts、Bulk inserts、Mixed-mode inserts</code>。通过分析 INSERT 语句可以明确知道插入数量的叫做 <code>Simple inserts</code>；通过分析 INSERT 语句无法确定插入数量的叫做 <code>Bulk inserts</code>；还有一种是不确定是否需要分配自增值的</li>
<li>Bulk inserts 不能确定插入数使用表锁；Simple inserts 和 Mixed-mode inserts 使用轻量级锁 mutex，只锁住预分配自增值的过程，不锁整张表。</li>
<li>Bulk inserts 不能确定插入数使用表锁；Simple inserts 和 Mixed-mode inserts 使用轻量级锁 mutex，只锁住预分配自增值的过程，不锁整张表。</li>
</ul>
</li>
<li>innodb_autoinc_lock_mode &#x3D; 2 （interleaved lock mode）<ul>
<li>全部都用轻量级锁 mutex，并发性能最高，按顺序依次分配自增值，不会预分配。</li>
<li>缺点是不能保证同一条 INSERT 语句内的自增值是连续的，这样在复制（replication）时，如果 binlog_format 为 statement-based（基于语句的复制）就会存在问题，因为是来一个分配一个，同一条 INSERT 语句内获得的自增值可能不连续，主从数据集会出现数据不一致。所以在做数据库同步时要特别注意这个配置。</li>
</ul>
</li>
</ul>
<h2 id="细说-MySQL-锁类型"><a href="#细说-MySQL-锁类型" class="headerlink" title="细说 MySQL 锁类型"></a>细说 MySQL 锁类型</h2><p>行锁也有可能并不是锁在行上而是行与行之间的间隙上，事实上，我理解的这种锁是最简单的行锁模式：记录锁。</p>
<h3 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h3><p>记录锁是最简单的行锁，并没有什么好说的。譬如下面的 SQL 语句（id 为主键）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> level <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句就会在 id &#x3D; 5 这条记录上加上记录锁，防止其他事务对 id &#x3D; 5 这条记录进行修改或删除。记录锁永远都是加在索引上的。如果 WHERE 条件中指定的列是个二级索引，那么记录锁不仅会加在这个二级索引上，还会加在这个二级索引所对应的聚簇索引上。</p>
<p>注意，如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。</p>
<h3 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h3><p>还是看上面的那个例子，如果 id &#x3D; 5 这条记录不存在，这个 SQL 语句还会加锁吗？答案是可能有，这取决于数据库的隔离级别。</p>
<p>间隙锁 是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。有时候又称为<strong>范围锁（Range Locks）</strong>。这个范围可以跨一个索引记录，多个索引记录，甚至是空的。这个范围可以跨一个索引记录，多个索引记录，甚至是空的。这个范围可以跨一个索引记录，多个索引记录，甚至是空的。</p>
<p>回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id &#x3D; 5 前后两个索引之间加上间隙锁。</p>
<p>回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id &#x3D; 5 前后两个索引之间加上间隙锁。</p>
<h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>Next-key 锁 是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</p>
<h3 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h3><p>插入意向锁 是一种特殊的间隙锁（所以有的地方把它简写成 II GAP），这个锁表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混淆了。插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。</p>
<p>插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，那么间隙锁是如何防止幻读的呢？正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。</p>
<h3 id="行锁的兼容矩阵"><a href="#行锁的兼容矩阵" class="headerlink" title="行锁的兼容矩阵"></a>行锁的兼容矩阵</h3><p>下面我们对这四种行锁做一个总结，它们之间的兼容矩阵如下图所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318984.png" alt="3404508090"></p>
<p>其中，<strong>第一行表示已有的锁，第一列表示要加的锁</strong>。</p>
<p>插入意向锁做个总结:</p>
<ul>
<li>插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；</li>
<li>插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。</li>
</ul>
<p>了解插入意向锁的特点之后，我们将它从矩阵中移去，兼容矩阵就变成了下面这个样子：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072318074.png" alt="3787975353"></p>
<p>这个看起来就非常简单了，可以得出下面的结论：</p>
<ul>
<li>间隙锁不和其他锁（不包括插入意向锁）冲突；</li>
<li>记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突；</li>
</ul>
<h2 id="在-MySQL-中观察行锁"><a href="#在-MySQL-中观察行锁" class="headerlink" title="在 MySQL 中观察行锁"></a>在 MySQL 中观察行锁</h2><p>有两种方式可以在 MySQL 中观察行锁，第一种是通过下面的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_locks;</span><br></pre></td></tr></table></figure>

<p>这个命令会打印出 InnoDb 的所有锁信息，包括锁 ID、事务 ID、以及每个锁的类型和模式等其他信息。第二种是使用下面的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engine innodb status\G</span><br></pre></td></tr></table></figure>

<p>这个命令并不是专门用来查看锁信息的，而是用于输出当前 InnoDb 引擎的状态信息，包括：BACKGROUND THREAD、SEMAPHORES、TRANSACTIONS、FILE I&#x2F;O、INSERT BUFFER AND ADAPTIVE HASH INDEX、LOG、BUFFER POOL AND MEMORY、ROW OPERATIONS 等等。其中 TRANSACTIONS 部分会打印当前 MySQL 所有的事务，如果某个事务有加锁，还会显示加锁的详细信息。如果发生死锁，也可以通过这个命令来定位死锁发生的原因。不过在这之前需要先打开 Innodb 的锁监控：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_status_output <span class="operator">=</span> <span class="keyword">ON</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_status_output_locks <span class="operator">=</span> <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>打开锁监控之后，使用 <code>show engine innodb status</code> 命令，会输出大量的信息，我们在其中可以找到 <strong>TRANSACTIONS</strong> 部分，这里面就包含了每个事务及相关锁的信息，如下所示：</p>
<p><code>show engine innodb status</code> 的输出比较晦涩，要读懂它还需要学习一些其他知识，我们这里暂且不提，后面再专门对其进行介绍。这里使用 <code>information_schema.innodb_locks</code> 表来体验一下 MySQL 中不同的行锁。</p>
<p>要注意的是，只有在两个事务出现锁竞争时才能在这个表中看到锁信息，譬如你执行一条 UPDATE 语句，它会对某条记录加 X 锁，这个时候 <code>information_schema.innodb_locks</code> 表里是没有任何记录的。</p>
<p>另外，只看这个表只能得到当前持有锁的事务，至于是哪个事务被阻塞，可以通过 <code>information_schema.innodb_lock_waits</code> 表来查看。</p>
<p>###记录锁</p>
<p>根据上面的行锁兼容矩阵，记录锁和记录锁或 Next-key 锁冲突，所以想观察到记录锁，可以让两个事务都对同一条记录加记录锁，或者一个事务加记录锁另一个事务加 Next-key 锁。</p>
<p>事务 A 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span>     name <span class="operator">|</span> level <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> zhangsan <span class="operator">|</span>     <span class="number">7</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 B 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>事务 B 阻塞，出现锁竞争，查看锁状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_locks;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> lock_id     <span class="operator">|</span> lock_trx_id <span class="operator">|</span> lock_mode <span class="operator">|</span> lock_type <span class="operator">|</span> lock_table <span class="operator">|</span> lock_index <span class="operator">|</span> lock_space <span class="operator">|</span> lock_page <span class="operator">|</span> lock_rec <span class="operator">|</span> lock_data <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3108</span>:<span class="number">53</span>:<span class="number">3</span>:<span class="number">4</span> <span class="operator">|</span> <span class="number">3108</span>        <span class="operator">|</span> S         <span class="operator">|</span> RECORD    <span class="operator">|</span> `accounts` <span class="operator">|</span> <span class="keyword">PRIMARY</span>    <span class="operator">|</span>         <span class="number">53</span> <span class="operator">|</span>         <span class="number">3</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">5</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3107</span>:<span class="number">53</span>:<span class="number">3</span>:<span class="number">4</span> <span class="operator">|</span> <span class="number">3107</span>        <span class="operator">|</span> X         <span class="operator">|</span> RECORD    <span class="operator">|</span> `accounts` <span class="operator">|</span> <span class="keyword">PRIMARY</span>    <span class="operator">|</span>         <span class="number">53</span> <span class="operator">|</span>         <span class="number">3</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">5</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>根据兼容矩阵，间隙锁只和插入意向锁冲突，而且是先加间隙锁，然后加插入意向锁时才会冲突。</p>
<p>事务 A 执行（id 为主键，且 id &#x3D; 3 这条记录不存在）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 B 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> accounts(id, name, level) <span class="keyword">value</span>(<span class="number">3</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>事务 B 阻塞，出现锁竞争，查看锁状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_locks;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> lock_id     <span class="operator">|</span> lock_trx_id <span class="operator">|</span> lock_mode <span class="operator">|</span> lock_type <span class="operator">|</span> lock_table <span class="operator">|</span> lock_index <span class="operator">|</span> lock_space <span class="operator">|</span> lock_page <span class="operator">|</span> lock_rec <span class="operator">|</span> lock_data <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3110</span>:<span class="number">53</span>:<span class="number">3</span>:<span class="number">4</span> <span class="operator">|</span> <span class="number">3110</span>        <span class="operator">|</span> X,GAP     <span class="operator">|</span> RECORD    <span class="operator">|</span> `accounts` <span class="operator">|</span> <span class="keyword">PRIMARY</span>    <span class="operator">|</span>         <span class="number">53</span> <span class="operator">|</span>         <span class="number">3</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">3</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3109</span>:<span class="number">53</span>:<span class="number">3</span>:<span class="number">4</span> <span class="operator">|</span> <span class="number">3109</span>        <span class="operator">|</span> S,GAP     <span class="operator">|</span> RECORD    <span class="operator">|</span> `accounts` <span class="operator">|</span> <span class="keyword">PRIMARY</span>    <span class="operator">|</span>         <span class="number">53</span> <span class="operator">|</span>         <span class="number">3</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">3</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="Next-key-锁"><a href="#Next-key-锁" class="headerlink" title="Next-key 锁"></a>Next-key 锁</h3><p>根据兼容矩阵，Next-key 锁和记录锁、Next-key 锁或插入意向锁冲突，但是貌似很难制造 Next-key 锁和记录锁冲突的场景，也很难制造 Next-key 锁和 Next-key 锁冲突的场景（如果你能找到这样的例子，还望不吝赐教）。所以还是用 Next-key 锁和插入意向锁冲突的例子，和上面间隙锁的例子几乎一样。</p>
<p>事务 A 执行（level 为二级索引）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts <span class="keyword">where</span> level <span class="operator">=</span> <span class="number">7</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span>     name <span class="operator">|</span> level <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> zhangsan <span class="operator">|</span>     <span class="number">7</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span>   liusan <span class="operator">|</span>     <span class="number">7</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 B 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> accounts(name, level) <span class="keyword">value</span>(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p>事务 B 阻塞，出现锁竞争，查看锁状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_locks;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> lock_id     <span class="operator">|</span> lock_trx_id <span class="operator">|</span> lock_mode <span class="operator">|</span> lock_type <span class="operator">|</span> lock_table <span class="operator">|</span> lock_index <span class="operator">|</span> lock_space <span class="operator">|</span> lock_page <span class="operator">|</span> lock_rec <span class="operator">|</span> lock_data      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3114</span>:<span class="number">53</span>:<span class="number">5</span>:<span class="number">5</span> <span class="operator">|</span> <span class="number">3114</span>        <span class="operator">|</span> X,GAP     <span class="operator">|</span> RECORD    <span class="operator">|</span> `accounts` <span class="operator">|</span>      level <span class="operator">|</span>         <span class="number">53</span> <span class="operator">|</span>         <span class="number">5</span> <span class="operator">|</span>        <span class="number">5</span> <span class="operator">|</span> <span class="number">0x5A119FA1</span>, <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3113</span>:<span class="number">53</span>:<span class="number">5</span>:<span class="number">5</span> <span class="operator">|</span> <span class="number">3113</span>        <span class="operator">|</span> S,GAP     <span class="operator">|</span> RECORD    <span class="operator">|</span> `accounts` <span class="operator">|</span>      level <span class="operator">|</span>         <span class="number">53</span> <span class="operator">|</span>         <span class="number">5</span> <span class="operator">|</span>        <span class="number">5</span> <span class="operator">|</span> <span class="number">0x5A119FA1</span>, <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到除了锁住的索引不同之外，Next-key 锁和间隙锁之间几乎看不出任何差异。</p>
<h2 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs. 悲观锁"></a>乐观锁 vs. 悲观锁</h2><p>锁的思想</p>
<p>其实在讲 MVCC 的时候也提到过，解决并发问题的方式除了锁，还可以利用时间戳或者版本号等等手段。前一种处理数据的方式通常叫做 <strong>悲观锁（Pessimistic Lock）</strong>，第二种无锁方式叫做 <strong>乐观锁（Optimistic Lock）</strong>。</p>
<ul>
<li>悲观锁，顾名思义就是很悲观，每次拿数据时都假设有别人会来修改，所以每次在拿数据的时候都会给数据加上锁，用这种方式来避免跟别人冲突，虽然很有效，但是可能会出现大量的锁冲突，导致性能低下。</li>
<li>乐观锁则是完全相反，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有改过这个数据，可以使用版本号等机制来判断。</li>
</ul>
<p>总的来说，<strong>悲观锁需要使用数据库的锁机制来实现，而乐观锁是通过程序的手段来实现</strong></p>
<p>像乐观锁适用于读多写少的情况下，即冲突真的很少发生，这样可以省去锁的开销，加大系统的吞吐量。但如果经常产生冲突，上层应用不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁更合适。虽然使用带版本检查的乐观锁能够同时保持高并发和高可伸缩性，但它也不是万能的，譬如它不能解决脏读问题，所以在实际应用中还是会和数据库的隔离级别一起使用。</p>
<h2 id="常见-SQL-语句的加锁分析"><a href="#常见-SQL-语句的加锁分析" class="headerlink" title="常见 SQL 语句的加锁分析"></a>常见 SQL 语句的加锁分析</h2><p>总体来说，MySQL 中的锁可以分成两个粒度：表锁和行锁，表锁有：表级读锁，表级写锁，读意向锁，写意向锁，自增锁；行锁有：读记录锁，写记录锁，间隙锁，Next-key 锁，插入意向锁。</p>
<p>不同的隔离级别加锁也是不一样的，譬如 RR 隔离级别下有间隙锁和 Next-key 锁，这在 RC 隔离级别下是没有的（也有例外）</p>
<h3 id="基本的加锁规则"><a href="#基本的加锁规则" class="headerlink" title="基本的加锁规则"></a>基本的加锁规则</h3><p>快照读是不加锁的，更新语句肯定是加排它锁的，RC 隔离级别是没有间隙锁的等等。这些规则整理如下，后面就不再重复介绍了：</p>
<ul>
<li>常见语句的加锁<ul>
<li>SELECT … 语句正常情况下为快照读，不加锁；</li>
<li>SELECT … LOCK IN SHARE MODE 语句为当前读，加 S 锁；</li>
<li>SELECT … FOR UPDATE 语句为当前读，加 X 锁；</li>
<li>常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；</li>
<li>常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚；</li>
</ul>
</li>
<li>表锁<ul>
<li>表锁（分 S 锁和 X 锁）</li>
<li>意向锁（分 IS 锁和 IX 锁）</li>
<li>自增锁（一般见不到，只有在 innodb_autoinc_lock_mode &#x3D; 0 或者 Bulk inserts 时才可能有）</li>
</ul>
</li>
<li>行锁<ul>
<li>记录锁（分 S 锁和 X 锁）</li>
<li>间隙锁（分 S 锁和 X 锁）</li>
<li>Next-key 锁（分 S 锁和 X 锁）</li>
<li>插入意向锁</li>
</ul>
</li>
<li>行锁分析<ul>
<li>行锁都是加在索引上的，最终都会落在聚簇索引上；</li>
<li>加行锁的过程是一条一条记录加的；</li>
</ul>
</li>
<li>锁冲突<ul>
<li>S 锁和 S 锁兼容，X 锁和 X 锁冲突，X 锁和 S 锁冲突；</li>
<li>表锁和行锁的冲突矩阵</li>
</ul>
</li>
<li>不同隔离级别下的锁<ul>
<li>上面说 SELECT … 语句正常情况下为快照读，不加锁；但是在 Serializable 隔离级别下为当前读，加 S 锁；</li>
<li>RC 隔离级别下没有间隙锁和 Next-key 锁（特殊情况下也会有：purge + unique key）；</li>
<li>不同隔离级别下锁的区别</li>
</ul>
</li>
</ul>
<h3 id="简单-SQL-的加锁分析"><a href="#简单-SQL-的加锁分析" class="headerlink" title="简单 SQL 的加锁分析"></a>简单 SQL 的加锁分析</h3><p>我们使用下面这张 students 表作为实例，其中 id 为主键，no（学号）为二级唯一索引，name（姓名）和 age（年龄）为二级非唯一索引，score（学分）无索引。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319342.png" alt="1845259072"></p>
<p>这一节我们只分析最简单的一种 SQL，它只包含一个 WHERE 条件，等值查询或范围查询。虽然 SQL 非常简单，但是针对不同类型的列，我们还是会面对各种情况：</p>
<ul>
<li>聚簇索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 15;</li>
<li>聚簇索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 16;</li>
<li>二级唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0003’;</li>
<li>二级唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0008’;</li>
<li>二级非唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘Tom’;</li>
<li>二级非唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘John’;</li>
<li>无索引：UPDATE students SET score &#x3D; 100 WHERE score &#x3D; 22;</li>
<li>聚簇索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE id &lt;&#x3D; 20;</li>
<li>二级索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE age &lt;&#x3D; 23;</li>
<li>修改索引值：UPDATE students SET name &#x3D; ‘John’ WHERE id &#x3D; 15;</li>
</ul>
<h3 id="聚簇索引，查询命中"><a href="#聚簇索引，查询命中" class="headerlink" title="聚簇索引，查询命中"></a>聚簇索引，查询命中</h3><p>语句 <code>UPDATE students SET score = 100 WHERE id = 15</code> 在 RC 和 RR 隔离级别下加锁情况一样，都是对 id 这个聚簇索引加 X 锁，如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319661.png" alt="quan_2021-12-28_16-22-11"></p>
<h3 id="聚簇索引，查询未命中"><a href="#聚簇索引，查询未命中" class="headerlink" title="聚簇索引，查询未命中"></a>聚簇索引，查询未命中</h3><p>如果查询未命中纪录，在 RC 和 RR 隔离级别下加锁是不一样的，因为 RR 有 GAP 锁。语句 <code>UPDATE students SET score = 100 WHERE id = 16</code> 在 RC 和 RR 隔离级别下的加锁情况如下（RC 不加锁）：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319388.png" alt="quan_2021-12-28_16-22-48"></p>
<h3 id="二级唯一索引，查询命中"><a href="#二级唯一索引，查询命中" class="headerlink" title="二级唯一索引，查询命中"></a>二级唯一索引，查询命中</h3><p>语句 <code>UPDATE students SET score = 100 WHERE no = &#39;S0003&#39;</code> 命中二级唯一索引，上一篇博客中我们介绍了索引的结构，我们知道二级索引的叶子节点中保存了主键索引的位置，在给二级索引加锁的时候，主键索引也会一并加锁。这个在 RC 和 RR 两种隔离级别下没有区别：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320433.png" alt="quan_2021-12-28_16-24-48"></p>
<p>那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 students 表进行更新，如：<code>UPDATE students SET score = 100 WHERE id = 20</code>，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。</p>
<h3 id="二级唯一索引，查询未命中"><a href="#二级唯一索引，查询未命中" class="headerlink" title="二级唯一索引，查询未命中"></a>二级唯一索引，查询未命中</h3><p>如果查询未命中纪录，和 2.2 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 <code>UPDATE students SET score = 100 WHERE no = &#39;S0008&#39;</code> 加锁情况如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072319534.png" alt="quan_2021-12-28_16-26-10"></p>
<p>这种情况下只会在二级索引加锁，不会在聚簇索引上加锁。</p>
<h3 id="二级非唯一索引，查询命中"><a href="#二级非唯一索引，查询命中" class="headerlink" title="二级非唯一索引，查询命中"></a>二级非唯一索引，查询命中</h3><p>如果查询命中的是二级非唯一索引，在 RR 隔离级别下，还会加 GAP 锁。语句 <code>UPDATE students SET score = 100 WHERE name = &#39;Tom&#39;</code> 加锁如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320990.png" alt="quan_2021-12-28_16-27-11"></p>
<p>为什么非唯一索引会加 GAP 锁，而唯一索引不用加 GAP 锁呢？原因很简单，GAP 锁的作用是为了解决幻读，防止其他事务插入相同索引值的记录，而唯一索引和主键约束都已经保证了该索引值肯定只有一条记录，所以无需加 GAP 锁。</p>
<p>这里还有一点要注意一下，数一数右图中的锁你可能会觉得一共加了 7 把锁，实际情况不是，要注意的是 (Tom, 37) 上的**&#x3D;&#x3D;记录锁和它前面的 GAP 锁合起来是一个 Next-key 锁&#x3D;&#x3D;**，这个锁加在 (Tom, 37) 这个索引上，另外 (Tom, 49) 上也有一把 Next-key 锁。那么最右边的 GAP 锁加在哪呢？右边已经没有任何记录了啊。其实，在 InnoDb 存储引擎里，每个数据页中都会有两个虚拟的行记录，用来限定记录的边界，分别是：<code>Infimum Record</code> 和 <code>Supremum Record</code>，Infimum 是比该页中任何记录都要小的值，而 Supremum 比该页中最大的记录值还要大，这两条记录在创建页的时候就有了，并且不会删除。上面右边的 GAP 锁就是加在 Supremum Record 上。所以说，上面右图中共有 2 把 Next-key 锁，1 把 GAP 锁，2 把记录锁，一共 5 把锁。</p>
<h3 id="二级非唯一索引，查询未命中"><a href="#二级非唯一索引，查询未命中" class="headerlink" title="二级非唯一索引，查询未命中"></a>二级非唯一索引，查询未命中</h3><p>如果查询未命中纪录，RR 隔离级别会加 GAP 锁，RC 无锁。语句 <code>UPDATE students SET score = 100 WHERE name = &#39;John&#39;</code> 加锁情况如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320168.png" alt="quan_2021-12-28_16-29-19"></p>
<h3 id="无索引"><a href="#无索引" class="headerlink" title="无索引"></a>无索引</h3><p>如果 WHERE 条件不能走索引，MySQL 会如何加锁呢？有的人说会在表上加 X 锁，也有人说会根据 WHERE 条件将筛选出来的记录在聚簇索引上加上 X 锁，那么究竟如何，我们看下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072320392.png" alt="quan_2021-12-28_16-30-54"></p>
<p>在没有索引的时候，只能走聚簇索引，对表中的记录进行全表扫描。在 RC 隔离级别下会给所有记录加行锁，在 RR 隔离级别下，不仅会给所有记录加行锁，所有聚簇索引和聚簇索引之间还会加上 GAP 锁。</p>
<p>语句 <code>UPDATE students SET score = 100 WHERE score = 22</code> 满足条件的虽然只有 1 条记录，但是聚簇索引上所有的记录，都被加上了 X 锁。那么，为什么不是只在满足条件的记录上加锁呢？这是由于 MySQL 的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 MySQL Server 层进行过滤，因此也就把所有的记录都锁上了。</p>
<p>不过在实际的实现中，MySQL 有一些改进，如果是 RC 隔离级别，在 MySQL Server 过滤条件发现不满足后，会调用 <strong>unlock_row 方法</strong>，把不满足条件的记录锁释放掉（违背了 2PL 的约束）。这样做可以保证最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。如果是 RR 隔离级别，一般情况下 MySQL 是不能这样优化的，除非设置了 <code>innodb_locks_unsafe_for_binlog</code> 参数，这时也会提前释放锁，并且不加 GAP 锁，这就是所谓的 <strong>semi-consistent read</strong>。</p>
<h3 id="聚簇索引，范围查询"><a href="#聚簇索引，范围查询" class="headerlink" title="聚簇索引，范围查询"></a>聚簇索引，范围查询</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321729.png" alt="quan_2021-12-28_16-36-15"></p>
<p>SQL 语句为 <code>UPDATE students SET score = 100 WHERE id &lt;= 20</code>，按理说我们只需要将 id &#x3D; 20、18、15 三条记录锁住即可，但是看右边的图，在 RR 隔离级别下，我们还把 id &#x3D; 30 这条记录以及 (20, 30] 之间的间隙也锁起来了，很显然这是一个 Next-key 锁。如果 WHERE 条件是 id &lt; 20，则会把 id &#x3D; 20 这条记录锁住。</p>
<p>所以对于范围查询，如果 WHERE 条件是 id &lt;&#x3D; N，那么 N 后一条记录也会被加上 Next-key 锁；如果条件是 id &lt; N，那么 N 这条记录会被加上 Next-key 锁。另外，如果 WHERE 条件是 id &gt;&#x3D; N，只会给 N 加上记录锁，以及给比 N 大的记录加锁，不会给 N 前一条记录加锁；如果条件是 id &gt; N，也不会锁前一条记录，连 N 这条记录都不会锁。</p>
<h3 id="二级索引，范围查询"><a href="#二级索引，范围查询" class="headerlink" title="二级索引，范围查询"></a>二级索引，范围查询</h3><p>然后我们把范围查询应用到二级非唯一索引上来，SQL 语句为：<code>UPDATE students SET score = 100 WHERE age &lt;= 23</code>，加锁情况如下图所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321048.png" alt="quan_2021-12-28_16-40-36"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321351.png" alt="quan_2021-12-28_16-41-10"></p>
<p>可以看出和聚簇索引的范围查询一样，除了 WHERE 条件范围内的记录加锁之外，后面一条记录也会加上 Next-key 锁，这里有意思的一点是，尽管满足 age &#x3D; 24 的记录有两条，但只有第一条被加锁，第二条没有加锁，并且第一条和第二条之间也没有加锁。</p>
<h2 id="复杂条件加锁分析"><a href="#复杂条件加锁分析" class="headerlink" title="复杂条件加锁分析"></a>复杂条件加锁分析</h2><p>这里就只是学习一下在对复杂 SQL 加锁分析之前如何先对索引进行分析。譬如下面这样的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">22</span>;</span><br></pre></td></tr></table></figure>

<p>其中 name 和 age 两个字段都是索引，那么该如何加锁？</p>
<h2 id="DELETE-语句加锁分析"><a href="#DELETE-语句加锁分析" class="headerlink" title="DELETE 语句加锁分析"></a>DELETE 语句加锁分析</h2><p>一般来说，DELETE 的加锁和 SELECT FOR UPDATE 或 UPDATE 并没有太大的差异，DELETE 语句一样会有下面这些情况：</p>
<ul>
<li>聚簇索引，查询命中：DELETE FROM students WHERE id &#x3D; 15;</li>
<li>聚簇索引，查询未命中：DELETE FROM students WHERE id &#x3D; 16;</li>
<li>二级唯一索引，查询命中：DELETE FROM students WHERE no &#x3D; ‘S0003’;</li>
<li>二级唯一索引，查询未命中：DELETE FROM students WHERE no &#x3D; ‘S0008’;</li>
<li>二级非唯一索引，查询命中：DELETE FROM students WHERE name &#x3D; ‘Tom’;</li>
<li>二级非唯一索引，查询未命中：DELETE FROM students WHERE name &#x3D; ‘John’;</li>
<li>无索引：DELETE FROM students WHERE score &#x3D; 22;</li>
<li>聚簇索引，范围查询：DELETE FROM students WHERE id &lt;&#x3D; 20;</li>
<li>二级索引，范围查询：DELETE FROM students WHERE age &lt;&#x3D; 23;</li>
</ul>
<p>针对这些情况的加锁分析和上文一致，这里不再赘述。</p>
<p>那么 DELETE 语句和 UPDATE 语句的加锁到底会有什么不同呢？我们知道，在 MySQL 数据库中，执行 DELETE 语句其实并没有直接删除记录，而是在记录上打上一个删除标记，然后通过后台的一个叫做 <strong>&#x3D;&#x3D;purge&#x3D;&#x3D;</strong> 的线程来清理。</p>
<p>标记为删除的记录，对于这种类型记录，它的加锁和其他记录的加锁机制不一样。所以这一节的标题叫做 <strong>标记为删除的记录的加锁分析</strong> 可能更合适。</p>
<p>那么问题又来了：什么情况下会对已标记为删除的记录加锁呢？我总结下来会有两种情况：<strong>阻塞后加锁</strong> 和 <strong>快照读后加锁</strong>（自己取得名字），下面分别介绍。</p>
<p><strong>阻塞后加锁</strong> 事务 A 删除 id &#x3D; 18 这条记录，同时事务 B 也删除 id &#x3D; 18 这条记录，很显然，id 为主键，DELETE 语句需要获取 X 记录锁，事务 B 阻塞。事务 A 提交之后，id &#x3D; 18 这条记录被标记为删除，此时事务 B 就需要对已删除记录进行加锁。</p>
<p><strong>快照读后加锁</strong> 事务 A 删除 id &#x3D; 18 这条记录，并提交。事务 B 在事务 A 提交之前有一次 id &#x3D; 18 的快照读，所以在后面删除 id &#x3D; 18 这条记录的时候就需要对已删除记录加锁了。如果没有事务开头的这个快照读，DELETE 语句就只是简单的删除一条不存在的记录。</p>
<p>注意，上面的事务 B 不限于 DELETE 语句，换成 UPDATE 或 SELECT FOR UPDATE 同样适用。</p>
<p>我通过自己做的实验，得到了下面这些结论，如有不正确的地方，欢迎斧正。（实验环境，MySQL 版本：5.7，隔离级别：RR）</p>
<ul>
<li>删除记录为聚簇索引<ul>
<li>阻塞后加锁：在删除记录上加 X 记录锁（rec but not gap），并在删除的后一条记录上加间隙锁（gap before rec）</li>
<li>快照读后加锁：在删除记录上加 X 记录锁（rec but not gap）</li>
</ul>
</li>
<li>删除记录为二级索引（唯一索引和非唯一索引都适用）<ul>
<li>阻塞后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁</li>
<li>快照读后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁</li>
</ul>
</li>
</ul>
<h2 id="INSERT-语句加锁分析"><a href="#INSERT-语句加锁分析" class="headerlink" title="INSERT 语句加锁分析"></a>INSERT 语句加锁分析</h2><p>还是用 students 表来实验，譬如我们执行下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> students(<span class="keyword">no</span>, name, age, score) <span class="keyword">value</span>(<span class="string">&#x27;S0008&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="number">26</span>, <span class="number">87</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们用 <code>show engine innodb status\G</code> 查询事务的锁情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---TRANSACTION 3774, ACTIVE 2 sec</span></span><br><span class="line"><span class="number">1</span> lock struct(s), heap size <span class="number">1136</span>, <span class="number">0</span> <span class="type">row</span> lock(s), undo log entries <span class="number">1</span></span><br><span class="line">MySQL thread id <span class="number">150</span>, OS thread handle <span class="number">10420</span>, query id <span class="number">3125</span> localhost ::<span class="number">1</span> root</span><br><span class="line"><span class="keyword">TABLE</span> LOCK <span class="keyword">table</span> `sys`.`t3` trx id <span class="number">3774</span> lock mode IX</span><br></pre></td></tr></table></figure>

<p> INSERT 语句是插入一条新的纪录，这条记录表中本来就没有，那是不是就不需要加锁了？显然不是，至少有两个原因可以说明 INSERT 加了锁：</p>
<ol>
<li>为了防止幻读，如果记录之间加有 GAP 锁，此时不能 INSERT；</li>
<li>如果 INSERT 的记录和已有记录造成唯一键冲突，此时不能 INSERT；</li>
</ol>
<p>要解决这两个问题，都是靠锁来解决的（第一个加插入意向锁，第二个加 S 锁进行当前读），只是在 INSERT 的时候如果没有出现这两种情况，那么锁就是隐式的，只是我们看不到而已。这里我们不得不提一个概念叫 <strong>隐式锁（Implicit Lock）</strong>，它对我们分析 INSERT 语句的加锁过程至关重要。</p>
<blockquote>
<p>锁是一种悲观的顺序化机制，它假设很可能发生冲突，因此在操作数据时，就加锁，如果冲突的可能性很小，多数的锁都是不必要的。Innodb 实现了一个延迟加锁的机制来减少加锁的数量，这被称为隐式锁。</p>
<p>隐式锁中有个重要的元素：事务ID（trx_id）。隐式锁的逻辑过程如下：</p>
<p>A. InnoDB 的每条记录中都有一个隐含的 trx_id 字段，这个字段存在于簇索引的 B+Tree 中;<br>B. 在操作一条记录前，首先根据记录中的 trx_id 检查该事务是否是活动的事务（未提交或回滚），如果是活动的事务，首先将隐式锁转换为显式锁（就是为该事务添加一个锁）；<br>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为 waiting 状态；如果没有冲突不加锁，跳到 E；<br>D. 等待加锁成功，被唤醒，或者超时；<br>E. 写数据，并将自己的 trx_id 写入 trx_id 字段。</p>
<p>隐式锁的特点是只有在可能发生冲突时才加锁，减少了锁的数量。另外，隐式锁是针对被修改的 B+Tree 记录，因此都是 Record 类型的锁，不可能是 Gap 或 Next-Key 类型。</p>
<ol>
<li>INSERT 操作只加隐式锁，不需要显示加锁；</li>
<li>UPDATE、DELETE 在查询时，直接对查询用的 Index 和主键使用显示锁，其他索引上使用隐式锁。</li>
</ol>
<p>理论上说，可以对主键使用隐式锁的。提前使用显示锁应该是为了减少死锁的可能性。INSERT，UPDATE，DELETE 对 B+Tree 们的操作都是从主键的 B+Tree 开始，因此对主键加锁可以有效的阻止死锁。</p>
</blockquote>
<h2 id="再见死锁"><a href="#再见死锁" class="headerlink" title="再见死锁"></a>再见死锁</h2><h3 id="开启锁监控"><a href="#开启锁监控" class="headerlink" title="开启锁监控"></a>开启锁监控</h3><p>在遇到线上死锁问题时，我们应该第一时间获取相关的死锁日志。我们可以通过 <code>show engine innodb status</code> 命令来获取死锁信息，但是它有个限制，只能拿到最近一次的死锁日志。MySQL 提供了一套 InnoDb 的监控机制，用于周期性（每隔 15 秒）输出 InnoDb 的运行状态到 mysqld 服务的标准错误输出（stderr）。默认情况下监控是关闭的，只有当需要分析问题时再开启，并且在分析问题之后，建议将监控关闭，因为它对数据库的性能有一定影响，另外每 15 秒输出一次日志，会使日志文件变得特别大。</p>
<p>InnoDb 的监控主要分为四种：标准监控（Standard InnoDB Monitor）、锁监控（InnoDB Lock Monitor）、表空间监控（InnoDB Tablespace Monitor）和表监控（InnoDB Table Monitor）。后两种监控已经基本上废弃了</p>
<p>要获取死锁日志，我们需要开启 InnoDb 的标准监控，我推荐将锁监控也打开，它可以提供一些额外的锁信息，在分析死锁问题时会很有用。开启监控的方法有两种：</p>
<h4 id="基于系统表"><a href="#基于系统表" class="headerlink" title="基于系统表"></a>基于系统表</h4><p>比如在数据库中创建一个表名为 <code>innodb_monitor</code> 的表开启标准监控，创建一个表名为 <code>innodb_lock_monitor</code> 的表开启锁监控。MySQL 通过检测是否存在这个表名来决定是否开启监控，至于表的结构和表里的内容无所谓。相反的，如果要关闭监控，则将这两个表删除即可。这种方法有点奇怪，在 5.6.16 版本之后，推荐使用系统参数的形式开启监控。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启标准监控</span></span><br><span class="line"><span class="keyword">CREATE</span>` `<span class="keyword">TABLE</span>` `innodb_monitor (a ``<span class="type">INT</span>``) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="comment">-- 关闭标准监控</span></span><br><span class="line"><span class="keyword">DROP</span>` `<span class="keyword">TABLE</span>` `innodb_monitor;</span><br><span class="line"><span class="comment">-- 开启锁监控</span></span><br><span class="line"><span class="keyword">CREATE</span>` `<span class="keyword">TABLE</span>` `innodb_lock_monitor (a ``<span class="type">INT</span>``) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="comment">-- 关闭锁监控</span></span><br><span class="line"><span class="keyword">DROP</span>` `<span class="keyword">TABLE</span>` `innodb_lock_monitor;</span><br></pre></td></tr></table></figure>

<h4 id="基于系统参数"><a href="#基于系统参数" class="headerlink" title="基于系统参数"></a>基于系统参数</h4><p>在 MySQL 5.6.16 之后，可以通过设置系统参数来开启锁监控，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启标准监控</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> innodb_status_output<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"><span class="comment">-- 关闭标准监控</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> innodb_status_output<span class="operator">=</span>OFF;</span><br><span class="line"><span class="comment">-- 开启锁监控</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"><span class="comment">-- 关闭锁监控</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks<span class="operator">=</span>OFF;</span><br></pre></td></tr></table></figure>

<p>另外，MySQL 提供了一个系统参数 <code>innodb_print_all_deadlocks</code> 专门用于记录死锁日志，当发生死锁时，死锁日志会记录到 MySQL 的错误日志文件中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> innodb_print_all_deadlocks<span class="operator">=</span><span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>除了 MySQL 自带的监控机制，还有一些有趣的监控工具也很有用，比如 <a target="_blank" rel="noopener" href="http://yeshaoting.cn/article/database/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7Innotop/">Innotop</a> 和 Percona Toolkit 里的小工具 pt-deadlock-logger。</p>
<h3 id="读懂死锁日志"><a href="#读懂死锁日志" class="headerlink" title="读懂死锁日志"></a>读懂死锁日志</h3><p>日志中列出了死锁发生的时间，以及导致死锁的事务信息（只显示两个事务，如果由多个事务导致的死锁也只显示两个），并显示出每个事务正在执行的 SQL 语句、等待的锁以及持有的锁信息等。下面我们就来研究下这份死锁日志，看看从这份死锁日志中能不能发现死锁的原因？</p>
<p>首先看事务一的信息：</p>
<blockquote>
<p>*** (1) TRANSACTION:<br>TRANSACTION 182335752, ACTIVE 0 sec inserting</p>
</blockquote>
<p>ACTIVE 0 sec 表示事务活动时间，inserting 为事务当前正在运行的状态，可能的事务状态有：fetching rows，updating，deleting，inserting 等。</p>
<blockquote>
<p>mysql tables in use 1, locked 1<br>LOCK WAIT 11 lock struct(s), heap size 1184, 2 row lock(s), undo log entries 15</p>
</blockquote>
<p>tables in use 1 表示有一个表被使用，locked 1 表示有一个表锁。LOCK WAIT 表示事务正在等待锁，11 lock struct(s) 表示该事务的锁链表的长度为 11，每个链表节点代表该事务持有的一个锁结构，包括表锁，记录锁以及 autoinc 锁等。heap size 1184 为事务分配的锁堆内存大小。<br>2 row lock(s) 表示当前事务持有的行锁个数，通过遍历上面提到的 11 个锁结构，找出其中类型为 LOCK_REC 的记录数。undo log entries 15 表示当前事务有 15 个 undo log 记录，因为二级索引不记 undo log，说明该事务已经更新了 15 条聚集索引记录。</p>
<blockquote>
<p>MySQL thread id 12032077, OS thread handle 0x7ff35ebf6700, query id 196418265 10.40.191.57 RW_bok_db update</p>
</blockquote>
<p>事务的线程信息，以及数据库 IP 地址和数据库名，对我们分析死锁用处不大。</p>
<blockquote>
<p>INSERT INTO bok_task</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( order_id ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里显示的是正在等待锁的 SQL 语句，死锁日志里每个事务都只显示一条 SQL 语句，这对我们分析死锁很不方便，我们必须要结合应用程序去具体分析这个 SQL 之前还执行了哪些其他的 SQL 语句，或者根据 binlog 也可以大致找到一个事务执行的 SQL 语句。</p>
<blockquote>
<p>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</p>
</blockquote>
<p>RECORD LOCKS space id 300 page no 5480 n bits 552 index <code>order_id_un</code> of table <code>bok_db</code>.<code>bok_task</code> trx id 182335752 lock_mode X insert intention waiting</p>
<p>这里显示的是事务正在等待什么锁。RECORD LOCKS 表示记录锁（并且可以看出要加锁的索引为 order_id_un），space id 为 300，page no 为 5480，n bits 552 表示这个记录锁结构上留有 552 个 bit 位（该 page 上的记录数 + 64）。<br>lock_mode X 表示该记录锁为排他锁，insert intention waiting 表示要加的锁为插入意向锁，并处于锁等待状态。</p>
<p>在上面有提到 <code>innodb_status_output_locks</code> 这个系统变量可以开启 InnoDb 的锁监控，如果开启了，这个地方还会显示出锁的一些额外信息，包括索引记录的 info bits 和数据信息等：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000002</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000001</span>; <span class="keyword">asc</span>     ;;</span><br></pre></td></tr></table></figure>

<p>一共有四种类型的行锁：记录锁，间隙锁，Next-key 锁和插入意向锁。这四种锁对应的死锁日志各不相同，如下：</p>
<ul>
<li>记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap</li>
<li>间隙锁（LOCK_GAP）: lock_mode X locks gap before rec</li>
<li>Next-key 锁（LOCK_ORNIDARY）: lock_mode X</li>
<li>插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention</li>
</ul>
<p>这里有一点要注意的是，并不是在日志里看到 lock_mode X 就认为这是 Next-key 锁，因为还有一个例外：如果在 supremum record 上加锁，<code>locks gap before rec</code> 会省略掉，间隙锁会显示成 <code>lock_mode X</code>，插入意向锁会显示成 <code>lock_mode X insert intention</code>。譬如下面这个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">0</span> page <span class="keyword">no</span> <span class="number">307</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`test` trx id <span class="number">50</span>F lock_mode X</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">1</span> PHYSICAL RECORD: n_fields <span class="number">1</span>; compact format; info bits <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>看起来像是 Next-key 锁，但是看下面的 <code>heap no 1</code> 表示这个记录是 supremum record（另外，infimum record 的 heap no 为 0），所以这个锁应该看作是一个间隙锁。</p>
<p>看完第一个事务，再来看看第二个事务：</p>
<blockquote>
<p>*** (2) TRANSACTION:</p>
<p>TRANSACTION 182335756, ACTIVE 0 sec inserting<br>mysql tables in use 1, locked 1<br>11 lock struct(s), heap size 1184, 2 row lock(s), undo log entries 15<br>MySQL thread id 12032049, OS thread handle 0x7ff35f5dd700, query id 196418268 10.40.189.132 RW_bok_db update<br>INSERT INTO bok_task</p>
<p>** (2) HOLDS THE LOCK(S):<br>RECORD LOCKS space id 300 page no 5480 n bits 552 index <code>order_id_un</code> of table <code>bok_db</code>.<code>bok_task</code> trx id 182335756 lock_mode X<br>**(2) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 300 page no 5480 n bits 552 index <code>order_id_un</code> of table <code>bok_db</code>.<code>bok_task</code> trx id 182335756 lock_mode X insert intention waiting</p>
</blockquote>
<p>事务二和事务一的日志基本类似，不过它多了一部分 HOLDS THE LOCK(S)，表示事务二持有什么锁，这个锁往往就是事务一处于锁等待的原因。这里可以看到事务二正在等待索引 order_id_un 上的插入意向锁，并且它已经持有了一个 X 锁（Next-key 锁，也有可能是 supremum 上的间隙锁）。</p>
<p>到这里为止，我们得到了很多关键信息，此时我们可以逆推出死锁发生的原因吗？这可能也是每个开发人员和 DBA 最关心的问题，如何通过死锁日志来诊断死锁的成因？实际上这是非常困难的。</p>
<p>如果每个事务都只有一条 SQL 语句，这种情况的死锁成因还算比较好分析，因为我们可以从死锁日志里找到每个事务执行的 SQL 语句，只要对这两条 SQL 语句的加锁过程有一定的了解，死锁原因一般不难定位。但也有可能死锁的成因非常隐蔽，这时需要我们对这两条 SQL 语句的加锁流程做非常深入的研究才有可能分析出死锁的根源。</p>
<p>不过大多数情况下，每个事务都不止一条 SQL 语句，譬如上面的死锁日志里显示的 <code>undo log entries 15</code>，说明执行 INSERT 语句之前肯定还执行了其他的 SQL 语句，但是具体是什么，我们不得而知，我们只能根据 HOLDS THE LOCK(S) 部分知道有某个 SQL 语句对 order_id_un 索引加了 Next-key 锁（或间隙锁）。另外事务二在 WAITING FOR 插入意向锁，至于它和事务一的哪个锁冲突也不得而知，因为事务一的死锁日志里并没有 HOLDS THE LOCK(S) 部分。</p>
<p>所以，对死锁的诊断不能仅仅靠死锁日志，还应该结合应用程序的代码来进行分析，如果实在接触不到应用代码，还可以通过数据库的 binlog 来分析（只要你的死锁不是 100% 必现，那么 binlog 日志里肯定能找到一份完整的事务一和事务二的 SQL 语句）。通过应用代码或 binlog 理出每个事务的 SQL 执行顺序，这样分析死锁时就会容易很多。</p>
<h2 id="常见死锁分析"><a href="#常见死锁分析" class="headerlink" title="常见死锁分析"></a>常见死锁分析</h2><h3 id="死锁案例一"><a href="#死锁案例一" class="headerlink" title="死锁案例一"></a>死锁案例一</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072321425.png" alt="quan_2021-12-28_17-12-34"></p>
<p>死锁的根本原因是有两个或多个事务之间加锁顺序的不一致导致的，这个死锁案例其实是最经典的死锁场景。</p>
<p>首先，事务 A 获取 id &#x3D; 20 的锁（lock_mode X locks rec but not gap），事务 B 获取 id &#x3D; 30 的锁；然后，事务 A 试图获取 id &#x3D; 30 的锁，而该锁已经被事务 B 持有，所以事务 A 等待事务 B 释放该锁，然后事务 B 又试图获取 id &#x3D; 20 的锁，这个锁被事务 A 占有，于是两个事务之间相互等待，导致死锁。</p>
<h3 id="死锁案例二"><a href="#死锁案例二" class="headerlink" title="死锁案例二"></a>死锁案例二</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072322679.png" alt="quan_2021-12-28_17-16-50"></p>
<p>首先事务 A 和事务 B 执行了两条 UPDATE 语句，但是由于 id &#x3D; 25 和 id &#x3D; 26 记录都不存在，事务 A 和 事务 B 并没有更新任何记录，但是由于数据库隔离级别为 RR，所以会在 (20, 30) 之间加上间隙锁（lock_mode X locks gap before rec），间隙锁和间隙锁并不冲突。之后事务 A 和事务 B 分别执行 INSERT 语句要插入记录 id &#x3D; 25 和 id &#x3D; 26，需要在 (20, 30) 之间加插入意向锁（lock_mode X locks gap before rec insert intention），插入意向锁和间隙锁冲突，所以两个事务互相等待，最后形成死锁。</p>
<p>要解决这个死锁很简单，显然，前面两条 UPDATE 语句是无效的，将其删除即可。另外也可以将数据库隔离级别改成 RC，这样在 UPDATE 的时候就不会有间隙锁了。这个案例正是文章开头提到的死锁日志中的死锁场景，别看这个 UPDATE 语句是无效的，看起来很傻，但是确实是真实的场景，因为在真实的项目中代码会非常复杂，比如采用了 ORM 框架，应用层和数据层代码分离，一般开发人员写代码时都不知道会生成什么样的 SQL 语句，我也是从 DBA 那里拿到了 binlog，然后从里面找到了事务执行的所有 SQL 语句，发现其中竟然有一行无效的 UPDATE 语句，最后追本溯源，找到对应的应用代码，将其删除，从而修复了这个死锁。</p>
<h3 id="死锁案例三"><a href="#死锁案例三" class="headerlink" title="死锁案例三"></a>死锁案例三</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://www.everlasting520.top/d/tblog/%E5%9B%BE%E7%89%87/imgs/202203072322848.png" alt="quan_2021-12-28_17-18-53"></p>
<p>别看这个案例里每个事务都只有一条 SQL 语句，但是却实实在在可能会导致死锁问题，其实说起来，这个死锁和案例一并没有什么区别，只不过理解起来要更深入一点。要知道在范围查询时，加锁是一条记录一条记录挨个加锁的，所以虽然只有一条 SQL 语句，如果两条 SQL 语句的加锁顺序不一样，也会导致死锁。</p>
<p>在案例一中，事务 A 的加锁顺序为： id &#x3D; 20 -&gt; 30，事务 B 的加锁顺序为：id &#x3D; 30 -&gt; 20，正好相反，所以会导致死锁。这里的情景也是一样，事务 A 的范围条件为 id &lt; 30，加锁顺序为：id &#x3D; 15 -&gt; 18 -&gt; 20，事务 B 走的是二级索引 age，加锁顺序为：(age, id) &#x3D; (24, 18) -&gt; (24, 20) -&gt; (25, 15) -&gt; (25, 49)，其中，对 id 的加锁顺序为 id &#x3D; 18 -&gt; 20 -&gt; 15 -&gt; 49。可以看到事务 A 先锁 15，再锁 18，而事务 B 先锁 18，再锁 15，从而形成死锁。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>在工作过程中偶尔会遇到死锁问题，虽然这种问题遇到的概率不大，但每次遇到的时候要想彻底弄懂其原理并找到解决方案却并不容易。其实，对于 MySQL 的 InnoDb 存储引擎来说，死锁问题是避免不了的，没有哪种解决方案可以说完全解决死锁问题，但是我们可以通过一些可控的手段，降低出现死锁的概率。</p>
<ol>
<li>如上面的案例一和案例三所示，对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</li>
<li>如上面的案例二所示，Gap 锁往往是程序中导致死锁的真凶，由于默认情况下 MySQL 的隔离级别是 RR，所以如果能确定幻读和不可重复读对应用的影响不大，可以考虑将隔离级别改成 RC，可以避免 Gap 锁导致的死锁；</li>
<li>为表添加合理的索引，如果不走索引将会为表的每一行记录加锁，死锁的概率就会大大增大；</li>
<li>我们知道 MyISAM 只支持表锁，它采用一次封锁技术来保证事务之间不会发生死锁，所以，我们也可以使用同样的思想，在事务中一次锁定所需要的所有资源，减少死锁概率；</li>
<li>避免大事务，尽量将大事务拆成多个小事务来处理；因为大事务占用资源多，耗时长，与其他事务冲突的概率也会变高；</li>
<li>避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行；</li>
<li>设置锁等待超时参数：<code>innodb_lock_wait_timeout</code>，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</li>
</ol>
<h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>当mysql运行一条SQL语句时，在你预期的时间内，没有完成时，我们都会登陆到mysql数据库上想查看是不是出了什么问题，通常会使用的一个命令就是 show processlist，看看有哪些session，这些session在做什么事情。就从这个命令开始，显示如下：</p>
<p> 图中看到了显示了几处信息：</p>
<p> id：为session_id，也就是processlist_id</p>
<p> user：该session使用什么用户登陆的mysql数据库</p>
<p> host：客户端登陆的ip地址（这里我都是本地登陆的）</p>
<p> db：连接了哪个数据库（这里我只是连接上了数据库，并没有其他操作，所以都是NULL）</p>
<p> command：当前session执行命令的类型</p>
<p> Time：处于当前命令类型持续的时间</p>
<p> State：当前命令类型的状态</p>
<p> Info：具体命令信息</p>
<p>元数据锁是server层的锁，表级锁，主要用于隔离DML和DDL操作之间的干扰。</p>
<p>每执行一条DML、DDL语句时都会申请MDL锁，DML操作需要MDL读锁，DDL操作需要MDL写锁（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥），申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放（这里有种特殊情况如果事务中包含DDL操作，mysql会在DDL操作语句执行后，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放，例如id 44的语句改为&lt;begin;alter table testok add z varchar(10) not Null;select * from testok;&gt;，此时一旦alter语句执行完成会马上提交事务（autocommit&#x3D;1），后面的select就在本次事务之外，其执行完成后不会持有读锁）</p>
<p>表级锁有两种，一种是针对于表记录数据的锁，另外一种就是MDL(metadata lock)的锁，它是基于表元数据(表结构)的锁，MDL锁是为了保证并发环境下元数据和表数据的结构一致性。如果有其它事务对表加了MDL锁，那么其它事务就不能对表结构进行变更，同样对于正在进行表结构变更的时候也不允许其它事务对表数据进行增删改查。</p>
<h3 id="什么时候会加MDL锁"><a href="#什么时候会加MDL锁" class="headerlink" title="什么时候会加MDL锁"></a>什么时候会加MDL锁</h3><p>MDL读锁：在我们对表数据进行增删改查的的时候都需要对表加MDL读锁。</p>
<p>MDL写锁：当我们对表结构进行修改的时候会加MDL写锁。</p>



<div class="article-footer reveal fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/6b3e1469/">Spring</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/f7ede91d/">Java基础</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@Gentle Conspiracy</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.22.1';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.22.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img, .gallery img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@v2/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@v2/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@v2/dist/waline.js","css":"https://unpkg.com/@waline/client@v2/dist/waline.css","serverURL":"https://discuss.forever520.top/","commentCount":true,"pageview":false,"locale":{"placeholder":"有事可评论，无事更可评论！"},"emoji":["https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs","https://unpkg.com/@waline/emojis@1.1.0/qq"],"requiredMeta":["nick"],"lang":"zh-CN","wordLimit":500,"pageSize":50}, {
        el: '#waline_container',
        path: path,
        
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->

  
    <div class="iframe-container"><iframe frameborder="0" src="https://blog.ltyuanfang.cn/shizhong" width="100%" height="230px" scrolling="no"></iframe></div>
  
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/Everlasting16108/html/css/clock5.css">
  
    <div style="height:60px;line-height:60px;font-size:14pt;font-weight:bold;text-align:center;color:pink;"><span id="hitokoto"><a href="#" id="hitokoto_text">"人生最大的遗憾,就是在最无能为力的时候遇到一个想要保护一生的人."</a></span><font color="pink">欢迎访问：<a href="https://al.forever520.top" target="_blank" >ZQ的资源站</a></font></div>
  
    <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script>
  
    <div style=" height:30px;line-height:30px;font-size:14pt;font-weight:bold;text-align:center;color:pink"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div>
  
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures1/js/yh3.js"></script>
  
    <div align="center"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://count.getloli.com/get/@LYcc?theme=rule34"></div>
  
    <script type="text/javascript" src="https://fastly.jsdelivr.net/gh/Everlasting16108/MyPictures1/js/mytime2.js"></script>
  
    <script src="https://myhkw.cn/api/player/166996049082" id="myhk" key="166996049082" m="1"></script>
  


  </div>
</body>
</html>
